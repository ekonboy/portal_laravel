/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@popperjs/core/lib/createPopper.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/createPopper.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createPopper: () => (/* binding */ createPopper),
/* harmony export */   detectOverflow: () => (/* reexport safe */ _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   popperGenerator: () => (/* binding */ popperGenerator)
/* harmony export */ });
/* harmony import */ var _dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dom-utils/getCompositeRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-utils/listScrollParents.js */ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/orderModifiers.js */ "./node_modules/@popperjs/core/lib/utils/orderModifiers.js");
/* harmony import */ var _utils_debounce_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/debounce.js */ "./node_modules/@popperjs/core/lib/utils/debounce.js");
/* harmony import */ var _utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/mergeByName.js */ "./node_modules/@popperjs/core/lib/utils/mergeByName.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");









var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions,
    _generatorOptions$def = _generatorOptions.defaultModifiers,
    defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
    _generatorOptions$def2 = _generatorOptions.defaultOptions,
    defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: (0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(reference) ? (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__["default"])(reference) : reference.contextElement ? (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__["default"])(reference.contextElement) : [],
          popper: (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__["default"])(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = (0,_utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_3__["default"])([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements,
          reference = _state$elements.reference,
          popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          return;
        } // Store the reference and popper rects to be read by modifiers

        state.rects = {
          reference: (0,_dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_4__["default"])(reference, (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_5__["default"])(popper), state.options.strategy === 'fixed'),
          popper: (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__["default"])(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index],
            fn = _state$orderedModifie.fn,
            _state$orderedModifie2 = _state$orderedModifie.options,
            _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
            name = _state$orderedModifie.name;
          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: (0,_utils_debounce_js__WEBPACK_IMPORTED_MODULE_7__["default"])(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference, popper)) {
      return instance;
    }
    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref) {
        var name = _ref.name,
          _ref$options = _ref.options,
          options = _ref$options === void 0 ? {} : _ref$options,
          effect = _ref.effect;
        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });
          var noopFn = function noopFn() {};
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/contains.js":
/*!***************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/contains.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ contains)
/* harmony export */ });
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      } // $FlowFixMe[prop-missing]: need a better way to handle this...

      next = next.parentNode || next.host;
    } while (next);
  } // Give up, the result is false

  return false;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getBoundingClientRect)
/* harmony export */ });
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isLayoutViewport.js */ "./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js");




function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {
    scaleX = element.offsetWidth > 0 ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_1__.round)(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_1__.round)(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element) : window,
    visualViewport = _ref.visualViewport;
  var addVisualOffsets = !(0,_isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_3__["default"])() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x: x,
    y: y
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getClippingRect)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _getViewportRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getViewportRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js");
/* harmony import */ var _getDocumentRect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getDocumentRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js");
/* harmony import */ var _listScrollParents_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./listScrollParents.js */ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js");
/* harmony import */ var _getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./contains.js */ "./node_modules/@popperjs/core/lib/dom-utils/contains.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/rectToClientRect.js */ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");














function getInnerBoundingClientRect(element, strategy) {
  var rect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element, false, strategy === 'fixed');
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === _enums_js__WEBPACK_IMPORTED_MODULE_1__.viewport ? (0,_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_getViewportRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element, strategy)) : (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : (0,_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_getDocumentRect_js__WEBPACK_IMPORTED_MODULE_5__["default"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_6__["default"])(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`

function getClippingParents(element) {
  var clippingParents = (0,_listScrollParents_js__WEBPACK_IMPORTED_MODULE_7__["default"])((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_8__["default"])(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf((0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_9__["default"])(element).position) >= 0;
  var clipperElement = canEscapeClipping && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(element) ? (0,_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__["default"])(element) : element;
  if (!(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414

  return clippingParents.filter(function (clippingParent) {
    return (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(clippingParent) && (0,_contains_js__WEBPACK_IMPORTED_MODULE_11__["default"])(clippingParent, clipperElement) && (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_12__["default"])(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents

function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.max)(rect.top, accRect.top);
    accRect.right = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.min)(rect.right, accRect.right);
    accRect.bottom = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.min)(rect.bottom, accRect.bottom);
    accRect.left = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.max)(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getCompositeRect)
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getNodeScroll_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getNodeScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");








function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(rect.width) / element.offsetWidth || 1;
  var scaleY = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.

function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent);
  var offsetParentIsScaled = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent) && isElementScaled(offsetParent);
  var documentElement = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(offsetParent);
  var rect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent) !== 'body' ||
    // https://github.com/popperjs/popper-core/issues/1078
    (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_5__["default"])(documentElement)) {
      scroll = (0,_getNodeScroll_js__WEBPACK_IMPORTED_MODULE_6__["default"])(offsetParent);
    }
    if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent)) {
      offsets = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_7__["default"])(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getComputedStyle)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

function getComputedStyle(element) {
  return (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element).getComputedStyle(element);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getDocumentElement)
/* harmony export */ });
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return (((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? element.ownerDocument :
  // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getDocumentRect)
/* harmony export */ });
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");




 // Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var winScroll = (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element);
  var y = -winScroll.scrollTop;
  if ((0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__["default"])(body || html).direction === 'rtl') {
    x += (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_2__.max)(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getHTMLElementScroll)
/* harmony export */ });
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getLayoutRect)
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
 // Returns the layout rect of an element relative to its offsetParent. Layout
// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getNodeName)
/* harmony export */ });
function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getNodeScroll)
/* harmony export */ });
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getHTMLElementScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js");




function getNodeScroll(node) {
  if (node === (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node) || !(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(node)) {
    return (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(node);
  } else {
    return (0,_getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node);
  }
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getOffsetParent)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _isTableElement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isTableElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _utils_userAgent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/userAgent.js */ "./node_modules/@popperjs/core/lib/utils/userAgent.js");







function getTrueOffsetParent(element) {
  if (!(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) ||
  // https://github.com/popperjs/popper-core/issues/837
  (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element).position === 'fixed') {
    return null;
  }
  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block

function getContainingBlock(element) {
  var isFirefox = /firefox/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_2__["default"])());
  var isIE = /Trident/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_2__["default"])());
  if (isIE && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);
    if (elementCss.position === 'fixed') {
      return null;
    }
  }
  var currentNode = (0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element);
  if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(currentNode)) {
    currentNode = currentNode.host;
  }
  while ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(currentNode) && ['html', 'body'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__["default"])(currentNode)) < 0) {
    var css = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.

function getOffsetParent(element) {
  var window = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_5__["default"])(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && (0,_isTableElement_js__WEBPACK_IMPORTED_MODULE_6__["default"])(offsetParent) && (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent) === 'html' || (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent) === 'body' && (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent).position === 'static')) {
    return window;
  }
  return offsetParent || getContainingBlock(element) || window;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getParentNode)
/* harmony export */ });
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");



function getParentNode(element) {
  if ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element) === 'html') {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot ||
    // step into the shadow DOM of the parent of a slotted node
    element.parentNode || (
    // DOM Element detected
    (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isShadowRoot)(element) ? element.host : null) ||
    // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element) // fallback
  );
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getScrollParent)
/* harmony export */ });
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");




function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }
  if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(node) && (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__["default"])(node)) {
    return node;
  }
  return getScrollParent((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node));
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getViewportRect)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");
/* harmony import */ var _isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isLayoutViewport.js */ "./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js");




function getViewportRect(element, strategy) {
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var html = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = (0,_isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_2__["default"])();
    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width: width,
    height: height,
    x: x + (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element),
    y: y
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js":
/*!****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindow.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWindow)
/* harmony export */ });
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWindowScroll)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

function getWindowScroll(node) {
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWindowScrollBarX)
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");



function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)).left + (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element).scrollLeft;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isElement: () => (/* binding */ isElement),
/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),
/* harmony export */   isShadowRoot: () => (/* binding */ isShadowRoot)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

function isElement(node) {
  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }
  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}


/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isLayoutViewport)
/* harmony export */ });
/* harmony import */ var _utils_userAgent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/userAgent.js */ "./node_modules/@popperjs/core/lib/utils/userAgent.js");

function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_0__["default"])());
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isScrollParent)
/* harmony export */ });
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element),
    overflow = _getComputedStyle.overflow,
    overflowX = _getComputedStyle.overflowX,
    overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isTableElement)
/* harmony export */ });
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element)) >= 0;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js":
/*!************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ listScrollParents)
/* harmony export */ });
/* harmony import */ var _getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");




/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = (0,_getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__["default"])(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList :
  // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__["default"])(target)));
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/enums.js":
/*!**************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/enums.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   afterMain: () => (/* binding */ afterMain),
/* harmony export */   afterRead: () => (/* binding */ afterRead),
/* harmony export */   afterWrite: () => (/* binding */ afterWrite),
/* harmony export */   auto: () => (/* binding */ auto),
/* harmony export */   basePlacements: () => (/* binding */ basePlacements),
/* harmony export */   beforeMain: () => (/* binding */ beforeMain),
/* harmony export */   beforeRead: () => (/* binding */ beforeRead),
/* harmony export */   beforeWrite: () => (/* binding */ beforeWrite),
/* harmony export */   bottom: () => (/* binding */ bottom),
/* harmony export */   clippingParents: () => (/* binding */ clippingParents),
/* harmony export */   end: () => (/* binding */ end),
/* harmony export */   left: () => (/* binding */ left),
/* harmony export */   main: () => (/* binding */ main),
/* harmony export */   modifierPhases: () => (/* binding */ modifierPhases),
/* harmony export */   placements: () => (/* binding */ placements),
/* harmony export */   popper: () => (/* binding */ popper),
/* harmony export */   read: () => (/* binding */ read),
/* harmony export */   reference: () => (/* binding */ reference),
/* harmony export */   right: () => (/* binding */ right),
/* harmony export */   start: () => (/* binding */ start),
/* harmony export */   top: () => (/* binding */ top),
/* harmony export */   variationPlacements: () => (/* binding */ variationPlacements),
/* harmony export */   viewport: () => (/* binding */ viewport),
/* harmony export */   write: () => (/* binding */ write)
/* harmony export */ });
var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/applyStyles.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

 // This modifier takes the styles prepared by the `computeStyles` modifier
// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || !(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]

    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];
      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || !(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect,
  requires: ['computeStyles']
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/arrow.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/arrow.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../dom-utils/contains.js */ "./node_modules/@popperjs/core/lib/dom-utils/contains.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/within.js */ "./node_modules/@popperjs/core/lib/utils/within.js");
/* harmony import */ var _utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/mergePaddingObject.js */ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js");
/* harmony import */ var _utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/expandToHashMap.js */ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");








 // eslint-disable-next-line import/no-unused-modules

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return (0,_utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(typeof padding !== 'number' ? padding : (0,_utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_1__["default"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_2__.basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state,
    name = _ref.name,
    options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(state.placement);
  var axis = (0,_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(basePlacement);
  var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_2__.left, _enums_js__WEBPACK_IMPORTED_MODULE_2__.right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';
  if (!arrowElement || !popperOffsets) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__["default"])(arrowElement);
  var minProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_2__.top : _enums_js__WEBPACK_IMPORTED_MODULE_2__.left;
  var maxProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_2__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_2__.right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__["default"])(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_7__.within)(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}
function effect(_ref2) {
  var state = _ref2.state,
    options = _ref2.options;
  var _options$element = options.element,
    arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;
  if (arrowElement == null) {
    return;
  } // CSS selector

  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!(0,_dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_8__["default"])(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/computeStyles.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   mapToStyles: () => (/* binding */ mapToStyles)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");







 // eslint-disable-next-line import/no-unused-modules

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x,
    y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(x * dpr) / dpr || 0,
    y: (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper = _ref2.popper,
    popperRect = _ref2.popperRect,
    placement = _ref2.placement,
    variation = _ref2.variation,
    offsets = _ref2.offsets,
    position = _ref2.position,
    gpuAcceleration = _ref2.gpuAcceleration,
    adaptive = _ref2.adaptive,
    roundOffsets = _ref2.roundOffsets,
    isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
    x = _offsets$x === void 0 ? 0 : _offsets$x,
    _offsets$y = offsets.y,
    y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = _enums_js__WEBPACK_IMPORTED_MODULE_1__.left;
  var sideY = _enums_js__WEBPACK_IMPORTED_MODULE_1__.top;
  var win = window;
  if (adaptive) {
    var offsetParent = (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_2__["default"])(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';
    if (offsetParent === (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_3__["default"])(popper)) {
      offsetParent = (0,_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(popper);
      if ((0,_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_5__["default"])(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it

    offsetParent = offsetParent;
    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.top || (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.left || placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.right) && variation === _enums_js__WEBPACK_IMPORTED_MODULE_1__.end) {
      sideY = _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height :
      // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.left || (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.top || placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom) && variation === _enums_js__WEBPACK_IMPORTED_MODULE_1__.end) {
      sideX = _enums_js__WEBPACK_IMPORTED_MODULE_1__.right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width :
      // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }, (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_3__["default"])(popper)) : {
    x: x,
    y: y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state,
    options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
    gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
    _options$adaptive = options.adaptive,
    adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
    _options$roundOffsets = options.roundOffsets,
    roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state.placement),
    variation: (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_7__["default"])(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/eventListeners.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
 // eslint-disable-next-line import/no-unused-modules

var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state,
    instance = _ref.instance,
    options = _ref.options;
  var _options$scroll = options.scroll,
    scroll = _options$scroll === void 0 ? true : _options$scroll,
    _options$resize = options.resize,
    resize = _options$resize === void 0 ? true : _options$resize;
  var window = (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }
  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }
  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }
    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/flip.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/flip.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getOppositePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getOppositeVariationPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/computeAutoPlacement.js */ "./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");






 // eslint-disable-next-line import/no-unused-modules

function getExpandedFallbackPlacements(placement) {
  if ((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.auto) {
    return [];
  }
  var oppositePlacement = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(placement);
  return [(0,_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(placement), oppositePlacement, (0,_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state,
    options = _ref.options,
    name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis,
    checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
    _options$altAxis = options.altAxis,
    checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
    specifiedFallbackPlacements = options.fallbackPlacements,
    padding = options.padding,
    boundary = options.boundary,
    rootBoundary = options.rootBoundary,
    altBoundary = options.altBoundary,
    _options$flipVariatio = options.flipVariations,
    flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
    allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [(0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.auto ? (0,_utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];
  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];
    var _basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);
    var isStartVariation = (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_5__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.start;
    var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_1__.top, _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_1__.right : _enums_js__WEBPACK_IMPORTED_MODULE_1__.left : isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_1__.top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(mainVariationSide);
    }
    var altVariationSide = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    // `2` may be desired in some cases – research later
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);
        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/hide.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/hide.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");


function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [_enums_js__WEBPACK_IMPORTED_MODULE_0__.top, _enums_js__WEBPACK_IMPORTED_MODULE_0__.right, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom, _enums_js__WEBPACK_IMPORTED_MODULE_0__.left].some(function (side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state,
    name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyStyles: () => (/* reexport safe */ _applyStyles_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   arrow: () => (/* reexport safe */ _arrow_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   computeStyles: () => (/* reexport safe */ _computeStyles_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   eventListeners: () => (/* reexport safe */ _eventListeners_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   flip: () => (/* reexport safe */ _flip_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   hide: () => (/* reexport safe */ _hide_js__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   offset: () => (/* reexport safe */ _offset_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   popperOffsets: () => (/* reexport safe */ _popperOffsets_js__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   preventOverflow: () => (/* reexport safe */ _preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__["default"])
/* harmony export */ });
/* harmony import */ var _applyStyles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");
/* harmony import */ var _arrow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./arrow.js */ "./node_modules/@popperjs/core/lib/modifiers/arrow.js");
/* harmony import */ var _computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");
/* harmony import */ var _eventListeners_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");
/* harmony import */ var _flip_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flip.js */ "./node_modules/@popperjs/core/lib/modifiers/flip.js");
/* harmony import */ var _hide_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hide.js */ "./node_modules/@popperjs/core/lib/modifiers/hide.js");
/* harmony import */ var _offset_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./offset.js */ "./node_modules/@popperjs/core/lib/modifiers/offset.js");
/* harmony import */ var _popperOffsets_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");
/* harmony import */ var _preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./preventOverflow.js */ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js");










/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/offset.js":
/*!*************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/offset.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   distanceAndSkiddingToXY: () => (/* binding */ distanceAndSkiddingToXY)
/* harmony export */ });
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");

 // eslint-disable-next-line import/no-unused-modules

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);
  var invertDistance = [_enums_js__WEBPACK_IMPORTED_MODULE_1__.left, _enums_js__WEBPACK_IMPORTED_MODULE_1__.top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
      placement: placement
    })) : offset,
    skidding = _ref[0],
    distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [_enums_js__WEBPACK_IMPORTED_MODULE_1__.left, _enums_js__WEBPACK_IMPORTED_MODULE_1__.right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state,
    options = _ref2.options,
    name = _ref2.name;
  var _options$offset = options.offset,
    offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = _enums_js__WEBPACK_IMPORTED_MODULE_1__.placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
    x = _data$state$placement.x,
    y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/computeOffsets.js */ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js");

function popperOffsets(_ref) {
  var state = _ref.state,
    name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = (0,_utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/getAltAxis.js */ "./node_modules/@popperjs/core/lib/utils/getAltAxis.js");
/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/within.js */ "./node_modules/@popperjs/core/lib/utils/within.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/getFreshSideObject.js */ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");











function preventOverflow(_ref) {
  var state = _ref.state,
    options = _ref.options,
    name = _ref.name;
  var _options$mainAxis = options.mainAxis,
    checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
    _options$altAxis = options.altAxis,
    checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
    boundary = options.boundary,
    rootBoundary = options.rootBoundary,
    altBoundary = options.altBoundary,
    padding = options.padding,
    _options$tether = options.tether,
    tether = _options$tether === void 0 ? true : _options$tether,
    _options$tetherOffset = options.tetherOffset,
    tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state.placement);
  var variation = (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = (0,_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(basePlacement);
  var altAxis = (0,_utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_4__["default"])(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.top : _enums_js__WEBPACK_IMPORTED_MODULE_5__.left;
    var altSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_5__.right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min = offset + overflow[mainSide];
    var max = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_5__.start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_5__.start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__["default"])(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : (0,_utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_7__["default"])();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.within)(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_9__["default"])(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.within)(tether ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_10__.min)(min, tetherMin) : min, offset, tether ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_10__.max)(max, tetherMax) : max);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.top : _enums_js__WEBPACK_IMPORTED_MODULE_5__.left;
    var _altSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_5__.right;
    var _offset = popperOffsets[altAxis];
    var _len = altAxis === 'y' ? 'height' : 'width';
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [_enums_js__WEBPACK_IMPORTED_MODULE_5__.top, _enums_js__WEBPACK_IMPORTED_MODULE_5__.left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.withinMaxClamp)(_tetherMin, _offset, _tetherMax) : (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.within)(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/popper-lite.js":
/*!********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/popper-lite.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createPopper: () => (/* binding */ createPopper),
/* harmony export */   defaultModifiers: () => (/* binding */ defaultModifiers),
/* harmony export */   detectOverflow: () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   popperGenerator: () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_4__.popperGenerator)
/* harmony export */ });
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/createPopper.js");
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");
/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");
/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");
/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");





var defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__["default"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__["default"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__["default"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__["default"]];
var createPopper = /*#__PURE__*/(0,_createPopper_js__WEBPACK_IMPORTED_MODULE_4__.popperGenerator)({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/popper.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyStyles: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.applyStyles),
/* harmony export */   arrow: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.arrow),
/* harmony export */   computeStyles: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.computeStyles),
/* harmony export */   createPopper: () => (/* binding */ createPopper),
/* harmony export */   createPopperLite: () => (/* reexport safe */ _popper_lite_js__WEBPACK_IMPORTED_MODULE_11__.createPopper),
/* harmony export */   defaultModifiers: () => (/* binding */ defaultModifiers),
/* harmony export */   detectOverflow: () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   eventListeners: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.eventListeners),
/* harmony export */   flip: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.flip),
/* harmony export */   hide: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.hide),
/* harmony export */   offset: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.offset),
/* harmony export */   popperGenerator: () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_9__.popperGenerator),
/* harmony export */   popperOffsets: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.popperOffsets),
/* harmony export */   preventOverflow: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.preventOverflow)
/* harmony export */ });
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/createPopper.js");
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");
/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");
/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");
/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");
/* harmony import */ var _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modifiers/offset.js */ "./node_modules/@popperjs/core/lib/modifiers/offset.js");
/* harmony import */ var _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modifiers/flip.js */ "./node_modules/@popperjs/core/lib/modifiers/flip.js");
/* harmony import */ var _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modifiers/preventOverflow.js */ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js");
/* harmony import */ var _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modifiers/arrow.js */ "./node_modules/@popperjs/core/lib/modifiers/arrow.js");
/* harmony import */ var _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modifiers/hide.js */ "./node_modules/@popperjs/core/lib/modifiers/hide.js");
/* harmony import */ var _popper_lite_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./popper-lite.js */ "./node_modules/@popperjs/core/lib/popper-lite.js");
/* harmony import */ var _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modifiers/index.js */ "./node_modules/@popperjs/core/lib/modifiers/index.js");










var defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__["default"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__["default"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__["default"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__["default"], _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_4__["default"], _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_5__["default"], _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_6__["default"], _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_7__["default"], _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_8__["default"]];
var createPopper = /*#__PURE__*/(0,_createPopper_js__WEBPACK_IMPORTED_MODULE_9__.popperGenerator)({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ computeAutoPlacement)
/* harmony export */ });
/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");




function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options,
    placement = _options.placement,
    boundary = _options.boundary,
    rootBoundary = _options.rootBoundary,
    padding = _options.padding,
    flipVariations = _options.flipVariations,
    _options$allowedAutoP = _options.allowedAutoPlacements,
    allowedAutoPlacements = _options$allowedAutoP === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.placements : _options$allowedAutoP;
  var variation = (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement);
  var placements = variation ? flipVariations ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements : _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements.filter(function (placement) {
    return (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) === variation;
  }) : _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements;
  var allowedPlacements = placements.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements;
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...

  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = (0,_detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[(0,_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/computeOffsets.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ computeOffsets)
/* harmony export */ });
/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");




function computeOffsets(_ref) {
  var reference = _ref.reference,
    element = _ref.element,
    placement = _ref.placement;
  var basePlacement = placement ? (0,_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) : null;
  var variation = placement ? (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;
    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }
  var mainAxis = basePlacement ? (0,_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';
    switch (variation) {
      case _enums_js__WEBPACK_IMPORTED_MODULE_2__.start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;
      case _enums_js__WEBPACK_IMPORTED_MODULE_2__.end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/debounce.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/debounce.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ debounce)
/* harmony export */ });
function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }
    return pending;
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/detectOverflow.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ detectOverflow)
/* harmony export */ });
/* harmony import */ var _dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getClippingRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js");
/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _computeOffsets_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./computeOffsets.js */ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js");
/* harmony import */ var _rectToClientRect_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rectToClientRect.js */ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergePaddingObject.js */ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js");
/* harmony import */ var _expandToHashMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./expandToHashMap.js */ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js");








 // eslint-disable-next-line import/no-unused-modules

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options,
    _options$placement = _options.placement,
    placement = _options$placement === void 0 ? state.placement : _options$placement,
    _options$strategy = _options.strategy,
    strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
    _options$boundary = _options.boundary,
    boundary = _options$boundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.clippingParents : _options$boundary,
    _options$rootBoundary = _options.rootBoundary,
    rootBoundary = _options$rootBoundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.viewport : _options$rootBoundary,
    _options$elementConte = _options.elementContext,
    elementContext = _options$elementConte === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper : _options$elementConte,
    _options$altBoundary = _options.altBoundary,
    altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
    _options$padding = _options.padding,
    padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = (0,_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(typeof padding !== 'number' ? padding : (0,_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_2__["default"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements));
  var altContext = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.reference : _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = (0,_dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])((0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(element) ? element : element.contextElement || (0,_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__["default"])(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = (0,_dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state.elements.reference);
  var popperOffsets = (0,_computeOffsets_js__WEBPACK_IMPORTED_MODULE_7__["default"])({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = (0,_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_8__["default"])(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [_enums_js__WEBPACK_IMPORTED_MODULE_0__.right, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [_enums_js__WEBPACK_IMPORTED_MODULE_0__.top, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }
  return overflowOffsets;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/expandToHashMap.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ expandToHashMap)
/* harmony export */ });
function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getAltAxis.js":
/*!*************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getAltAxis.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getAltAxis)
/* harmony export */ });
function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getBasePlacement.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getBasePlacement)
/* harmony export */ });

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getFreshSideObject)
/* harmony export */ });
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getMainAxisFromPlacement)
/* harmony export */ });
function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getOppositePlacement)
/* harmony export */ });
var hash = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getOppositeVariationPlacement)
/* harmony export */ });
var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getVariation.js":
/*!***************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getVariation.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getVariation)
/* harmony export */ });
function getVariation(placement) {
  return placement.split('-')[1];
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/math.js":
/*!*******************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/math.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   round: () => (/* binding */ round)
/* harmony export */ });
var max = Math.max;
var min = Math.min;
var round = Math.round;

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/mergeByName.js":
/*!**************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/mergeByName.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mergeByName)
/* harmony export */ });
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mergePaddingObject)
/* harmony export */ });
/* harmony import */ var _getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getFreshSideObject.js */ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js");

function mergePaddingObject(paddingObject) {
  return Object.assign({}, (0,_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(), paddingObject);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/orderModifiers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/orderModifiers.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ orderModifiers)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
 // source: https://stackoverflow.com/questions/49875255

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return _enums_js__WEBPACK_IMPORTED_MODULE_0__.modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/rectToClientRect.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rectToClientRect)
/* harmony export */ });
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/userAgent.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/userAgent.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getUAString)
/* harmony export */ });
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function (item) {
      return item.brand + "/" + item.version;
    }).join(' ');
  }
  return navigator.userAgent;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/within.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/within.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   within: () => (/* binding */ within),
/* harmony export */   withinMaxClamp: () => (/* binding */ withinMaxClamp)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");

function within(min, value, max) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.max)(min, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(value, max));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}

/***/ }),

/***/ "./node_modules/@yaireo/tagify/dist/tagify.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@yaireo/tagify/dist/tagify.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ $)
/* harmony export */ });
/*
Tagify v4.31.3 - tags input component
By: Yair Even-Or <vsync.design@gmail.com>
https://github.com/yairEO/tagify

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

This Software may not be rebranded and sold as a library under any other name
other than "Tagify" (by owner) or as part of another library.
*/

var t = "&#8203;";
function e(t, e) {
  (null == e || e > t.length) && (e = t.length);
  for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];
  return n;
}
function i(t) {
  return function (t) {
    if (Array.isArray(t)) return e(t);
  }(t) || function (t) {
    if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
  }(t) || function (t, i) {
    if (!t) return;
    if ("string" == typeof t) return e(t, i);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    "Object" === n && t.constructor && (n = t.constructor.name);
    if ("Map" === n || "Set" === n) return Array.from(n);
    if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return e(t, i);
  }(t) || function () {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
var n = {
    isEnabled: function () {
      var t;
      return null === (t = window.TAGIFY_DEBUG) || void 0 === t || t;
    },
    log: function () {
      for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
      var s;
      this.isEnabled() && (s = console).log.apply(s, ["[Tagify]:"].concat(i(e)));
    },
    warn: function () {
      for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
      var s;
      this.isEnabled() && (s = console).warn.apply(s, ["[Tagify]:"].concat(i(e)));
    }
  },
  s = function (t, e, i, n) {
    return t = "" + t, e = "" + e, n && (t = t.trim(), e = e.trim()), i ? t == e : t.toLowerCase() == e.toLowerCase();
  },
  a = function (t, e) {
    return t && Array.isArray(t) && t.map(function (t) {
      return o(t, e);
    });
  };
function o(t, e) {
  var i,
    n = {};
  for (i in t) e.indexOf(i) < 0 && (n[i] = t[i]);
  return n;
}
function r(t) {
  return new DOMParser().parseFromString(t.trim(), "text/html").body.firstElementChild;
}
function l(t, e) {
  for (e = e || "previous"; t = t[e + "Sibling"];) if (3 == t.nodeType) return t;
}
function d(t) {
  return "string" == typeof t ? t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/`|'/g, "&#039;") : t;
}
function c(t) {
  var e = Object.prototype.toString.call(t).split(" ")[1].slice(0, -1);
  return t === Object(t) && "Array" != e && "Function" != e && "RegExp" != e && "HTMLUnknownElement" != e;
}
function u(t, e, i) {
  var n, s;
  function a(t, e) {
    for (var i in e) if (e.hasOwnProperty(i)) {
      if (c(e[i])) {
        c(t[i]) ? a(t[i], e[i]) : t[i] = Object.assign({}, e[i]);
        continue;
      }
      if (Array.isArray(e[i])) {
        t[i] = Object.assign([], e[i]);
        continue;
      }
      t[i] = e[i];
    }
  }
  return n = t, (null != (s = Object) && "undefined" != typeof Symbol && s[Symbol.hasInstance] ? s[Symbol.hasInstance](n) : n instanceof s) || (t = {}), a(t, e), i && a(t, i), t;
}
function g() {
  var t = [],
    e = {},
    i = !0,
    n = !1,
    s = void 0;
  try {
    for (var a, o = arguments[Symbol.iterator](); !(i = (a = o.next()).done); i = !0) {
      var r = a.value,
        l = !0,
        d = !1,
        u = void 0;
      try {
        for (var g, h = r[Symbol.iterator](); !(l = (g = h.next()).done); l = !0) {
          var p = g.value;
          c(p) ? e[p.value] || (t.push(p), e[p.value] = 1) : t.includes(p) || t.push(p);
        }
      } catch (t) {
        d = !0, u = t;
      } finally {
        try {
          l || null == h.return || h.return();
        } finally {
          if (d) throw u;
        }
      }
    }
  } catch (t) {
    n = !0, s = t;
  } finally {
    try {
      i || null == o.return || o.return();
    } finally {
      if (n) throw s;
    }
  }
  return t;
}
function h(t) {
  return String.prototype.normalize ? "string" == typeof t ? t.normalize("NFD").replace(/[\u0300-\u036f]/g, "") : void 0 : t;
}
var p = function () {
  return /(?=.*chrome)(?=.*android)/i.test(navigator.userAgent);
};
function f() {
  return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, function (t) {
    return (t ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> t / 4).toString(16);
  });
}
function m(t) {
  return t && t.classList && t.classList.contains(this.settings.classNames.tag);
}
function v(t) {
  return t && t.closest(this.settings.classNames.tagSelector);
}
function b(t, e) {
  var i = window.getSelection();
  return e = e || i.getRangeAt(0), "string" == typeof t && (t = document.createTextNode(t)), e && (e.deleteContents(), e.insertNode(t)), t;
}
function w(t, e, i) {
  return t ? (e && (t.__tagifyTagData = i ? e : u({}, t.__tagifyTagData || {}, e)), t.__tagifyTagData) : (n.warn("tag element doesn't exist", {
    tagElm: t,
    data: e
  }), e);
}
function y(t) {
  if (t && t.parentNode) {
    var e = t,
      i = window.getSelection(),
      n = i.getRangeAt(0);
    i.rangeCount && (n.setStartAfter(e), n.collapse(!0), i.removeAllRanges(), i.addRange(n));
  }
}
function T(t, e) {
  t.forEach(function (t) {
    if (w(t.previousSibling) || !t.previousSibling) {
      var i = document.createTextNode("​");
      t.before(i), e && y(i);
    }
  });
}
var O = {
  delimiters: ",",
  pattern: null,
  tagTextProp: "value",
  maxTags: 1 / 0,
  callbacks: {},
  addTagOnBlur: !0,
  addTagOn: ["blur", "tab", "enter"],
  onChangeAfterBlur: !0,
  duplicates: !1,
  whitelist: [],
  blacklist: [],
  enforceWhitelist: !1,
  userInput: !0,
  focusable: !0,
  keepInvalidTags: !1,
  createInvalidTags: !0,
  mixTagsAllowedAfter: /,|\.|\:|\s/,
  mixTagsInterpolator: ["[[", "]]"],
  backspace: !0,
  skipInvalid: !1,
  pasteAsTags: !0,
  editTags: {
    clicks: 2,
    keepInvalid: !0
  },
  transformTag: function () {},
  trim: !0,
  a11y: {
    focusableTags: !1
  },
  mixMode: {
    insertAfterTag: " "
  },
  autoComplete: {
    enabled: !0,
    rightKey: !1,
    tabKey: !1
  },
  classNames: {
    namespace: "tagify",
    mixMode: "tagify--mix",
    selectMode: "tagify--select",
    input: "tagify__input",
    focus: "tagify--focus",
    tagNoAnimation: "tagify--noAnim",
    tagInvalid: "tagify--invalid",
    tagNotAllowed: "tagify--notAllowed",
    scopeLoading: "tagify--loading",
    hasMaxTags: "tagify--hasMaxTags",
    hasNoTags: "tagify--noTags",
    empty: "tagify--empty",
    inputInvalid: "tagify__input--invalid",
    dropdown: "tagify__dropdown",
    dropdownWrapper: "tagify__dropdown__wrapper",
    dropdownHeader: "tagify__dropdown__header",
    dropdownFooter: "tagify__dropdown__footer",
    dropdownItem: "tagify__dropdown__item",
    dropdownItemActive: "tagify__dropdown__item--active",
    dropdownItemHidden: "tagify__dropdown__item--hidden",
    dropdownItemSelected: "tagify__dropdown__item--selected",
    dropdownInital: "tagify__dropdown--initial",
    tag: "tagify__tag",
    tagText: "tagify__tag-text",
    tagX: "tagify__tag__removeBtn",
    tagLoading: "tagify__tag--loading",
    tagEditing: "tagify__tag--editable",
    tagFlash: "tagify__tag--flash",
    tagHide: "tagify__tag--hide"
  },
  dropdown: {
    classname: "",
    enabled: 2,
    maxItems: 10,
    searchKeys: ["value", "searchBy"],
    fuzzySearch: !0,
    caseSensitive: !1,
    accentedSearch: !0,
    includeSelectedTags: !1,
    escapeHTML: !0,
    highlightFirst: !0,
    closeOnSelect: !0,
    clearOnSelect: !0,
    position: "all",
    appendTarget: null
  },
  hooks: {
    beforeRemoveTag: function () {
      return Promise.resolve();
    },
    beforePaste: function () {
      return Promise.resolve();
    },
    suggestionClick: function () {
      return Promise.resolve();
    },
    beforeKeyDown: function () {
      return Promise.resolve();
    }
  }
};
function x(t, e, i) {
  return e in t ? Object.defineProperty(t, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = i, t;
}
function D(t) {
  for (var e = 1; e < arguments.length; e++) {
    var i = null != arguments[e] ? arguments[e] : {},
      n = Object.keys(i);
    "function" == typeof Object.getOwnPropertySymbols && (n = n.concat(Object.getOwnPropertySymbols(i).filter(function (t) {
      return Object.getOwnPropertyDescriptor(i, t).enumerable;
    }))), n.forEach(function (e) {
      x(t, e, i[e]);
    });
  }
  return t;
}
function I(t, e) {
  return e = null != e ? e : {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(e)) : function (t, e) {
    var i = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(t);
      e && (n = n.filter(function (e) {
        return Object.getOwnPropertyDescriptor(t, e).enumerable;
      })), i.push.apply(i, n);
    }
    return i;
  }(Object(e)).forEach(function (i) {
    Object.defineProperty(t, i, Object.getOwnPropertyDescriptor(e, i));
  }), t;
}
function S(t, e) {
  (null == e || e > t.length) && (e = t.length);
  for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];
  return n;
}
function E(t, e, i) {
  return e in t ? Object.defineProperty(t, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = i, t;
}
function M(t) {
  return function (t) {
    if (Array.isArray(t)) return S(t);
  }(t) || function (t) {
    if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
  }(t) || function (t, e) {
    if (!t) return;
    if ("string" == typeof t) return S(t, e);
    var i = Object.prototype.toString.call(t).slice(8, -1);
    "Object" === i && t.constructor && (i = t.constructor.name);
    if ("Map" === i || "Set" === i) return Array.from(i);
    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return S(t, e);
  }(t) || function () {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
function N() {
  for (var t in this.dropdown = {}, this._dropdown) this.dropdown[t] = "function" == typeof this._dropdown[t] ? this._dropdown[t].bind(this) : this._dropdown[t];
  this.dropdown.refs(), this.DOM.dropdown.__tagify = this;
}
var _,
  A,
  C = (_ = function (t) {
    for (var e = 1; e < arguments.length; e++) {
      var i = null != arguments[e] ? arguments[e] : {},
        n = Object.keys(i);
      "function" == typeof Object.getOwnPropertySymbols && (n = n.concat(Object.getOwnPropertySymbols(i).filter(function (t) {
        return Object.getOwnPropertyDescriptor(i, t).enumerable;
      }))), n.forEach(function (e) {
        E(t, e, i[e]);
      });
    }
    return t;
  }({}, {
    events: {
      binding: function () {
        var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
          e = this.dropdown.events.callbacks,
          i = this.listeners.dropdown = this.listeners.dropdown || {
            position: this.dropdown.position.bind(this, null),
            onKeyDown: e.onKeyDown.bind(this),
            onMouseOver: e.onMouseOver.bind(this),
            onMouseLeave: e.onMouseLeave.bind(this),
            onClick: e.onClick.bind(this),
            onScroll: e.onScroll.bind(this)
          },
          n = t ? "addEventListener" : "removeEventListener";
        "manual" != this.settings.dropdown.position && (document[n]("scroll", i.position, !0), window[n]("resize", i.position), window[n]("keydown", i.onKeyDown)), this.DOM.dropdown[n]("mouseover", i.onMouseOver), this.DOM.dropdown[n]("mouseleave", i.onMouseLeave), this.DOM.dropdown[n]("mousedown", i.onClick), this.DOM.dropdown.content[n]("scroll", i.onScroll);
      },
      callbacks: {
        onKeyDown: function (t) {
          var e = this;
          if (this.state.hasFocus && !this.state.composing) {
            var i = this.settings,
              s = this.DOM.dropdown.querySelector(i.classNames.dropdownItemActiveSelector),
              a = this.dropdown.getSuggestionDataByNode(s),
              o = "mix" == i.mode,
              r = "select" == i.mode;
            i.hooks.beforeKeyDown(t, {
              tagify: this
            }).then(function (l) {
              switch (t.key) {
                case "ArrowDown":
                case "ArrowUp":
                case "Down":
                case "Up":
                  t.preventDefault();
                  var d = e.dropdown.getAllSuggestionsRefs(),
                    c = "ArrowUp" == t.key || "Up" == t.key;
                  s && (s = e.dropdown.getNextOrPrevOption(s, !c)), s && s.matches(i.classNames.dropdownItemSelector) || (s = d[c ? d.length - 1 : 0]), e.dropdown.highlightOption(s, !0);
                  break;
                case "Escape":
                case "Esc":
                  e.dropdown.hide();
                  break;
                case "ArrowRight":
                  if (e.state.actions.ArrowLeft || i.autoComplete.rightKey) return;
                case "Tab":
                  var u = !i.autoComplete.rightKey || !i.autoComplete.tabKey;
                  if (!o && !r && s && u && !e.state.editing && a) {
                    t.preventDefault();
                    var g = e.dropdown.getMappedValue(a);
                    return e.input.autocomplete.set.call(e, g), !1;
                  }
                  return !0;
                case "Enter":
                  t.preventDefault(), i.hooks.suggestionClick(t, {
                    tagify: e,
                    tagData: a,
                    suggestionElm: s
                  }).then(function () {
                    if (s) return e.dropdown.selectOption(s), s = e.dropdown.getNextOrPrevOption(s, !c), void e.dropdown.highlightOption(s);
                    e.dropdown.hide(), o || e.addTags(e.state.inputText.trim(), !0);
                  }).catch(function (t) {
                    return n.warn(t);
                  });
                  break;
                case "Backspace":
                  if (o || e.state.editing.scope) return;
                  var h = e.input.raw.call(e);
                  "" != h && 8203 != h.charCodeAt(0) || (!0 === i.backspace ? e.removeTags() : "edit" == i.backspace && setTimeout(e.editTag.bind(e), 0));
              }
            });
          }
        },
        onMouseOver: function (t) {
          var e = t.target.closest(this.settings.classNames.dropdownItemSelector);
          this.dropdown.highlightOption(e);
        },
        onMouseLeave: function (t) {
          this.dropdown.highlightOption();
        },
        onClick: function (t) {
          var e = this;
          if (0 == t.button && t.target != this.DOM.dropdown && t.target != this.DOM.dropdown.content) {
            var i = t.target.closest(this.settings.classNames.dropdownItemSelector),
              s = this.dropdown.getSuggestionDataByNode(i);
            this.state.actions.selectOption = !0, setTimeout(function () {
              return e.state.actions.selectOption = !1;
            }, 50), this.settings.hooks.suggestionClick(t, {
              tagify: this,
              tagData: s,
              suggestionElm: i
            }).then(function () {
              i ? e.dropdown.selectOption(i, t) : e.dropdown.hide();
            }).catch(function (t) {
              return n.warn(t);
            });
          }
        },
        onScroll: function (t) {
          var e = t.target,
            i = e.scrollTop / (e.scrollHeight - e.parentNode.clientHeight) * 100;
          this.trigger("dropdown:scroll", {
            percentage: Math.round(i)
          });
        }
      }
    },
    refilter: function (t) {
      t = t || this.state.dropdown.query || "", this.suggestedListItems = this.dropdown.filterListItems(t), this.dropdown.fill(), this.suggestedListItems.length || this.dropdown.hide(), this.trigger("dropdown:updated", this.DOM.dropdown);
    },
    getSuggestionDataByNode: function (t) {
      for (var e, i = t && t.getAttribute("value"), n = this.suggestedListItems.length; n--;) {
        if (c(e = this.suggestedListItems[n]) && e.value == i) return e;
        if (e == i) return {
          value: e
        };
      }
    },
    getNextOrPrevOption: function (t) {
      var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
        i = this.dropdown.getAllSuggestionsRefs(),
        n = i.findIndex(function (e) {
          return e === t;
        });
      return e ? i[n + 1] : i[n - 1];
    },
    highlightOption: function (t, e) {
      var i,
        n = this.settings.classNames.dropdownItemActive;
      if (this.state.ddItemElm && (this.state.ddItemElm.classList.remove(n), this.state.ddItemElm.removeAttribute("aria-selected")), !t) return this.state.ddItemData = null, this.state.ddItemElm = null, void this.input.autocomplete.suggest.call(this);
      i = this.dropdown.getSuggestionDataByNode(t), this.state.ddItemData = i, this.state.ddItemElm = t, t.classList.add(n), t.setAttribute("aria-selected", !0), e && (t.parentNode.scrollTop = t.clientHeight + t.offsetTop - t.parentNode.clientHeight), this.settings.autoComplete && (this.input.autocomplete.suggest.call(this, i), this.dropdown.position());
    },
    selectOption: function (t, e) {
      var i = this,
        n = this.settings,
        s = n.dropdown,
        a = s.clearOnSelect,
        o = s.closeOnSelect;
      if (!t) return this.addTags(this.state.inputText, !0), void (o && this.dropdown.hide());
      e = e || {};
      var r = t.getAttribute("value"),
        l = "noMatch" == r,
        d = "mix" == n.mode,
        c = this.suggestedListItems.find(function (t) {
          var e;
          return (null !== (e = t.value) && void 0 !== e ? e : t) == r;
        });
      if (this.trigger("dropdown:select", {
        data: c,
        elm: t,
        event: e
      }), c || l) {
        if (this.state.editing) {
          var g = this.normalizeTags([c])[0];
          c = n.transformTag.call(this, g) || g, this.onEditTagDone(null, u({
            __isValid: !0
          }, c));
        } else this[d ? "addMixTags" : "addTags"]([c || this.input.raw.call(this)], a);
        (d || this.DOM.input.parentNode) && (setTimeout(function () {
          i.DOM.input.focus(), i.toggleFocusClass(!0);
        }), o && setTimeout(this.dropdown.hide.bind(this)), t.addEventListener("transitionend", function () {
          i.dropdown.fillHeaderFooter(), setTimeout(function () {
            t.remove(), i.dropdown.refilter();
          }, 100);
        }, {
          once: !0
        }), t.classList.add(this.settings.classNames.dropdownItemHidden));
      } else o && setTimeout(this.dropdown.hide.bind(this));
    },
    selectAll: function (t) {
      this.suggestedListItems.length = 0, this.dropdown.hide(), this.dropdown.filterListItems("");
      var e = this.dropdown.filterListItems("");
      return t || (e = this.state.dropdown.suggestions), this.addTags(e, !0), this;
    },
    filterListItems: function (t, e) {
      var i,
        n,
        s,
        a,
        o,
        r,
        l = function () {
          var t,
            l,
            d = void 0,
            u = void 0;
          t = m[y], n = (null != (l = Object) && "undefined" != typeof Symbol && l[Symbol.hasInstance] ? l[Symbol.hasInstance](t) : t instanceof l) ? m[y] : {
            value: m[y]
          };
          var v,
            b = !Object.keys(n).some(function (t) {
              return w.includes(t);
            }) ? ["value"] : w;
          g.fuzzySearch && !e.exact ? (a = b.reduce(function (t, e) {
            return t + " " + (n[e] || "");
          }, "").toLowerCase().trim(), g.accentedSearch && (a = h(a), r = h(r)), d = 0 == a.indexOf(r), u = a === r, v = a, s = r.toLowerCase().split(" ").every(function (t) {
            return v.includes(t.toLowerCase());
          })) : (d = !0, s = b.some(function (t) {
            var i = "" + (n[t] || "");
            return g.accentedSearch && (i = h(i), r = h(r)), g.caseSensitive || (i = i.toLowerCase()), u = i === r, e.exact ? i === r : 0 == i.indexOf(r);
          })), o = !g.includeSelectedTags && i.isTagDuplicate(c(n) ? n.value : n), s && !o && (u && d ? f.push(n) : "startsWith" == g.sortby && d ? p.unshift(n) : p.push(n));
        },
        d = this,
        u = this.settings,
        g = u.dropdown,
        p = (e = e || {}, []),
        f = [],
        m = u.whitelist,
        v = g.maxItems >= 0 ? g.maxItems : 1 / 0,
        b = g.includeSelectedTags || "select" == u.mode,
        w = g.searchKeys,
        y = 0;
      if (!(t = "select" == u.mode && this.value.length && this.value[0][u.tagTextProp] == t ? "" : t) || !w.length) return p = b ? m : m.filter(function (t) {
        return !d.isTagDuplicate(c(t) ? t.value : t);
      }), this.state.dropdown.suggestions = p, p.slice(0, v);
      for (r = g.caseSensitive ? "" + t : ("" + t).toLowerCase(); y < m.length; y++) i = this, l();
      return this.state.dropdown.suggestions = f.concat(p), "function" == typeof g.sortby ? g.sortby(f.concat(p), r) : f.concat(p).slice(0, v);
    },
    getMappedValue: function (t) {
      var e = this.settings.dropdown.mapValueTo;
      return e ? "function" == typeof e ? e(t) : t[e] || t.value : t.value;
    },
    createListHTML: function (t) {
      var e = this;
      return u([], t).map(function (t, i) {
        "string" != typeof t && "number" != typeof t || (t = {
          value: t
        });
        var n = e.dropdown.getMappedValue(t);
        return n = "string" == typeof n && e.settings.dropdown.escapeHTML ? d(n) : n, e.settings.templates.dropdownItem.apply(e, [I(D({}, t), {
          mappedValue: n
        }), e]);
      }).join("");
    }
  }), A = null != (A = {
    refs: function () {
      this.DOM.dropdown = this.parseTemplate("dropdown", [this.settings]), this.DOM.dropdown.content = this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-wrapper']");
    },
    getHeaderRef: function () {
      return this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-header']");
    },
    getFooterRef: function () {
      return this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-footer']");
    },
    getAllSuggestionsRefs: function () {
      return M(this.DOM.dropdown.content.querySelectorAll(this.settings.classNames.dropdownItemSelector));
    },
    show: function (t) {
      var e,
        i,
        n,
        a = this,
        o = this.settings,
        r = "mix" == o.mode && !o.enforceWhitelist,
        l = !o.whitelist || !o.whitelist.length,
        d = "manual" == o.dropdown.position;
      if (t = void 0 === t ? this.state.inputText : t, !(l && !r && !o.templates.dropdownItemNoMatch || !1 === o.dropdown.enable || this.state.isLoading || this.settings.readonly)) {
        if (clearTimeout(this.dropdownHide__bindEventsTimeout), this.suggestedListItems = this.dropdown.filterListItems(t), t && !this.suggestedListItems.length && (this.trigger("dropdown:noMatch", t), o.templates.dropdownItemNoMatch && (n = o.templates.dropdownItemNoMatch.call(this, {
          value: t
        }))), !n) {
          if (this.suggestedListItems.length) t && r && !this.state.editing.scope && !s(this.suggestedListItems[0].value, t) && this.suggestedListItems.unshift({
            value: t
          });else {
            if (!t || !r || this.state.editing.scope) return this.input.autocomplete.suggest.call(this), void this.dropdown.hide();
            this.suggestedListItems = [{
              value: t
            }];
          }
          i = "" + (c(e = this.suggestedListItems[0]) ? e.value : e), o.autoComplete && i && 0 == i.indexOf(t) && this.input.autocomplete.suggest.call(this, e);
        }
        this.dropdown.fill(n), o.dropdown.highlightFirst && this.dropdown.highlightOption(this.DOM.dropdown.content.querySelector(o.classNames.dropdownItemSelector)), this.state.dropdown.visible || setTimeout(this.dropdown.events.binding.bind(this)), this.state.dropdown.visible = t || !0, this.state.dropdown.query = t, this.setStateSelection(), d || setTimeout(function () {
          a.dropdown.position(), a.dropdown.render();
        }), setTimeout(function () {
          a.trigger("dropdown:show", a.DOM.dropdown);
        });
      }
    },
    hide: function (t) {
      var e = this,
        i = this.DOM,
        n = i.scope,
        s = i.dropdown,
        a = "manual" == this.settings.dropdown.position && !t;
      if (s && document.body.contains(s) && !a) return window.removeEventListener("resize", this.dropdown.position), this.dropdown.events.binding.call(this, !1), n.setAttribute("aria-expanded", !1), s.parentNode.removeChild(s), setTimeout(function () {
        e.state.dropdown.visible = !1;
      }, 100), this.state.dropdown.query = this.state.ddItemData = this.state.ddItemElm = this.state.selection = null, this.state.tag && this.state.tag.value.length && (this.state.flaggedTags[this.state.tag.baseOffset] = this.state.tag), this.trigger("dropdown:hide", s), this;
    },
    toggle: function (t) {
      this.dropdown[this.state.dropdown.visible && !t ? "hide" : "show"]();
    },
    getAppendTarget: function () {
      var t = this.settings.dropdown;
      return "function" == typeof t.appendTarget ? t.appendTarget() : t.appendTarget;
    },
    render: function () {
      var t,
        e,
        i,
        n = this,
        s = (t = this.DOM.dropdown, (i = t.cloneNode(!0)).style.cssText = "position:fixed; top:-9999px; opacity:0", document.body.appendChild(i), e = i.clientHeight, i.parentNode.removeChild(i), e),
        a = this.settings,
        o = this.dropdown.getAppendTarget();
      return !1 === a.dropdown.enabled || (this.DOM.scope.setAttribute("aria-expanded", !0), document.body.contains(this.DOM.dropdown) || (this.DOM.dropdown.classList.add(a.classNames.dropdownInital), this.dropdown.position(s), o.appendChild(this.DOM.dropdown), setTimeout(function () {
        return n.DOM.dropdown.classList.remove(a.classNames.dropdownInital);
      }))), this;
    },
    fill: function (t) {
      t = "string" == typeof t ? t : this.dropdown.createListHTML(t || this.suggestedListItems);
      var e,
        i = this.settings.templates.dropdownContent.call(this, t);
      this.DOM.dropdown.content.innerHTML = (e = i) ? e.replace(/\>[\r\n ]+\</g, "><").split(/>\s+</).join("><").trim() : "";
    },
    fillHeaderFooter: function () {
      var t = this.dropdown.filterListItems(this.state.dropdown.query),
        e = this.parseTemplate("dropdownHeader", [t]),
        i = this.parseTemplate("dropdownFooter", [t]),
        n = this.dropdown.getHeaderRef(),
        s = this.dropdown.getFooterRef();
      e && (null == n || n.parentNode.replaceChild(e, n)), i && (null == s || s.parentNode.replaceChild(i, s));
    },
    position: function (t) {
      var e = this.settings.dropdown,
        i = this.dropdown.getAppendTarget();
      if ("manual" != e.position && i) {
        var n,
          s,
          a,
          o,
          r,
          l,
          d,
          c,
          u,
          g = this.DOM.dropdown,
          h = e.RTL,
          p = i === document.body,
          f = i === this.DOM.scope,
          m = p ? window.pageYOffset : i.scrollTop,
          v = document.fullscreenElement || document.webkitFullscreenElement || document.documentElement,
          b = v.clientHeight,
          w = Math.max(v.clientWidth || 0, window.innerWidth || 0) > 480 ? e.position : "all",
          y = this.DOM["input" == w ? "input" : "scope"];
        if (t = t || g.clientHeight, this.state.dropdown.visible) {
          if ("text" == w ? (a = (n = function () {
            var t = document.getSelection();
            if (t.rangeCount) {
              var e,
                i,
                n = t.getRangeAt(0),
                s = n.startContainer,
                a = n.startOffset;
              if (a > 0) return (i = document.createRange()).setStart(s, a - 1), i.setEnd(s, a), {
                left: (e = i.getBoundingClientRect()).right,
                top: e.top,
                bottom: e.bottom
              };
              if (s.getBoundingClientRect) return s.getBoundingClientRect();
            }
            return {
              left: -9999,
              top: -9999
            };
          }()).bottom, s = n.top, o = n.left, r = "auto") : (l = function (t) {
            var e = 0,
              i = 0;
            for (t = t.parentNode; t && t != v;) e += t.offsetTop || 0, i += t.offsetLeft || 0, t = t.parentNode;
            return {
              top: e,
              left: i
            };
          }(i), n = y.getBoundingClientRect(), s = f ? -1 : n.top - l.top, a = (f ? n.height : n.bottom - l.top) - 1, o = f ? -1 : n.left - l.left, r = n.width + "px"), !p) {
            var T = function () {
              for (var t = 0, i = e.appendTarget.parentNode; i;) t += i.scrollTop || 0, i = i.parentNode;
              return t;
            }();
            s += T, a += T;
          }
          var O;
          s = Math.floor(s), a = Math.ceil(a), c = ((d = null !== (O = e.placeAbove) && void 0 !== O ? O : b - n.bottom < t) ? s : a) + m, u = "left: ".concat(o + (h && n.width || 0) + window.pageXOffset, "px;"), g.style.cssText = "".concat(u, "; top: ").concat(c, "px; min-width: ").concat(r, "; max-width: ").concat(r), g.setAttribute("placement", d ? "top" : "bottom"), g.setAttribute("position", w);
        }
      }
    }
  }) ? A : {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(_, Object.getOwnPropertyDescriptors(A)) : function (t, e) {
    var i = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(t);
      e && (n = n.filter(function (e) {
        return Object.getOwnPropertyDescriptor(t, e).enumerable;
      })), i.push.apply(i, n);
    }
    return i;
  }(Object(A)).forEach(function (t) {
    Object.defineProperty(_, t, Object.getOwnPropertyDescriptor(A, t));
  }), _),
  k = "@yaireo/tagify/",
  L = {
    empty: "empty",
    exceed: "number of tags exceeded",
    pattern: "pattern mismatch",
    duplicate: "already exists",
    notAllowed: "not allowed"
  },
  j = {
    wrapper: function (e, i) {
      return '<tags class="'.concat(i.classNames.namespace, " ").concat(i.mode ? "".concat(i.classNames[i.mode + "Mode"]) : "", " ").concat(e.className, '"\n                    ').concat(i.readonly ? "readonly" : "", "\n                    ").concat(i.disabled ? "disabled" : "", "\n                    ").concat(i.required ? "required" : "", "\n                    ").concat("select" === i.mode ? "spellcheck='false'" : "", '\n                    tabIndex="-1">\n                    ').concat(this.settings.templates.input.call(this), "\n                ").concat(t, "\n        </tags>");
    },
    input: function () {
      var e = this.settings,
        i = e.placeholder || t;
      return "<span ".concat(!e.readonly && e.userInput ? "contenteditable" : "", ' tabIndex="0" data-placeholder="').concat(i, '" aria-placeholder="').concat(e.placeholder || "", '"\n                    class="').concat(e.classNames.input, '"\n                    role="textbox"\n                    autocapitalize="false"\n                    autocorrect="off"\n                    spellcheck="false"\n                    aria-autocomplete="both"\n                    aria-multiline="').concat("mix" == e.mode, '"></span>');
    },
    tag: function (t, e) {
      var i = e.settings;
      return '<tag title="'.concat(t.title || t.value, "\"\n                    contenteditable='false'\n                    tabIndex=\"").concat(i.a11y.focusableTags ? 0 : -1, '"\n                    class="').concat(i.classNames.tag, " ").concat(t.class || "", '"\n                    ').concat(this.getAttributes(t), ">\n            <x title='' tabIndex=\"").concat(i.a11y.focusableTags ? 0 : -1, '" class="').concat(i.classNames.tagX, "\" role='button' aria-label='remove tag'></x>\n            <div>\n                <span ").concat("select" === i.mode && i.userInput ? "contenteditable='true'" : "", ' autocapitalize="false" autocorrect="off" spellcheck=\'false\' class="').concat(i.classNames.tagText, '">').concat(t[i.tagTextProp] || t.value, "</span>\n            </div>\n        </tag>");
    },
    dropdown: function (t) {
      var e = t.dropdown,
        i = "manual" == e.position;
      return '<div class="'.concat(i ? "" : t.classNames.dropdown, " ").concat(e.classname, '" role="listbox" aria-labelledby="dropdown" dir="').concat(e.RTL ? "rtl" : "", "\">\n                    <div data-selector='tagify-suggestions-wrapper' class=\"").concat(t.classNames.dropdownWrapper, '"></div>\n                </div>');
    },
    dropdownContent: function (t) {
      var e = this.settings.templates,
        i = this.state.dropdown.suggestions;
      return "\n            ".concat(e.dropdownHeader.call(this, i), "\n            ").concat(t, "\n            ").concat(e.dropdownFooter.call(this, i), "\n        ");
    },
    dropdownItem: function (t) {
      return "<div ".concat(this.getAttributes(t), "\n                    class='").concat(this.settings.classNames.dropdownItem, " ").concat(this.isTagDuplicate(t.value) ? this.settings.classNames.dropdownItemSelected : "", " ").concat(t.class || "", '\'\n                    tabindex="0"\n                    role="option">').concat(t.mappedValue || t.value, "</div>");
    },
    dropdownHeader: function (t) {
      return "<header data-selector='tagify-suggestions-header' class=\"".concat(this.settings.classNames.dropdownHeader, '"></header>');
    },
    dropdownFooter: function (t) {
      var e = t.length - this.settings.dropdown.maxItems;
      return e > 0 ? "<footer data-selector='tagify-suggestions-footer' class=\"".concat(this.settings.classNames.dropdownFooter, '">\n                ').concat(e, " more items. Refine your search.\n            </footer>") : "";
    },
    dropdownItemNoMatch: null
  };
function P(t, e) {
  (null == e || e > t.length) && (e = t.length);
  for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];
  return n;
}
function V(t, e) {
  return null != e && "undefined" != typeof Symbol && e[Symbol.hasInstance] ? !!e[Symbol.hasInstance](t) : t instanceof e;
}
function F(t, e) {
  return function (t) {
    if (Array.isArray(t)) return t;
  }(t) || function (t, e) {
    var i = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
    if (null != i) {
      var n,
        s,
        a = [],
        o = !0,
        r = !1;
      try {
        for (i = i.call(t); !(o = (n = i.next()).done) && (a.push(n.value), !e || a.length !== e); o = !0);
      } catch (t) {
        r = !0, s = t;
      } finally {
        try {
          o || null == i.return || i.return();
        } finally {
          if (r) throw s;
        }
      }
      return a;
    }
  }(t, e) || function (t, e) {
    if (!t) return;
    if ("string" == typeof t) return P(t, e);
    var i = Object.prototype.toString.call(t).slice(8, -1);
    "Object" === i && t.constructor && (i = t.constructor.name);
    if ("Map" === i || "Set" === i) return Array.from(i);
    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return P(t, e);
  }(t, e) || function () {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
function R(t, e) {
  (null == e || e > t.length) && (e = t.length);
  for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];
  return n;
}
function H(t, e, i) {
  return e in t ? Object.defineProperty(t, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = i, t;
}
function B(t, e) {
  return null != e && "undefined" != typeof Symbol && e[Symbol.hasInstance] ? !!e[Symbol.hasInstance](t) : t instanceof e;
}
function W(t, e) {
  return e = null != e ? e : {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(e)) : function (t, e) {
    var i = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(t);
      e && (n = n.filter(function (e) {
        return Object.getOwnPropertyDescriptor(t, e).enumerable;
      })), i.push.apply(i, n);
    }
    return i;
  }(Object(e)).forEach(function (i) {
    Object.defineProperty(t, i, Object.getOwnPropertyDescriptor(e, i));
  }), t;
}
function K(t) {
  return function (t) {
    if (Array.isArray(t)) return R(t);
  }(t) || function (t) {
    if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
  }(t) || function (t, e) {
    if (!t) return;
    if ("string" == typeof t) return R(t, e);
    var i = Object.prototype.toString.call(t).slice(8, -1);
    "Object" === i && t.constructor && (i = t.constructor.name);
    if ("Map" === i || "Set" === i) return Array.from(i);
    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return R(t, e);
  }(t) || function () {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
var U = {
  customBinding: function () {
    var t = this;
    this.customEventsList.forEach(function (e) {
      t.on(e, t.settings.callbacks[e]);
    });
  },
  binding: function () {
    var t,
      e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
      i = this.settings,
      n = this.events.callbacks,
      s = e ? "addEventListener" : "removeEventListener";
    if (!this.state.mainEvents || !e) {
      for (var a in this.state.mainEvents = e, e && !this.listeners.main && (this.events.bindGlobal.call(this), this.settings.isJQueryPlugin && jQuery(this.DOM.originalInput).on("tagify.removeAllTags", this.removeAllTags.bind(this))), t = this.listeners.main = this.listeners.main || {
        keydown: ["input", n.onKeydown.bind(this)],
        click: ["scope", n.onClickScope.bind(this)],
        dblclick: "select" != i.mode && ["scope", n.onDoubleClickScope.bind(this)],
        paste: ["input", n.onPaste.bind(this)],
        drop: ["input", n.onDrop.bind(this)],
        compositionstart: ["input", n.onCompositionStart.bind(this)],
        compositionend: ["input", n.onCompositionEnd.bind(this)]
      }) t[a] && this.DOM[t[a][0]][s](a, t[a][1]);
      var o = this.listeners.main.inputMutationObserver || new MutationObserver(n.onInputDOMChange.bind(this));
      o.disconnect(), "mix" == i.mode && o.observe(this.DOM.input, {
        childList: !0
      }), this.events.bindOriginaInputListener.call(this);
    }
  },
  bindOriginaInputListener: function (t) {
    var e = (t || 0) + 500;
    this.listeners.main && (clearInterval(this.listeners.main.originalInputValueObserverInterval), this.listeners.main.originalInputValueObserverInterval = setInterval(this.events.callbacks.observeOriginalInputValue.bind(this), e));
  },
  bindGlobal: function (t) {
    var e,
      i = this.events.callbacks,
      n = t ? "removeEventListener" : "addEventListener";
    if (this.listeners && (t || !this.listeners.global)) {
      this.listeners.global = this.listeners.global || [{
        type: this.isIE ? "keydown" : "input",
        target: this.DOM.input,
        cb: i[this.isIE ? "onInputIE" : "onInput"].bind(this)
      }, {
        type: "keydown",
        target: window,
        cb: i.onWindowKeyDown.bind(this)
      }, {
        type: "focusin",
        target: this.DOM.scope,
        cb: i.onFocusBlur.bind(this)
      }, {
        type: "focusout",
        target: this.DOM.scope,
        cb: i.onFocusBlur.bind(this)
      }, {
        type: "click",
        target: document,
        cb: i.onClickAnywhere.bind(this),
        useCapture: !0
      }];
      var s = !0,
        a = !1,
        o = void 0;
      try {
        for (var r, l = this.listeners.global[Symbol.iterator](); !(s = (r = l.next()).done); s = !0) (e = r.value).target[n](e.type, e.cb, !!e.useCapture);
      } catch (t) {
        a = !0, o = t;
      } finally {
        try {
          s || null == l.return || l.return();
        } finally {
          if (a) throw o;
        }
      }
    }
  },
  unbindGlobal: function () {
    this.events.bindGlobal.call(this, !0);
  },
  callbacks: {
    onFocusBlur: function (t) {
      var e,
        i,
        n = this.settings,
        s = v.call(this, t.target),
        a = m.call(this, t.target),
        o = t.target.classList.contains(n.classNames.tagX),
        r = "focusin" == t.type,
        l = "focusout" == t.type;
      s && r && !a && !o && this.toggleFocusClass(this.state.hasFocus = +new Date());
      var d = t.target ? this.trim(this.DOM.input.textContent) : "",
        c = null === (i = this.value) || void 0 === i || null === (e = i[0]) || void 0 === e ? void 0 : e[n.tagTextProp],
        u = n.dropdown.enabled >= 0,
        g = {
          relatedTarget: t.relatedTarget
        },
        h = this.state.actions.selectOption && (u || !n.dropdown.closeOnSelect),
        p = this.state.actions.addNew && u;
      if (l) {
        if (t.relatedTarget === this.DOM.scope) return this.dropdown.hide(), void this.DOM.input.focus();
        this.postUpdate(), n.onChangeAfterBlur && this.triggerChangeEvent();
      }
      if (!(h || p || o)) if (r || s ? (this.state.hasFocus = +new Date(), this.toggleFocusClass(this.state.hasFocus)) : this.state.hasFocus = !1, "mix" != n.mode) {
        if (r) {
          if (!n.focusable) return;
          var f = 0 === n.dropdown.enabled && !this.state.dropdown.visible,
            b = !a || "select" === n.mode;
          return this.toggleFocusClass(!0), this.trigger("focus", g), void (f && b && this.dropdown.show(this.value.length ? "" : void 0));
        }
        if (l) {
          if (this.trigger("blur", g), this.loading(!1), "select" == n.mode) {
            if (this.value.length) {
              var w = this.getTagElms()[0];
              d = this.trim(w.textContent);
            }
            c === d && (d = "");
          }
          d && !this.state.actions.selectOption && n.addTagOnBlur && n.addTagOn.includes("blur") && this.addTags(d, !0);
        }
        s || (this.DOM.input.removeAttribute("style"), this.dropdown.hide());
      } else r ? this.trigger("focus", g) : l && (this.trigger("blur", g), this.loading(!1), this.dropdown.hide(), this.state.dropdown.visible = void 0, this.setStateSelection());
    },
    onCompositionStart: function (t) {
      this.state.composing = !0;
    },
    onCompositionEnd: function (t) {
      this.state.composing = !1;
    },
    onWindowKeyDown: function (t) {
      var e,
        i = this.settings,
        n = document.activeElement,
        s = v.call(this, n) && this.DOM.scope.contains(document.activeElement),
        a = s && n.hasAttribute("readonly");
      if (this.state.hasFocus || s && !a) {
        e = n.nextElementSibling;
        var o = t.target.classList.contains(i.classNames.tagX);
        switch (t.key) {
          case "Backspace":
            i.readonly || this.state.editing || (this.removeTags(n), (e || this.DOM.input).focus());
            break;
          case "Enter":
            if (o) return void this.removeTags(t.target.parentNode);
            i.a11y.focusableTags && m.call(this, n) && setTimeout(this.editTag.bind(this), 0, n);
            break;
          case "ArrowDown":
            this.state.dropdown.visible || "mix" == i.mode || this.dropdown.show();
        }
      }
    },
    onKeydown: function (t) {
      var e = this,
        i = this.settings;
      if (!this.state.composing && i.userInput) {
        "select" == i.mode && i.enforceWhitelist && this.value.length && "Tab" != t.key && t.preventDefault();
        var n = this.trim(t.target.textContent);
        this.trigger("keydown", {
          event: t
        }), i.hooks.beforeKeyDown(t, {
          tagify: this
        }).then(function (s) {
          if ("mix" == i.mode) {
            switch (t.key) {
              case "Left":
              case "ArrowLeft":
                e.state.actions.ArrowLeft = !0;
                break;
              case "Delete":
              case "Backspace":
                if (e.state.editing) return;
                var a = document.getSelection(),
                  o = "Delete" == t.key && a.anchorOffset == (a.anchorNode.length || 0),
                  r = a.anchorNode.previousSibling,
                  d = 1 == a.anchorNode.nodeType || !a.anchorOffset && r && 1 == r.nodeType && a.anchorNode.previousSibling;
                !function (t) {
                  var e = document.createElement("div");
                  t.replace(/\&#?[0-9a-z]+;/gi, function (t) {
                    return e.innerHTML = t, e.innerText;
                  });
                }(e.DOM.input.innerHTML);
                var c,
                  u,
                  g,
                  h = e.getTagElms(),
                  f = 1 === a.anchorNode.length && a.anchorNode.nodeValue == String.fromCharCode(8203);
                if ("edit" == i.backspace && d) return c = 1 == a.anchorNode.nodeType ? null : a.anchorNode.previousElementSibling, setTimeout(e.editTag.bind(e), 0, c), void t.preventDefault();
                if (p() && B(d, Element)) return g = l(d), d.hasAttribute("readonly") || d.remove(), e.DOM.input.focus(), void setTimeout(function () {
                  y(g), e.DOM.input.click();
                });
                if ("BR" == a.anchorNode.nodeName) return;
                if ((o || d) && 1 == a.anchorNode.nodeType ? u = 0 == a.anchorOffset ? o ? h[0] : null : h[Math.min(h.length, a.anchorOffset) - 1] : o ? u = a.anchorNode.nextElementSibling : B(d, Element) && (u = d), 3 == a.anchorNode.nodeType && !a.anchorNode.nodeValue && a.anchorNode.previousElementSibling && t.preventDefault(), (d || o) && !i.backspace) return void t.preventDefault();
                if ("Range" != a.type && !a.anchorOffset && a.anchorNode == e.DOM.input && "Delete" != t.key) return void t.preventDefault();
                if ("Range" != a.type && u && u.hasAttribute("readonly")) return void y(l(u));
                "Delete" == t.key && f && w(a.anchorNode.nextSibling) && e.removeTags(a.anchorNode.nextSibling);
            }
            return !0;
          }
          var m = "manual" == i.dropdown.position;
          switch (t.key) {
            case "Backspace":
              "select" == i.mode && i.enforceWhitelist && e.value.length ? e.removeTags() : e.state.dropdown.visible && "manual" != i.dropdown.position || "" != t.target.textContent && 8203 != n.charCodeAt(0) || (!0 === i.backspace ? e.removeTags() : "edit" == i.backspace && setTimeout(e.editTag.bind(e), 0));
              break;
            case "Esc":
            case "Escape":
              if (e.state.dropdown.visible) return;
              t.target.blur();
              break;
            case "Down":
            case "ArrowDown":
              e.state.dropdown.visible || e.dropdown.show();
              break;
            case "ArrowRight":
              var v = e.state.inputSuggestion || e.state.ddItemData;
              if (v && i.autoComplete.rightKey) return void e.addTags([v], !0);
              break;
            case "Tab":
              var b = "select" == i.mode;
              if (!n || b) return !0;
              t.preventDefault();
            case "Enter":
              if (e.state.dropdown.visible && !m) return;
              t.preventDefault(), setTimeout(function () {
                e.state.dropdown.visible && !m || e.state.actions.selectOption || !i.addTagOn.includes(t.key.toLowerCase()) || e.addTags(n, !0);
              });
          }
        }).catch(function (t) {
          return t;
        });
      }
    },
    onInput: function (t) {
      this.postUpdate();
      var e = this.settings;
      if ("mix" == e.mode) return this.events.callbacks.onMixTagsInput.call(this, t);
      var i = this.input.normalize.call(this, void 0, {
          trim: !1
        }),
        n = i.length >= e.dropdown.enabled,
        s = {
          value: i,
          inputElm: this.DOM.input
        },
        a = this.validateTag({
          value: i
        });
      "select" == e.mode && this.toggleScopeValidation(a), s.isValid = a, this.state.inputText != i && (this.input.set.call(this, i, !1), -1 != i.search(e.delimiters) ? this.addTags(i) && this.input.set.call(this) : e.dropdown.enabled >= 0 && this.dropdown[n ? "show" : "hide"](i), this.trigger("input", s));
    },
    onMixTagsInput: function (t) {
      var e,
        i,
        n,
        s,
        a,
        o,
        r,
        l,
        d = this,
        c = this.settings,
        g = this.value.length,
        h = this.getTagElms(),
        f = document.createDocumentFragment(),
        m = window.getSelection().getRangeAt(0),
        v = [].map.call(h, function (t) {
          return w(t).value;
        });
      if ("deleteContentBackward" == t.inputType && p() && this.events.callbacks.onKeydown.call(this, {
        target: t.target,
        key: "Backspace"
      }), T(this.getTagElms()), this.value.slice().forEach(function (t) {
        t.readonly && !v.includes(t.value) && f.appendChild(d.createTagElem(t));
      }), f.childNodes.length && (m.insertNode(f), this.setRangeAtStartEnd(!1, f.lastChild)), h.length != g) return this.value = [].map.call(this.getTagElms(), function (t) {
        return w(t);
      }), void this.update({
        withoutChangeEvent: !0
      });
      if (this.hasMaxTags()) return !0;
      if (window.getSelection && (o = window.getSelection()).rangeCount > 0 && 3 == o.anchorNode.nodeType) {
        if ((m = o.getRangeAt(0).cloneRange()).collapse(!0), m.setStart(o.focusNode, 0), n = (e = m.toString().slice(0, m.endOffset)).split(c.pattern).length - 1, (i = e.match(c.pattern)) && (s = e.slice(e.lastIndexOf(i[i.length - 1]))), s) {
          if (this.state.actions.ArrowLeft = !1, this.state.tag = {
            prefix: s.match(c.pattern)[0],
            value: s.replace(c.pattern, "")
          }, this.state.tag.baseOffset = o.baseOffset - this.state.tag.value.length, l = this.state.tag.value.match(c.delimiters)) return this.state.tag.value = this.state.tag.value.replace(c.delimiters, ""), this.state.tag.delimiters = l[0], this.addTags(this.state.tag.value, c.dropdown.clearOnSelect), void this.dropdown.hide();
          a = this.state.tag.value.length >= c.dropdown.enabled;
          try {
            r = (r = this.state.flaggedTags[this.state.tag.baseOffset]).prefix == this.state.tag.prefix && r.value[0] == this.state.tag.value[0], this.state.flaggedTags[this.state.tag.baseOffset] && !this.state.tag.value && delete this.state.flaggedTags[this.state.tag.baseOffset];
          } catch (t) {}
          (r || n < this.state.mixMode.matchedPatternCount) && (a = !1);
        } else this.state.flaggedTags = {};
        this.state.mixMode.matchedPatternCount = n;
      }
      setTimeout(function () {
        d.update({
          withoutChangeEvent: !0
        }), d.trigger("input", u({}, d.state.tag, {
          textContent: d.DOM.input.textContent
        })), d.state.tag && d.dropdown[a ? "show" : "hide"](d.state.tag.value);
      }, 10);
    },
    onInputIE: function (t) {
      var e = this;
      setTimeout(function () {
        e.events.callbacks.onInput.call(e, t);
      });
    },
    observeOriginalInputValue: function () {
      this.DOM.originalInput.parentNode || this.destroy(), this.DOM.originalInput.value != this.DOM.originalInput.tagifyValue && this.loadOriginalValues();
    },
    onClickAnywhere: function (t) {
      t.target == this.DOM.scope || this.DOM.scope.contains(t.target) || (this.toggleFocusClass(!1), this.state.hasFocus = !1, t.target.closest(".tagify__dropdown") && t.target.closest(".tagify__dropdown").__tagify != this && this.dropdown.hide());
    },
    onClickScope: function (t) {
      var e = this.settings,
        i = t.target.closest("." + e.classNames.tag),
        n = t.target === this.DOM.scope,
        s = +new Date() - this.state.hasFocus;
      if (n && "select" != e.mode) this.DOM.input.focus();else {
        if (!t.target.classList.contains(e.classNames.tagX)) return i && !this.state.editing ? (this.trigger("click", {
          tag: i,
          index: this.getNodeIndex(i),
          data: w(i),
          event: t
        }), void (1 !== e.editTags && 1 !== e.editTags.clicks && "select" != e.mode || this.events.callbacks.onDoubleClickScope.call(this, t))) : void (t.target == this.DOM.input && ("mix" == e.mode && this.fixFirefoxLastTagNoCaret(), s > 500 || !e.focusable) ? this.state.dropdown.visible ? this.dropdown.hide() : 0 === e.dropdown.enabled && "mix" != e.mode && this.dropdown.show(this.value.length ? "" : void 0) : "select" != e.mode || 0 !== e.dropdown.enabled || this.state.dropdown.visible || (this.events.callbacks.onDoubleClickScope.call(this, W(function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var i = null != arguments[e] ? arguments[e] : {},
              n = Object.keys(i);
            "function" == typeof Object.getOwnPropertySymbols && (n = n.concat(Object.getOwnPropertySymbols(i).filter(function (t) {
              return Object.getOwnPropertyDescriptor(i, t).enumerable;
            }))), n.forEach(function (e) {
              H(t, e, i[e]);
            });
          }
          return t;
        }({}, t), {
          target: this.getTagElms()[0]
        })), !e.userInput && this.dropdown.show()));
        this.removeTags(t.target.parentNode);
      }
    },
    onPaste: function (t) {
      var e = this;
      t.preventDefault();
      var i,
        n,
        s,
        a = this.settings;
      if ("select" == a.mode && a.enforceWhitelist || !a.userInput) return !1;
      a.readonly || (n = t.clipboardData || window.clipboardData, s = n.getData("Text"), a.hooks.beforePaste(t, {
        tagify: this,
        pastedText: s,
        clipboardData: n
      }).then(function (a) {
        void 0 === a && (a = s), a && (e.injectAtCaret(a, window.getSelection().getRangeAt(0)), "mix" == e.settings.mode ? e.events.callbacks.onMixTagsInput.call(e, t) : e.settings.pasteAsTags ? i = e.addTags(e.state.inputText + a, !0) : (e.state.inputText = a, e.dropdown.show(a))), e.trigger("paste", {
          event: t,
          pastedText: s,
          clipboardData: n,
          tagsElems: i
        });
      }).catch(function (t) {
        return t;
      }));
    },
    onDrop: function (t) {
      t.preventDefault();
    },
    onEditTagInput: function (t, e) {
      var i,
        n = t.closest("." + this.settings.classNames.tag),
        s = this.getNodeIndex(n),
        a = w(n),
        o = this.input.normalize.call(this, t),
        r = (H(i = {}, this.settings.tagTextProp, o), H(i, "__tagId", a.__tagId), i),
        l = this.validateTag(r);
      this.editTagChangeDetected(u(a, r)) || !0 !== t.originalIsValid || (l = !0), n.classList.toggle(this.settings.classNames.tagInvalid, !0 !== l), a.__isValid = l, n.title = !0 === l ? a.title || a.value : l, o.length >= this.settings.dropdown.enabled && (this.state.editing && (this.state.editing.value = o), this.dropdown.show(o)), this.trigger("edit:input", {
        tag: n,
        index: s,
        data: u({}, this.value[s], {
          newValue: o
        }),
        event: e
      });
    },
    onEditTagPaste: function (t, e) {
      var i = (e.clipboardData || window.clipboardData).getData("Text");
      e.preventDefault();
      var n = b(i);
      this.setRangeAtStartEnd(!1, n);
    },
    onEditTagClick: function (t, e) {
      this.events.callbacks.onClickScope.call(this, e);
    },
    onEditTagFocus: function (t) {
      this.state.editing = {
        scope: t,
        input: t.querySelector("[contenteditable]")
      };
    },
    onEditTagBlur: function (t, e) {
      var i = m.call(this, e.relatedTarget);
      if ("select" == this.settings.mode && i && e.relatedTarget.contains(e.target)) this.dropdown.hide();else if (this.state.editing && (this.state.hasFocus || this.toggleFocusClass(), this.DOM.scope.contains(t))) {
        var n,
          s,
          a,
          o = this.settings,
          r = t.closest("." + o.classNames.tag),
          l = w(r),
          d = this.input.normalize.call(this, t),
          c = (H(n = {}, o.tagTextProp, d), H(n, "__tagId", l.__tagId), n),
          g = l.__originalData,
          h = this.editTagChangeDetected(u(l, c)),
          p = this.validateTag(c);
        if (d) {
          if (h) {
            var f;
            if (s = this.hasMaxTags(), a = u({}, g, (H(f = {}, o.tagTextProp, this.trim(d)), H(f, "__isValid", p), f)), o.transformTag.call(this, a, g), !0 !== (p = (!s || !0 === g.__isValid) && this.validateTag(a))) {
              if (this.trigger("invalid", {
                data: a,
                tag: r,
                message: p
              }), o.editTags.keepInvalid) return;
              o.keepInvalidTags ? a.__isValid = p : a = g;
            } else o.keepInvalidTags && (delete a.title, delete a["aria-invalid"], delete a.class);
            this.onEditTagDone(r, a);
          } else this.onEditTagDone(r, g);
        } else this.onEditTagDone(r);
      }
    },
    onEditTagkeydown: function (t, e) {
      if (!this.state.composing) switch (this.trigger("edit:keydown", {
        event: t
      }), t.key) {
        case "Esc":
        case "Escape":
          this.state.editing = !1, !!e.__tagifyTagData.__originalData.value ? e.parentNode.replaceChild(e.__tagifyTagData.__originalHTML, e) : e.remove();
          break;
        case "Enter":
        case "Tab":
          t.preventDefault();
          setTimeout(function () {
            return t.target.blur();
          }, 0);
      }
    },
    onDoubleClickScope: function (t) {
      var e,
        i,
        n = t.target.closest("." + this.settings.classNames.tag),
        s = w(n),
        a = this.settings;
      n && !1 !== s.editable && (e = n.classList.contains(this.settings.classNames.tagEditing), i = n.hasAttribute("readonly"), a.readonly || e || i || !this.settings.editTags || !a.userInput || (this.events.callbacks.onEditTagFocus.call(this, n), this.editTag(n)), this.toggleFocusClass(!0), "select" != a.mode && this.trigger("dblclick", {
        tag: n,
        index: this.getNodeIndex(n),
        data: w(n)
      }));
    },
    onInputDOMChange: function (t) {
      var e = this;
      t.forEach(function (t) {
        t.addedNodes.forEach(function (t) {
          if ("<div><br></div>" == t.outerHTML) t.replaceWith(document.createElement("br"));else if (1 == t.nodeType && t.querySelector(e.settings.classNames.tagSelector)) {
            var i,
              n = document.createTextNode("");
            3 == t.childNodes[0].nodeType && "BR" != t.previousSibling.nodeName && (n = document.createTextNode("\n")), (i = t).replaceWith.apply(i, K([n].concat(K(K(t.childNodes).slice(0, -1))))), y(n);
          } else if (m.call(e, t)) {
            var s;
            if (3 != (null === (s = t.previousSibling) || void 0 === s ? void 0 : s.nodeType) || t.previousSibling.textContent || t.previousSibling.remove(), t.previousSibling && "BR" == t.previousSibling.nodeName) {
              t.previousSibling.replaceWith("\n​");
              for (var a = t.nextSibling, o = ""; a;) o += a.textContent, a = a.nextSibling;
              o.trim() && y(t.previousSibling);
            } else t.previousSibling && !w(t.previousSibling) || t.before("​");
          }
        }), t.removedNodes.forEach(function (t) {
          t && "BR" == t.nodeName && m.call(e, i) && (e.removeTags(i), e.fixFirefoxLastTagNoCaret());
        });
      });
      var i = this.DOM.input.lastChild;
      i && "" == i.nodeValue && i.remove(), i && "BR" == i.nodeName || this.DOM.input.appendChild(document.createElement("br"));
    }
  }
};
function q(t, e) {
  (null == e || e > t.length) && (e = t.length);
  for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];
  return n;
}
function z(t, e, i) {
  return e in t ? Object.defineProperty(t, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = i, t;
}
function X(t, e) {
  return null != e && "undefined" != typeof Symbol && e[Symbol.hasInstance] ? !!e[Symbol.hasInstance](t) : t instanceof e;
}
function J(t) {
  for (var e = 1; e < arguments.length; e++) {
    var i = null != arguments[e] ? arguments[e] : {},
      n = Object.keys(i);
    "function" == typeof Object.getOwnPropertySymbols && (n = n.concat(Object.getOwnPropertySymbols(i).filter(function (t) {
      return Object.getOwnPropertyDescriptor(i, t).enumerable;
    }))), n.forEach(function (e) {
      z(t, e, i[e]);
    });
  }
  return t;
}
function G(t) {
  return function (t) {
    if (Array.isArray(t)) return q(t);
  }(t) || function (t) {
    if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
  }(t) || function (t, e) {
    if (!t) return;
    if ("string" == typeof t) return q(t, e);
    var i = Object.prototype.toString.call(t).slice(8, -1);
    "Object" === i && t.constructor && (i = t.constructor.name);
    if ("Map" === i || "Set" === i) return Array.from(i);
    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return q(t, e);
  }(t) || function () {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
function $(t, e) {
  if (!t) {
    n.warn("input element not found", t);
    var i = new Proxy(this, {
      get: function () {
        return function () {
          return i;
        };
      }
    });
    return i;
  }
  if (t.__tagify) return n.warn("input element is already Tagified - Same instance is returned.", t), t.__tagify;
  var s;
  u(this, function (t) {
    var e = document.createTextNode(""),
      i = {};
    function s(t, i, n) {
      n && i.split(/\s+/g).forEach(function (i) {
        return e[t + "EventListener"].call(e, i, n);
      });
    }
    return {
      removeAllCustomListeners: function () {
        Object.entries(i).forEach(function (t) {
          var e = F(t, 2),
            i = e[0];
          e[1].forEach(function (t) {
            return s("remove", i, t);
          });
        }), i = {};
      },
      off: function (t, e) {
        return t && (e ? s("remove", t, e) : t.split(/\s+/g).forEach(function (t) {
          var e;
          null === (e = i[t]) || void 0 === e || e.forEach(function (e) {
            return s("remove", t, e);
          }), delete i[t];
        })), this;
      },
      on: function (t, e) {
        return e && "function" == typeof e && (t.split(/\s+/g).forEach(function (t) {
          Array.isArray(i[t]) ? i[t].push(e) : i[t] = [e];
        }), s("add", t, e)), this;
      },
      trigger: function (i, s, a) {
        var o;
        if (a = a || {
          cloneData: !0
        }, i) if (t.settings.isJQueryPlugin) "remove" == i && (i = "removeTag"), jQuery(t.DOM.originalInput).triggerHandler(i, [s]);else {
          try {
            var r = "object" == typeof s ? s : {
              value: s
            };
            if ((r = a.cloneData ? u({}, r) : r).tagify = this, s.event && (r.event = this.cloneEvent(s.event)), V(s, Object)) for (var l in s) V(s[l], HTMLElement) && (r[l] = s[l]);
            o = new CustomEvent(i, {
              detail: r
            });
          } catch (t) {
            n.warn(t);
          }
          e.dispatchEvent(o);
        }
      }
    };
  }(this)), this.isFirefox = /firefox|fxios/i.test(navigator.userAgent) && !/seamonkey/i.test(navigator.userAgent), this.isIE = window.document.documentMode, e = e || {}, this.getPersistedData = (s = e.id, function (t) {
    var e,
      i = "/" + t;
    if (1 == localStorage.getItem(k + s + "/v", 1)) try {
      e = JSON.parse(localStorage[k + s + i]);
    } catch (t) {}
    return e;
  }), this.setPersistedData = function (t) {
    return t ? (localStorage.setItem(k + t + "/v", 1), function (e, i) {
      var n = "/" + i,
        s = JSON.stringify(e);
      e && i && (localStorage.setItem(k + t + n, s), dispatchEvent(new Event("storage")));
    }) : function () {};
  }(e.id), this.clearPersistedData = function (t) {
    return function (e) {
      var i = k + "/" + t + "/";
      if (e) localStorage.removeItem(i + e);else for (var n in localStorage) n.includes(i) && localStorage.removeItem(n);
    };
  }(e.id), this.applySettings(t, e), this.state = {
    inputText: "",
    editing: !1,
    composing: !1,
    actions: {},
    mixMode: {},
    dropdown: {},
    flaggedTags: {}
  }, this.value = [], this.listeners = {}, this.DOM = {}, this.build(t), N.call(this), this.getCSSVars(), this.loadOriginalValues(), this.events.customBinding.call(this), this.events.binding.call(this), t.autofocus && this.DOM.input.focus(), t.__tagify = this;
}
$.prototype = {
  _dropdown: C,
  placeCaretAfterNode: y,
  getSetTagData: w,
  helpers: {
    sameStr: s,
    removeCollectionProp: a,
    omit: o,
    isObject: c,
    parseHTML: r,
    escapeHTML: d,
    extend: u,
    concatWithoutDups: g,
    getUID: f,
    isNodeTag: m
  },
  customEventsList: ["change", "add", "remove", "invalid", "input", "paste", "click", "keydown", "focus", "blur", "edit:input", "edit:beforeUpdate", "edit:updated", "edit:start", "edit:keydown", "dropdown:show", "dropdown:hide", "dropdown:select", "dropdown:updated", "dropdown:noMatch", "dropdown:scroll"],
  dataProps: ["__isValid", "__removed", "__originalData", "__originalHTML", "__tagId"],
  trim: function (t) {
    return this.settings.trim && t && "string" == typeof t ? t.trim() : t;
  },
  parseHTML: r,
  templates: j,
  parseTemplate: function (t, e) {
    return r((t = this.settings.templates[t] || t).apply(this, e));
  },
  set whitelist(t) {
    var e = t && Array.isArray(t);
    this.settings.whitelist = e ? t : [], this.setPersistedData(e ? t : [], "whitelist");
  },
  get whitelist() {
    return this.settings.whitelist;
  },
  set userInput(t) {
    this.settings.userInput = !!t, this.setContentEditable(!!t);
  },
  get userInput() {
    return this.settings.userInput;
  },
  generateClassSelectors: function (t) {
    var e = function (e) {
      var i = e;
      Object.defineProperty(t, i + "Selector", {
        get: function () {
          return "." + this[i].split(" ")[0];
        }
      });
    };
    for (var i in t) e(i);
  },
  applySettings: function (t, e) {
    var i, n;
    O.templates = this.templates;
    var s = u({}, O, "mix" == e.mode ? {
        dropdown: {
          position: "text"
        }
      } : {}),
      a = this.settings = u({}, s, e);
    if (a.disabled = t.hasAttribute("disabled"), a.readonly = a.readonly || t.hasAttribute("readonly"), a.placeholder = d(t.getAttribute("placeholder") || a.placeholder || ""), a.required = t.hasAttribute("required"), this.generateClassSelectors(a.classNames), void 0 === a.dropdown.includeSelectedTags && (a.dropdown.includeSelectedTags = a.duplicates), this.isIE && (a.autoComplete = !1), ["whitelist", "blacklist"].forEach(function (e) {
      var i = t.getAttribute("data-" + e);
      i && X(i = i.split(a.delimiters), Array) && (a[e] = i);
    }), "autoComplete" in e && !c(e.autoComplete) && (a.autoComplete = O.autoComplete, a.autoComplete.enabled = e.autoComplete), "mix" == a.mode && (a.pattern = a.pattern || /@/, a.autoComplete.rightKey = !0, a.delimiters = e.delimiters || null, a.tagTextProp && !a.dropdown.searchKeys.includes(a.tagTextProp) && a.dropdown.searchKeys.push(a.tagTextProp)), t.pattern) try {
      a.pattern = new RegExp(t.pattern);
    } catch (t) {}
    if (a.delimiters) {
      a._delimiters = a.delimiters;
      try {
        a.delimiters = new RegExp(this.settings.delimiters, "g");
      } catch (t) {}
    }
    a.disabled && (a.userInput = !1), this.TEXTS = J({}, L, a.texts || {}), ("select" != a.mode || (null === (i = e.dropdown) || void 0 === i ? void 0 : i.enabled)) && a.userInput || (a.dropdown.enabled = 0), a.dropdown.appendTarget = (null === (n = e.dropdown) || void 0 === n ? void 0 : n.appendTarget) || document.body;
    var o = this.getPersistedData("whitelist");
    Array.isArray(o) && (this.whitelist = Array.isArray(a.whitelist) ? g(a.whitelist, o) : o);
  },
  getAttributes: function (t) {
    var e,
      i = this.getCustomAttributes(t),
      n = "";
    for (e in i) n += " " + e + (void 0 !== t[e] ? '="'.concat(i[e], '"') : "");
    return n;
  },
  getCustomAttributes: function (t) {
    if (!c(t)) return "";
    var e,
      i = {};
    for (e in t) "__" != e.slice(0, 2) && "class" != e && t.hasOwnProperty(e) && void 0 !== t[e] && (i[e] = d(t[e]));
    return i;
  },
  setStateSelection: function () {
    var t = window.getSelection(),
      e = {
        anchorOffset: t.anchorOffset,
        anchorNode: t.anchorNode,
        range: t.getRangeAt && t.rangeCount && t.getRangeAt(0)
      };
    return this.state.selection = e, e;
  },
  getCSSVars: function () {
    var t,
      e,
      i,
      n = getComputedStyle(this.DOM.scope, null);
    this.CSSVars = {
      tagHideTransition: (t = function (t) {
        if (!t) return {};
        var e = (t = t.trim().split(" ")[0]).split(/\d+/g).filter(function (t) {
          return t;
        }).pop().trim();
        return {
          value: +t.split(e).filter(function (t) {
            return t;
          })[0].trim(),
          unit: e
        };
      }((i = "tag-hide-transition", n.getPropertyValue("--" + i))), e = t.value, "s" == t.unit ? 1e3 * e : e)
    };
  },
  build: function (t) {
    var e = this.DOM,
      i = t.closest("label");
    this.settings.mixMode.integrated ? (e.originalInput = null, e.scope = t, e.input = t) : (e.originalInput = t, e.originalInput_tabIndex = t.tabIndex, e.scope = this.parseTemplate("wrapper", [t, this.settings]), e.input = e.scope.querySelector(this.settings.classNames.inputSelector), t.parentNode.insertBefore(e.scope, t), t.tabIndex = -1), i && i.setAttribute("for", "");
  },
  destroy: function () {
    this.events.unbindGlobal.call(this), this.DOM.scope.parentNode.removeChild(this.DOM.scope), this.DOM.originalInput.tabIndex = this.DOM.originalInput_tabIndex, delete this.DOM.originalInput.__tagify, this.dropdown.hide(!0), this.removeAllCustomListeners(), clearTimeout(this.dropdownHide__bindEventsTimeout), clearInterval(this.listeners.main.originalInputValueObserverInterval);
  },
  loadOriginalValues: function (t) {
    var e,
      i = this.settings;
    if (this.state.blockChangeEvent = !0, void 0 === t) {
      var n = this.getPersistedData("value");
      t = n && !this.DOM.originalInput.value ? n : i.mixMode.integrated ? this.DOM.input.textContent : this.DOM.originalInput.value;
    }
    if (this.removeAllTags(), t) {
      if ("mix" == i.mode) this.parseMixTags(t), (e = this.DOM.input.lastChild) && "BR" == e.tagName || this.DOM.input.insertAdjacentHTML("beforeend", "<br>");else {
        try {
          X(JSON.parse(t), Array) && (t = JSON.parse(t));
        } catch (t) {}
        this.addTags(t, !0).forEach(function (t) {
          return t && t.classList.add(i.classNames.tagNoAnimation);
        });
      }
    } else this.postUpdate();
    this.state.lastOriginalValueReported = i.mixMode.integrated ? "" : this.DOM.originalInput.value;
  },
  cloneEvent: function (t) {
    var e = {};
    for (var i in t) "path" != i && (e[i] = t[i]);
    return e;
  },
  loading: function (t) {
    return this.state.isLoading = t, this.DOM.scope.classList[t ? "add" : "remove"](this.settings.classNames.scopeLoading), this;
  },
  tagLoading: function (t, e) {
    return t && t.classList[e ? "add" : "remove"](this.settings.classNames.tagLoading), this;
  },
  toggleClass: function (t, e) {
    "string" == typeof t && this.DOM.scope.classList.toggle(t, e);
  },
  toggleScopeValidation: function (t) {
    var e = !0 === t || void 0 === t;
    !this.settings.required && t && t === this.TEXTS.empty && (e = !0), this.toggleClass(this.settings.classNames.tagInvalid, !e), this.DOM.scope.title = e ? "" : t;
  },
  toggleFocusClass: function (t) {
    this.toggleClass(this.settings.classNames.focus, !!t);
  },
  setPlaceholder: function (t) {
    var e = this;
    ["data", "aria"].forEach(function (i) {
      return e.DOM.input.setAttribute("".concat(i, "-placeholder"), t);
    });
  },
  triggerChangeEvent: function () {
    if (!this.settings.mixMode.integrated) {
      var t = this.DOM.originalInput,
        e = this.state.lastOriginalValueReported !== t.value,
        i = new CustomEvent("change", {
          bubbles: !0
        });
      e && (this.state.lastOriginalValueReported = t.value, i.simulated = !0, t._valueTracker && t._valueTracker.setValue(Math.random()), t.dispatchEvent(i), this.trigger("change", this.state.lastOriginalValueReported), t.value = this.state.lastOriginalValueReported);
    }
  },
  events: U,
  fixFirefoxLastTagNoCaret: function () {},
  setRangeAtStartEnd: function (t, e) {
    if (e) {
      t = "number" == typeof t ? t : !!t, e = e.lastChild || e;
      var i = document.getSelection();
      if (X(i.focusNode, Element) && !this.DOM.input.contains(i.focusNode)) return !0;
      try {
        i.rangeCount >= 1 && ["Start", "End"].forEach(function (n) {
          return i.getRangeAt(0)["set" + n](e, t || e.length);
        });
      } catch (t) {
        console.warn(t);
      }
    }
  },
  insertAfterTag: function (t, e) {
    if (e = e || this.settings.mixMode.insertAfterTag, t && t.parentNode && e) return e = "string" == typeof e ? document.createTextNode(e) : e, t.parentNode.insertBefore(e, t.nextSibling), e;
  },
  editTagChangeDetected: function (t) {
    var e = t.__originalData;
    for (var i in e) if (!this.dataProps.includes(i) && t[i] != e[i]) return !0;
    return !1;
  },
  getTagTextNode: function (t) {
    return t.querySelector(this.settings.classNames.tagTextSelector);
  },
  setTagTextNode: function (t, e) {
    this.getTagTextNode(t).innerHTML = d(e);
  },
  editTag: function (t, e) {
    var i = this;
    t = t || this.getLastTag(), e = e || {};
    var s = this.settings,
      a = this.getTagTextNode(t),
      o = this.getNodeIndex(t),
      r = w(t),
      l = this.events.callbacks,
      d = !0,
      c = "select" == s.mode;
    if (!c && this.dropdown.hide(), a) {
      if (!X(r, Object) || !("editable" in r) || r.editable) return r = w(t, {
        __originalData: u({}, r),
        __originalHTML: t.cloneNode(!0)
      }), w(r.__originalHTML, r.__originalData), a.setAttribute("contenteditable", !0), t.classList.add(s.classNames.tagEditing), this.events.callbacks.onEditTagFocus.call(this, t), a.addEventListener("click", l.onEditTagClick.bind(this, t)), a.addEventListener("blur", l.onEditTagBlur.bind(this, this.getTagTextNode(t))), a.addEventListener("input", l.onEditTagInput.bind(this, a)), a.addEventListener("paste", l.onEditTagPaste.bind(this, a)), a.addEventListener("keydown", function (e) {
        return l.onEditTagkeydown.call(i, e, t);
      }), a.addEventListener("compositionstart", l.onCompositionStart.bind(this)), a.addEventListener("compositionend", l.onCompositionEnd.bind(this)), e.skipValidation || (d = this.editTagToggleValidity(t)), a.originalIsValid = d, this.trigger("edit:start", {
        tag: t,
        index: o,
        data: r,
        isValid: d
      }), a.focus(), !c && this.setRangeAtStartEnd(!1, a), 0 === s.dropdown.enabled && !c && this.dropdown.show(), this.state.hasFocus = !0, this;
    } else n.warn("Cannot find element in Tag template: .", s.classNames.tagTextSelector);
  },
  editTagToggleValidity: function (t, e) {
    var i;
    if (e = e || w(t)) return (i = !("__isValid" in e) || !0 === e.__isValid) || this.removeTagsFromValue(t), this.update(), t.classList.toggle(this.settings.classNames.tagNotAllowed, !i), e.__isValid = i, e.__isValid;
    n.warn("tag has no data: ", t, e);
  },
  onEditTagDone: function (t, e) {
    t = t || this.state.editing.scope, e = e || {};
    var i,
      n,
      s = {
        tag: t,
        index: this.getNodeIndex(t),
        previousData: w(t),
        data: e
      },
      a = this.settings;
    this.trigger("edit:beforeUpdate", s, {
      cloneData: !1
    }), this.state.editing = !1, delete e.__originalData, delete e.__originalHTML, t && (void 0 !== (n = e[a.tagTextProp]) ? null === (i = (n += "").trim) || void 0 === i ? void 0 : i.call(n) : a.tagTextProp in e ? void 0 : e.value) ? (t = this.replaceTag(t, e), this.editTagToggleValidity(t, e), a.a11y.focusableTags ? t.focus() : "select" != a.mode && y(t)) : t && this.removeTags(t), this.trigger("edit:updated", s), this.dropdown.hide(), this.settings.keepInvalidTags && this.reCheckInvalidTags();
  },
  replaceTag: function (t, e) {
    e && "" !== e.value && void 0 !== e.value || (e = t.__tagifyTagData), e.__isValid && 1 != e.__isValid && u(e, this.getInvalidTagAttrs(e, e.__isValid));
    var i = this.createTagElem(e);
    return t.parentNode.replaceChild(i, t), this.updateValueByDOMTags(), i;
  },
  updateValueByDOMTags: function () {
    var t = this;
    this.value.length = 0;
    var e = this.settings.classNames,
      i = [e.tagNotAllowed.split(" ")[0], e.tagHide];
    [].forEach.call(this.getTagElms(), function (e) {
      G(e.classList).some(function (t) {
        return i.includes(t);
      }) || t.value.push(w(e));
    }), this.update();
  },
  injectAtCaret: function (t, e) {
    var i;
    if (e = e || (null === (i = this.state.selection) || void 0 === i ? void 0 : i.range), "string" == typeof t && (t = document.createTextNode(t)), !e && t) return this.appendMixTags(t), this;
    var n = b(t, e);
    return this.setRangeAtStartEnd(!1, n), this.updateValueByDOMTags(), this.update(), this;
  },
  input: {
    set: function () {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
        e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
        i = this.settings,
        n = i.dropdown.closeOnSelect;
      this.state.inputText = t, e && (this.DOM.input.innerHTML = d("" + t), t && this.toggleClass(i.classNames.empty, !this.DOM.input.innerHTML)), !t && n && this.dropdown.hide.bind(this), this.input.autocomplete.suggest.call(this), this.input.validate.call(this);
    },
    raw: function () {
      return this.DOM.input.textContent;
    },
    validate: function () {
      var t = !this.state.inputText || !0 === this.validateTag({
        value: this.state.inputText
      });
      return this.DOM.input.classList.toggle(this.settings.classNames.inputInvalid, !t), t;
    },
    normalize: function (t, e) {
      var i = t || this.DOM.input,
        n = [];
      i.childNodes.forEach(function (t) {
        return 3 == t.nodeType && n.push(t.nodeValue);
      }), n = n.join("\n");
      try {
        n = n.replace(/(?:\r\n|\r|\n)/g, this.settings.delimiters.source.charAt(0));
      } catch (t) {}
      return n = n.replace(/\s/g, " "), (null == e ? void 0 : e.trim) ? this.trim(n) : n;
    },
    autocomplete: {
      suggest: function (t) {
        if (this.settings.autoComplete.enabled) {
          "object" != typeof (t = t || {
            value: ""
          }) && (t = {
            value: t
          });
          var e = this.dropdown.getMappedValue(t);
          if ("number" != typeof e) {
            var i = this.state.inputText.toLowerCase(),
              n = e.substr(0, this.state.inputText.length).toLowerCase(),
              s = e.substring(this.state.inputText.length);
            e && this.state.inputText && n == i ? (this.DOM.input.setAttribute("data-suggest", s), this.state.inputSuggestion = t) : (this.DOM.input.removeAttribute("data-suggest"), delete this.state.inputSuggestion);
          }
        }
      },
      set: function (t) {
        var e = this.DOM.input.getAttribute("data-suggest"),
          i = t || (e ? this.state.inputText + e : null);
        return !!i && ("mix" == this.settings.mode ? this.replaceTextWithNode(document.createTextNode(this.state.tag.prefix + i)) : (this.input.set.call(this, i), this.setRangeAtStartEnd(!1, this.DOM.input)), this.input.autocomplete.suggest.call(this), this.dropdown.hide(), !0);
      }
    }
  },
  getTagIdx: function (t) {
    return this.value.findIndex(function (e) {
      return e.__tagId == (t || {}).__tagId;
    });
  },
  getNodeIndex: function (t) {
    var e = 0;
    if (t) for (; t = t.previousElementSibling;) e++;
    return e;
  },
  getTagElms: function () {
    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
    var n = "." + G(this.settings.classNames.tag.split(" ")).concat(G(e)).join(".");
    return [].slice.call(this.DOM.scope.querySelectorAll(n));
  },
  getLastTag: function () {
    var t = this.settings.classNames,
      e = this.DOM.scope.querySelectorAll("".concat(t.tagSelector, ":not(.").concat(t.tagHide, "):not([readonly])"));
    return e[e.length - 1];
  },
  isTagDuplicate: function (t, e, i) {
    var n = 0,
      a = !0,
      o = !1,
      r = void 0;
    try {
      for (var l, d = this.value[Symbol.iterator](); !(a = (l = d.next()).done); a = !0) {
        var c = l.value;
        s(this.trim("" + t), c.value, e) && i != c.__tagId && n++;
      }
    } catch (t) {
      o = !0, r = t;
    } finally {
      try {
        a || null == d.return || d.return();
      } finally {
        if (o) throw r;
      }
    }
    return n;
  },
  getTagIndexByValue: function (t) {
    var e = this,
      i = [],
      n = this.settings.dropdown.caseSensitive;
    return this.getTagElms().forEach(function (a, o) {
      a.__tagifyTagData && s(e.trim(a.__tagifyTagData.value), t, n) && i.push(o);
    }), i;
  },
  getTagElmByValue: function (t) {
    var e = this.getTagIndexByValue(t)[0];
    return this.getTagElms()[e];
  },
  flashTag: function (t) {
    var e = this;
    t && (t.classList.add(this.settings.classNames.tagFlash), setTimeout(function () {
      t.classList.remove(e.settings.classNames.tagFlash);
    }, 100));
  },
  isTagBlacklisted: function (t) {
    return t = this.trim(t.toLowerCase()), this.settings.blacklist.filter(function (e) {
      return ("" + e).toLowerCase() == t;
    }).length;
  },
  isTagWhitelisted: function (t) {
    return !!this.getWhitelistItem(t);
  },
  getWhitelistItem: function (t, e, i) {
    e = e || "value";
    var n,
      a = this.settings;
    return (i = i || a.whitelist).some(function (i) {
      var o = "object" == typeof i ? i[e] || i.value : i;
      if (s(o, t, a.dropdown.caseSensitive, a.trim)) return n = "object" == typeof i ? i : {
        value: i
      }, !0;
    }), n || "value" != e || "value" == a.tagTextProp || (n = this.getWhitelistItem(t, a.tagTextProp, i)), n;
  },
  validateTag: function (t) {
    var e = this.settings,
      i = "value" in t ? "value" : e.tagTextProp,
      n = this.trim(t[i] + "");
    return (t[i] + "").trim() ? "mix" != e.mode && e.pattern && X(e.pattern, RegExp) && !e.pattern.test(n) ? this.TEXTS.pattern : !e.duplicates && this.isTagDuplicate(n, e.dropdown.caseSensitive, t.__tagId) ? this.TEXTS.duplicate : this.isTagBlacklisted(n) || e.enforceWhitelist && !this.isTagWhitelisted(n) ? this.TEXTS.notAllowed : !e.validate || e.validate(t) : this.TEXTS.empty;
  },
  getInvalidTagAttrs: function (t, e) {
    return {
      "aria-invalid": !0,
      class: "".concat(t.class || "", " ").concat(this.settings.classNames.tagNotAllowed).trim(),
      title: e
    };
  },
  hasMaxTags: function () {
    return this.value.length >= this.settings.maxTags && this.TEXTS.exceed;
  },
  setReadonly: function (t, e) {
    var i = this.settings;
    this.DOM.scope.contains(document.activeElement) && document.activeElement.blur(), i[e || "readonly"] = t, this.DOM.scope[(t ? "set" : "remove") + "Attribute"](e || "readonly", !0), this.settings.userInput = !0, this.setContentEditable(!t);
  },
  setContentEditable: function (t) {
    this.DOM.input.contentEditable = t, this.DOM.input.tabIndex = t ? 0 : -1;
  },
  setDisabled: function (t) {
    this.setReadonly(t, "disabled");
  },
  normalizeTags: function (t) {
    var e = this,
      i = this.settings,
      n = i.whitelist,
      s = i.delimiters,
      a = i.mode,
      o = i.tagTextProp,
      r = [],
      l = !!n && X(n[0], Object),
      d = Array.isArray(t),
      g = d && t[0].value,
      h = function (t) {
        return (t + "").split(s).reduce(function (t, i) {
          var n,
            s = e.trim(i);
          return s && t.push((z(n = {}, o, s), z(n, "value", s), n)), t;
        }, []);
      };
    if ("number" == typeof t && (t = t.toString()), "string" == typeof t) {
      if (!t.trim()) return [];
      t = h(t);
    } else d && (t = t.reduce(function (t, i) {
      if (c(i)) {
        var n = u({}, i);
        o in n || (o = "value"), n[o] = e.trim(n[o]), (n[o] || 0 === n[o]) && t.push(n);
      } else if (i) {
        var s;
        (s = t).push.apply(s, G(h(i)));
      }
      return t;
    }, []));
    return l && !g && (t.forEach(function (t) {
      var i = r.map(function (t) {
          return t.value;
        }),
        n = e.dropdown.filterListItems.call(e, t[o], {
          exact: !0
        });
      e.settings.duplicates || (n = n.filter(function (t) {
        return !i.includes(t.value);
      }));
      var s = n.length > 1 ? e.getWhitelistItem(t[o], o, n) : n[0];
      s && X(s, Object) ? r.push(s) : "mix" != a && (null == t.value && (t.value = t[o]), r.push(t));
    }), r.length && (t = r)), t;
  },
  parseMixTags: function (t) {
    var e = this,
      i = this.settings,
      n = i.mixTagsInterpolator,
      s = i.duplicates,
      a = i.transformTag,
      o = i.enforceWhitelist,
      r = i.maxTags,
      l = i.tagTextProp,
      d = [];
    t = t.split(n[0]).map(function (t, i) {
      var c,
        u,
        g,
        h = t.split(n[1]),
        p = h[0],
        f = d.length == r;
      try {
        if (p == +p) throw Error;
        u = JSON.parse(p);
      } catch (t) {
        u = e.normalizeTags(p)[0] || {
          value: p
        };
      }
      if (a.call(e, u), f || !(h.length > 1) || o && !e.isTagWhitelisted(u.value) || !s && e.isTagDuplicate(u.value)) {
        if (t) return i ? n[0] + t : t;
      } else u[c = u[l] ? l : "value"] = e.trim(u[c]), g = e.createTagElem(u), d.push(u), g.classList.add(e.settings.classNames.tagNoAnimation), h[0] = g.outerHTML, e.value.push(u);
      return h.join("");
    }).join(""), this.DOM.input.innerHTML = t, this.DOM.input.appendChild(document.createTextNode("")), this.DOM.input.normalize();
    var c = this.getTagElms();
    return c.forEach(function (t, e) {
      return w(t, d[e]);
    }), this.update({
      withoutChangeEvent: !0
    }), T(c, this.state.hasFocus), t;
  },
  replaceTextWithNode: function (t, e) {
    if (this.state.tag || e) {
      e = e || this.state.tag.prefix + this.state.tag.value;
      var i,
        n,
        s = this.state.selection || window.getSelection(),
        a = s.anchorNode,
        o = this.state.tag.delimiters ? this.state.tag.delimiters.length : 0;
      return a.splitText(s.anchorOffset - o), -1 == (i = a.nodeValue.lastIndexOf(e)) ? !0 : (n = a.splitText(i), t && a.parentNode.replaceChild(t, n), !0);
    }
  },
  prepareNewTagNode: function (t, e) {
    e = e || {};
    var i = this.settings,
      n = [],
      s = {},
      a = Object.assign({}, t, {
        value: t.value + ""
      });
    if (t = Object.assign({}, a), i.transformTag.call(this, t), t.__isValid = this.hasMaxTags() || this.validateTag(t), !0 !== t.__isValid) {
      if (e.skipInvalid) return;
      if (u(s, this.getInvalidTagAttrs(t, t.__isValid), {
        __preInvalidData: a
      }), t.__isValid == this.TEXTS.duplicate && this.flashTag(this.getTagElmByValue(t.value)), !i.createInvalidTags) return void n.push(t.value);
    }
    return "readonly" in t && (t.readonly ? s["aria-readonly"] = !0 : delete t.readonly), {
      tagElm: this.createTagElem(t, s),
      tagData: t,
      aggregatedInvalidInput: n
    };
  },
  postProcessNewTagNode: function (t, e) {
    var i = this,
      n = this.settings,
      s = e.__isValid;
    s && !0 === s ? this.value.push(e) : (this.trigger("invalid", {
      data: e,
      index: this.value.length,
      tag: t,
      message: s
    }), n.keepInvalidTags || setTimeout(function () {
      return i.removeTags(t, !0);
    }, 1e3)), this.dropdown.position();
  },
  selectTag: function (t, e) {
    var i = this;
    if (!this.settings.enforceWhitelist || this.isTagWhitelisted(e.value)) {
      this.state.actions.selectOption && setTimeout(function () {
        return i.setRangeAtStartEnd(!1, i.DOM.input);
      });
      var n = this.getLastTag();
      return n ? this.replaceTag(n, e) : this.appendTag(t), this.value[0] = e, this.update(), this.trigger("add", {
        tag: t,
        data: e
      }), [t];
    }
  },
  addEmptyTag: function (t) {
    var e = u({
        value: ""
      }, t || {}),
      i = this.createTagElem(e);
    w(i, e), this.appendTag(i), this.editTag(i, {
      skipValidation: !0
    }), this.toggleFocusClass(!0);
  },
  addTags: function (t, e, i) {
    var n = this,
      s = [],
      a = this.settings,
      o = [],
      r = document.createDocumentFragment(),
      l = [];
    if (!t || 0 == t.length) return s;
    switch (t = this.normalizeTags(t), a.mode) {
      case "mix":
        return this.addMixTags(t);
      case "select":
        e = !1, this.removeAllTags();
    }
    return this.DOM.input.removeAttribute("style"), t.forEach(function (t) {
      var e = n.prepareNewTagNode(t, {
        skipInvalid: i || a.skipInvalid
      });
      if (e) {
        var d = e.tagElm;
        if (t = e.tagData, o = e.aggregatedInvalidInput, s.push(d), "select" == a.mode) return n.selectTag(d, t);
        r.appendChild(d), n.postProcessNewTagNode(d, t), l.push({
          tagElm: d,
          tagData: t
        });
      }
    }), this.appendTag(r), l.forEach(function (t) {
      var e = t.tagElm,
        i = t.tagData;
      return n.trigger("add", {
        tag: e,
        index: n.getTagIdx(i),
        data: i
      });
    }), this.update(), t.length && e && (this.input.set.call(this, a.createInvalidTags ? "" : o.join(a._delimiters)), this.setRangeAtStartEnd(!1, this.DOM.input)), this.dropdown.refilter(), s;
  },
  addMixTags: function (t) {
    var e = this;
    if ((t = this.normalizeTags(t))[0].prefix || this.state.tag) return this.prefixedTextToTag(t[0]);
    var i = document.createDocumentFragment();
    return t.forEach(function (t) {
      var n = e.prepareNewTagNode(t);
      i.appendChild(n.tagElm), e.insertAfterTag(n.tagElm), e.postProcessNewTagNode(n.tagElm, n.tagData);
    }), this.appendMixTags(i), i.children;
  },
  appendMixTags: function (t) {
    var e = !!this.state.selection;
    e ? this.injectAtCaret(t) : (this.DOM.input.focus(), (e = this.setStateSelection()).range.setStart(this.DOM.input, e.range.endOffset), e.range.setEnd(this.DOM.input, e.range.endOffset), this.DOM.input.appendChild(t), this.updateValueByDOMTags(), this.update());
  },
  prefixedTextToTag: function (t) {
    var e,
      i,
      n,
      s = this,
      a = this.settings,
      o = null === (e = this.state.tag) || void 0 === e ? void 0 : e.delimiters;
    if (t.prefix = t.prefix || this.state.tag ? this.state.tag.prefix : (a.pattern.source || a.pattern)[0], n = this.prepareNewTagNode(t), i = n.tagElm, this.replaceTextWithNode(i) || this.DOM.input.appendChild(i), setTimeout(function () {
      return i.classList.add(s.settings.classNames.tagNoAnimation);
    }, 300), this.update(), !o) {
      var r = this.insertAfterTag(i) || i;
      setTimeout(y, 0, r);
    }
    return this.state.tag = null, this.postProcessNewTagNode(i, n.tagData), i;
  },
  appendTag: function (t) {
    var e = this.DOM,
      i = e.input;
    e.scope.insertBefore(t, i);
  },
  createTagElem: function (t, e) {
    t.__tagId = f();
    var i,
      n = u({}, t, J({
        value: d(t.value + "")
      }, e));
    return function (t) {
      for (var e, i = document.createNodeIterator(t, NodeFilter.SHOW_TEXT, null, !1); e = i.nextNode();) e.textContent.trim() || e.parentNode.removeChild(e);
    }(i = this.parseTemplate("tag", [n, this])), w(i, t), i;
  },
  reCheckInvalidTags: function () {
    var t = this,
      e = this.settings;
    this.getTagElms(e.classNames.tagNotAllowed).forEach(function (i, n) {
      var s = w(i),
        a = t.hasMaxTags(),
        o = t.validateTag(s),
        r = !0 === o && !a;
      if ("select" == e.mode && t.toggleScopeValidation(o), r) return s = s.__preInvalidData ? s.__preInvalidData : {
        value: s.value
      }, t.replaceTag(i, s);
      i.title = a || o;
    });
  },
  removeTags: function (t, e, i) {
    var n,
      s = this,
      a = this.settings;
    if (t = t && X(t, HTMLElement) ? [t] : X(t, Array) ? t : t ? [t] : [this.getLastTag()].filter(function (t) {
      return t;
    }), n = t.reduce(function (t, e) {
      e && "string" == typeof e && (e = s.getTagElmByValue(e));
      var i = w(e);
      return e && i && !i.readonly && t.push({
        node: e,
        idx: s.getTagIdx(i),
        data: w(e, {
          __removed: !0
        })
      }), t;
    }, []), i = "number" == typeof i ? i : this.CSSVars.tagHideTransition, "select" == a.mode && (i = 0, this.input.set.call(this)), 1 == n.length && "select" != a.mode && n[0].node.classList.contains(a.classNames.tagNotAllowed) && (e = !0), n.length) return a.hooks.beforeRemoveTag(n, {
      tagify: this
    }).then(function () {
      var t = function (t) {
        t.node.parentNode && (t.node.parentNode.removeChild(t.node), e ? a.keepInvalidTags && this.trigger("remove", {
          tag: t.node,
          index: t.idx
        }) : (this.trigger("remove", {
          tag: t.node,
          index: t.idx,
          data: t.data
        }), this.dropdown.refilter(), this.dropdown.position(), this.DOM.input.normalize(), a.keepInvalidTags && this.reCheckInvalidTags()));
      };
      i && i > 10 && 1 == n.length ? function (e) {
        e.node.style.width = parseFloat(window.getComputedStyle(e.node).width) + "px", document.body.clientTop, e.node.classList.add(a.classNames.tagHide), setTimeout(t.bind(this), i, e);
      }.call(s, n[0]) : n.forEach(t.bind(s)), e || (s.removeTagsFromValue(n.map(function (t) {
        return t.node;
      })), s.update(), "select" == a.mode && a.userInput && s.setContentEditable(!0));
    }).catch(function (t) {});
  },
  removeTagsFromDOM: function () {
    this.getTagElms().forEach(function (t) {
      return t.remove();
    });
  },
  removeTagsFromValue: function (t) {
    var e = this;
    (t = Array.isArray(t) ? t : [t]).forEach(function (t) {
      var i = w(t),
        n = e.getTagIdx(i);
      n > -1 && e.value.splice(n, 1);
    });
  },
  removeAllTags: function (t) {
    var e = this;
    t = t || {}, this.value = [], "mix" == this.settings.mode ? this.DOM.input.innerHTML = "" : this.removeTagsFromDOM(), this.dropdown.refilter(), this.dropdown.position(), this.state.dropdown.visible && setTimeout(function () {
      e.DOM.input.focus();
    }), "select" == this.settings.mode && (this.input.set.call(this), this.settings.userInput && this.setContentEditable(!0)), this.update(t);
  },
  postUpdate: function () {
    this.state.blockChangeEvent = !1;
    var t,
      e,
      i = this.settings,
      n = i.classNames,
      s = "mix" == i.mode ? i.mixMode.integrated ? this.DOM.input.textContent : this.DOM.originalInput.value.trim() : this.value.length + this.input.raw.call(this).length;
    (this.toggleClass(n.hasMaxTags, this.value.length >= i.maxTags), this.toggleClass(n.hasNoTags, !this.value.length), this.toggleClass(n.empty, !s), "select" == i.mode) && this.toggleScopeValidation(null === (e = this.value) || void 0 === e || null === (t = e[0]) || void 0 === t ? void 0 : t.__isValid);
  },
  setOriginalInputValue: function (t) {
    var e = this.DOM.originalInput;
    this.settings.mixMode.integrated || (e.value = t, e.tagifyValue = e.value, this.setPersistedData(t, "value"));
  },
  update: function (t) {
    clearTimeout(this.debouncedUpdateTimeout), this.debouncedUpdateTimeout = setTimeout(function () {
      var e = this.getInputValue();
      this.setOriginalInputValue(e), this.settings.onChangeAfterBlur && (t || {}).withoutChangeEvent || this.state.blockChangeEvent || this.triggerChangeEvent();
      this.postUpdate();
    }.bind(this), 100), this.events.bindOriginaInputListener.call(this, 100);
  },
  getInputValue: function () {
    var t = this.getCleanValue();
    return "mix" == this.settings.mode ? this.getMixedTagsAsString(t) : t.length ? this.settings.originalInputValueFormat ? this.settings.originalInputValueFormat(t) : JSON.stringify(t) : "";
  },
  getCleanValue: function (t) {
    return a(t || this.value, this.dataProps);
  },
  getMixedTagsAsString: function () {
    var t = "",
      e = this,
      i = this.settings,
      n = i.originalInputValueFormat || JSON.stringify,
      s = i.mixTagsInterpolator;
    return function i(a) {
      a.childNodes.forEach(function (a) {
        if (1 == a.nodeType) {
          var r = w(a);
          if ("BR" == a.tagName && (t += "\r\n"), r && m.call(e, a)) {
            if (r.__removed) return;
            t += s[0] + n(o(r, e.dataProps)) + s[1];
          } else a.getAttribute("style") || ["B", "I", "U"].includes(a.tagName) ? t += a.textContent : "DIV" != a.tagName && "P" != a.tagName || (t += "\r\n", i(a));
        } else t += a.textContent;
      });
    }(this.DOM.input), t;
  }
}, $.prototype.removeTag = $.prototype.removeTags;


/***/ }),

/***/ "./node_modules/clipboard/dist/clipboard.js":
/*!**************************************************!*\
  !*** ./node_modules/clipboard/dist/clipboard.js ***!
  \**************************************************/
/***/ (function(module) {

/*!
 * clipboard.js v2.0.11
 * https://clipboardjs.com/
 *
 * Licensed MIT © Zeno Rocha
 */
(function webpackUniversalModuleDefinition(root, factory) {
  if (true) module.exports = factory();else {}
})(this, function () {
  return /******/function () {
    // webpackBootstrap
    /******/
    var __webpack_modules__ = {
      /***/686: (/***/function (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_629__) {
        "use strict";

        // EXPORTS
        __nested_webpack_require_629__.d(__nested_webpack_exports__, {
          "default": function () {
            return /* binding */clipboard;
          }
        });

        // EXTERNAL MODULE: ./node_modules/tiny-emitter/index.js
        var tiny_emitter = __nested_webpack_require_629__(279);
        var tiny_emitter_default = /*#__PURE__*/__nested_webpack_require_629__.n(tiny_emitter);
        // EXTERNAL MODULE: ./node_modules/good-listener/src/listen.js
        var listen = __nested_webpack_require_629__(370);
        var listen_default = /*#__PURE__*/__nested_webpack_require_629__.n(listen);
        // EXTERNAL MODULE: ./node_modules/select/src/select.js
        var src_select = __nested_webpack_require_629__(817);
        var select_default = /*#__PURE__*/__nested_webpack_require_629__.n(src_select);
        ; // CONCATENATED MODULE: ./src/common/command.js
        /**
         * Executes a given operation type.
         * @param {String} type
         * @return {Boolean}
         */
        function command(type) {
          try {
            return document.execCommand(type);
          } catch (err) {
            return false;
          }
        }
        ; // CONCATENATED MODULE: ./src/actions/cut.js

        /**
         * Cut action wrapper.
         * @param {String|HTMLElement} target
         * @return {String}
         */

        var ClipboardActionCut = function ClipboardActionCut(target) {
          var selectedText = select_default()(target);
          command('cut');
          return selectedText;
        };

        /* harmony default export */
        var actions_cut = ClipboardActionCut;
        ; // CONCATENATED MODULE: ./src/common/create-fake-element.js
        /**
         * Creates a fake textarea element with a value.
         * @param {String} value
         * @return {HTMLElement}
         */
        function createFakeElement(value) {
          var isRTL = document.documentElement.getAttribute('dir') === 'rtl';
          var fakeElement = document.createElement('textarea'); // Prevent zooming on iOS

          fakeElement.style.fontSize = '12pt'; // Reset box model

          fakeElement.style.border = '0';
          fakeElement.style.padding = '0';
          fakeElement.style.margin = '0'; // Move element out of screen horizontally

          fakeElement.style.position = 'absolute';
          fakeElement.style[isRTL ? 'right' : 'left'] = '-9999px'; // Move element to the same position vertically

          var yPosition = window.pageYOffset || document.documentElement.scrollTop;
          fakeElement.style.top = "".concat(yPosition, "px");
          fakeElement.setAttribute('readonly', '');
          fakeElement.value = value;
          return fakeElement;
        }
        ; // CONCATENATED MODULE: ./src/actions/copy.js

        /**
         * Create fake copy action wrapper using a fake element.
         * @param {String} target
         * @param {Object} options
         * @return {String}
         */

        var fakeCopyAction = function fakeCopyAction(value, options) {
          var fakeElement = createFakeElement(value);
          options.container.appendChild(fakeElement);
          var selectedText = select_default()(fakeElement);
          command('copy');
          fakeElement.remove();
          return selectedText;
        };
        /**
         * Copy action wrapper.
         * @param {String|HTMLElement} target
         * @param {Object} options
         * @return {String}
         */

        var ClipboardActionCopy = function ClipboardActionCopy(target) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            container: document.body
          };
          var selectedText = '';
          if (typeof target === 'string') {
            selectedText = fakeCopyAction(target, options);
          } else if (target instanceof HTMLInputElement && !['text', 'search', 'url', 'tel', 'password'].includes(target === null || target === void 0 ? void 0 : target.type)) {
            // If input type doesn't support `setSelectionRange`. Simulate it. https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/setSelectionRange
            selectedText = fakeCopyAction(target.value, options);
          } else {
            selectedText = select_default()(target);
            command('copy');
          }
          return selectedText;
        };

        /* harmony default export */
        var actions_copy = ClipboardActionCopy;
        ; // CONCATENATED MODULE: ./src/actions/default.js
        function _typeof(obj) {
          "@babel/helpers - typeof";

          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
          }
          return _typeof(obj);
        }

        /**
         * Inner function which performs selection from either `text` or `target`
         * properties and then executes copy or cut operations.
         * @param {Object} options
         */

        var ClipboardActionDefault = function ClipboardActionDefault() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          // Defines base properties passed from constructor.
          var _options$action = options.action,
            action = _options$action === void 0 ? 'copy' : _options$action,
            container = options.container,
            target = options.target,
            text = options.text; // Sets the `action` to be performed which can be either 'copy' or 'cut'.

          if (action !== 'copy' && action !== 'cut') {
            throw new Error('Invalid "action" value, use either "copy" or "cut"');
          } // Sets the `target` property using an element that will be have its content copied.

          if (target !== undefined) {
            if (target && _typeof(target) === 'object' && target.nodeType === 1) {
              if (action === 'copy' && target.hasAttribute('disabled')) {
                throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
              }
              if (action === 'cut' && (target.hasAttribute('readonly') || target.hasAttribute('disabled'))) {
                throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes');
              }
            } else {
              throw new Error('Invalid "target" value, use a valid Element');
            }
          } // Define selection strategy based on `text` property.

          if (text) {
            return actions_copy(text, {
              container: container
            });
          } // Defines which selection strategy based on `target` property.

          if (target) {
            return action === 'cut' ? actions_cut(target) : actions_copy(target, {
              container: container
            });
          }
        };

        /* harmony default export */
        var actions_default = ClipboardActionDefault;
        ; // CONCATENATED MODULE: ./src/clipboard.js
        function clipboard_typeof(obj) {
          "@babel/helpers - typeof";

          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            clipboard_typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            clipboard_typeof = function _typeof(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
          }
          return clipboard_typeof(obj);
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps);
          if (staticProps) _defineProperties(Constructor, staticProps);
          return Constructor;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              writable: true,
              configurable: true
            }
          });
          if (superClass) _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
            o.__proto__ = p;
            return o;
          };
          return _setPrototypeOf(o, p);
        }
        function _createSuper(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function _possibleConstructorReturn(self, call) {
          if (call && (clipboard_typeof(call) === "object" || typeof call === "function")) {
            return call;
          }
          return _assertThisInitialized(self);
        }
        function _assertThisInitialized(self) {
          if (self === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return self;
        }
        function _isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        function _getPrototypeOf(o) {
          _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
            return o.__proto__ || Object.getPrototypeOf(o);
          };
          return _getPrototypeOf(o);
        }

        /**
         * Helper function to retrieve attribute value.
         * @param {String} suffix
         * @param {Element} element
         */

        function getAttributeValue(suffix, element) {
          var attribute = "data-clipboard-".concat(suffix);
          if (!element.hasAttribute(attribute)) {
            return;
          }
          return element.getAttribute(attribute);
        }
        /**
         * Base class which takes one or more elements, adds event listeners to them,
         * and instantiates a new `ClipboardAction` on each click.
         */

        var Clipboard = /*#__PURE__*/function (_Emitter) {
          _inherits(Clipboard, _Emitter);
          var _super = _createSuper(Clipboard);

          /**
           * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
           * @param {Object} options
           */
          function Clipboard(trigger, options) {
            var _this;
            _classCallCheck(this, Clipboard);
            _this = _super.call(this);
            _this.resolveOptions(options);
            _this.listenClick(trigger);
            return _this;
          }
          /**
           * Defines if attributes would be resolved using internal setter functions
           * or custom functions that were passed in the constructor.
           * @param {Object} options
           */

          _createClass(Clipboard, [{
            key: "resolveOptions",
            value: function resolveOptions() {
              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              this.action = typeof options.action === 'function' ? options.action : this.defaultAction;
              this.target = typeof options.target === 'function' ? options.target : this.defaultTarget;
              this.text = typeof options.text === 'function' ? options.text : this.defaultText;
              this.container = clipboard_typeof(options.container) === 'object' ? options.container : document.body;
            }
            /**
             * Adds a click event listener to the passed trigger.
             * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
             */
          }, {
            key: "listenClick",
            value: function listenClick(trigger) {
              var _this2 = this;
              this.listener = listen_default()(trigger, 'click', function (e) {
                return _this2.onClick(e);
              });
            }
            /**
             * Defines a new `ClipboardAction` on each click event.
             * @param {Event} e
             */
          }, {
            key: "onClick",
            value: function onClick(e) {
              var trigger = e.delegateTarget || e.currentTarget;
              var action = this.action(trigger) || 'copy';
              var text = actions_default({
                action: action,
                container: this.container,
                target: this.target(trigger),
                text: this.text(trigger)
              }); // Fires an event based on the copy operation result.

              this.emit(text ? 'success' : 'error', {
                action: action,
                text: text,
                trigger: trigger,
                clearSelection: function clearSelection() {
                  if (trigger) {
                    trigger.focus();
                  }
                  window.getSelection().removeAllRanges();
                }
              });
            }
            /**
             * Default `action` lookup function.
             * @param {Element} trigger
             */
          }, {
            key: "defaultAction",
            value: function defaultAction(trigger) {
              return getAttributeValue('action', trigger);
            }
            /**
             * Default `target` lookup function.
             * @param {Element} trigger
             */
          }, {
            key: "defaultTarget",
            value: function defaultTarget(trigger) {
              var selector = getAttributeValue('target', trigger);
              if (selector) {
                return document.querySelector(selector);
              }
            }
            /**
             * Allow fire programmatically a copy action
             * @param {String|HTMLElement} target
             * @param {Object} options
             * @returns Text copied.
             */
          }, {
            key: "defaultText",
            /**
             * Default `text` lookup function.
             * @param {Element} trigger
             */
            value: function defaultText(trigger) {
              return getAttributeValue('text', trigger);
            }
            /**
             * Destroy lifecycle.
             */
          }, {
            key: "destroy",
            value: function destroy() {
              this.listener.destroy();
            }
          }], [{
            key: "copy",
            value: function copy(target) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
                container: document.body
              };
              return actions_copy(target, options);
            }
            /**
             * Allow fire programmatically a cut action
             * @param {String|HTMLElement} target
             * @returns Text cutted.
             */
          }, {
            key: "cut",
            value: function cut(target) {
              return actions_cut(target);
            }
            /**
             * Returns the support of the given action, or all actions if no action is
             * given.
             * @param {String} [action]
             */
          }, {
            key: "isSupported",
            value: function isSupported() {
              var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['copy', 'cut'];
              var actions = typeof action === 'string' ? [action] : action;
              var support = !!document.queryCommandSupported;
              actions.forEach(function (action) {
                support = support && !!document.queryCommandSupported(action);
              });
              return support;
            }
          }]);
          return Clipboard;
        }(tiny_emitter_default());

        /* harmony default export */
        var clipboard = Clipboard;

        /***/
      }),
      /***/828: (/***/function (module) {
        var DOCUMENT_NODE_TYPE = 9;

        /**
         * A polyfill for Element.matches()
         */
        if (typeof Element !== 'undefined' && !Element.prototype.matches) {
          var proto = Element.prototype;
          proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
        }

        /**
         * Finds the closest parent that matches a selector.
         *
         * @param {Element} element
         * @param {String} selector
         * @return {Function}
         */
        function closest(element, selector) {
          while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
            if (typeof element.matches === 'function' && element.matches(selector)) {
              return element;
            }
            element = element.parentNode;
          }
        }
        module.exports = closest;

        /***/
      }),
      /***/438: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_19439__) {
        var closest = __nested_webpack_require_19439__(828);

        /**
         * Delegates event to a selector.
         *
         * @param {Element} element
         * @param {String} selector
         * @param {String} type
         * @param {Function} callback
         * @param {Boolean} useCapture
         * @return {Object}
         */
        function _delegate(element, selector, type, callback, useCapture) {
          var listenerFn = listener.apply(this, arguments);
          element.addEventListener(type, listenerFn, useCapture);
          return {
            destroy: function () {
              element.removeEventListener(type, listenerFn, useCapture);
            }
          };
        }

        /**
         * Delegates event to a selector.
         *
         * @param {Element|String|Array} [elements]
         * @param {String} selector
         * @param {String} type
         * @param {Function} callback
         * @param {Boolean} useCapture
         * @return {Object}
         */
        function delegate(elements, selector, type, callback, useCapture) {
          // Handle the regular Element usage
          if (typeof elements.addEventListener === 'function') {
            return _delegate.apply(null, arguments);
          }

          // Handle Element-less usage, it defaults to global delegation
          if (typeof type === 'function') {
            // Use `document` as the first parameter, then apply arguments
            // This is a short way to .unshift `arguments` without running into deoptimizations
            return _delegate.bind(null, document).apply(null, arguments);
          }

          // Handle Selector-based usage
          if (typeof elements === 'string') {
            elements = document.querySelectorAll(elements);
          }

          // Handle Array-like based usage
          return Array.prototype.map.call(elements, function (element) {
            return _delegate(element, selector, type, callback, useCapture);
          });
        }

        /**
         * Finds closest match and invokes callback.
         *
         * @param {Element} element
         * @param {String} selector
         * @param {String} type
         * @param {Function} callback
         * @return {Function}
         */
        function listener(element, selector, type, callback) {
          return function (e) {
            e.delegateTarget = closest(e.target, selector);
            if (e.delegateTarget) {
              callback.call(element, e);
            }
          };
        }
        module.exports = delegate;

        /***/
      }),
      /***/879: (/***/function (__unused_webpack_module, exports) {
        /**
         * Check if argument is a HTML element.
         *
         * @param {Object} value
         * @return {Boolean}
         */
        exports.node = function (value) {
          return value !== undefined && value instanceof HTMLElement && value.nodeType === 1;
        };

        /**
         * Check if argument is a list of HTML elements.
         *
         * @param {Object} value
         * @return {Boolean}
         */
        exports.nodeList = function (value) {
          var type = Object.prototype.toString.call(value);
          return value !== undefined && (type === '[object NodeList]' || type === '[object HTMLCollection]') && 'length' in value && (value.length === 0 || exports.node(value[0]));
        };

        /**
         * Check if argument is a string.
         *
         * @param {Object} value
         * @return {Boolean}
         */
        exports.string = function (value) {
          return typeof value === 'string' || value instanceof String;
        };

        /**
         * Check if argument is a function.
         *
         * @param {Object} value
         * @return {Boolean}
         */
        exports.fn = function (value) {
          var type = Object.prototype.toString.call(value);
          return type === '[object Function]';
        };

        /***/
      }),
      /***/370: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_23531__) {
        var is = __nested_webpack_require_23531__(879);
        var delegate = __nested_webpack_require_23531__(438);

        /**
         * Validates all params and calls the right
         * listener function based on its target type.
         *
         * @param {String|HTMLElement|HTMLCollection|NodeList} target
         * @param {String} type
         * @param {Function} callback
         * @return {Object}
         */
        function listen(target, type, callback) {
          if (!target && !type && !callback) {
            throw new Error('Missing required arguments');
          }
          if (!is.string(type)) {
            throw new TypeError('Second argument must be a String');
          }
          if (!is.fn(callback)) {
            throw new TypeError('Third argument must be a Function');
          }
          if (is.node(target)) {
            return listenNode(target, type, callback);
          } else if (is.nodeList(target)) {
            return listenNodeList(target, type, callback);
          } else if (is.string(target)) {
            return listenSelector(target, type, callback);
          } else {
            throw new TypeError('First argument must be a String, HTMLElement, HTMLCollection, or NodeList');
          }
        }

        /**
         * Adds an event listener to a HTML element
         * and returns a remove listener function.
         *
         * @param {HTMLElement} node
         * @param {String} type
         * @param {Function} callback
         * @return {Object}
         */
        function listenNode(node, type, callback) {
          node.addEventListener(type, callback);
          return {
            destroy: function () {
              node.removeEventListener(type, callback);
            }
          };
        }

        /**
         * Add an event listener to a list of HTML elements
         * and returns a remove listener function.
         *
         * @param {NodeList|HTMLCollection} nodeList
         * @param {String} type
         * @param {Function} callback
         * @return {Object}
         */
        function listenNodeList(nodeList, type, callback) {
          Array.prototype.forEach.call(nodeList, function (node) {
            node.addEventListener(type, callback);
          });
          return {
            destroy: function () {
              Array.prototype.forEach.call(nodeList, function (node) {
                node.removeEventListener(type, callback);
              });
            }
          };
        }

        /**
         * Add an event listener to a selector
         * and returns a remove listener function.
         *
         * @param {String} selector
         * @param {String} type
         * @param {Function} callback
         * @return {Object}
         */
        function listenSelector(selector, type, callback) {
          return delegate(document.body, selector, type, callback);
        }
        module.exports = listen;

        /***/
      }),
      /***/817: (/***/function (module) {
        function select(element) {
          var selectedText;
          if (element.nodeName === 'SELECT') {
            element.focus();
            selectedText = element.value;
          } else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {
            var isReadOnly = element.hasAttribute('readonly');
            if (!isReadOnly) {
              element.setAttribute('readonly', '');
            }
            element.select();
            element.setSelectionRange(0, element.value.length);
            if (!isReadOnly) {
              element.removeAttribute('readonly');
            }
            selectedText = element.value;
          } else {
            if (element.hasAttribute('contenteditable')) {
              element.focus();
            }
            var selection = window.getSelection();
            var range = document.createRange();
            range.selectNodeContents(element);
            selection.removeAllRanges();
            selection.addRange(range);
            selectedText = selection.toString();
          }
          return selectedText;
        }
        module.exports = select;

        /***/
      }),
      /***/279: (/***/function (module) {
        function E() {
          // Keep this empty so it's easier to inherit from
          // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
        }
        E.prototype = {
          on: function (name, callback, ctx) {
            var e = this.e || (this.e = {});
            (e[name] || (e[name] = [])).push({
              fn: callback,
              ctx: ctx
            });
            return this;
          },
          once: function (name, callback, ctx) {
            var self = this;
            function listener() {
              self.off(name, listener);
              callback.apply(ctx, arguments);
            }
            ;
            listener._ = callback;
            return this.on(name, listener, ctx);
          },
          emit: function (name) {
            var data = [].slice.call(arguments, 1);
            var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
            var i = 0;
            var len = evtArr.length;
            for (i; i < len; i++) {
              evtArr[i].fn.apply(evtArr[i].ctx, data);
            }
            return this;
          },
          off: function (name, callback) {
            var e = this.e || (this.e = {});
            var evts = e[name];
            var liveEvents = [];
            if (evts && callback) {
              for (var i = 0, len = evts.length; i < len; i++) {
                if (evts[i].fn !== callback && evts[i].fn._ !== callback) liveEvents.push(evts[i]);
              }
            }

            // Remove event from queue to prevent memory leak
            // Suggested by https://github.com/lazd
            // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

            liveEvents.length ? e[name] = liveEvents : delete e[name];
            return this;
          }
        };
        module.exports = E;
        module.exports.TinyEmitter = E;

        /***/
      })

      /******/
    };
    /************************************************************************/
    /******/ // The module cache
    /******/
    var __webpack_module_cache__ = {};
    /******/
    /******/ // The require function
    /******/
    function __nested_webpack_require_30018__(moduleId) {
      /******/ // Check if module is in cache
      /******/if (__webpack_module_cache__[moduleId]) {
        /******/return __webpack_module_cache__[moduleId].exports;
        /******/
      }
      /******/ // Create a new module (and put it into the cache)
      /******/
      var module = __webpack_module_cache__[moduleId] = {
        /******/ // no module.id needed
        /******/ // no module.loaded needed
        /******/exports: {}
        /******/
      };
      /******/
      /******/ // Execute the module function
      /******/
      __webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_30018__);
      /******/
      /******/ // Return the exports of the module
      /******/
      return module.exports;
      /******/
    }
    /******/
    /************************************************************************/
    /******/ /* webpack/runtime/compat get default export */
    /******/
    !function () {
      /******/ // getDefaultExport function for compatibility with non-harmony modules
      /******/__nested_webpack_require_30018__.n = function (module) {
        /******/var getter = module && module.__esModule ? /******/function () {
          return module['default'];
        } : /******/function () {
          return module;
        };
        /******/
        __nested_webpack_require_30018__.d(getter, {
          a: getter
        });
        /******/
        return getter;
        /******/
      };
      /******/
    }();
    /******/
    /******/ /* webpack/runtime/define property getters */
    /******/
    !function () {
      /******/ // define getter functions for harmony exports
      /******/__nested_webpack_require_30018__.d = function (exports, definition) {
        /******/for (var key in definition) {
          /******/if (__nested_webpack_require_30018__.o(definition, key) && !__nested_webpack_require_30018__.o(exports, key)) {
            /******/Object.defineProperty(exports, key, {
              enumerable: true,
              get: definition[key]
            });
            /******/
          }
          /******/
        }
        /******/
      };
      /******/
    }();
    /******/
    /******/ /* webpack/runtime/hasOwnProperty shorthand */
    /******/
    !function () {
      /******/__nested_webpack_require_30018__.o = function (obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      };
      /******/
    }();
    /******/
    /************************************************************************/
    /******/ // module exports must be returned from runtime so entry inlining is disabled
    /******/ // startup
    /******/ // Load entry module and return exports
    /******/
    return __nested_webpack_require_30018__(686);
    /******/
  }().default;
});

/***/ }),

/***/ "./node_modules/dropzone/dist/dropzone.js":
/*!************************************************!*\
  !*** ./node_modules/dropzone/dist/dropzone.js ***!
  \************************************************/
/***/ ((module) => {

(function webpackUniversalModuleDefinition(root, factory) {
  if (true) module.exports = factory();else { var i, a; }
})(self, function () {
  return /******/function () {
    // webpackBootstrap
    /******/
    var __webpack_modules__ = {
      /***/3099: (/***/function (module) {
        module.exports = function (it) {
          if (typeof it != 'function') {
            throw TypeError(String(it) + ' is not a function');
          }
          return it;
        };

        /***/
      }),
      /***/6077: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_786__) {
        var isObject = __nested_webpack_require_786__(111);
        module.exports = function (it) {
          if (!isObject(it) && it !== null) {
            throw TypeError("Can't set " + String(it) + ' as a prototype');
          }
          return it;
        };

        /***/
      }),
      /***/1223: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_1157__) {
        var wellKnownSymbol = __nested_webpack_require_1157__(5112);
        var create = __nested_webpack_require_1157__(30);
        var definePropertyModule = __nested_webpack_require_1157__(3070);
        var UNSCOPABLES = wellKnownSymbol('unscopables');
        var ArrayPrototype = Array.prototype;

        // Array.prototype[@@unscopables]
        // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
        if (ArrayPrototype[UNSCOPABLES] == undefined) {
          definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
            configurable: true,
            value: create(null)
          });
        }

        // add a key to Array.prototype[@@unscopables]
        module.exports = function (key) {
          ArrayPrototype[UNSCOPABLES][key] = true;
        };

        /***/
      }),
      /***/1530: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_2022__) {
        "use strict";

        var charAt = __nested_webpack_require_2022__(8710).charAt;

        // `AdvanceStringIndex` abstract operation
        // https://tc39.es/ecma262/#sec-advancestringindex
        module.exports = function (S, index, unicode) {
          return index + (unicode ? charAt(S, index).length : 1);
        };

        /***/
      }),
      /***/5787: (/***/function (module) {
        module.exports = function (it, Constructor, name) {
          if (!(it instanceof Constructor)) {
            throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
          }
          return it;
        };

        /***/
      }),
      /***/9670: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_2762__) {
        var isObject = __nested_webpack_require_2762__(111);
        module.exports = function (it) {
          if (!isObject(it)) {
            throw TypeError(String(it) + ' is not an object');
          }
          return it;
        };

        /***/
      }),
      /***/4019: (/***/function (module) {
        module.exports = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';

        /***/
      }),
      /***/260: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_3268__) {
        "use strict";

        var NATIVE_ARRAY_BUFFER = __nested_webpack_require_3268__(4019);
        var DESCRIPTORS = __nested_webpack_require_3268__(9781);
        var global = __nested_webpack_require_3268__(7854);
        var isObject = __nested_webpack_require_3268__(111);
        var has = __nested_webpack_require_3268__(6656);
        var classof = __nested_webpack_require_3268__(648);
        var createNonEnumerableProperty = __nested_webpack_require_3268__(8880);
        var redefine = __nested_webpack_require_3268__(1320);
        var defineProperty = __nested_webpack_require_3268__(3070).f;
        var getPrototypeOf = __nested_webpack_require_3268__(9518);
        var setPrototypeOf = __nested_webpack_require_3268__(7674);
        var wellKnownSymbol = __nested_webpack_require_3268__(5112);
        var uid = __nested_webpack_require_3268__(9711);
        var Int8Array = global.Int8Array;
        var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
        var Uint8ClampedArray = global.Uint8ClampedArray;
        var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
        var TypedArray = Int8Array && getPrototypeOf(Int8Array);
        var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
        var ObjectPrototype = Object.prototype;
        var isPrototypeOf = ObjectPrototype.isPrototypeOf;
        var TO_STRING_TAG = wellKnownSymbol('toStringTag');
        var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
        // Fixing native typed arrays in Opera Presto crashes the browser, see #595
        var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';
        var TYPED_ARRAY_TAG_REQIRED = false;
        var NAME;
        var TypedArrayConstructorsList = {
          Int8Array: 1,
          Uint8Array: 1,
          Uint8ClampedArray: 1,
          Int16Array: 2,
          Uint16Array: 2,
          Int32Array: 4,
          Uint32Array: 4,
          Float32Array: 4,
          Float64Array: 8
        };
        var BigIntArrayConstructorsList = {
          BigInt64Array: 8,
          BigUint64Array: 8
        };
        var isView = function isView(it) {
          if (!isObject(it)) return false;
          var klass = classof(it);
          return klass === 'DataView' || has(TypedArrayConstructorsList, klass) || has(BigIntArrayConstructorsList, klass);
        };
        var isTypedArray = function (it) {
          if (!isObject(it)) return false;
          var klass = classof(it);
          return has(TypedArrayConstructorsList, klass) || has(BigIntArrayConstructorsList, klass);
        };
        var aTypedArray = function (it) {
          if (isTypedArray(it)) return it;
          throw TypeError('Target is not a typed array');
        };
        var aTypedArrayConstructor = function (C) {
          if (setPrototypeOf) {
            if (isPrototypeOf.call(TypedArray, C)) return C;
          } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME)) {
            var TypedArrayConstructor = global[ARRAY];
            if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
              return C;
            }
          }
          throw TypeError('Target is not a typed array constructor');
        };
        var exportTypedArrayMethod = function (KEY, property, forced) {
          if (!DESCRIPTORS) return;
          if (forced) for (var ARRAY in TypedArrayConstructorsList) {
            var TypedArrayConstructor = global[ARRAY];
            if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {
              delete TypedArrayConstructor.prototype[KEY];
            }
          }
          if (!TypedArrayPrototype[KEY] || forced) {
            redefine(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
          }
        };
        var exportTypedArrayStaticMethod = function (KEY, property, forced) {
          var ARRAY, TypedArrayConstructor;
          if (!DESCRIPTORS) return;
          if (setPrototypeOf) {
            if (forced) for (ARRAY in TypedArrayConstructorsList) {
              TypedArrayConstructor = global[ARRAY];
              if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {
                delete TypedArrayConstructor[KEY];
              }
            }
            if (!TypedArray[KEY] || forced) {
              // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
              try {
                return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array[KEY] || property);
              } catch (error) {/* empty */}
            } else return;
          }
          for (ARRAY in TypedArrayConstructorsList) {
            TypedArrayConstructor = global[ARRAY];
            if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
              redefine(TypedArrayConstructor, KEY, property);
            }
          }
        };
        for (NAME in TypedArrayConstructorsList) {
          if (!global[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;
        }

        // WebKit bug - typed arrays constructors prototype is Object.prototype
        if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
          // eslint-disable-next-line no-shadow -- safe
          TypedArray = function TypedArray() {
            throw TypeError('Incorrect invocation');
          };
          if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
            if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
          }
        }
        if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
          TypedArrayPrototype = TypedArray.prototype;
          if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
            if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
          }
        }

        // WebKit bug - one more object in Uint8ClampedArray prototype chain
        if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
          setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
        }
        if (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) {
          TYPED_ARRAY_TAG_REQIRED = true;
          defineProperty(TypedArrayPrototype, TO_STRING_TAG, {
            get: function () {
              return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
            }
          });
          for (NAME in TypedArrayConstructorsList) if (global[NAME]) {
            createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
          }
        }
        module.exports = {
          NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
          TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
          aTypedArray: aTypedArray,
          aTypedArrayConstructor: aTypedArrayConstructor,
          exportTypedArrayMethod: exportTypedArrayMethod,
          exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
          isView: isView,
          isTypedArray: isTypedArray,
          TypedArray: TypedArray,
          TypedArrayPrototype: TypedArrayPrototype
        };

        /***/
      }),
      /***/3331: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_10670__) {
        "use strict";

        var global = __nested_webpack_require_10670__(7854);
        var DESCRIPTORS = __nested_webpack_require_10670__(9781);
        var NATIVE_ARRAY_BUFFER = __nested_webpack_require_10670__(4019);
        var createNonEnumerableProperty = __nested_webpack_require_10670__(8880);
        var redefineAll = __nested_webpack_require_10670__(2248);
        var fails = __nested_webpack_require_10670__(7293);
        var anInstance = __nested_webpack_require_10670__(5787);
        var toInteger = __nested_webpack_require_10670__(9958);
        var toLength = __nested_webpack_require_10670__(7466);
        var toIndex = __nested_webpack_require_10670__(7067);
        var IEEE754 = __nested_webpack_require_10670__(1179);
        var getPrototypeOf = __nested_webpack_require_10670__(9518);
        var setPrototypeOf = __nested_webpack_require_10670__(7674);
        var getOwnPropertyNames = __nested_webpack_require_10670__(8006).f;
        var defineProperty = __nested_webpack_require_10670__(3070).f;
        var arrayFill = __nested_webpack_require_10670__(1285);
        var setToStringTag = __nested_webpack_require_10670__(8003);
        var InternalStateModule = __nested_webpack_require_10670__(9909);
        var getInternalState = InternalStateModule.get;
        var setInternalState = InternalStateModule.set;
        var ARRAY_BUFFER = 'ArrayBuffer';
        var DATA_VIEW = 'DataView';
        var PROTOTYPE = 'prototype';
        var WRONG_LENGTH = 'Wrong length';
        var WRONG_INDEX = 'Wrong index';
        var NativeArrayBuffer = global[ARRAY_BUFFER];
        var $ArrayBuffer = NativeArrayBuffer;
        var $DataView = global[DATA_VIEW];
        var $DataViewPrototype = $DataView && $DataView[PROTOTYPE];
        var ObjectPrototype = Object.prototype;
        var RangeError = global.RangeError;
        var packIEEE754 = IEEE754.pack;
        var unpackIEEE754 = IEEE754.unpack;
        var packInt8 = function (number) {
          return [number & 0xFF];
        };
        var packInt16 = function (number) {
          return [number & 0xFF, number >> 8 & 0xFF];
        };
        var packInt32 = function (number) {
          return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
        };
        var unpackInt32 = function (buffer) {
          return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
        };
        var packFloat32 = function (number) {
          return packIEEE754(number, 23, 4);
        };
        var packFloat64 = function (number) {
          return packIEEE754(number, 52, 8);
        };
        var addGetter = function (Constructor, key) {
          defineProperty(Constructor[PROTOTYPE], key, {
            get: function () {
              return getInternalState(this)[key];
            }
          });
        };
        var get = function (view, count, index, isLittleEndian) {
          var intIndex = toIndex(index);
          var store = getInternalState(view);
          if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
          var bytes = getInternalState(store.buffer).bytes;
          var start = intIndex + store.byteOffset;
          var pack = bytes.slice(start, start + count);
          return isLittleEndian ? pack : pack.reverse();
        };
        var set = function (view, count, index, conversion, value, isLittleEndian) {
          var intIndex = toIndex(index);
          var store = getInternalState(view);
          if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
          var bytes = getInternalState(store.buffer).bytes;
          var start = intIndex + store.byteOffset;
          var pack = conversion(+value);
          for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
        };
        if (!NATIVE_ARRAY_BUFFER) {
          $ArrayBuffer = function ArrayBuffer(length) {
            anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
            var byteLength = toIndex(length);
            setInternalState(this, {
              bytes: arrayFill.call(new Array(byteLength), 0),
              byteLength: byteLength
            });
            if (!DESCRIPTORS) this.byteLength = byteLength;
          };
          $DataView = function DataView(buffer, byteOffset, byteLength) {
            anInstance(this, $DataView, DATA_VIEW);
            anInstance(buffer, $ArrayBuffer, DATA_VIEW);
            var bufferLength = getInternalState(buffer).byteLength;
            var offset = toInteger(byteOffset);
            if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset');
            byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
            if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
            setInternalState(this, {
              buffer: buffer,
              byteLength: byteLength,
              byteOffset: offset
            });
            if (!DESCRIPTORS) {
              this.buffer = buffer;
              this.byteLength = byteLength;
              this.byteOffset = offset;
            }
          };
          if (DESCRIPTORS) {
            addGetter($ArrayBuffer, 'byteLength');
            addGetter($DataView, 'buffer');
            addGetter($DataView, 'byteLength');
            addGetter($DataView, 'byteOffset');
          }
          redefineAll($DataView[PROTOTYPE], {
            getInt8: function getInt8(byteOffset) {
              return get(this, 1, byteOffset)[0] << 24 >> 24;
            },
            getUint8: function getUint8(byteOffset) {
              return get(this, 1, byteOffset)[0];
            },
            getInt16: function getInt16(byteOffset /* , littleEndian */) {
              var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
              return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
            },
            getUint16: function getUint16(byteOffset /* , littleEndian */) {
              var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
              return bytes[1] << 8 | bytes[0];
            },
            getInt32: function getInt32(byteOffset /* , littleEndian */) {
              return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
            },
            getUint32: function getUint32(byteOffset /* , littleEndian */) {
              return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
            },
            getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
              return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
            },
            getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
              return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
            },
            setInt8: function setInt8(byteOffset, value) {
              set(this, 1, byteOffset, packInt8, value);
            },
            setUint8: function setUint8(byteOffset, value) {
              set(this, 1, byteOffset, packInt8, value);
            },
            setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
              set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
            },
            setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
              set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
            },
            setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
              set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
            },
            setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
              set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
            },
            setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
              set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
            },
            setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
              set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
            }
          });
        } else {
          /* eslint-disable no-new -- required for testing */
          if (!fails(function () {
            NativeArrayBuffer(1);
          }) || !fails(function () {
            new NativeArrayBuffer(-1);
          }) || fails(function () {
            new NativeArrayBuffer();
            new NativeArrayBuffer(1.5);
            new NativeArrayBuffer(NaN);
            return NativeArrayBuffer.name != ARRAY_BUFFER;
          })) {
            /* eslint-enable no-new -- required for testing */
            $ArrayBuffer = function ArrayBuffer(length) {
              anInstance(this, $ArrayBuffer);
              return new NativeArrayBuffer(toIndex(length));
            };
            var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE] = NativeArrayBuffer[PROTOTYPE];
            for (var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys.length > j;) {
              if (!((key = keys[j++]) in $ArrayBuffer)) {
                createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
              }
            }
            ArrayBufferPrototype.constructor = $ArrayBuffer;
          }

          // WebKit bug - the same parent prototype for typed arrays and data view
          if (setPrototypeOf && getPrototypeOf($DataViewPrototype) !== ObjectPrototype) {
            setPrototypeOf($DataViewPrototype, ObjectPrototype);
          }

          // iOS Safari 7.x bug
          var testView = new $DataView(new $ArrayBuffer(2));
          var nativeSetInt8 = $DataViewPrototype.setInt8;
          testView.setInt8(0, 2147483648);
          testView.setInt8(1, 2147483649);
          if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {
            setInt8: function setInt8(byteOffset, value) {
              nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
            },
            setUint8: function setUint8(byteOffset, value) {
              nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
            }
          }, {
            unsafe: true
          });
        }
        setToStringTag($ArrayBuffer, ARRAY_BUFFER);
        setToStringTag($DataView, DATA_VIEW);
        module.exports = {
          ArrayBuffer: $ArrayBuffer,
          DataView: $DataView
        };

        /***/
      }),
      /***/1048: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_21360__) {
        "use strict";

        var toObject = __nested_webpack_require_21360__(7908);
        var toAbsoluteIndex = __nested_webpack_require_21360__(1400);
        var toLength = __nested_webpack_require_21360__(7466);
        var min = Math.min;

        // `Array.prototype.copyWithin` method implementation
        // https://tc39.es/ecma262/#sec-array.prototype.copywithin
        module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
          var O = toObject(this);
          var len = toLength(O.length);
          var to = toAbsoluteIndex(target, len);
          var from = toAbsoluteIndex(start, len);
          var end = arguments.length > 2 ? arguments[2] : undefined;
          var count = min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
          var inc = 1;
          if (from < to && to < from + count) {
            inc = -1;
            from += count - 1;
            to += count - 1;
          }
          while (count-- > 0) {
            if (from in O) O[to] = O[from];else delete O[to];
            to += inc;
            from += inc;
          }
          return O;
        };

        /***/
      }),
      /***/1285: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_22618__) {
        "use strict";

        var toObject = __nested_webpack_require_22618__(7908);
        var toAbsoluteIndex = __nested_webpack_require_22618__(1400);
        var toLength = __nested_webpack_require_22618__(7466);

        // `Array.prototype.fill` method implementation
        // https://tc39.es/ecma262/#sec-array.prototype.fill
        module.exports = function fill(value /* , start = 0, end = @length */) {
          var O = toObject(this);
          var length = toLength(O.length);
          var argumentsLength = arguments.length;
          var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
          var end = argumentsLength > 2 ? arguments[2] : undefined;
          var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
          while (endPos > index) O[index++] = value;
          return O;
        };

        /***/
      }),
      /***/8533: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_23568__) {
        "use strict";

        var $forEach = __nested_webpack_require_23568__(2092).forEach;
        var arrayMethodIsStrict = __nested_webpack_require_23568__(9341);
        var STRICT_METHOD = arrayMethodIsStrict('forEach');

        // `Array.prototype.forEach` method implementation
        // https://tc39.es/ecma262/#sec-array.prototype.foreach
        module.exports = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */) {
          return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        } : [].forEach;

        /***/
      }),
      /***/8457: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_24216__) {
        "use strict";

        var bind = __nested_webpack_require_24216__(9974);
        var toObject = __nested_webpack_require_24216__(7908);
        var callWithSafeIterationClosing = __nested_webpack_require_24216__(3411);
        var isArrayIteratorMethod = __nested_webpack_require_24216__(7659);
        var toLength = __nested_webpack_require_24216__(7466);
        var createProperty = __nested_webpack_require_24216__(6135);
        var getIteratorMethod = __nested_webpack_require_24216__(1246);

        // `Array.from` method implementation
        // https://tc39.es/ecma262/#sec-array.from
        module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
          var O = toObject(arrayLike);
          var C = typeof this == 'function' ? this : Array;
          var argumentsLength = arguments.length;
          var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
          var mapping = mapfn !== undefined;
          var iteratorMethod = getIteratorMethod(O);
          var index = 0;
          var length, result, step, iterator, next, value;
          if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
          // if the target is not iterable or it's an array with the default iterator - use a simple case
          if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
            iterator = iteratorMethod.call(O);
            next = iterator.next;
            result = new C();
            for (; !(step = next.call(iterator)).done; index++) {
              value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
              createProperty(result, index, value);
            }
          } else {
            length = toLength(O.length);
            result = new C(length);
            for (; length > index; index++) {
              value = mapping ? mapfn(O[index], index) : O[index];
              createProperty(result, index, value);
            }
          }
          result.length = index;
          return result;
        };

        /***/
      }),
      /***/1318: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_26368__) {
        var toIndexedObject = __nested_webpack_require_26368__(5656);
        var toLength = __nested_webpack_require_26368__(7466);
        var toAbsoluteIndex = __nested_webpack_require_26368__(1400);

        // `Array.prototype.{ indexOf, includes }` methods implementation
        var createMethod = function (IS_INCLUDES) {
          return function ($this, el, fromIndex) {
            var O = toIndexedObject($this);
            var length = toLength(O.length);
            var index = toAbsoluteIndex(fromIndex, length);
            var value;
            // Array#includes uses SameValueZero equality algorithm
            // eslint-disable-next-line no-self-compare -- NaN check
            if (IS_INCLUDES && el != el) while (length > index) {
              value = O[index++];
              // eslint-disable-next-line no-self-compare -- NaN check
              if (value != value) return true;
              // Array#indexOf ignores holes, Array#includes - not
            } else for (; length > index; index++) {
              if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
            }
            return !IS_INCLUDES && -1;
          };
        };
        module.exports = {
          // `Array.prototype.includes` method
          // https://tc39.es/ecma262/#sec-array.prototype.includes
          includes: createMethod(true),
          // `Array.prototype.indexOf` method
          // https://tc39.es/ecma262/#sec-array.prototype.indexof
          indexOf: createMethod(false)
        };

        /***/
      }),
      /***/2092: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_27992__) {
        var bind = __nested_webpack_require_27992__(9974);
        var IndexedObject = __nested_webpack_require_27992__(8361);
        var toObject = __nested_webpack_require_27992__(7908);
        var toLength = __nested_webpack_require_27992__(7466);
        var arraySpeciesCreate = __nested_webpack_require_27992__(5417);
        var push = [].push;

        // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation
        var createMethod = function (TYPE) {
          var IS_MAP = TYPE == 1;
          var IS_FILTER = TYPE == 2;
          var IS_SOME = TYPE == 3;
          var IS_EVERY = TYPE == 4;
          var IS_FIND_INDEX = TYPE == 6;
          var IS_FILTER_OUT = TYPE == 7;
          var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
          return function ($this, callbackfn, that, specificCreate) {
            var O = toObject($this);
            var self = IndexedObject(O);
            var boundFunction = bind(callbackfn, that, 3);
            var length = toLength(self.length);
            var index = 0;
            var create = specificCreate || arraySpeciesCreate;
            var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;
            var value, result;
            for (; length > index; index++) if (NO_HOLES || index in self) {
              value = self[index];
              result = boundFunction(value, index, O);
              if (TYPE) {
                if (IS_MAP) target[index] = result; // map
                else if (result) switch (TYPE) {
                  case 3:
                    return true;
                  // some
                  case 5:
                    return value;
                  // find
                  case 6:
                    return index;
                  // findIndex
                  case 2:
                    push.call(target, value);
                  // filter
                } else switch (TYPE) {
                  case 4:
                    return false;
                  // every
                  case 7:
                    push.call(target, value);
                  // filterOut
                }
              }
            }
            return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
          };
        };
        module.exports = {
          // `Array.prototype.forEach` method
          // https://tc39.es/ecma262/#sec-array.prototype.foreach
          forEach: createMethod(0),
          // `Array.prototype.map` method
          // https://tc39.es/ecma262/#sec-array.prototype.map
          map: createMethod(1),
          // `Array.prototype.filter` method
          // https://tc39.es/ecma262/#sec-array.prototype.filter
          filter: createMethod(2),
          // `Array.prototype.some` method
          // https://tc39.es/ecma262/#sec-array.prototype.some
          some: createMethod(3),
          // `Array.prototype.every` method
          // https://tc39.es/ecma262/#sec-array.prototype.every
          every: createMethod(4),
          // `Array.prototype.find` method
          // https://tc39.es/ecma262/#sec-array.prototype.find
          find: createMethod(5),
          // `Array.prototype.findIndex` method
          // https://tc39.es/ecma262/#sec-array.prototype.findIndex
          findIndex: createMethod(6),
          // `Array.prototype.filterOut` method
          // https://github.com/tc39/proposal-array-filtering
          filterOut: createMethod(7)
        };

        /***/
      }),
      /***/6583: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_31563__) {
        "use strict";

        var toIndexedObject = __nested_webpack_require_31563__(5656);
        var toInteger = __nested_webpack_require_31563__(9958);
        var toLength = __nested_webpack_require_31563__(7466);
        var arrayMethodIsStrict = __nested_webpack_require_31563__(9341);
        var min = Math.min;
        var nativeLastIndexOf = [].lastIndexOf;
        var NEGATIVE_ZERO = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
        var STRICT_METHOD = arrayMethodIsStrict('lastIndexOf');
        var FORCED = NEGATIVE_ZERO || !STRICT_METHOD;

        // `Array.prototype.lastIndexOf` method implementation
        // https://tc39.es/ecma262/#sec-array.prototype.lastindexof
        module.exports = FORCED ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
          // convert -0 to +0
          if (NEGATIVE_ZERO) return nativeLastIndexOf.apply(this, arguments) || 0;
          var O = toIndexedObject(this);
          var length = toLength(O.length);
          var index = length - 1;
          if (arguments.length > 1) index = min(index, toInteger(arguments[1]));
          if (index < 0) index = length + index;
          for (; index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
          return -1;
        } : nativeLastIndexOf;

        /***/
      }),
      /***/1194: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_32944__) {
        var fails = __nested_webpack_require_32944__(7293);
        var wellKnownSymbol = __nested_webpack_require_32944__(5112);
        var V8_VERSION = __nested_webpack_require_32944__(7392);
        var SPECIES = wellKnownSymbol('species');
        module.exports = function (METHOD_NAME) {
          // We can't use this feature detection in V8 since it causes
          // deoptimization and serious performance degradation
          // https://github.com/zloirock/core-js/issues/677
          return V8_VERSION >= 51 || !fails(function () {
            var array = [];
            var constructor = array.constructor = {};
            constructor[SPECIES] = function () {
              return {
                foo: 1
              };
            };
            return array[METHOD_NAME](Boolean).foo !== 1;
          });
        };

        /***/
      }),
      /***/9341: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_33860__) {
        "use strict";

        var fails = __nested_webpack_require_33860__(7293);
        module.exports = function (METHOD_NAME, argument) {
          var method = [][METHOD_NAME];
          return !!method && fails(function () {
            // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing
            method.call(null, argument || function () {
              throw 1;
            }, 1);
          });
        };

        /***/
      }),
      /***/3671: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_34414__) {
        var aFunction = __nested_webpack_require_34414__(3099);
        var toObject = __nested_webpack_require_34414__(7908);
        var IndexedObject = __nested_webpack_require_34414__(8361);
        var toLength = __nested_webpack_require_34414__(7466);

        // `Array.prototype.{ reduce, reduceRight }` methods implementation
        var createMethod = function (IS_RIGHT) {
          return function (that, callbackfn, argumentsLength, memo) {
            aFunction(callbackfn);
            var O = toObject(that);
            var self = IndexedObject(O);
            var length = toLength(O.length);
            var index = IS_RIGHT ? length - 1 : 0;
            var i = IS_RIGHT ? -1 : 1;
            if (argumentsLength < 2) while (true) {
              if (index in self) {
                memo = self[index];
                index += i;
                break;
              }
              index += i;
              if (IS_RIGHT ? index < 0 : length <= index) {
                throw TypeError('Reduce of empty array with no initial value');
              }
            }
            for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
              memo = callbackfn(memo, self[index], index, O);
            }
            return memo;
          };
        };
        module.exports = {
          // `Array.prototype.reduce` method
          // https://tc39.es/ecma262/#sec-array.prototype.reduce
          left: createMethod(false),
          // `Array.prototype.reduceRight` method
          // https://tc39.es/ecma262/#sec-array.prototype.reduceright
          right: createMethod(true)
        };

        /***/
      }),
      /***/5417: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_36122__) {
        var isObject = __nested_webpack_require_36122__(111);
        var isArray = __nested_webpack_require_36122__(3157);
        var wellKnownSymbol = __nested_webpack_require_36122__(5112);
        var SPECIES = wellKnownSymbol('species');

        // `ArraySpeciesCreate` abstract operation
        // https://tc39.es/ecma262/#sec-arrayspeciescreate
        module.exports = function (originalArray, length) {
          var C;
          if (isArray(originalArray)) {
            C = originalArray.constructor;
            // cross-realm fallback
            if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;else if (isObject(C)) {
              C = C[SPECIES];
              if (C === null) C = undefined;
            }
          }
          return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
        };

        /***/
      }),
      /***/3411: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_37059__) {
        var anObject = __nested_webpack_require_37059__(9670);
        var iteratorClose = __nested_webpack_require_37059__(9212);

        // call something on iterator step with safe closing on error
        module.exports = function (iterator, fn, value, ENTRIES) {
          try {
            return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
            // 7.4.6 IteratorClose(iterator, completion)
          } catch (error) {
            iteratorClose(iterator);
            throw error;
          }
        };

        /***/
      }),
      /***/7072: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_37678__) {
        var wellKnownSymbol = __nested_webpack_require_37678__(5112);
        var ITERATOR = wellKnownSymbol('iterator');
        var SAFE_CLOSING = false;
        try {
          var called = 0;
          var iteratorWithReturn = {
            next: function () {
              return {
                done: !!called++
              };
            },
            'return': function () {
              SAFE_CLOSING = true;
            }
          };
          iteratorWithReturn[ITERATOR] = function () {
            return this;
          };
          // eslint-disable-next-line no-throw-literal -- required for testing
          Array.from(iteratorWithReturn, function () {
            throw 2;
          });
        } catch (error) {/* empty */}
        module.exports = function (exec, SKIP_CLOSING) {
          if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
          var ITERATION_SUPPORT = false;
          try {
            var object = {};
            object[ITERATOR] = function () {
              return {
                next: function () {
                  return {
                    done: ITERATION_SUPPORT = true
                  };
                }
              };
            };
            exec(object);
          } catch (error) {/* empty */}
          return ITERATION_SUPPORT;
        };

        /***/
      }),
      /***/4326: (/***/function (module) {
        var toString = {}.toString;
        module.exports = function (it) {
          return toString.call(it).slice(8, -1);
        };

        /***/
      }),
      /***/648: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_39304__) {
        var TO_STRING_TAG_SUPPORT = __nested_webpack_require_39304__(1694);
        var classofRaw = __nested_webpack_require_39304__(4326);
        var wellKnownSymbol = __nested_webpack_require_39304__(5112);
        var TO_STRING_TAG = wellKnownSymbol('toStringTag');
        // ES3 wrong here
        var CORRECT_ARGUMENTS = classofRaw(function () {
          return arguments;
        }()) == 'Arguments';

        // fallback for IE11 Script Access Denied error
        var tryGet = function (it, key) {
          try {
            return it[key];
          } catch (error) {/* empty */}
        };

        // getting tag from ES6+ `Object.prototype.toString`
        module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
          var O, tag, result;
          return it === undefined ? 'Undefined' : it === null ? 'Null'
          // @@toStringTag case
          : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
          // builtinTag case
          : CORRECT_ARGUMENTS ? classofRaw(O)
          // ES3 arguments fallback
          : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
        };

        /***/
      }),
      /***/9920: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_40569__) {
        var has = __nested_webpack_require_40569__(6656);
        var ownKeys = __nested_webpack_require_40569__(3887);
        var getOwnPropertyDescriptorModule = __nested_webpack_require_40569__(1236);
        var definePropertyModule = __nested_webpack_require_40569__(3070);
        module.exports = function (target, source) {
          var keys = ownKeys(source);
          var defineProperty = definePropertyModule.f;
          var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
          }
        };

        /***/
      }),
      /***/8544: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_41340__) {
        var fails = __nested_webpack_require_41340__(7293);
        module.exports = !fails(function () {
          function F() {/* empty */}
          F.prototype.constructor = null;
          return Object.getPrototypeOf(new F()) !== F.prototype;
        });

        /***/
      }),
      /***/4994: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_41704__) {
        "use strict";

        var IteratorPrototype = __nested_webpack_require_41704__(3383).IteratorPrototype;
        var create = __nested_webpack_require_41704__(30);
        var createPropertyDescriptor = __nested_webpack_require_41704__(9114);
        var setToStringTag = __nested_webpack_require_41704__(8003);
        var Iterators = __nested_webpack_require_41704__(7497);
        var returnThis = function () {
          return this;
        };
        module.exports = function (IteratorConstructor, NAME, next) {
          var TO_STRING_TAG = NAME + ' Iterator';
          IteratorConstructor.prototype = create(IteratorPrototype, {
            next: createPropertyDescriptor(1, next)
          });
          setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
          Iterators[TO_STRING_TAG] = returnThis;
          return IteratorConstructor;
        };

        /***/
      }),
      /***/8880: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_42640__) {
        var DESCRIPTORS = __nested_webpack_require_42640__(9781);
        var definePropertyModule = __nested_webpack_require_42640__(3070);
        var createPropertyDescriptor = __nested_webpack_require_42640__(9114);
        module.exports = DESCRIPTORS ? function (object, key, value) {
          return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
        } : function (object, key, value) {
          object[key] = value;
          return object;
        };

        /***/
      }),
      /***/9114: (/***/function (module) {
        module.exports = function (bitmap, value) {
          return {
            enumerable: !(bitmap & 1),
            configurable: !(bitmap & 2),
            writable: !(bitmap & 4),
            value: value
          };
        };

        /***/
      }),
      /***/6135: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_43513__) {
        "use strict";

        var toPrimitive = __nested_webpack_require_43513__(7593);
        var definePropertyModule = __nested_webpack_require_43513__(3070);
        var createPropertyDescriptor = __nested_webpack_require_43513__(9114);
        module.exports = function (object, key, value) {
          var propertyKey = toPrimitive(key);
          if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));else object[propertyKey] = value;
        };

        /***/
      }),
      /***/654: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_44096__) {
        "use strict";

        var $ = __nested_webpack_require_44096__(2109);
        var createIteratorConstructor = __nested_webpack_require_44096__(4994);
        var getPrototypeOf = __nested_webpack_require_44096__(9518);
        var setPrototypeOf = __nested_webpack_require_44096__(7674);
        var setToStringTag = __nested_webpack_require_44096__(8003);
        var createNonEnumerableProperty = __nested_webpack_require_44096__(8880);
        var redefine = __nested_webpack_require_44096__(1320);
        var wellKnownSymbol = __nested_webpack_require_44096__(5112);
        var IS_PURE = __nested_webpack_require_44096__(1913);
        var Iterators = __nested_webpack_require_44096__(7497);
        var IteratorsCore = __nested_webpack_require_44096__(3383);
        var IteratorPrototype = IteratorsCore.IteratorPrototype;
        var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
        var ITERATOR = wellKnownSymbol('iterator');
        var KEYS = 'keys';
        var VALUES = 'values';
        var ENTRIES = 'entries';
        var returnThis = function () {
          return this;
        };
        module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
          createIteratorConstructor(IteratorConstructor, NAME, next);
          var getIterationMethod = function (KIND) {
            if (KIND === DEFAULT && defaultIterator) return defaultIterator;
            if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
            switch (KIND) {
              case KEYS:
                return function keys() {
                  return new IteratorConstructor(this, KIND);
                };
              case VALUES:
                return function values() {
                  return new IteratorConstructor(this, KIND);
                };
              case ENTRIES:
                return function entries() {
                  return new IteratorConstructor(this, KIND);
                };
            }
            return function () {
              return new IteratorConstructor(this);
            };
          };
          var TO_STRING_TAG = NAME + ' Iterator';
          var INCORRECT_VALUES_NAME = false;
          var IterablePrototype = Iterable.prototype;
          var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
          var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
          var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
          var CurrentIteratorPrototype, methods, KEY;

          // fix native
          if (anyNativeIterator) {
            CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
            if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
              if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                if (setPrototypeOf) {
                  setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
                  createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
                }
              }
              // Set @@toStringTag to native iterators
              setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
              if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
            }
          }

          // fix Array#{values, @@iterator}.name in V8 / FF
          if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
            INCORRECT_VALUES_NAME = true;
            defaultIterator = function values() {
              return nativeIterator.call(this);
            };
          }

          // define iterator
          if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
            createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
          }
          Iterators[NAME] = defaultIterator;

          // export additional methods
          if (DEFAULT) {
            methods = {
              values: getIterationMethod(VALUES),
              keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
              entries: getIterationMethod(ENTRIES)
            };
            if (FORCED) for (KEY in methods) {
              if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                redefine(IterablePrototype, KEY, methods[KEY]);
              }
            } else $({
              target: NAME,
              proto: true,
              forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
            }, methods);
          }
          return methods;
        };

        /***/
      }),
      /***/9781: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_48980__) {
        var fails = __nested_webpack_require_48980__(7293);

        // Detect IE8's incomplete defineProperty implementation
        module.exports = !fails(function () {
          return Object.defineProperty({}, 1, {
            get: function () {
              return 7;
            }
          })[1] != 7;
        });

        /***/
      }),
      /***/317: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_49404__) {
        var global = __nested_webpack_require_49404__(7854);
        var isObject = __nested_webpack_require_49404__(111);
        var document = global.document;
        // typeof document.createElement is 'object' in old IE
        var EXISTS = isObject(document) && isObject(document.createElement);
        module.exports = function (it) {
          return EXISTS ? document.createElement(it) : {};
        };

        /***/
      }),
      /***/8324: (/***/function (module) {
        // iterable DOM collections
        // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
        module.exports = {
          CSSRuleList: 0,
          CSSStyleDeclaration: 0,
          CSSValueList: 0,
          ClientRectList: 0,
          DOMRectList: 0,
          DOMStringList: 0,
          DOMTokenList: 1,
          DataTransferItemList: 0,
          FileList: 0,
          HTMLAllCollection: 0,
          HTMLCollection: 0,
          HTMLFormElement: 0,
          HTMLSelectElement: 0,
          MediaList: 0,
          MimeTypeArray: 0,
          NamedNodeMap: 0,
          NodeList: 1,
          PaintRequestList: 0,
          Plugin: 0,
          PluginArray: 0,
          SVGLengthList: 0,
          SVGNumberList: 0,
          SVGPathSegList: 0,
          SVGPointList: 0,
          SVGStringList: 0,
          SVGTransformList: 0,
          SourceBufferList: 0,
          StyleSheetList: 0,
          TextTrackCueList: 0,
          TextTrackList: 0,
          TouchList: 0
        };

        /***/
      }),
      /***/8113: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_51008__) {
        var getBuiltIn = __nested_webpack_require_51008__(5005);
        module.exports = getBuiltIn('navigator', 'userAgent') || '';

        /***/
      }),
      /***/7392: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_51244__) {
        var global = __nested_webpack_require_51244__(7854);
        var userAgent = __nested_webpack_require_51244__(8113);
        var process = global.process;
        var versions = process && process.versions;
        var v8 = versions && versions.v8;
        var match, version;
        if (v8) {
          match = v8.split('.');
          version = match[0] + match[1];
        } else if (userAgent) {
          match = userAgent.match(/Edge\/(\d+)/);
          if (!match || match[1] >= 74) {
            match = userAgent.match(/Chrome\/(\d+)/);
            if (match) version = match[1];
          }
        }
        module.exports = version && +version;

        /***/
      }),
      /***/748: (/***/function (module) {
        // IE8- don't enum bug keys
        module.exports = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

        /***/
      }),
      /***/2109: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_52244__) {
        var global = __nested_webpack_require_52244__(7854);
        var getOwnPropertyDescriptor = __nested_webpack_require_52244__(1236).f;
        var createNonEnumerableProperty = __nested_webpack_require_52244__(8880);
        var redefine = __nested_webpack_require_52244__(1320);
        var setGlobal = __nested_webpack_require_52244__(3505);
        var copyConstructorProperties = __nested_webpack_require_52244__(9920);
        var isForced = __nested_webpack_require_52244__(4705);

        /*
          options.target      - name of the target object
          options.global      - target is the global object
          options.stat        - export as static methods of target
          options.proto       - export as prototype methods of target
          options.real        - real prototype method for the `pure` version
          options.forced      - export even if the native feature is available
          options.bind        - bind methods to the target, required for the `pure` version
          options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
          options.unsafe      - use the simple assignment of property instead of delete + defineProperty
          options.sham        - add a flag to not completely full polyfills
          options.enumerable  - export as enumerable property
          options.noTargetGet - prevent calling a getter on target
        */
        module.exports = function (options, source) {
          var TARGET = options.target;
          var GLOBAL = options.global;
          var STATIC = options.stat;
          var FORCED, target, key, targetProperty, sourceProperty, descriptor;
          if (GLOBAL) {
            target = global;
          } else if (STATIC) {
            target = global[TARGET] || setGlobal(TARGET, {});
          } else {
            target = (global[TARGET] || {}).prototype;
          }
          if (target) for (key in source) {
            sourceProperty = source[key];
            if (options.noTargetGet) {
              descriptor = getOwnPropertyDescriptor(target, key);
              targetProperty = descriptor && descriptor.value;
            } else targetProperty = target[key];
            FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
            // contained in target
            if (!FORCED && targetProperty !== undefined) {
              if (typeof sourceProperty === typeof targetProperty) continue;
              copyConstructorProperties(sourceProperty, targetProperty);
            }
            // add a flag to not completely full polyfills
            if (options.sham || targetProperty && targetProperty.sham) {
              createNonEnumerableProperty(sourceProperty, 'sham', true);
            }
            // extend global
            redefine(target, key, sourceProperty, options);
          }
        };

        /***/
      }),
      /***/7293: (/***/function (module) {
        module.exports = function (exec) {
          try {
            return !!exec();
          } catch (error) {
            return true;
          }
        };

        /***/
      }),
      /***/7007: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_55415__) {
        "use strict";

        // TODO: Remove from `core-js@4` since it's moved to entry points
        __nested_webpack_require_55415__(4916);
        var redefine = __nested_webpack_require_55415__(1320);
        var fails = __nested_webpack_require_55415__(7293);
        var wellKnownSymbol = __nested_webpack_require_55415__(5112);
        var regexpExec = __nested_webpack_require_55415__(2261);
        var createNonEnumerableProperty = __nested_webpack_require_55415__(8880);
        var SPECIES = wellKnownSymbol('species');
        var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
          // #replace needs built-in support for named groups.
          // #match works fine because it just return the exec results, even if it has
          // a "grops" property.
          var re = /./;
          re.exec = function () {
            var result = [];
            result.groups = {
              a: '7'
            };
            return result;
          };
          return ''.replace(re, '$<a>') !== '7';
        });

        // IE <= 11 replaces $0 with the whole match, as if it was $&
        // https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
        var REPLACE_KEEPS_$0 = function () {
          return 'a'.replace(/./, '$0') === '$0';
        }();
        var REPLACE = wellKnownSymbol('replace');
        // Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
        var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function () {
          if (/./[REPLACE]) {
            return /./[REPLACE]('a', '$0') === '';
          }
          return false;
        }();

        // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
        // Weex JS has frozen built-in prototypes, so use try / catch wrapper
        var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
          // eslint-disable-next-line regexp/no-empty-group -- required for testing
          var re = /(?:)/;
          var originalExec = re.exec;
          re.exec = function () {
            return originalExec.apply(this, arguments);
          };
          var result = 'ab'.split(re);
          return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
        });
        module.exports = function (KEY, length, exec, sham) {
          var SYMBOL = wellKnownSymbol(KEY);
          var DELEGATES_TO_SYMBOL = !fails(function () {
            // String methods call symbol-named RegEp methods
            var O = {};
            O[SYMBOL] = function () {
              return 7;
            };
            return ''[KEY](O) != 7;
          });
          var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
            // Symbol-named RegExp methods call .exec
            var execCalled = false;
            var re = /a/;
            if (KEY === 'split') {
              // We can't use real regex here since it causes deoptimization
              // and serious performance degradation in V8
              // https://github.com/zloirock/core-js/issues/306
              re = {};
              // RegExp[@@split] doesn't call the regex's exec method, but first creates
              // a new one. We need to return the patched regex when creating the new one.
              re.constructor = {};
              re.constructor[SPECIES] = function () {
                return re;
              };
              re.flags = '';
              re[SYMBOL] = /./[SYMBOL];
            }
            re.exec = function () {
              execCalled = true;
              return null;
            };
            re[SYMBOL]('');
            return !execCalled;
          });
          if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !(REPLACE_SUPPORTS_NAMED_GROUPS && REPLACE_KEEPS_$0 && !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE) || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
            var nativeRegExpMethod = /./[SYMBOL];
            var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
              if (regexp.exec === regexpExec) {
                if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                  // The native String method already delegates to @@method (this
                  // polyfilled function), leasing to infinite recursion.
                  // We avoid it by directly calling the native @@method method.
                  return {
                    done: true,
                    value: nativeRegExpMethod.call(regexp, str, arg2)
                  };
                }
                return {
                  done: true,
                  value: nativeMethod.call(str, regexp, arg2)
                };
              }
              return {
                done: false
              };
            }, {
              REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
              REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
            });
            var stringMethod = methods[0];
            var regexMethod = methods[1];
            redefine(String.prototype, KEY, stringMethod);
            redefine(RegExp.prototype, SYMBOL, length == 2
            // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
            // 21.2.5.11 RegExp.prototype[@@split](string, limit)
            ? function (string, arg) {
              return regexMethod.call(string, this, arg);
            }
            // 21.2.5.6 RegExp.prototype[@@match](string)
            // 21.2.5.9 RegExp.prototype[@@search](string)
            : function (string) {
              return regexMethod.call(string, this);
            });
          }
          if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
        };

        /***/
      }),
      /***/9974: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_61264__) {
        var aFunction = __nested_webpack_require_61264__(3099);

        // optional / simple context binding
        module.exports = function (fn, that, length) {
          aFunction(fn);
          if (that === undefined) return fn;
          switch (length) {
            case 0:
              return function () {
                return fn.call(that);
              };
            case 1:
              return function (a) {
                return fn.call(that, a);
              };
            case 2:
              return function (a, b) {
                return fn.call(that, a, b);
              };
            case 3:
              return function (a, b, c) {
                return fn.call(that, a, b, c);
              };
          }
          return function /* ...args */
          () {
            return fn.apply(that, arguments);
          };
        };

        /***/
      }),
      /***/5005: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_62236__) {
        var path = __nested_webpack_require_62236__(857);
        var global = __nested_webpack_require_62236__(7854);
        var aFunction = function (variable) {
          return typeof variable == 'function' ? variable : undefined;
        };
        module.exports = function (namespace, method) {
          return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace]) : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
        };

        /***/
      }),
      /***/1246: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_62834__) {
        var classof = __nested_webpack_require_62834__(648);
        var Iterators = __nested_webpack_require_62834__(7497);
        var wellKnownSymbol = __nested_webpack_require_62834__(5112);
        var ITERATOR = wellKnownSymbol('iterator');
        module.exports = function (it) {
          if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
        };

        /***/
      }),
      /***/8554: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_63307__) {
        var anObject = __nested_webpack_require_63307__(9670);
        var getIteratorMethod = __nested_webpack_require_63307__(1246);
        module.exports = function (it) {
          var iteratorMethod = getIteratorMethod(it);
          if (typeof iteratorMethod != 'function') {
            throw TypeError(String(it) + ' is not iterable');
          }
          return anObject(iteratorMethod.call(it));
        };

        /***/
      }),
      /***/647: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_63815__) {
        var toObject = __nested_webpack_require_63815__(7908);
        var floor = Math.floor;
        var replace = ''.replace;
        var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
        var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;

        // https://tc39.es/ecma262/#sec-getsubstitution
        module.exports = function (matched, str, position, captures, namedCaptures, replacement) {
          var tailPos = position + matched.length;
          var m = captures.length;
          var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
          if (namedCaptures !== undefined) {
            namedCaptures = toObject(namedCaptures);
            symbols = SUBSTITUTION_SYMBOLS;
          }
          return replace.call(replacement, symbols, function (match, ch) {
            var capture;
            switch (ch.charAt(0)) {
              case '$':
                return '$';
              case '&':
                return matched;
              case '`':
                return str.slice(0, position);
              case "'":
                return str.slice(tailPos);
              case '<':
                capture = namedCaptures[ch.slice(1, -1)];
                break;
              default:
                // \d\d?
                var n = +ch;
                if (n === 0) return match;
                if (n > m) {
                  var f = floor(n / 10);
                  if (f === 0) return match;
                  if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
                  return match;
                }
                capture = captures[n - 1];
            }
            return capture === undefined ? '' : capture;
          });
        };

        /***/
      }),
      /***/7854: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_65653__) {
        var check = function (it) {
          return it && it.Math == Math && it;
        };

        // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
        module.exports = /* global globalThis -- safe */
        check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || check(typeof self == 'object' && self) || check(typeof __nested_webpack_require_65653__.g == 'object' && __nested_webpack_require_65653__.g) ||
        // eslint-disable-next-line no-new-func -- fallback
        function () {
          return this;
        }() || Function('return this')();

        /***/
      }),
      /***/6656: (/***/function (module) {
        var hasOwnProperty = {}.hasOwnProperty;
        module.exports = function (it, key) {
          return hasOwnProperty.call(it, key);
        };

        /***/
      }),
      /***/3501: (/***/function (module) {
        module.exports = {};

        /***/
      }),
      /***/490: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_66688__) {
        var getBuiltIn = __nested_webpack_require_66688__(5005);
        module.exports = getBuiltIn('document', 'documentElement');

        /***/
      }),
      /***/4664: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_66923__) {
        var DESCRIPTORS = __nested_webpack_require_66923__(9781);
        var fails = __nested_webpack_require_66923__(7293);
        var createElement = __nested_webpack_require_66923__(317);

        // Thank's IE8 for his funny defineProperty
        module.exports = !DESCRIPTORS && !fails(function () {
          return Object.defineProperty(createElement('div'), 'a', {
            get: function () {
              return 7;
            }
          }).a != 7;
        });

        /***/
      }),
      /***/1179: (/***/function (module) {
        // IEEE754 conversions based on https://github.com/feross/ieee754
        var abs = Math.abs;
        var pow = Math.pow;
        var floor = Math.floor;
        var log = Math.log;
        var LN2 = Math.LN2;
        var pack = function (number, mantissaLength, bytes) {
          var buffer = new Array(bytes);
          var exponentLength = bytes * 8 - mantissaLength - 1;
          var eMax = (1 << exponentLength) - 1;
          var eBias = eMax >> 1;
          var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
          var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
          var index = 0;
          var exponent, mantissa, c;
          number = abs(number);
          // eslint-disable-next-line no-self-compare -- NaN check
          if (number != number || number === Infinity) {
            // eslint-disable-next-line no-self-compare -- NaN check
            mantissa = number != number ? 1 : 0;
            exponent = eMax;
          } else {
            exponent = floor(log(number) / LN2);
            if (number * (c = pow(2, -exponent)) < 1) {
              exponent--;
              c *= 2;
            }
            if (exponent + eBias >= 1) {
              number += rt / c;
            } else {
              number += rt * pow(2, 1 - eBias);
            }
            if (number * c >= 2) {
              exponent++;
              c /= 2;
            }
            if (exponent + eBias >= eMax) {
              mantissa = 0;
              exponent = eMax;
            } else if (exponent + eBias >= 1) {
              mantissa = (number * c - 1) * pow(2, mantissaLength);
              exponent = exponent + eBias;
            } else {
              mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
              exponent = 0;
            }
          }
          for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);
          exponent = exponent << mantissaLength | mantissa;
          exponentLength += mantissaLength;
          for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);
          buffer[--index] |= sign * 128;
          return buffer;
        };
        var unpack = function (buffer, mantissaLength) {
          var bytes = buffer.length;
          var exponentLength = bytes * 8 - mantissaLength - 1;
          var eMax = (1 << exponentLength) - 1;
          var eBias = eMax >> 1;
          var nBits = exponentLength - 7;
          var index = bytes - 1;
          var sign = buffer[index--];
          var exponent = sign & 127;
          var mantissa;
          sign >>= 7;
          for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);
          mantissa = exponent & (1 << -nBits) - 1;
          exponent >>= -nBits;
          nBits += mantissaLength;
          for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);
          if (exponent === 0) {
            exponent = 1 - eBias;
          } else if (exponent === eMax) {
            return mantissa ? NaN : sign ? -Infinity : Infinity;
          } else {
            mantissa = mantissa + pow(2, mantissaLength);
            exponent = exponent - eBias;
          }
          return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
        };
        module.exports = {
          pack: pack,
          unpack: unpack
        };

        /***/
      }),
      /***/8361: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_70997__) {
        var fails = __nested_webpack_require_70997__(7293);
        var classof = __nested_webpack_require_70997__(4326);
        var split = ''.split;

        // fallback for non-array-like ES3 and non-enumerable old V8 strings
        module.exports = fails(function () {
          // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
          // eslint-disable-next-line no-prototype-builtins -- safe
          return !Object('z').propertyIsEnumerable(0);
        }) ? function (it) {
          return classof(it) == 'String' ? split.call(it, '') : Object(it);
        } : Object;

        /***/
      }),
      /***/9587: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_71696__) {
        var isObject = __nested_webpack_require_71696__(111);
        var setPrototypeOf = __nested_webpack_require_71696__(7674);

        // makes subclassing work correct for wrapped built-ins
        module.exports = function ($this, dummy, Wrapper) {
          var NewTarget, NewTargetPrototype;
          if (
          // it can work only with native `setPrototypeOf`
          setPrototypeOf &&
          // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
          typeof (NewTarget = dummy.constructor) == 'function' && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) setPrototypeOf($this, NewTargetPrototype);
          return $this;
        };

        /***/
      }),
      /***/2788: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_72546__) {
        var store = __nested_webpack_require_72546__(5465);
        var functionToString = Function.toString;

        // this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
        if (typeof store.inspectSource != 'function') {
          store.inspectSource = function (it) {
            return functionToString.call(it);
          };
        }
        module.exports = store.inspectSource;

        /***/
      }),
      /***/9909: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_73058__) {
        var NATIVE_WEAK_MAP = __nested_webpack_require_73058__(8536);
        var global = __nested_webpack_require_73058__(7854);
        var isObject = __nested_webpack_require_73058__(111);
        var createNonEnumerableProperty = __nested_webpack_require_73058__(8880);
        var objectHas = __nested_webpack_require_73058__(6656);
        var shared = __nested_webpack_require_73058__(5465);
        var sharedKey = __nested_webpack_require_73058__(6200);
        var hiddenKeys = __nested_webpack_require_73058__(3501);
        var WeakMap = global.WeakMap;
        var set, get, has;
        var enforce = function (it) {
          return has(it) ? get(it) : set(it, {});
        };
        var getterFor = function (TYPE) {
          return function (it) {
            var state;
            if (!isObject(it) || (state = get(it)).type !== TYPE) {
              throw TypeError('Incompatible receiver, ' + TYPE + ' required');
            }
            return state;
          };
        };
        if (NATIVE_WEAK_MAP) {
          var store = shared.state || (shared.state = new WeakMap());
          var wmget = store.get;
          var wmhas = store.has;
          var wmset = store.set;
          set = function (it, metadata) {
            metadata.facade = it;
            wmset.call(store, it, metadata);
            return metadata;
          };
          get = function (it) {
            return wmget.call(store, it) || {};
          };
          has = function (it) {
            return wmhas.call(store, it);
          };
        } else {
          var STATE = sharedKey('state');
          hiddenKeys[STATE] = true;
          set = function (it, metadata) {
            metadata.facade = it;
            createNonEnumerableProperty(it, STATE, metadata);
            return metadata;
          };
          get = function (it) {
            return objectHas(it, STATE) ? it[STATE] : {};
          };
          has = function (it) {
            return objectHas(it, STATE);
          };
        }
        module.exports = {
          set: set,
          get: get,
          has: has,
          enforce: enforce,
          getterFor: getterFor
        };

        /***/
      }),
      /***/7659: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_75245__) {
        var wellKnownSymbol = __nested_webpack_require_75245__(5112);
        var Iterators = __nested_webpack_require_75245__(7497);
        var ITERATOR = wellKnownSymbol('iterator');
        var ArrayPrototype = Array.prototype;

        // check on default Array iterator
        module.exports = function (it) {
          return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
        };

        /***/
      }),
      /***/3157: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_75760__) {
        var classof = __nested_webpack_require_75760__(4326);

        // `IsArray` abstract operation
        // https://tc39.es/ecma262/#sec-isarray
        module.exports = Array.isArray || function isArray(arg) {
          return classof(arg) == 'Array';
        };

        /***/
      }),
      /***/4705: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_76132__) {
        var fails = __nested_webpack_require_76132__(7293);
        var replacement = /#|\.prototype\./;
        var isForced = function (feature, detection) {
          var value = data[normalize(feature)];
          return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;
        };
        var normalize = isForced.normalize = function (string) {
          return String(string).replace(replacement, '.').toLowerCase();
        };
        var data = isForced.data = {};
        var NATIVE = isForced.NATIVE = 'N';
        var POLYFILL = isForced.POLYFILL = 'P';
        module.exports = isForced;

        /***/
      }),
      /***/111: (/***/function (module) {
        module.exports = function (it) {
          return typeof it === 'object' ? it !== null : typeof it === 'function';
        };

        /***/
      }),
      /***/1913: (/***/function (module) {
        module.exports = false;

        /***/
      }),
      /***/7850: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_77204__) {
        var isObject = __nested_webpack_require_77204__(111);
        var classof = __nested_webpack_require_77204__(4326);
        var wellKnownSymbol = __nested_webpack_require_77204__(5112);
        var MATCH = wellKnownSymbol('match');

        // `IsRegExp` abstract operation
        // https://tc39.es/ecma262/#sec-isregexp
        module.exports = function (it) {
          var isRegExp;
          return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
        };

        /***/
      }),
      /***/9212: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_77799__) {
        var anObject = __nested_webpack_require_77799__(9670);
        module.exports = function (iterator) {
          var returnMethod = iterator['return'];
          if (returnMethod !== undefined) {
            return anObject(returnMethod.call(iterator)).value;
          }
        };

        /***/
      }),
      /***/3383: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_78191__) {
        "use strict";

        var fails = __nested_webpack_require_78191__(7293);
        var getPrototypeOf = __nested_webpack_require_78191__(9518);
        var createNonEnumerableProperty = __nested_webpack_require_78191__(8880);
        var has = __nested_webpack_require_78191__(6656);
        var wellKnownSymbol = __nested_webpack_require_78191__(5112);
        var IS_PURE = __nested_webpack_require_78191__(1913);
        var ITERATOR = wellKnownSymbol('iterator');
        var BUGGY_SAFARI_ITERATORS = false;
        var returnThis = function () {
          return this;
        };

        // `%IteratorPrototype%` object
        // https://tc39.es/ecma262/#sec-%iteratorprototype%-object
        var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
        if ([].keys) {
          arrayIterator = [].keys();
          // Safari 8 has buggy iterators w/o `next`
          if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;else {
            PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
            if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
          }
        }
        var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {
          var test = {};
          // FF44- legacy iterators case
          return IteratorPrototype[ITERATOR].call(test) !== test;
        });
        if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};

        // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
        if ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {
          createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
        }
        module.exports = {
          IteratorPrototype: IteratorPrototype,
          BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
        };

        /***/
      }),
      /***/7497: (/***/function (module) {
        module.exports = {};

        /***/
      }),
      /***/133: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_80216__) {
        var fails = __nested_webpack_require_80216__(7293);
        module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
          // Chrome 38 Symbol has incorrect toString conversion
          /* global Symbol -- required for testing */
          return !String(Symbol());
        });

        /***/
      }),
      /***/590: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_80623__) {
        var fails = __nested_webpack_require_80623__(7293);
        var wellKnownSymbol = __nested_webpack_require_80623__(5112);
        var IS_PURE = __nested_webpack_require_80623__(1913);
        var ITERATOR = wellKnownSymbol('iterator');
        module.exports = !fails(function () {
          var url = new URL('b?a=1&b=2&c=3', 'http://a');
          var searchParams = url.searchParams;
          var result = '';
          url.pathname = 'c%20d';
          searchParams.forEach(function (value, key) {
            searchParams['delete']('b');
            result += key + value;
          });
          return IS_PURE && !url.toJSON || !searchParams.sort || url.href !== 'http://a/c%20d?a=1&c=3' || searchParams.get('c') !== '3' || String(new URLSearchParams('?a=1')) !== 'a=1' || !searchParams[ITERATOR]
          // throws in Edge
          || new URL('https://a@b').username !== 'a' || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'
          // not punycoded in Edge
          || new URL('http://тест').host !== 'xn--e1aybc'
          // not escaped in Chrome 62-
          || new URL('http://a#б').hash !== '#%D0%B1'
          // fails in Chrome 66-
          || result !== 'a1c3'
          // throws in Safari
          || new URL('http://x', undefined).host !== 'x';
        });

        /***/
      }),
      /***/8536: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_82011__) {
        var global = __nested_webpack_require_82011__(7854);
        var inspectSource = __nested_webpack_require_82011__(2788);
        var WeakMap = global.WeakMap;
        module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));

        /***/
      }),
      /***/1574: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_82369__) {
        "use strict";

        var DESCRIPTORS = __nested_webpack_require_82369__(9781);
        var fails = __nested_webpack_require_82369__(7293);
        var objectKeys = __nested_webpack_require_82369__(1956);
        var getOwnPropertySymbolsModule = __nested_webpack_require_82369__(5181);
        var propertyIsEnumerableModule = __nested_webpack_require_82369__(5296);
        var toObject = __nested_webpack_require_82369__(7908);
        var IndexedObject = __nested_webpack_require_82369__(8361);
        var nativeAssign = Object.assign;
        var defineProperty = Object.defineProperty;

        // `Object.assign` method
        // https://tc39.es/ecma262/#sec-object.assign
        module.exports = !nativeAssign || fails(function () {
          // should have correct order of operations (Edge bug)
          if (DESCRIPTORS && nativeAssign({
            b: 1
          }, nativeAssign(defineProperty({}, 'a', {
            enumerable: true,
            get: function () {
              defineProperty(this, 'b', {
                value: 3,
                enumerable: false
              });
            }
          }), {
            b: 2
          })).b !== 1) return true;
          // should work with symbols and should have deterministic property order (V8 bug)
          var A = {};
          var B = {};
          /* global Symbol -- required for testing */
          var symbol = Symbol();
          var alphabet = 'abcdefghijklmnopqrst';
          A[symbol] = 7;
          alphabet.split('').forEach(function (chr) {
            B[chr] = chr;
          });
          return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
        }) ? function assign(target, source) {
          // eslint-disable-line no-unused-vars -- required for `.length`
          var T = toObject(target);
          var argumentsLength = arguments.length;
          var index = 1;
          var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
          var propertyIsEnumerable = propertyIsEnumerableModule.f;
          while (argumentsLength > index) {
            var S = IndexedObject(arguments[index++]);
            var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
            var length = keys.length;
            var j = 0;
            var key;
            while (length > j) {
              key = keys[j++];
              if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];
            }
          }
          return T;
        } : nativeAssign;

        /***/
      }),
      /***/30: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_84965__) {
        var anObject = __nested_webpack_require_84965__(9670);
        var defineProperties = __nested_webpack_require_84965__(6048);
        var enumBugKeys = __nested_webpack_require_84965__(748);
        var hiddenKeys = __nested_webpack_require_84965__(3501);
        var html = __nested_webpack_require_84965__(490);
        var documentCreateElement = __nested_webpack_require_84965__(317);
        var sharedKey = __nested_webpack_require_84965__(6200);
        var GT = '>';
        var LT = '<';
        var PROTOTYPE = 'prototype';
        var SCRIPT = 'script';
        var IE_PROTO = sharedKey('IE_PROTO');
        var EmptyConstructor = function () {/* empty */};
        var scriptTag = function (content) {
          return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
        };

        // Create object with fake `null` prototype: use ActiveX Object with cleared prototype
        var NullProtoObjectViaActiveX = function (activeXDocument) {
          activeXDocument.write(scriptTag(''));
          activeXDocument.close();
          var temp = activeXDocument.parentWindow.Object;
          activeXDocument = null; // avoid memory leak
          return temp;
        };

        // Create object with fake `null` prototype: use iframe Object with cleared prototype
        var NullProtoObjectViaIFrame = function () {
          // Thrash, waste and sodomy: IE GC bug
          var iframe = documentCreateElement('iframe');
          var JS = 'java' + SCRIPT + ':';
          var iframeDocument;
          iframe.style.display = 'none';
          html.appendChild(iframe);
          // https://github.com/zloirock/core-js/issues/475
          iframe.src = String(JS);
          iframeDocument = iframe.contentWindow.document;
          iframeDocument.open();
          iframeDocument.write(scriptTag('document.F=Object'));
          iframeDocument.close();
          return iframeDocument.F;
        };

        // Check for document.domain and active x support
        // No need to use active x approach when document.domain is not set
        // see https://github.com/es-shims/es5-shim/issues/150
        // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
        // avoid IE GC bug
        var activeXDocument;
        var NullProtoObject = function () {
          try {
            /* global ActiveXObject -- old IE */
            activeXDocument = document.domain && new ActiveXObject('htmlfile');
          } catch (error) {/* ignore */}
          NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
          var length = enumBugKeys.length;
          while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
          return NullProtoObject();
        };
        hiddenKeys[IE_PROTO] = true;

        // `Object.create` method
        // https://tc39.es/ecma262/#sec-object.create
        module.exports = Object.create || function create(O, Properties) {
          var result;
          if (O !== null) {
            EmptyConstructor[PROTOTYPE] = anObject(O);
            result = new EmptyConstructor();
            EmptyConstructor[PROTOTYPE] = null;
            // add "__proto__" for Object.getPrototypeOf polyfill
            result[IE_PROTO] = O;
          } else result = NullProtoObject();
          return Properties === undefined ? result : defineProperties(result, Properties);
        };

        /***/
      }),
      /***/6048: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_88427__) {
        var DESCRIPTORS = __nested_webpack_require_88427__(9781);
        var definePropertyModule = __nested_webpack_require_88427__(3070);
        var anObject = __nested_webpack_require_88427__(9670);
        var objectKeys = __nested_webpack_require_88427__(1956);

        // `Object.defineProperties` method
        // https://tc39.es/ecma262/#sec-object.defineproperties
        module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
          anObject(O);
          var keys = objectKeys(Properties);
          var length = keys.length;
          var index = 0;
          var key;
          while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);
          return O;
        };

        /***/
      }),
      /***/3070: (/***/function (__unused_webpack_module, exports, __nested_webpack_require_89253__) {
        var DESCRIPTORS = __nested_webpack_require_89253__(9781);
        var IE8_DOM_DEFINE = __nested_webpack_require_89253__(4664);
        var anObject = __nested_webpack_require_89253__(9670);
        var toPrimitive = __nested_webpack_require_89253__(7593);
        var nativeDefineProperty = Object.defineProperty;

        // `Object.defineProperty` method
        // https://tc39.es/ecma262/#sec-object.defineproperty
        exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
          anObject(O);
          P = toPrimitive(P, true);
          anObject(Attributes);
          if (IE8_DOM_DEFINE) try {
            return nativeDefineProperty(O, P, Attributes);
          } catch (error) {/* empty */}
          if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
          if ('value' in Attributes) O[P] = Attributes.value;
          return O;
        };

        /***/
      }),
      /***/1236: (/***/function (__unused_webpack_module, exports, __nested_webpack_require_90265__) {
        var DESCRIPTORS = __nested_webpack_require_90265__(9781);
        var propertyIsEnumerableModule = __nested_webpack_require_90265__(5296);
        var createPropertyDescriptor = __nested_webpack_require_90265__(9114);
        var toIndexedObject = __nested_webpack_require_90265__(5656);
        var toPrimitive = __nested_webpack_require_90265__(7593);
        var has = __nested_webpack_require_90265__(6656);
        var IE8_DOM_DEFINE = __nested_webpack_require_90265__(4664);
        var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

        // `Object.getOwnPropertyDescriptor` method
        // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
        exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
          O = toIndexedObject(O);
          P = toPrimitive(P, true);
          if (IE8_DOM_DEFINE) try {
            return nativeGetOwnPropertyDescriptor(O, P);
          } catch (error) {/* empty */}
          if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
        };

        /***/
      }),
      /***/8006: (/***/function (__unused_webpack_module, exports, __nested_webpack_require_91410__) {
        var internalObjectKeys = __nested_webpack_require_91410__(6324);
        var enumBugKeys = __nested_webpack_require_91410__(748);
        var hiddenKeys = enumBugKeys.concat('length', 'prototype');

        // `Object.getOwnPropertyNames` method
        // https://tc39.es/ecma262/#sec-object.getownpropertynames
        exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
          return internalObjectKeys(O, hiddenKeys);
        };

        /***/
      }),
      /***/5181: (/***/function (__unused_webpack_module, exports) {
        exports.f = Object.getOwnPropertySymbols;

        /***/
      }),
      /***/9518: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_92111__) {
        var has = __nested_webpack_require_92111__(6656);
        var toObject = __nested_webpack_require_92111__(7908);
        var sharedKey = __nested_webpack_require_92111__(6200);
        var CORRECT_PROTOTYPE_GETTER = __nested_webpack_require_92111__(8544);
        var IE_PROTO = sharedKey('IE_PROTO');
        var ObjectPrototype = Object.prototype;

        // `Object.getPrototypeOf` method
        // https://tc39.es/ecma262/#sec-object.getprototypeof
        module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
          O = toObject(O);
          if (has(O, IE_PROTO)) return O[IE_PROTO];
          if (typeof O.constructor == 'function' && O instanceof O.constructor) {
            return O.constructor.prototype;
          }
          return O instanceof Object ? ObjectPrototype : null;
        };

        /***/
      }),
      /***/6324: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_93019__) {
        var has = __nested_webpack_require_93019__(6656);
        var toIndexedObject = __nested_webpack_require_93019__(5656);
        var indexOf = __nested_webpack_require_93019__(1318).indexOf;
        var hiddenKeys = __nested_webpack_require_93019__(3501);
        module.exports = function (object, names) {
          var O = toIndexedObject(object);
          var i = 0;
          var result = [];
          var key;
          for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
          // Don't enum bug & hidden keys
          while (names.length > i) if (has(O, key = names[i++])) {
            ~indexOf(result, key) || result.push(key);
          }
          return result;
        };

        /***/
      }),
      /***/1956: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_93802__) {
        var internalObjectKeys = __nested_webpack_require_93802__(6324);
        var enumBugKeys = __nested_webpack_require_93802__(748);

        // `Object.keys` method
        // https://tc39.es/ecma262/#sec-object.keys
        module.exports = Object.keys || function keys(O) {
          return internalObjectKeys(O, enumBugKeys);
        };

        /***/
      }),
      /***/5296: (/***/function (__unused_webpack_module, exports) {
        "use strict";

        var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

        // Nashorn ~ JDK8 bug
        var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({
          1: 2
        }, 1);

        // `Object.prototype.propertyIsEnumerable` method implementation
        // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
        exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
          var descriptor = getOwnPropertyDescriptor(this, V);
          return !!descriptor && descriptor.enumerable;
        } : nativePropertyIsEnumerable;

        /***/
      }),
      /***/7674: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_95021__) {
        /* eslint-disable no-proto -- safe */
        var anObject = __nested_webpack_require_95021__(9670);
        var aPossiblePrototype = __nested_webpack_require_95021__(6077);

        // `Object.setPrototypeOf` method
        // https://tc39.es/ecma262/#sec-object.setprototypeof
        // Works with __proto__ only. Old v8 can't work with null proto objects.
        module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
          var CORRECT_SETTER = false;
          var test = {};
          var setter;
          try {
            setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
            setter.call(test, []);
            CORRECT_SETTER = test instanceof Array;
          } catch (error) {/* empty */}
          return function setPrototypeOf(O, proto) {
            anObject(O);
            aPossiblePrototype(proto);
            if (CORRECT_SETTER) setter.call(O, proto);else O.__proto__ = proto;
            return O;
          };
        }() : undefined);

        /***/
      }),
      /***/288: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_96137__) {
        "use strict";

        var TO_STRING_TAG_SUPPORT = __nested_webpack_require_96137__(1694);
        var classof = __nested_webpack_require_96137__(648);

        // `Object.prototype.toString` method implementation
        // https://tc39.es/ecma262/#sec-object.prototype.tostring
        module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
          return '[object ' + classof(this) + ']';
        };

        /***/
      }),
      /***/3887: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_96661__) {
        var getBuiltIn = __nested_webpack_require_96661__(5005);
        var getOwnPropertyNamesModule = __nested_webpack_require_96661__(8006);
        var getOwnPropertySymbolsModule = __nested_webpack_require_96661__(5181);
        var anObject = __nested_webpack_require_96661__(9670);

        // all object keys, includes non-enumerable and symbols
        module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
          var keys = getOwnPropertyNamesModule.f(anObject(it));
          var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
          return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
        };

        /***/
      }),
      /***/857: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_97394__) {
        var global = __nested_webpack_require_97394__(7854);
        module.exports = global;

        /***/
      }),
      /***/2248: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_97590__) {
        var redefine = __nested_webpack_require_97590__(1320);
        module.exports = function (target, src, options) {
          for (var key in src) redefine(target, key, src[key], options);
          return target;
        };

        /***/
      }),
      /***/1320: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_97923__) {
        var global = __nested_webpack_require_97923__(7854);
        var createNonEnumerableProperty = __nested_webpack_require_97923__(8880);
        var has = __nested_webpack_require_97923__(6656);
        var setGlobal = __nested_webpack_require_97923__(3505);
        var inspectSource = __nested_webpack_require_97923__(2788);
        var InternalStateModule = __nested_webpack_require_97923__(9909);
        var getInternalState = InternalStateModule.get;
        var enforceInternalState = InternalStateModule.enforce;
        var TEMPLATE = String(String).split('String');
        (module.exports = function (O, key, value, options) {
          var unsafe = options ? !!options.unsafe : false;
          var simple = options ? !!options.enumerable : false;
          var noTargetGet = options ? !!options.noTargetGet : false;
          var state;
          if (typeof value == 'function') {
            if (typeof key == 'string' && !has(value, 'name')) {
              createNonEnumerableProperty(value, 'name', key);
            }
            state = enforceInternalState(value);
            if (!state.source) {
              state.source = TEMPLATE.join(typeof key == 'string' ? key : '');
            }
          }
          if (O === global) {
            if (simple) O[key] = value;else setGlobal(key, value);
            return;
          } else if (!unsafe) {
            delete O[key];
          } else if (!noTargetGet && O[key]) {
            simple = true;
          }
          if (simple) O[key] = value;else createNonEnumerableProperty(O, key, value);
          // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
        })(Function.prototype, 'toString', function toString() {
          return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
        });

        /***/
      }),
      /***/7651: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_99836__) {
        var classof = __nested_webpack_require_99836__(4326);
        var regexpExec = __nested_webpack_require_99836__(2261);

        // `RegExpExec` abstract operation
        // https://tc39.es/ecma262/#sec-regexpexec
        module.exports = function (R, S) {
          var exec = R.exec;
          if (typeof exec === 'function') {
            var result = exec.call(R, S);
            if (typeof result !== 'object') {
              throw TypeError('RegExp exec method returned something other than an Object or null');
            }
            return result;
          }
          if (classof(R) !== 'RegExp') {
            throw TypeError('RegExp#exec called on incompatible receiver');
          }
          return regexpExec.call(R, S);
        };

        /***/
      }),
      /***/2261: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_100685__) {
        "use strict";

        var regexpFlags = __nested_webpack_require_100685__(7066);
        var stickyHelpers = __nested_webpack_require_100685__(2999);
        var nativeExec = RegExp.prototype.exec;
        // This always refers to the native implementation, because the
        // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
        // which loads this file before patching the method.
        var nativeReplace = String.prototype.replace;
        var patchedExec = nativeExec;
        var UPDATES_LAST_INDEX_WRONG = function () {
          var re1 = /a/;
          var re2 = /b*/g;
          nativeExec.call(re1, 'a');
          nativeExec.call(re2, 'a');
          return re1.lastIndex !== 0 || re2.lastIndex !== 0;
        }();
        var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;

        // nonparticipating capturing group, copied from es5-shim's String#split patch.
        // eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group -- required for testing
        var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
        var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;
        if (PATCH) {
          patchedExec = function exec(str) {
            var re = this;
            var lastIndex, reCopy, match, i;
            var sticky = UNSUPPORTED_Y && re.sticky;
            var flags = regexpFlags.call(re);
            var source = re.source;
            var charsAdded = 0;
            var strCopy = str;
            if (sticky) {
              flags = flags.replace('y', '');
              if (flags.indexOf('g') === -1) {
                flags += 'g';
              }
              strCopy = String(str).slice(re.lastIndex);
              // Support anchored sticky behavior.
              if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
                source = '(?: ' + source + ')';
                strCopy = ' ' + strCopy;
                charsAdded++;
              }
              // ^(? + rx + ) is needed, in combination with some str slicing, to
              // simulate the 'y' flag.
              reCopy = new RegExp('^(?:' + source + ')', flags);
            }
            if (NPCG_INCLUDED) {
              reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
            }
            if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
            match = nativeExec.call(sticky ? reCopy : re, strCopy);
            if (sticky) {
              if (match) {
                match.input = match.input.slice(charsAdded);
                match[0] = match[0].slice(charsAdded);
                match.index = re.lastIndex;
                re.lastIndex += match[0].length;
              } else re.lastIndex = 0;
            } else if (UPDATES_LAST_INDEX_WRONG && match) {
              re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
            }
            if (NPCG_INCLUDED && match && match.length > 1) {
              // Fix browsers whose `exec` methods don't consistently return `undefined`
              // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
              nativeReplace.call(match[0], reCopy, function () {
                for (i = 1; i < arguments.length - 2; i++) {
                  if (arguments[i] === undefined) match[i] = undefined;
                }
              });
            }
            return match;
          };
        }
        module.exports = patchedExec;

        /***/
      }),
      /***/7066: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_104296__) {
        "use strict";

        var anObject = __nested_webpack_require_104296__(9670);

        // `RegExp.prototype.flags` getter implementation
        // https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
        module.exports = function () {
          var that = anObject(this);
          var result = '';
          if (that.global) result += 'g';
          if (that.ignoreCase) result += 'i';
          if (that.multiline) result += 'm';
          if (that.dotAll) result += 's';
          if (that.unicode) result += 'u';
          if (that.sticky) result += 'y';
          return result;
        };

        /***/
      }),
      /***/2999: (/***/function (__unused_webpack_module, exports, __nested_webpack_require_105009__) {
        "use strict";

        var fails = __nested_webpack_require_105009__(7293);

        // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
        // so we use an intermediate function.
        function RE(s, f) {
          return RegExp(s, f);
        }
        exports.UNSUPPORTED_Y = fails(function () {
          // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
          var re = RE('a', 'y');
          re.lastIndex = 2;
          return re.exec('abcd') != null;
        });
        exports.BROKEN_CARET = fails(function () {
          // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
          var re = RE('^r', 'gy');
          re.lastIndex = 2;
          return re.exec('str') != null;
        });

        /***/
      }),
      /***/4488: (/***/function (module) {
        // `RequireObjectCoercible` abstract operation
        // https://tc39.es/ecma262/#sec-requireobjectcoercible
        module.exports = function (it) {
          if (it == undefined) throw TypeError("Can't call method on " + it);
          return it;
        };

        /***/
      }),
      /***/3505: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_106222__) {
        var global = __nested_webpack_require_106222__(7854);
        var createNonEnumerableProperty = __nested_webpack_require_106222__(8880);
        module.exports = function (key, value) {
          try {
            createNonEnumerableProperty(global, key, value);
          } catch (error) {
            global[key] = value;
          }
          return value;
        };

        /***/
      }),
      /***/6340: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_106688__) {
        "use strict";

        var getBuiltIn = __nested_webpack_require_106688__(5005);
        var definePropertyModule = __nested_webpack_require_106688__(3070);
        var wellKnownSymbol = __nested_webpack_require_106688__(5112);
        var DESCRIPTORS = __nested_webpack_require_106688__(9781);
        var SPECIES = wellKnownSymbol('species');
        module.exports = function (CONSTRUCTOR_NAME) {
          var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
          var defineProperty = definePropertyModule.f;
          if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
            defineProperty(Constructor, SPECIES, {
              configurable: true,
              get: function () {
                return this;
              }
            });
          }
        };

        /***/
      }),
      /***/8003: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_107539__) {
        var defineProperty = __nested_webpack_require_107539__(3070).f;
        var has = __nested_webpack_require_107539__(6656);
        var wellKnownSymbol = __nested_webpack_require_107539__(5112);
        var TO_STRING_TAG = wellKnownSymbol('toStringTag');
        module.exports = function (it, TAG, STATIC) {
          if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
            defineProperty(it, TO_STRING_TAG, {
              configurable: true,
              value: TAG
            });
          }
        };

        /***/
      }),
      /***/6200: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_108150__) {
        var shared = __nested_webpack_require_108150__(2309);
        var uid = __nested_webpack_require_108150__(9711);
        var keys = shared('keys');
        module.exports = function (key) {
          return keys[key] || (keys[key] = uid(key));
        };

        /***/
      }),
      /***/5465: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_108500__) {
        var global = __nested_webpack_require_108500__(7854);
        var setGlobal = __nested_webpack_require_108500__(3505);
        var SHARED = '__core-js_shared__';
        var store = global[SHARED] || setGlobal(SHARED, {});
        module.exports = store;

        /***/
      }),
      /***/2309: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_108850__) {
        var IS_PURE = __nested_webpack_require_108850__(1913);
        var store = __nested_webpack_require_108850__(5465);
        (module.exports = function (key, value) {
          return store[key] || (store[key] = value !== undefined ? value : {});
        })('versions', []).push({
          version: '3.9.0',
          mode: IS_PURE ? 'pure' : 'global',
          copyright: '© 2021 Denis Pushkarev (zloirock.ru)'
        });

        /***/
      }),
      /***/6707: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_109370__) {
        var anObject = __nested_webpack_require_109370__(9670);
        var aFunction = __nested_webpack_require_109370__(3099);
        var wellKnownSymbol = __nested_webpack_require_109370__(5112);
        var SPECIES = wellKnownSymbol('species');

        // `SpeciesConstructor` abstract operation
        // https://tc39.es/ecma262/#sec-speciesconstructor
        module.exports = function (O, defaultConstructor) {
          var C = anObject(O).constructor;
          var S;
          return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
        };

        /***/
      }),
      /***/8710: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_110048__) {
        var toInteger = __nested_webpack_require_110048__(9958);
        var requireObjectCoercible = __nested_webpack_require_110048__(4488);

        // `String.prototype.{ codePointAt, at }` methods implementation
        var createMethod = function (CONVERT_TO_STRING) {
          return function ($this, pos) {
            var S = String(requireObjectCoercible($this));
            var position = toInteger(pos);
            var size = S.length;
            var first, second;
            if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
            first = S.charCodeAt(position);
            return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
          };
        };
        module.exports = {
          // `String.prototype.codePointAt` method
          // https://tc39.es/ecma262/#sec-string.prototype.codepointat
          codeAt: createMethod(false),
          // `String.prototype.at` method
          // https://github.com/mathiasbynens/String.prototype.at
          charAt: createMethod(true)
        };

        /***/
      }),
      /***/3197: (/***/function (module) {
        "use strict";

        // based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
        var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
        var base = 36;
        var tMin = 1;
        var tMax = 26;
        var skew = 38;
        var damp = 700;
        var initialBias = 72;
        var initialN = 128; // 0x80
        var delimiter = '-'; // '\x2D'
        var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars
        var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
        var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
        var baseMinusTMin = base - tMin;
        var floor = Math.floor;
        var stringFromCharCode = String.fromCharCode;

        /**
         * Creates an array containing the numeric code points of each Unicode
         * character in the string. While JavaScript uses UCS-2 internally,
         * this function will convert a pair of surrogate halves (each of which
         * UCS-2 exposes as separate characters) into a single code point,
         * matching UTF-16.
         */
        var ucs2decode = function (string) {
          var output = [];
          var counter = 0;
          var length = string.length;
          while (counter < length) {
            var value = string.charCodeAt(counter++);
            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
              // It's a high surrogate, and there is a next character.
              var extra = string.charCodeAt(counter++);
              if ((extra & 0xFC00) == 0xDC00) {
                // Low surrogate.
                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
              } else {
                // It's an unmatched surrogate; only append this code unit, in case the
                // next code unit is the high surrogate of a surrogate pair.
                output.push(value);
                counter--;
              }
            } else {
              output.push(value);
            }
          }
          return output;
        };

        /**
         * Converts a digit/integer into a basic code point.
         */
        var digitToBasic = function (digit) {
          //  0..25 map to ASCII a..z or A..Z
          // 26..35 map to ASCII 0..9
          return digit + 22 + 75 * (digit < 26);
        };

        /**
         * Bias adaptation function as per section 3.4 of RFC 3492.
         * https://tools.ietf.org/html/rfc3492#section-3.4
         */
        var adapt = function (delta, numPoints, firstTime) {
          var k = 0;
          delta = firstTime ? floor(delta / damp) : delta >> 1;
          delta += floor(delta / numPoints);
          for (; delta > baseMinusTMin * tMax >> 1; k += base) {
            delta = floor(delta / baseMinusTMin);
          }
          return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
        };

        /**
         * Converts a string of Unicode symbols (e.g. a domain name label) to a
         * Punycode string of ASCII-only symbols.
         */
        // eslint-disable-next-line max-statements -- TODO
        var encode = function (input) {
          var output = [];

          // Convert the input in UCS-2 to an array of Unicode code points.
          input = ucs2decode(input);

          // Cache the length.
          var inputLength = input.length;

          // Initialize the state.
          var n = initialN;
          var delta = 0;
          var bias = initialBias;
          var i, currentValue;

          // Handle the basic code points.
          for (i = 0; i < input.length; i++) {
            currentValue = input[i];
            if (currentValue < 0x80) {
              output.push(stringFromCharCode(currentValue));
            }
          }
          var basicLength = output.length; // number of basic code points.
          var handledCPCount = basicLength; // number of code points that have been handled;

          // Finish the basic string with a delimiter unless it's empty.
          if (basicLength) {
            output.push(delimiter);
          }

          // Main encoding loop:
          while (handledCPCount < inputLength) {
            // All non-basic code points < n have been handled already. Find the next larger one:
            var m = maxInt;
            for (i = 0; i < input.length; i++) {
              currentValue = input[i];
              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }

            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
            var handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
              throw RangeError(OVERFLOW_ERROR);
            }
            delta += (m - n) * handledCPCountPlusOne;
            n = m;
            for (i = 0; i < input.length; i++) {
              currentValue = input[i];
              if (currentValue < n && ++delta > maxInt) {
                throw RangeError(OVERFLOW_ERROR);
              }
              if (currentValue == n) {
                // Represent delta as a generalized variable-length integer.
                var q = delta;
                for /* no condition */
                (var k = base;; k += base) {
                  var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q < t) break;
                  var qMinusT = q - t;
                  var baseMinusT = base - t;
                  output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
                  q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
            ++delta;
            ++n;
          }
          return output.join('');
        };
        module.exports = function (input) {
          var encoded = [];
          var labels = input.toLowerCase().replace(regexSeparators, '\u002E').split('.');
          var i, label;
          for (i = 0; i < labels.length; i++) {
            label = labels[i];
            encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);
          }
          return encoded.join('.');
        };

        /***/
      }),
      /***/6091: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_117962__) {
        var fails = __nested_webpack_require_117962__(7293);
        var whitespaces = __nested_webpack_require_117962__(1361);
        var non = '\u200B\u0085\u180E';

        // check that a method works with the correct list
        // of whitespaces and has a correct name
        module.exports = function (METHOD_NAME) {
          return fails(function () {
            return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
          });
        };

        /***/
      }),
      /***/3111: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_118565__) {
        var requireObjectCoercible = __nested_webpack_require_118565__(4488);
        var whitespaces = __nested_webpack_require_118565__(1361);
        var whitespace = '[' + whitespaces + ']';
        var ltrim = RegExp('^' + whitespace + whitespace + '*');
        var rtrim = RegExp(whitespace + whitespace + '*$');

        // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
        var createMethod = function (TYPE) {
          return function ($this) {
            var string = String(requireObjectCoercible($this));
            if (TYPE & 1) string = string.replace(ltrim, '');
            if (TYPE & 2) string = string.replace(rtrim, '');
            return string;
          };
        };
        module.exports = {
          // `String.prototype.{ trimLeft, trimStart }` methods
          // https://tc39.es/ecma262/#sec-string.prototype.trimstart
          start: createMethod(1),
          // `String.prototype.{ trimRight, trimEnd }` methods
          // https://tc39.es/ecma262/#sec-string.prototype.trimend
          end: createMethod(2),
          // `String.prototype.trim` method
          // https://tc39.es/ecma262/#sec-string.prototype.trim
          trim: createMethod(3)
        };

        /***/
      }),
      /***/1400: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_119903__) {
        var toInteger = __nested_webpack_require_119903__(9958);
        var max = Math.max;
        var min = Math.min;

        // Helper for a popular repeating case of the spec:
        // Let integer be ? ToInteger(index).
        // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
        module.exports = function (index, length) {
          var integer = toInteger(index);
          return integer < 0 ? max(integer + length, 0) : min(integer, length);
        };

        /***/
      }),
      /***/7067: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_120527__) {
        var toInteger = __nested_webpack_require_120527__(9958);
        var toLength = __nested_webpack_require_120527__(7466);

        // `ToIndex` abstract operation
        // https://tc39.es/ecma262/#sec-toindex
        module.exports = function (it) {
          if (it === undefined) return 0;
          var number = toInteger(it);
          var length = toLength(number);
          if (number !== length) throw RangeError('Wrong length or index');
          return length;
        };

        /***/
      }),
      /***/5656: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_121106__) {
        // toObject with fallback for non-array-like ES3 strings
        var IndexedObject = __nested_webpack_require_121106__(8361);
        var requireObjectCoercible = __nested_webpack_require_121106__(4488);
        module.exports = function (it) {
          return IndexedObject(requireObjectCoercible(it));
        };

        /***/
      }),
      /***/9958: (/***/function (module) {
        var ceil = Math.ceil;
        var floor = Math.floor;

        // `ToInteger` abstract operation
        // https://tc39.es/ecma262/#sec-tointeger
        module.exports = function (argument) {
          return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
        };

        /***/
      }),
      /***/7466: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_121890__) {
        var toInteger = __nested_webpack_require_121890__(9958);
        var min = Math.min;

        // `ToLength` abstract operation
        // https://tc39.es/ecma262/#sec-tolength
        module.exports = function (argument) {
          return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
        };

        /***/
      }),
      /***/7908: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_122348__) {
        var requireObjectCoercible = __nested_webpack_require_122348__(4488);

        // `ToObject` abstract operation
        // https://tc39.es/ecma262/#sec-toobject
        module.exports = function (argument) {
          return Object(requireObjectCoercible(argument));
        };

        /***/
      }),
      /***/4590: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_122735__) {
        var toPositiveInteger = __nested_webpack_require_122735__(3002);
        module.exports = function (it, BYTES) {
          var offset = toPositiveInteger(it);
          if (offset % BYTES) throw RangeError('Wrong offset');
          return offset;
        };

        /***/
      }),
      /***/3002: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_123103__) {
        var toInteger = __nested_webpack_require_123103__(9958);
        module.exports = function (it) {
          var result = toInteger(it);
          if (result < 0) throw RangeError("The argument can't be less than 0");
          return result;
        };

        /***/
      }),
      /***/7593: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_123465__) {
        var isObject = __nested_webpack_require_123465__(111);

        // `ToPrimitive` abstract operation
        // https://tc39.es/ecma262/#sec-toprimitive
        // instead of the ES6 spec version, we didn't implement @@toPrimitive case
        // and the second argument - flag - preferred type is a string
        module.exports = function (input, PREFERRED_STRING) {
          if (!isObject(input)) return input;
          var fn, val;
          if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
          if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
          if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
          throw TypeError("Can't convert object to primitive value");
        };

        /***/
      }),
      /***/1694: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_124447__) {
        var wellKnownSymbol = __nested_webpack_require_124447__(5112);
        var TO_STRING_TAG = wellKnownSymbol('toStringTag');
        var test = {};
        test[TO_STRING_TAG] = 'z';
        module.exports = String(test) === '[object z]';

        /***/
      }),
      /***/9843: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_124793__) {
        "use strict";

        var $ = __nested_webpack_require_124793__(2109);
        var global = __nested_webpack_require_124793__(7854);
        var DESCRIPTORS = __nested_webpack_require_124793__(9781);
        var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __nested_webpack_require_124793__(3832);
        var ArrayBufferViewCore = __nested_webpack_require_124793__(260);
        var ArrayBufferModule = __nested_webpack_require_124793__(3331);
        var anInstance = __nested_webpack_require_124793__(5787);
        var createPropertyDescriptor = __nested_webpack_require_124793__(9114);
        var createNonEnumerableProperty = __nested_webpack_require_124793__(8880);
        var toLength = __nested_webpack_require_124793__(7466);
        var toIndex = __nested_webpack_require_124793__(7067);
        var toOffset = __nested_webpack_require_124793__(4590);
        var toPrimitive = __nested_webpack_require_124793__(7593);
        var has = __nested_webpack_require_124793__(6656);
        var classof = __nested_webpack_require_124793__(648);
        var isObject = __nested_webpack_require_124793__(111);
        var create = __nested_webpack_require_124793__(30);
        var setPrototypeOf = __nested_webpack_require_124793__(7674);
        var getOwnPropertyNames = __nested_webpack_require_124793__(8006).f;
        var typedArrayFrom = __nested_webpack_require_124793__(7321);
        var forEach = __nested_webpack_require_124793__(2092).forEach;
        var setSpecies = __nested_webpack_require_124793__(6340);
        var definePropertyModule = __nested_webpack_require_124793__(3070);
        var getOwnPropertyDescriptorModule = __nested_webpack_require_124793__(1236);
        var InternalStateModule = __nested_webpack_require_124793__(9909);
        var inheritIfRequired = __nested_webpack_require_124793__(9587);
        var getInternalState = InternalStateModule.get;
        var setInternalState = InternalStateModule.set;
        var nativeDefineProperty = definePropertyModule.f;
        var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
        var round = Math.round;
        var RangeError = global.RangeError;
        var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
        var DataView = ArrayBufferModule.DataView;
        var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
        var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
        var TypedArray = ArrayBufferViewCore.TypedArray;
        var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
        var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
        var isTypedArray = ArrayBufferViewCore.isTypedArray;
        var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
        var WRONG_LENGTH = 'Wrong length';
        var fromList = function (C, list) {
          var index = 0;
          var length = list.length;
          var result = new (aTypedArrayConstructor(C))(length);
          while (length > index) result[index] = list[index++];
          return result;
        };
        var addGetter = function (it, key) {
          nativeDefineProperty(it, key, {
            get: function () {
              return getInternalState(this)[key];
            }
          });
        };
        var isArrayBuffer = function (it) {
          var klass;
          return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
        };
        var isTypedArrayIndex = function (target, key) {
          return isTypedArray(target) && typeof key != 'symbol' && key in target && String(+key) == String(key);
        };
        var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
          return isTypedArrayIndex(target, key = toPrimitive(key, true)) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
        };
        var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
          if (isTypedArrayIndex(target, key = toPrimitive(key, true)) && isObject(descriptor) && has(descriptor, 'value') && !has(descriptor, 'get') && !has(descriptor, 'set')
          // TODO: add validation descriptor w/o calling accessors
          && !descriptor.configurable && (!has(descriptor, 'writable') || descriptor.writable) && (!has(descriptor, 'enumerable') || descriptor.enumerable)) {
            target[key] = descriptor.value;
            return target;
          }
          return nativeDefineProperty(target, key, descriptor);
        };
        if (DESCRIPTORS) {
          if (!NATIVE_ARRAY_BUFFER_VIEWS) {
            getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
            definePropertyModule.f = wrappedDefineProperty;
            addGetter(TypedArrayPrototype, 'buffer');
            addGetter(TypedArrayPrototype, 'byteOffset');
            addGetter(TypedArrayPrototype, 'byteLength');
            addGetter(TypedArrayPrototype, 'length');
          }
          $({
            target: 'Object',
            stat: true,
            forced: !NATIVE_ARRAY_BUFFER_VIEWS
          }, {
            getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
            defineProperty: wrappedDefineProperty
          });
          module.exports = function (TYPE, wrapper, CLAMPED) {
            var BYTES = TYPE.match(/\d+$/)[0] / 8;
            var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
            var GETTER = 'get' + TYPE;
            var SETTER = 'set' + TYPE;
            var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];
            var TypedArrayConstructor = NativeTypedArrayConstructor;
            var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
            var exported = {};
            var getter = function (that, index) {
              var data = getInternalState(that);
              return data.view[GETTER](index * BYTES + data.byteOffset, true);
            };
            var setter = function (that, index, value) {
              var data = getInternalState(that);
              if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
              data.view[SETTER](index * BYTES + data.byteOffset, value, true);
            };
            var addElement = function (that, index) {
              nativeDefineProperty(that, index, {
                get: function () {
                  return getter(this, index);
                },
                set: function (value) {
                  return setter(this, index, value);
                },
                enumerable: true
              });
            };
            if (!NATIVE_ARRAY_BUFFER_VIEWS) {
              TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
                anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
                var index = 0;
                var byteOffset = 0;
                var buffer, byteLength, length;
                if (!isObject(data)) {
                  length = toIndex(data);
                  byteLength = length * BYTES;
                  buffer = new ArrayBuffer(byteLength);
                } else if (isArrayBuffer(data)) {
                  buffer = data;
                  byteOffset = toOffset(offset, BYTES);
                  var $len = data.byteLength;
                  if ($length === undefined) {
                    if ($len % BYTES) throw RangeError(WRONG_LENGTH);
                    byteLength = $len - byteOffset;
                    if (byteLength < 0) throw RangeError(WRONG_LENGTH);
                  } else {
                    byteLength = toLength($length) * BYTES;
                    if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
                  }
                  length = byteLength / BYTES;
                } else if (isTypedArray(data)) {
                  return fromList(TypedArrayConstructor, data);
                } else {
                  return typedArrayFrom.call(TypedArrayConstructor, data);
                }
                setInternalState(that, {
                  buffer: buffer,
                  byteOffset: byteOffset,
                  byteLength: byteLength,
                  length: length,
                  view: new DataView(buffer)
                });
                while (index < length) addElement(that, index++);
              });
              if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
              TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
            } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
              TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
                anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
                return inheritIfRequired(function () {
                  if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
                  if (isArrayBuffer(data)) return $length !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);
                  if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
                  return typedArrayFrom.call(TypedArrayConstructor, data);
                }(), dummy, TypedArrayConstructor);
              });
              if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
              forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
                if (!(key in TypedArrayConstructor)) {
                  createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
                }
              });
              TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
            }
            if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
              createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
            }
            if (TYPED_ARRAY_TAG) {
              createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
            }
            exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
            $({
              global: true,
              forced: TypedArrayConstructor != NativeTypedArrayConstructor,
              sham: !NATIVE_ARRAY_BUFFER_VIEWS
            }, exported);
            if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
              createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
            }
            if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
              createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
            }
            setSpecies(CONSTRUCTOR_NAME);
          };
        } else module.exports = function () {/* empty */};

        /***/
      }),
      /***/3832: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_135708__) {
        /* eslint-disable no-new -- required for testing */
        var global = __nested_webpack_require_135708__(7854);
        var fails = __nested_webpack_require_135708__(7293);
        var checkCorrectnessOfIteration = __nested_webpack_require_135708__(7072);
        var NATIVE_ARRAY_BUFFER_VIEWS = __nested_webpack_require_135708__(260).NATIVE_ARRAY_BUFFER_VIEWS;
        var ArrayBuffer = global.ArrayBuffer;
        var Int8Array = global.Int8Array;
        module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function () {
          Int8Array(1);
        }) || !fails(function () {
          new Int8Array(-1);
        }) || !checkCorrectnessOfIteration(function (iterable) {
          new Int8Array();
          new Int8Array(null);
          new Int8Array(1.5);
          new Int8Array(iterable);
        }, true) || fails(function () {
          // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
          return new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1;
        });

        /***/
      }),
      /***/3074: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_136805__) {
        var aTypedArrayConstructor = __nested_webpack_require_136805__(260).aTypedArrayConstructor;
        var speciesConstructor = __nested_webpack_require_136805__(6707);
        module.exports = function (instance, list) {
          var C = speciesConstructor(instance, instance.constructor);
          var index = 0;
          var length = list.length;
          var result = new (aTypedArrayConstructor(C))(length);
          while (length > index) result[index] = list[index++];
          return result;
        };

        /***/
      }),
      /***/7321: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_137414__) {
        var toObject = __nested_webpack_require_137414__(7908);
        var toLength = __nested_webpack_require_137414__(7466);
        var getIteratorMethod = __nested_webpack_require_137414__(1246);
        var isArrayIteratorMethod = __nested_webpack_require_137414__(7659);
        var bind = __nested_webpack_require_137414__(9974);
        var aTypedArrayConstructor = __nested_webpack_require_137414__(260).aTypedArrayConstructor;
        module.exports = function from(source /* , mapfn, thisArg */) {
          var O = toObject(source);
          var argumentsLength = arguments.length;
          var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
          var mapping = mapfn !== undefined;
          var iteratorMethod = getIteratorMethod(O);
          var i, length, result, step, iterator, next;
          if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
            iterator = iteratorMethod.call(O);
            next = iterator.next;
            O = [];
            while (!(step = next.call(iterator)).done) {
              O.push(step.value);
            }
          }
          if (mapping && argumentsLength > 2) {
            mapfn = bind(mapfn, arguments[2], 2);
          }
          length = toLength(O.length);
          result = new (aTypedArrayConstructor(this))(length);
          for (i = 0; length > i; i++) {
            result[i] = mapping ? mapfn(O[i], i) : O[i];
          }
          return result;
        };

        /***/
      }),
      /***/9711: (/***/function (module) {
        var id = 0;
        var postfix = Math.random();
        module.exports = function (key) {
          return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
        };

        /***/
      }),
      /***/3307: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_139211__) {
        var NATIVE_SYMBOL = __nested_webpack_require_139211__(133);
        module.exports = NATIVE_SYMBOL
        /* global Symbol -- safe */ && !Symbol.sham && typeof Symbol.iterator == 'symbol';

        /***/
      }),
      /***/5112: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_139510__) {
        var global = __nested_webpack_require_139510__(7854);
        var shared = __nested_webpack_require_139510__(2309);
        var has = __nested_webpack_require_139510__(6656);
        var uid = __nested_webpack_require_139510__(9711);
        var NATIVE_SYMBOL = __nested_webpack_require_139510__(133);
        var USE_SYMBOL_AS_UID = __nested_webpack_require_139510__(3307);
        var WellKnownSymbolsStore = shared('wks');
        var Symbol = global.Symbol;
        var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;
        module.exports = function (name) {
          if (!has(WellKnownSymbolsStore, name)) {
            if (NATIVE_SYMBOL && has(Symbol, name)) WellKnownSymbolsStore[name] = Symbol[name];else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
          }
          return WellKnownSymbolsStore[name];
        };

        /***/
      }),
      /***/1361: (/***/function (module) {
        // a string of all valid unicode whitespaces
        module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' + '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

        /***/
      }),
      /***/8264: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_140771__) {
        "use strict";

        var $ = __nested_webpack_require_140771__(2109);
        var global = __nested_webpack_require_140771__(7854);
        var arrayBufferModule = __nested_webpack_require_140771__(3331);
        var setSpecies = __nested_webpack_require_140771__(6340);
        var ARRAY_BUFFER = 'ArrayBuffer';
        var ArrayBuffer = arrayBufferModule[ARRAY_BUFFER];
        var NativeArrayBuffer = global[ARRAY_BUFFER];

        // `ArrayBuffer` constructor
        // https://tc39.es/ecma262/#sec-arraybuffer-constructor
        $({
          global: true,
          forced: NativeArrayBuffer !== ArrayBuffer
        }, {
          ArrayBuffer: ArrayBuffer
        });
        setSpecies(ARRAY_BUFFER);

        /***/
      }),
      /***/2222: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_141567__) {
        "use strict";

        var $ = __nested_webpack_require_141567__(2109);
        var fails = __nested_webpack_require_141567__(7293);
        var isArray = __nested_webpack_require_141567__(3157);
        var isObject = __nested_webpack_require_141567__(111);
        var toObject = __nested_webpack_require_141567__(7908);
        var toLength = __nested_webpack_require_141567__(7466);
        var createProperty = __nested_webpack_require_141567__(6135);
        var arraySpeciesCreate = __nested_webpack_require_141567__(5417);
        var arrayMethodHasSpeciesSupport = __nested_webpack_require_141567__(1194);
        var wellKnownSymbol = __nested_webpack_require_141567__(5112);
        var V8_VERSION = __nested_webpack_require_141567__(7392);
        var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
        var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
        var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

        // We can't use this feature detection in V8 since it causes
        // deoptimization and serious performance degradation
        // https://github.com/zloirock/core-js/issues/679
        var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
          var array = [];
          array[IS_CONCAT_SPREADABLE] = false;
          return array.concat()[0] !== array;
        });
        var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');
        var isConcatSpreadable = function (O) {
          if (!isObject(O)) return false;
          var spreadable = O[IS_CONCAT_SPREADABLE];
          return spreadable !== undefined ? !!spreadable : isArray(O);
        };
        var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

        // `Array.prototype.concat` method
        // https://tc39.es/ecma262/#sec-array.prototype.concat
        // with adding support of @@isConcatSpreadable and @@species
        $({
          target: 'Array',
          proto: true,
          forced: FORCED
        }, {
          // eslint-disable-next-line no-unused-vars -- required for `.length`
          concat: function concat(arg) {
            var O = toObject(this);
            var A = arraySpeciesCreate(O, 0);
            var n = 0;
            var i, k, length, len, E;
            for (i = -1, length = arguments.length; i < length; i++) {
              E = i === -1 ? O : arguments[i];
              if (isConcatSpreadable(E)) {
                len = toLength(E.length);
                if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
              } else {
                if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                createProperty(A, n++, E);
              }
            }
            A.length = n;
            return A;
          }
        });

        /***/
      }),
      /***/7327: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_144464__) {
        "use strict";

        var $ = __nested_webpack_require_144464__(2109);
        var $filter = __nested_webpack_require_144464__(2092).filter;
        var arrayMethodHasSpeciesSupport = __nested_webpack_require_144464__(1194);
        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');

        // `Array.prototype.filter` method
        // https://tc39.es/ecma262/#sec-array.prototype.filter
        // with adding support of @@species
        $({
          target: 'Array',
          proto: true,
          forced: !HAS_SPECIES_SUPPORT
        }, {
          filter: function filter(callbackfn /* , thisArg */) {
            return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
          }
        });

        /***/
      }),
      /***/2772: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_145310__) {
        "use strict";

        var $ = __nested_webpack_require_145310__(2109);
        var $indexOf = __nested_webpack_require_145310__(1318).indexOf;
        var arrayMethodIsStrict = __nested_webpack_require_145310__(9341);
        var nativeIndexOf = [].indexOf;
        var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
        var STRICT_METHOD = arrayMethodIsStrict('indexOf');

        // `Array.prototype.indexOf` method
        // https://tc39.es/ecma262/#sec-array.prototype.indexof
        $({
          target: 'Array',
          proto: true,
          forced: NEGATIVE_ZERO || !STRICT_METHOD
        }, {
          indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
            return NEGATIVE_ZERO
            // convert -0 to +0
            ? nativeIndexOf.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
          }
        });

        /***/
      }),
      /***/6992: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_146321__) {
        "use strict";

        var toIndexedObject = __nested_webpack_require_146321__(5656);
        var addToUnscopables = __nested_webpack_require_146321__(1223);
        var Iterators = __nested_webpack_require_146321__(7497);
        var InternalStateModule = __nested_webpack_require_146321__(9909);
        var defineIterator = __nested_webpack_require_146321__(654);
        var ARRAY_ITERATOR = 'Array Iterator';
        var setInternalState = InternalStateModule.set;
        var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

        // `Array.prototype.entries` method
        // https://tc39.es/ecma262/#sec-array.prototype.entries
        // `Array.prototype.keys` method
        // https://tc39.es/ecma262/#sec-array.prototype.keys
        // `Array.prototype.values` method
        // https://tc39.es/ecma262/#sec-array.prototype.values
        // `Array.prototype[@@iterator]` method
        // https://tc39.es/ecma262/#sec-array.prototype-@@iterator
        // `CreateArrayIterator` internal method
        // https://tc39.es/ecma262/#sec-createarrayiterator
        module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
          setInternalState(this, {
            type: ARRAY_ITERATOR,
            target: toIndexedObject(iterated),
            // target
            index: 0,
            // next index
            kind: kind // kind
          });
          // `%ArrayIteratorPrototype%.next` method
          // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
        }, function () {
          var state = getInternalState(this);
          var target = state.target;
          var kind = state.kind;
          var index = state.index++;
          if (!target || index >= target.length) {
            state.target = undefined;
            return {
              value: undefined,
              done: true
            };
          }
          if (kind == 'keys') return {
            value: index,
            done: false
          };
          if (kind == 'values') return {
            value: target[index],
            done: false
          };
          return {
            value: [index, target[index]],
            done: false
          };
        }, 'values');

        // argumentsList[@@iterator] is %ArrayProto_values%
        // https://tc39.es/ecma262/#sec-createunmappedargumentsobject
        // https://tc39.es/ecma262/#sec-createmappedargumentsobject
        Iterators.Arguments = Iterators.Array;

        // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
        addToUnscopables('keys');
        addToUnscopables('values');
        addToUnscopables('entries');

        /***/
      }),
      /***/1249: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_149050__) {
        "use strict";

        var $ = __nested_webpack_require_149050__(2109);
        var $map = __nested_webpack_require_149050__(2092).map;
        var arrayMethodHasSpeciesSupport = __nested_webpack_require_149050__(1194);
        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');

        // `Array.prototype.map` method
        // https://tc39.es/ecma262/#sec-array.prototype.map
        // with adding support of @@species
        $({
          target: 'Array',
          proto: true,
          forced: !HAS_SPECIES_SUPPORT
        }, {
          map: function map(callbackfn /* , thisArg */) {
            return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
          }
        });

        /***/
      }),
      /***/7042: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_149872__) {
        "use strict";

        var $ = __nested_webpack_require_149872__(2109);
        var isObject = __nested_webpack_require_149872__(111);
        var isArray = __nested_webpack_require_149872__(3157);
        var toAbsoluteIndex = __nested_webpack_require_149872__(1400);
        var toLength = __nested_webpack_require_149872__(7466);
        var toIndexedObject = __nested_webpack_require_149872__(5656);
        var createProperty = __nested_webpack_require_149872__(6135);
        var wellKnownSymbol = __nested_webpack_require_149872__(5112);
        var arrayMethodHasSpeciesSupport = __nested_webpack_require_149872__(1194);
        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');
        var SPECIES = wellKnownSymbol('species');
        var nativeSlice = [].slice;
        var max = Math.max;

        // `Array.prototype.slice` method
        // https://tc39.es/ecma262/#sec-array.prototype.slice
        // fallback for not array-like ES3 strings and DOM objects
        $({
          target: 'Array',
          proto: true,
          forced: !HAS_SPECIES_SUPPORT
        }, {
          slice: function slice(start, end) {
            var O = toIndexedObject(this);
            var length = toLength(O.length);
            var k = toAbsoluteIndex(start, length);
            var fin = toAbsoluteIndex(end === undefined ? length : end, length);
            // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
            var Constructor, result, n;
            if (isArray(O)) {
              Constructor = O.constructor;
              // cross-realm fallback
              if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
                Constructor = undefined;
              } else if (isObject(Constructor)) {
                Constructor = Constructor[SPECIES];
                if (Constructor === null) Constructor = undefined;
              }
              if (Constructor === Array || Constructor === undefined) {
                return nativeSlice.call(O, k, fin);
              }
            }
            result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));
            for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
            result.length = n;
            return result;
          }
        });

        /***/
      }),
      /***/561: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_152257__) {
        "use strict";

        var $ = __nested_webpack_require_152257__(2109);
        var toAbsoluteIndex = __nested_webpack_require_152257__(1400);
        var toInteger = __nested_webpack_require_152257__(9958);
        var toLength = __nested_webpack_require_152257__(7466);
        var toObject = __nested_webpack_require_152257__(7908);
        var arraySpeciesCreate = __nested_webpack_require_152257__(5417);
        var createProperty = __nested_webpack_require_152257__(6135);
        var arrayMethodHasSpeciesSupport = __nested_webpack_require_152257__(1194);
        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');
        var max = Math.max;
        var min = Math.min;
        var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
        var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

        // `Array.prototype.splice` method
        // https://tc39.es/ecma262/#sec-array.prototype.splice
        // with adding support of @@species
        $({
          target: 'Array',
          proto: true,
          forced: !HAS_SPECIES_SUPPORT
        }, {
          splice: function splice(start, deleteCount /* , ...items */) {
            var O = toObject(this);
            var len = toLength(O.length);
            var actualStart = toAbsoluteIndex(start, len);
            var argumentsLength = arguments.length;
            var insertCount, actualDeleteCount, A, k, from, to;
            if (argumentsLength === 0) {
              insertCount = actualDeleteCount = 0;
            } else if (argumentsLength === 1) {
              insertCount = 0;
              actualDeleteCount = len - actualStart;
            } else {
              insertCount = argumentsLength - 2;
              actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
            }
            if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
              throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
            }
            A = arraySpeciesCreate(O, actualDeleteCount);
            for (k = 0; k < actualDeleteCount; k++) {
              from = actualStart + k;
              if (from in O) createProperty(A, k, O[from]);
            }
            A.length = actualDeleteCount;
            if (insertCount < actualDeleteCount) {
              for (k = actualStart; k < len - actualDeleteCount; k++) {
                from = k + actualDeleteCount;
                to = k + insertCount;
                if (from in O) O[to] = O[from];else delete O[to];
              }
              for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
            } else if (insertCount > actualDeleteCount) {
              for (k = len - actualDeleteCount; k > actualStart; k--) {
                from = k + actualDeleteCount - 1;
                to = k + insertCount - 1;
                if (from in O) O[to] = O[from];else delete O[to];
              }
            }
            for (k = 0; k < insertCount; k++) {
              O[k + actualStart] = arguments[k + 2];
            }
            O.length = len - actualDeleteCount + insertCount;
            return A;
          }
        });

        /***/
      }),
      /***/8309: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_155441__) {
        var DESCRIPTORS = __nested_webpack_require_155441__(9781);
        var defineProperty = __nested_webpack_require_155441__(3070).f;
        var FunctionPrototype = Function.prototype;
        var FunctionPrototypeToString = FunctionPrototype.toString;
        var nameRE = /^\s*function ([^ (]*)/;
        var NAME = 'name';

        // Function instances `.name` property
        // https://tc39.es/ecma262/#sec-function-instances-name
        if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
          defineProperty(FunctionPrototype, NAME, {
            configurable: true,
            get: function () {
              try {
                return FunctionPrototypeToString.call(this).match(nameRE)[1];
              } catch (error) {
                return '';
              }
            }
          });
        }

        /***/
      }),
      /***/489: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_156373__) {
        var $ = __nested_webpack_require_156373__(2109);
        var fails = __nested_webpack_require_156373__(7293);
        var toObject = __nested_webpack_require_156373__(7908);
        var nativeGetPrototypeOf = __nested_webpack_require_156373__(9518);
        var CORRECT_PROTOTYPE_GETTER = __nested_webpack_require_156373__(8544);
        var FAILS_ON_PRIMITIVES = fails(function () {
          nativeGetPrototypeOf(1);
        });

        // `Object.getPrototypeOf` method
        // https://tc39.es/ecma262/#sec-object.getprototypeof
        $({
          target: 'Object',
          stat: true,
          forced: FAILS_ON_PRIMITIVES,
          sham: !CORRECT_PROTOTYPE_GETTER
        }, {
          getPrototypeOf: function getPrototypeOf(it) {
            return nativeGetPrototypeOf(toObject(it));
          }
        });

        /***/
      }),
      /***/1539: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_157270__) {
        var TO_STRING_TAG_SUPPORT = __nested_webpack_require_157270__(1694);
        var redefine = __nested_webpack_require_157270__(1320);
        var toString = __nested_webpack_require_157270__(288);

        // `Object.prototype.toString` method
        // https://tc39.es/ecma262/#sec-object.prototype.tostring
        if (!TO_STRING_TAG_SUPPORT) {
          redefine(Object.prototype, 'toString', toString, {
            unsafe: true
          });
        }

        /***/
      }),
      /***/4916: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_157825__) {
        "use strict";

        var $ = __nested_webpack_require_157825__(2109);
        var exec = __nested_webpack_require_157825__(2261);

        // `RegExp.prototype.exec` method
        // https://tc39.es/ecma262/#sec-regexp.prototype.exec
        $({
          target: 'RegExp',
          proto: true,
          forced: /./.exec !== exec
        }, {
          exec: exec
        });

        /***/
      }),
      /***/9714: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_158319__) {
        "use strict";

        var redefine = __nested_webpack_require_158319__(1320);
        var anObject = __nested_webpack_require_158319__(9670);
        var fails = __nested_webpack_require_158319__(7293);
        var flags = __nested_webpack_require_158319__(7066);
        var TO_STRING = 'toString';
        var RegExpPrototype = RegExp.prototype;
        var nativeToString = RegExpPrototype[TO_STRING];
        var NOT_GENERIC = fails(function () {
          return nativeToString.call({
            source: 'a',
            flags: 'b'
          }) != '/a/b';
        });
        // FF44- RegExp#toString has a wrong name
        var INCORRECT_NAME = nativeToString.name != TO_STRING;

        // `RegExp.prototype.toString` method
        // https://tc39.es/ecma262/#sec-regexp.prototype.tostring
        if (NOT_GENERIC || INCORRECT_NAME) {
          redefine(RegExp.prototype, TO_STRING, function toString() {
            var R = anObject(this);
            var p = String(R.source);
            var rf = R.flags;
            var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? flags.call(R) : rf);
            return '/' + p + '/' + f;
          }, {
            unsafe: true
          });
        }

        /***/
      }),
      /***/8783: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_159648__) {
        "use strict";

        var charAt = __nested_webpack_require_159648__(8710).charAt;
        var InternalStateModule = __nested_webpack_require_159648__(9909);
        var defineIterator = __nested_webpack_require_159648__(654);
        var STRING_ITERATOR = 'String Iterator';
        var setInternalState = InternalStateModule.set;
        var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

        // `String.prototype[@@iterator]` method
        // https://tc39.es/ecma262/#sec-string.prototype-@@iterator
        defineIterator(String, 'String', function (iterated) {
          setInternalState(this, {
            type: STRING_ITERATOR,
            string: String(iterated),
            index: 0
          });
          // `%StringIteratorPrototype%.next` method
          // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
        }, function next() {
          var state = getInternalState(this);
          var string = state.string;
          var index = state.index;
          var point;
          if (index >= string.length) return {
            value: undefined,
            done: true
          };
          point = charAt(string, index);
          state.index += point.length;
          return {
            value: point,
            done: false
          };
        });

        /***/
      }),
      /***/4723: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_161063__) {
        "use strict";

        var fixRegExpWellKnownSymbolLogic = __nested_webpack_require_161063__(7007);
        var anObject = __nested_webpack_require_161063__(9670);
        var toLength = __nested_webpack_require_161063__(7466);
        var requireObjectCoercible = __nested_webpack_require_161063__(4488);
        var advanceStringIndex = __nested_webpack_require_161063__(1530);
        var regExpExec = __nested_webpack_require_161063__(7651);

        // @@match logic
        fixRegExpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
          return [
          // `String.prototype.match` method
          // https://tc39.es/ecma262/#sec-string.prototype.match
          function match(regexp) {
            var O = requireObjectCoercible(this);
            var matcher = regexp == undefined ? undefined : regexp[MATCH];
            return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
          },
          // `RegExp.prototype[@@match]` method
          // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
          function (regexp) {
            var res = maybeCallNative(nativeMatch, regexp, this);
            if (res.done) return res.value;
            var rx = anObject(regexp);
            var S = String(this);
            if (!rx.global) return regExpExec(rx, S);
            var fullUnicode = rx.unicode;
            rx.lastIndex = 0;
            var A = [];
            var n = 0;
            var result;
            while ((result = regExpExec(rx, S)) !== null) {
              var matchStr = String(result[0]);
              A[n] = matchStr;
              if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
              n++;
            }
            return n === 0 ? null : A;
          }];
        });

        /***/
      }),
      /***/5306: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_162971__) {
        "use strict";

        var fixRegExpWellKnownSymbolLogic = __nested_webpack_require_162971__(7007);
        var anObject = __nested_webpack_require_162971__(9670);
        var toLength = __nested_webpack_require_162971__(7466);
        var toInteger = __nested_webpack_require_162971__(9958);
        var requireObjectCoercible = __nested_webpack_require_162971__(4488);
        var advanceStringIndex = __nested_webpack_require_162971__(1530);
        var getSubstitution = __nested_webpack_require_162971__(647);
        var regExpExec = __nested_webpack_require_162971__(7651);
        var max = Math.max;
        var min = Math.min;
        var maybeToString = function (it) {
          return it === undefined ? it : String(it);
        };

        // @@replace logic
        fixRegExpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {
          var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
          var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
          var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';
          return [
          // `String.prototype.replace` method
          // https://tc39.es/ecma262/#sec-string.prototype.replace
          function replace(searchValue, replaceValue) {
            var O = requireObjectCoercible(this);
            var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
            return replacer !== undefined ? replacer.call(searchValue, O, replaceValue) : nativeReplace.call(String(O), searchValue, replaceValue);
          },
          // `RegExp.prototype[@@replace]` method
          // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
          function (regexp, replaceValue) {
            if (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0 || typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1) {
              var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
              if (res.done) return res.value;
            }
            var rx = anObject(regexp);
            var S = String(this);
            var functionalReplace = typeof replaceValue === 'function';
            if (!functionalReplace) replaceValue = String(replaceValue);
            var global = rx.global;
            if (global) {
              var fullUnicode = rx.unicode;
              rx.lastIndex = 0;
            }
            var results = [];
            while (true) {
              var result = regExpExec(rx, S);
              if (result === null) break;
              results.push(result);
              if (!global) break;
              var matchStr = String(result[0]);
              if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
            }
            var accumulatedResult = '';
            var nextSourcePosition = 0;
            for (var i = 0; i < results.length; i++) {
              result = results[i];
              var matched = String(result[0]);
              var position = max(min(toInteger(result.index), S.length), 0);
              var captures = [];
              // NOTE: This is equivalent to
              //   captures = result.slice(1).map(maybeToString)
              // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
              // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
              // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
              for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
              var namedCaptures = result.groups;
              if (functionalReplace) {
                var replacerArgs = [matched].concat(captures, position, S);
                if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
                var replacement = String(replaceValue.apply(undefined, replacerArgs));
              } else {
                replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
              }
              if (position >= nextSourcePosition) {
                accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
                nextSourcePosition = position + matched.length;
              }
            }
            return accumulatedResult + S.slice(nextSourcePosition);
          }];
        });

        /***/
      }),
      /***/3123: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_167493__) {
        "use strict";

        var fixRegExpWellKnownSymbolLogic = __nested_webpack_require_167493__(7007);
        var isRegExp = __nested_webpack_require_167493__(7850);
        var anObject = __nested_webpack_require_167493__(9670);
        var requireObjectCoercible = __nested_webpack_require_167493__(4488);
        var speciesConstructor = __nested_webpack_require_167493__(6707);
        var advanceStringIndex = __nested_webpack_require_167493__(1530);
        var toLength = __nested_webpack_require_167493__(7466);
        var callRegExpExec = __nested_webpack_require_167493__(7651);
        var regexpExec = __nested_webpack_require_167493__(2261);
        var fails = __nested_webpack_require_167493__(7293);
        var arrayPush = [].push;
        var min = Math.min;
        var MAX_UINT32 = 0xFFFFFFFF;

        // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
        var SUPPORTS_Y = !fails(function () {
          return !RegExp(MAX_UINT32, 'y');
        });

        // @@split logic
        fixRegExpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
          var internalSplit;
          if ('abbc'.split(/(b)*/)[1] == 'c' ||
          // eslint-disable-next-line regexp/no-empty-group -- required for testing
          'test'.split(/(?:)/, -1).length != 4 || 'ab'.split(/(?:ab)*/).length != 2 || '.'.split(/(.?)(.?)/).length != 4 ||
          // eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group -- required for testing
          '.'.split(/()()/).length > 1 || ''.split(/.?/).length) {
            // based on es5-shim implementation, need to rework it
            internalSplit = function (separator, limit) {
              var string = String(requireObjectCoercible(this));
              var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
              if (lim === 0) return [];
              if (separator === undefined) return [string];
              // If `separator` is not a regex, use native split
              if (!isRegExp(separator)) {
                return nativeSplit.call(string, separator, lim);
              }
              var output = [];
              var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
              var lastLastIndex = 0;
              // Make `global` and avoid `lastIndex` issues by working with a copy
              var separatorCopy = new RegExp(separator.source, flags + 'g');
              var match, lastIndex, lastLength;
              while (match = regexpExec.call(separatorCopy, string)) {
                lastIndex = separatorCopy.lastIndex;
                if (lastIndex > lastLastIndex) {
                  output.push(string.slice(lastLastIndex, match.index));
                  if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
                  lastLength = match[0].length;
                  lastLastIndex = lastIndex;
                  if (output.length >= lim) break;
                }
                if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
              }
              if (lastLastIndex === string.length) {
                if (lastLength || !separatorCopy.test('')) output.push('');
              } else output.push(string.slice(lastLastIndex));
              return output.length > lim ? output.slice(0, lim) : output;
            };
            // Chakra, V8
          } else if ('0'.split(undefined, 0).length) {
            internalSplit = function (separator, limit) {
              return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
            };
          } else internalSplit = nativeSplit;
          return [
          // `String.prototype.split` method
          // https://tc39.es/ecma262/#sec-string.prototype.split
          function split(separator, limit) {
            var O = requireObjectCoercible(this);
            var splitter = separator == undefined ? undefined : separator[SPLIT];
            return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
          },
          // `RegExp.prototype[@@split]` method
          // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
          //
          // NOTE: This cannot be properly polyfilled in engines that don't support
          // the 'y' flag.
          function (regexp, limit) {
            var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
            if (res.done) return res.value;
            var rx = anObject(regexp);
            var S = String(this);
            var C = speciesConstructor(rx, RegExp);
            var unicodeMatching = rx.unicode;
            var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (SUPPORTS_Y ? 'y' : 'g');

            // ^(? + rx + ) is needed, in combination with some S slicing, to
            // simulate the 'y' flag.
            var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
            var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
            if (lim === 0) return [];
            if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
            var p = 0;
            var q = 0;
            var A = [];
            while (q < S.length) {
              splitter.lastIndex = SUPPORTS_Y ? q : 0;
              var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
              var e;
              if (z === null || (e = min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {
                q = advanceStringIndex(S, q, unicodeMatching);
              } else {
                A.push(S.slice(p, q));
                if (A.length === lim) return A;
                for (var i = 1; i <= z.length - 1; i++) {
                  A.push(z[i]);
                  if (A.length === lim) return A;
                }
                q = p = e;
              }
            }
            A.push(S.slice(p));
            return A;
          }];
        }, !SUPPORTS_Y);

        /***/
      }),
      /***/3210: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_173749__) {
        "use strict";

        var $ = __nested_webpack_require_173749__(2109);
        var $trim = __nested_webpack_require_173749__(3111).trim;
        var forcedStringTrimMethod = __nested_webpack_require_173749__(6091);

        // `String.prototype.trim` method
        // https://tc39.es/ecma262/#sec-string.prototype.trim
        $({
          target: 'String',
          proto: true,
          forced: forcedStringTrimMethod('trim')
        }, {
          trim: function trim() {
            return $trim(this);
          }
        });

        /***/
      }),
      /***/2990: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_174383__) {
        "use strict";

        var ArrayBufferViewCore = __nested_webpack_require_174383__(260);
        var $copyWithin = __nested_webpack_require_174383__(1048);
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.copyWithin` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin
        exportTypedArrayMethod('copyWithin', function copyWithin(target, start /* , end */) {
          return $copyWithin.call(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
        });

        /***/
      }),
      /***/8927: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_175144__) {
        "use strict";

        var ArrayBufferViewCore = __nested_webpack_require_175144__(260);
        var $every = __nested_webpack_require_175144__(2092).every;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.every` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.every
        exportTypedArrayMethod('every', function every(callbackfn /* , thisArg */) {
          return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        });

        /***/
      }),
      /***/3105: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_175874__) {
        "use strict";

        var ArrayBufferViewCore = __nested_webpack_require_175874__(260);
        var $fill = __nested_webpack_require_175874__(1285);
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.fill` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        exportTypedArrayMethod('fill', function fill(value /* , start, end */) {
          return $fill.apply(aTypedArray(this), arguments);
        });

        /***/
      }),
      /***/5035: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_176623__) {
        "use strict";

        var ArrayBufferViewCore = __nested_webpack_require_176623__(260);
        var $filter = __nested_webpack_require_176623__(2092).filter;
        var fromSpeciesAndList = __nested_webpack_require_176623__(3074);
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.filter` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter
        exportTypedArrayMethod('filter', function filter(callbackfn /* , thisArg */) {
          var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
          return fromSpeciesAndList(this, list);
        });

        /***/
      }),
      /***/7174: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_177473__) {
        "use strict";

        var ArrayBufferViewCore = __nested_webpack_require_177473__(260);
        var $findIndex = __nested_webpack_require_177473__(2092).findIndex;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.findIndex` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex
        exportTypedArrayMethod('findIndex', function findIndex(predicate /* , thisArg */) {
          return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
        });

        /***/
      }),
      /***/4345: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_178229__) {
        "use strict";

        var ArrayBufferViewCore = __nested_webpack_require_178229__(260);
        var $find = __nested_webpack_require_178229__(2092).find;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.find` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.find
        exportTypedArrayMethod('find', function find(predicate /* , thisArg */) {
          return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
        });

        /***/
      }),
      /***/2846: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_178950__) {
        "use strict";

        var ArrayBufferViewCore = __nested_webpack_require_178950__(260);
        var $forEach = __nested_webpack_require_178950__(2092).forEach;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.forEach` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach
        exportTypedArrayMethod('forEach', function forEach(callbackfn /* , thisArg */) {
          $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        });

        /***/
      }),
      /***/4731: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_179687__) {
        "use strict";

        var ArrayBufferViewCore = __nested_webpack_require_179687__(260);
        var $includes = __nested_webpack_require_179687__(1318).includes;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.includes` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes
        exportTypedArrayMethod('includes', function includes(searchElement /* , fromIndex */) {
          return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
        });

        /***/
      }),
      /***/7209: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_180446__) {
        "use strict";

        var ArrayBufferViewCore = __nested_webpack_require_180446__(260);
        var $indexOf = __nested_webpack_require_180446__(1318).indexOf;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.indexOf` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof
        exportTypedArrayMethod('indexOf', function indexOf(searchElement /* , fromIndex */) {
          return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
        });

        /***/
      }),
      /***/6319: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_181198__) {
        "use strict";

        var global = __nested_webpack_require_181198__(7854);
        var ArrayBufferViewCore = __nested_webpack_require_181198__(260);
        var ArrayIterators = __nested_webpack_require_181198__(6992);
        var wellKnownSymbol = __nested_webpack_require_181198__(5112);
        var ITERATOR = wellKnownSymbol('iterator');
        var Uint8Array = global.Uint8Array;
        var arrayValues = ArrayIterators.values;
        var arrayKeys = ArrayIterators.keys;
        var arrayEntries = ArrayIterators.entries;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var nativeTypedArrayIterator = Uint8Array && Uint8Array.prototype[ITERATOR];
        var CORRECT_ITER_NAME = !!nativeTypedArrayIterator && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);
        var typedArrayValues = function values() {
          return arrayValues.call(aTypedArray(this));
        };

        // `%TypedArray%.prototype.entries` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries
        exportTypedArrayMethod('entries', function entries() {
          return arrayEntries.call(aTypedArray(this));
        });
        // `%TypedArray%.prototype.keys` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys
        exportTypedArrayMethod('keys', function keys() {
          return arrayKeys.call(aTypedArray(this));
        });
        // `%TypedArray%.prototype.values` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.values
        exportTypedArrayMethod('values', typedArrayValues, !CORRECT_ITER_NAME);
        // `%TypedArray%.prototype[@@iterator]` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator
        exportTypedArrayMethod(ITERATOR, typedArrayValues, !CORRECT_ITER_NAME);

        /***/
      }),
      /***/8867: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_183208__) {
        "use strict";

        var ArrayBufferViewCore = __nested_webpack_require_183208__(260);
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var $join = [].join;

        // `%TypedArray%.prototype.join` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.join
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        exportTypedArrayMethod('join', function join(separator) {
          return $join.apply(aTypedArray(this), arguments);
        });

        /***/
      }),
      /***/7789: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_183924__) {
        "use strict";

        var ArrayBufferViewCore = __nested_webpack_require_183924__(260);
        var $lastIndexOf = __nested_webpack_require_183924__(6583);
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.lastIndexOf` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        exportTypedArrayMethod('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {
          return $lastIndexOf.apply(aTypedArray(this), arguments);
        });

        /***/
      }),
      /***/3739: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_184722__) {
        "use strict";

        var ArrayBufferViewCore = __nested_webpack_require_184722__(260);
        var $map = __nested_webpack_require_184722__(2092).map;
        var speciesConstructor = __nested_webpack_require_184722__(6707);
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.map` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.map
        exportTypedArrayMethod('map', function map(mapfn /* , thisArg */) {
          return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
            return new (aTypedArrayConstructor(speciesConstructor(O, O.constructor)))(length);
          });
        });

        /***/
      }),
      /***/4483: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_185700__) {
        "use strict";

        var ArrayBufferViewCore = __nested_webpack_require_185700__(260);
        var $reduceRight = __nested_webpack_require_185700__(3671).right;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.reduceRicht` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright
        exportTypedArrayMethod('reduceRight', function reduceRight(callbackfn /* , initialValue */) {
          return $reduceRight(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
        });

        /***/
      }),
      /***/9368: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_186489__) {
        "use strict";

        var ArrayBufferViewCore = __nested_webpack_require_186489__(260);
        var $reduce = __nested_webpack_require_186489__(3671).left;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.reduce` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce
        exportTypedArrayMethod('reduce', function reduce(callbackfn /* , initialValue */) {
          return $reduce(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
        });

        /***/
      }),
      /***/2056: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_187247__) {
        "use strict";

        var ArrayBufferViewCore = __nested_webpack_require_187247__(260);
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var floor = Math.floor;

        // `%TypedArray%.prototype.reverse` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse
        exportTypedArrayMethod('reverse', function reverse() {
          var that = this;
          var length = aTypedArray(that).length;
          var middle = floor(length / 2);
          var index = 0;
          var value;
          while (index < middle) {
            value = that[index];
            that[index++] = that[--length];
            that[length] = value;
          }
          return that;
        });

        /***/
      }),
      /***/3462: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_188177__) {
        "use strict";

        var ArrayBufferViewCore = __nested_webpack_require_188177__(260);
        var toLength = __nested_webpack_require_188177__(7466);
        var toOffset = __nested_webpack_require_188177__(4590);
        var toObject = __nested_webpack_require_188177__(7908);
        var fails = __nested_webpack_require_188177__(7293);
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var FORCED = fails(function () {
          /* global Int8Array -- safe */
          new Int8Array(1).set({});
        });

        // `%TypedArray%.prototype.set` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.set
        exportTypedArrayMethod('set', function set(arrayLike /* , offset */) {
          aTypedArray(this);
          var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
          var length = this.length;
          var src = toObject(arrayLike);
          var len = toLength(src.length);
          var index = 0;
          if (len + offset > length) throw RangeError('Wrong length');
          while (index < len) this[offset + index] = src[index++];
        }, FORCED);

        /***/
      }),
      /***/678: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_189468__) {
        "use strict";

        var ArrayBufferViewCore = __nested_webpack_require_189468__(260);
        var speciesConstructor = __nested_webpack_require_189468__(6707);
        var fails = __nested_webpack_require_189468__(7293);
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var $slice = [].slice;
        var FORCED = fails(function () {
          /* global Int8Array -- safe */
          new Int8Array(1).slice();
        });

        // `%TypedArray%.prototype.slice` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice
        exportTypedArrayMethod('slice', function slice(start, end) {
          var list = $slice.call(aTypedArray(this), start, end);
          var C = speciesConstructor(this, this.constructor);
          var index = 0;
          var length = list.length;
          var result = new (aTypedArrayConstructor(C))(length);
          while (length > index) result[index] = list[index++];
          return result;
        }, FORCED);

        /***/
      }),
      /***/7462: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_190721__) {
        "use strict";

        var ArrayBufferViewCore = __nested_webpack_require_190721__(260);
        var $some = __nested_webpack_require_190721__(2092).some;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.some` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.some
        exportTypedArrayMethod('some', function some(callbackfn /* , thisArg */) {
          return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        });

        /***/
      }),
      /***/3824: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_191444__) {
        "use strict";

        var ArrayBufferViewCore = __nested_webpack_require_191444__(260);
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var $sort = [].sort;

        // `%TypedArray%.prototype.sort` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort
        exportTypedArrayMethod('sort', function sort(comparefn) {
          return $sort.call(aTypedArray(this), comparefn);
        });

        /***/
      }),
      /***/5021: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_192082__) {
        "use strict";

        var ArrayBufferViewCore = __nested_webpack_require_192082__(260);
        var toLength = __nested_webpack_require_192082__(7466);
        var toAbsoluteIndex = __nested_webpack_require_192082__(1400);
        var speciesConstructor = __nested_webpack_require_192082__(6707);
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.subarray` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray
        exportTypedArrayMethod('subarray', function subarray(begin, end) {
          var O = aTypedArray(this);
          var length = O.length;
          var beginIndex = toAbsoluteIndex(begin, length);
          return new (speciesConstructor(O, O.constructor))(O.buffer, O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex));
        });

        /***/
      }),
      /***/2974: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_193149__) {
        "use strict";

        var global = __nested_webpack_require_193149__(7854);
        var ArrayBufferViewCore = __nested_webpack_require_193149__(260);
        var fails = __nested_webpack_require_193149__(7293);
        var Int8Array = global.Int8Array;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var $toLocaleString = [].toLocaleString;
        var $slice = [].slice;

        // iOS Safari 6.x fails here
        var TO_LOCALE_STRING_BUG = !!Int8Array && fails(function () {
          $toLocaleString.call(new Int8Array(1));
        });
        var FORCED = fails(function () {
          return [1, 2].toLocaleString() != new Int8Array([1, 2]).toLocaleString();
        }) || !fails(function () {
          Int8Array.prototype.toLocaleString.call([1, 2]);
        });

        // `%TypedArray%.prototype.toLocaleString` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring
        exportTypedArrayMethod('toLocaleString', function toLocaleString() {
          return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice.call(aTypedArray(this)) : aTypedArray(this), arguments);
        }, FORCED);

        /***/
      }),
      /***/5016: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_194482__) {
        "use strict";

        var exportTypedArrayMethod = __nested_webpack_require_194482__(260).exportTypedArrayMethod;
        var fails = __nested_webpack_require_194482__(7293);
        var global = __nested_webpack_require_194482__(7854);
        var Uint8Array = global.Uint8Array;
        var Uint8ArrayPrototype = Uint8Array && Uint8Array.prototype || {};
        var arrayToString = [].toString;
        var arrayJoin = [].join;
        if (fails(function () {
          arrayToString.call({});
        })) {
          arrayToString = function toString() {
            return arrayJoin.call(this);
          };
        }
        var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;

        // `%TypedArray%.prototype.toString` method
        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.tostring
        exportTypedArrayMethod('toString', arrayToString, IS_NOT_ARRAY_METHOD);

        /***/
      }),
      /***/2472: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_195490__) {
        var createTypedArrayConstructor = __nested_webpack_require_195490__(9843);

        // `Uint8Array` constructor
        // https://tc39.es/ecma262/#sec-typedarray-objects
        createTypedArrayConstructor('Uint8', function (init) {
          return function Uint8Array(data, byteOffset, length) {
            return init(this, data, byteOffset, length);
          };
        });

        /***/
      }),
      /***/4747: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_195997__) {
        var global = __nested_webpack_require_195997__(7854);
        var DOMIterables = __nested_webpack_require_195997__(8324);
        var forEach = __nested_webpack_require_195997__(8533);
        var createNonEnumerableProperty = __nested_webpack_require_195997__(8880);
        for (var COLLECTION_NAME in DOMIterables) {
          var Collection = global[COLLECTION_NAME];
          var CollectionPrototype = Collection && Collection.prototype;
          // some Chrome versions have non-configurable methods on DOMTokenList
          if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
            createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
          } catch (error) {
            CollectionPrototype.forEach = forEach;
          }
        }

        /***/
      }),
      /***/3948: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_196872__) {
        var global = __nested_webpack_require_196872__(7854);
        var DOMIterables = __nested_webpack_require_196872__(8324);
        var ArrayIteratorMethods = __nested_webpack_require_196872__(6992);
        var createNonEnumerableProperty = __nested_webpack_require_196872__(8880);
        var wellKnownSymbol = __nested_webpack_require_196872__(5112);
        var ITERATOR = wellKnownSymbol('iterator');
        var TO_STRING_TAG = wellKnownSymbol('toStringTag');
        var ArrayValues = ArrayIteratorMethods.values;
        for (var COLLECTION_NAME in DOMIterables) {
          var Collection = global[COLLECTION_NAME];
          var CollectionPrototype = Collection && Collection.prototype;
          if (CollectionPrototype) {
            // some Chrome versions have non-configurable methods on DOMTokenList
            if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
              createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
            } catch (error) {
              CollectionPrototype[ITERATOR] = ArrayValues;
            }
            if (!CollectionPrototype[TO_STRING_TAG]) {
              createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
            }
            if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
              // some Chrome versions have non-configurable methods on DOMTokenList
              if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
                createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
              } catch (error) {
                CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
              }
            }
          }
        }

        /***/
      }),
      /***/1637: (/***/function (module, __unused_webpack_exports, __nested_webpack_require_198722__) {
        "use strict";

        // TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
        __nested_webpack_require_198722__(6992);
        var $ = __nested_webpack_require_198722__(2109);
        var getBuiltIn = __nested_webpack_require_198722__(5005);
        var USE_NATIVE_URL = __nested_webpack_require_198722__(590);
        var redefine = __nested_webpack_require_198722__(1320);
        var redefineAll = __nested_webpack_require_198722__(2248);
        var setToStringTag = __nested_webpack_require_198722__(8003);
        var createIteratorConstructor = __nested_webpack_require_198722__(4994);
        var InternalStateModule = __nested_webpack_require_198722__(9909);
        var anInstance = __nested_webpack_require_198722__(5787);
        var hasOwn = __nested_webpack_require_198722__(6656);
        var bind = __nested_webpack_require_198722__(9974);
        var classof = __nested_webpack_require_198722__(648);
        var anObject = __nested_webpack_require_198722__(9670);
        var isObject = __nested_webpack_require_198722__(111);
        var create = __nested_webpack_require_198722__(30);
        var createPropertyDescriptor = __nested_webpack_require_198722__(9114);
        var getIterator = __nested_webpack_require_198722__(8554);
        var getIteratorMethod = __nested_webpack_require_198722__(1246);
        var wellKnownSymbol = __nested_webpack_require_198722__(5112);
        var $fetch = getBuiltIn('fetch');
        var Headers = getBuiltIn('Headers');
        var ITERATOR = wellKnownSymbol('iterator');
        var URL_SEARCH_PARAMS = 'URLSearchParams';
        var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
        var setInternalState = InternalStateModule.set;
        var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
        var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);
        var plus = /\+/g;
        var sequences = Array(4);
        var percentSequence = function (bytes) {
          return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
        };
        var percentDecode = function (sequence) {
          try {
            return decodeURIComponent(sequence);
          } catch (error) {
            return sequence;
          }
        };
        var deserialize = function (it) {
          var result = it.replace(plus, ' ');
          var bytes = 4;
          try {
            return decodeURIComponent(result);
          } catch (error) {
            while (bytes) {
              result = result.replace(percentSequence(bytes--), percentDecode);
            }
            return result;
          }
        };
        var find = /[!'()~]|%20/g;
        var replace = {
          '!': '%21',
          "'": '%27',
          '(': '%28',
          ')': '%29',
          '~': '%7E',
          '%20': '+'
        };
        var replacer = function (match) {
          return replace[match];
        };
        var serialize = function (it) {
          return encodeURIComponent(it).replace(find, replacer);
        };
        var parseSearchParams = function (result, query) {
          if (query) {
            var attributes = query.split('&');
            var index = 0;
            var attribute, entry;
            while (index < attributes.length) {
              attribute = attributes[index++];
              if (attribute.length) {
                entry = attribute.split('=');
                result.push({
                  key: deserialize(entry.shift()),
                  value: deserialize(entry.join('='))
                });
              }
            }
          }
        };
        var updateSearchParams = function (query) {
          this.entries.length = 0;
          parseSearchParams(this.entries, query);
        };
        var validateArgumentsLength = function (passed, required) {
          if (passed < required) throw TypeError('Not enough arguments');
        };
        var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
          setInternalState(this, {
            type: URL_SEARCH_PARAMS_ITERATOR,
            iterator: getIterator(getInternalParamsState(params).entries),
            kind: kind
          });
        }, 'Iterator', function next() {
          var state = getInternalIteratorState(this);
          var kind = state.kind;
          var step = state.iterator.next();
          var entry = step.value;
          if (!step.done) {
            step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];
          }
          return step;
        });

        // `URLSearchParams` constructor
        // https://url.spec.whatwg.org/#interface-urlsearchparams
        var URLSearchParamsConstructor = function URLSearchParams(/* init */
        ) {
          anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);
          var init = arguments.length > 0 ? arguments[0] : undefined;
          var that = this;
          var entries = [];
          var iteratorMethod, iterator, next, step, entryIterator, entryNext, first, second, key;
          setInternalState(that, {
            type: URL_SEARCH_PARAMS,
            entries: entries,
            updateURL: function () {/* empty */},
            updateSearchParams: updateSearchParams
          });
          if (init !== undefined) {
            if (isObject(init)) {
              iteratorMethod = getIteratorMethod(init);
              if (typeof iteratorMethod === 'function') {
                iterator = iteratorMethod.call(init);
                next = iterator.next;
                while (!(step = next.call(iterator)).done) {
                  entryIterator = getIterator(anObject(step.value));
                  entryNext = entryIterator.next;
                  if ((first = entryNext.call(entryIterator)).done || (second = entryNext.call(entryIterator)).done || !entryNext.call(entryIterator).done) throw TypeError('Expected sequence with length 2');
                  entries.push({
                    key: first.value + '',
                    value: second.value + ''
                  });
                }
              } else for (key in init) if (hasOwn(init, key)) entries.push({
                key: key,
                value: init[key] + ''
              });
            } else {
              parseSearchParams(entries, typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : init + '');
            }
          }
        };
        var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
        redefineAll(URLSearchParamsPrototype, {
          // `URLSearchParams.prototype.append` method
          // https://url.spec.whatwg.org/#dom-urlsearchparams-append
          append: function append(name, value) {
            validateArgumentsLength(arguments.length, 2);
            var state = getInternalParamsState(this);
            state.entries.push({
              key: name + '',
              value: value + ''
            });
            state.updateURL();
          },
          // `URLSearchParams.prototype.delete` method
          // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
          'delete': function (name) {
            validateArgumentsLength(arguments.length, 1);
            var state = getInternalParamsState(this);
            var entries = state.entries;
            var key = name + '';
            var index = 0;
            while (index < entries.length) {
              if (entries[index].key === key) entries.splice(index, 1);else index++;
            }
            state.updateURL();
          },
          // `URLSearchParams.prototype.get` method
          // https://url.spec.whatwg.org/#dom-urlsearchparams-get
          get: function get(name) {
            validateArgumentsLength(arguments.length, 1);
            var entries = getInternalParamsState(this).entries;
            var key = name + '';
            var index = 0;
            for (; index < entries.length; index++) {
              if (entries[index].key === key) return entries[index].value;
            }
            return null;
          },
          // `URLSearchParams.prototype.getAll` method
          // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
          getAll: function getAll(name) {
            validateArgumentsLength(arguments.length, 1);
            var entries = getInternalParamsState(this).entries;
            var key = name + '';
            var result = [];
            var index = 0;
            for (; index < entries.length; index++) {
              if (entries[index].key === key) result.push(entries[index].value);
            }
            return result;
          },
          // `URLSearchParams.prototype.has` method
          // https://url.spec.whatwg.org/#dom-urlsearchparams-has
          has: function has(name) {
            validateArgumentsLength(arguments.length, 1);
            var entries = getInternalParamsState(this).entries;
            var key = name + '';
            var index = 0;
            while (index < entries.length) {
              if (entries[index++].key === key) return true;
            }
            return false;
          },
          // `URLSearchParams.prototype.set` method
          // https://url.spec.whatwg.org/#dom-urlsearchparams-set
          set: function set(name, value) {
            validateArgumentsLength(arguments.length, 1);
            var state = getInternalParamsState(this);
            var entries = state.entries;
            var found = false;
            var key = name + '';
            var val = value + '';
            var index = 0;
            var entry;
            for (; index < entries.length; index++) {
              entry = entries[index];
              if (entry.key === key) {
                if (found) entries.splice(index--, 1);else {
                  found = true;
                  entry.value = val;
                }
              }
            }
            if (!found) entries.push({
              key: key,
              value: val
            });
            state.updateURL();
          },
          // `URLSearchParams.prototype.sort` method
          // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
          sort: function sort() {
            var state = getInternalParamsState(this);
            var entries = state.entries;
            // Array#sort is not stable in some engines
            var slice = entries.slice();
            var entry, entriesIndex, sliceIndex;
            entries.length = 0;
            for (sliceIndex = 0; sliceIndex < slice.length; sliceIndex++) {
              entry = slice[sliceIndex];
              for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) {
                if (entries[entriesIndex].key > entry.key) {
                  entries.splice(entriesIndex, 0, entry);
                  break;
                }
              }
              if (entriesIndex === sliceIndex) entries.push(entry);
            }
            state.updateURL();
          },
          // `URLSearchParams.prototype.forEach` method
          forEach: function forEach(callback /* , thisArg */) {
            var entries = getInternalParamsState(this).entries;
            var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined, 3);
            var index = 0;
            var entry;
            while (index < entries.length) {
              entry = entries[index++];
              boundFunction(entry.value, entry.key, this);
            }
          },
          // `URLSearchParams.prototype.keys` method
          keys: function keys() {
            return new URLSearchParamsIterator(this, 'keys');
          },
          // `URLSearchParams.prototype.values` method
          values: function values() {
            return new URLSearchParamsIterator(this, 'values');
          },
          // `URLSearchParams.prototype.entries` method
          entries: function entries() {
            return new URLSearchParamsIterator(this, 'entries');
          }
        }, {
          enumerable: true
        });

        // `URLSearchParams.prototype[@@iterator]` method
        redefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries);

        // `URLSearchParams.prototype.toString` method
        // https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
        redefine(URLSearchParamsPrototype, 'toString', function toString() {
          var entries = getInternalParamsState(this).entries;
          var result = [];
          var index = 0;
          var entry;
          while (index < entries.length) {
            entry = entries[index++];
            result.push(serialize(entry.key) + '=' + serialize(entry.value));
          }
          return result.join('&');
        }, {
          enumerable: true
        });
        setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
        $({
          global: true,
          forced: !USE_NATIVE_URL
        }, {
          URLSearchParams: URLSearchParamsConstructor
        });

        // Wrap `fetch` for correct work with polyfilled `URLSearchParams`
        // https://github.com/zloirock/core-js/issues/674
        if (!USE_NATIVE_URL && typeof $fetch == 'function' && typeof Headers == 'function') {
          $({
            global: true,
            enumerable: true,
            forced: true
          }, {
            fetch: function fetch(input /* , init */) {
              var args = [input];
              var init, body, headers;
              if (arguments.length > 1) {
                init = arguments[1];
                if (isObject(init)) {
                  body = init.body;
                  if (classof(body) === URL_SEARCH_PARAMS) {
                    headers = init.headers ? new Headers(init.headers) : new Headers();
                    if (!headers.has('content-type')) {
                      headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
                    }
                    init = create(init, {
                      body: createPropertyDescriptor(0, String(body)),
                      headers: createPropertyDescriptor(0, headers)
                    });
                  }
                }
                args.push(init);
              }
              return $fetch.apply(this, args);
            }
          });
        }
        module.exports = {
          URLSearchParams: URLSearchParamsConstructor,
          getState: getInternalParamsState
        };

        /***/
      }),
      /***/285: (/***/function (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_213265__) {
        "use strict";

        // TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
        __nested_webpack_require_213265__(8783);
        var $ = __nested_webpack_require_213265__(2109);
        var DESCRIPTORS = __nested_webpack_require_213265__(9781);
        var USE_NATIVE_URL = __nested_webpack_require_213265__(590);
        var global = __nested_webpack_require_213265__(7854);
        var defineProperties = __nested_webpack_require_213265__(6048);
        var redefine = __nested_webpack_require_213265__(1320);
        var anInstance = __nested_webpack_require_213265__(5787);
        var has = __nested_webpack_require_213265__(6656);
        var assign = __nested_webpack_require_213265__(1574);
        var arrayFrom = __nested_webpack_require_213265__(8457);
        var codeAt = __nested_webpack_require_213265__(8710).codeAt;
        var toASCII = __nested_webpack_require_213265__(3197);
        var setToStringTag = __nested_webpack_require_213265__(8003);
        var URLSearchParamsModule = __nested_webpack_require_213265__(1637);
        var InternalStateModule = __nested_webpack_require_213265__(9909);
        var NativeURL = global.URL;
        var URLSearchParams = URLSearchParamsModule.URLSearchParams;
        var getInternalSearchParamsState = URLSearchParamsModule.getState;
        var setInternalState = InternalStateModule.set;
        var getInternalURLState = InternalStateModule.getterFor('URL');
        var floor = Math.floor;
        var pow = Math.pow;
        var INVALID_AUTHORITY = 'Invalid authority';
        var INVALID_SCHEME = 'Invalid scheme';
        var INVALID_HOST = 'Invalid host';
        var INVALID_PORT = 'Invalid port';
        var ALPHA = /[A-Za-z]/;
        var ALPHANUMERIC = /[\d+-.A-Za-z]/;
        var DIGIT = /\d/;
        var HEX_START = /^(0x|0X)/;
        var OCT = /^[0-7]+$/;
        var DEC = /^\d+$/;
        var HEX = /^[\dA-Fa-f]+$/;
        /* eslint-disable no-control-regex -- safe */
        var FORBIDDEN_HOST_CODE_POINT = /[\u0000\t\u000A\u000D #%/:?@[\\]]/;
        var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\u0000\t\u000A\u000D #/:?@[\\]]/;
        var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g;
        var TAB_AND_NEW_LINE = /[\t\u000A\u000D]/g;
        /* eslint-enable no-control-regex -- safe */
        var EOF;
        var parseHost = function (url, input) {
          var result, codePoints, index;
          if (input.charAt(0) == '[') {
            if (input.charAt(input.length - 1) != ']') return INVALID_HOST;
            result = parseIPv6(input.slice(1, -1));
            if (!result) return INVALID_HOST;
            url.host = result;
            // opaque host
          } else if (!isSpecial(url)) {
            if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input)) return INVALID_HOST;
            result = '';
            codePoints = arrayFrom(input);
            for (index = 0; index < codePoints.length; index++) {
              result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
            }
            url.host = result;
          } else {
            input = toASCII(input);
            if (FORBIDDEN_HOST_CODE_POINT.test(input)) return INVALID_HOST;
            result = parseIPv4(input);
            if (result === null) return INVALID_HOST;
            url.host = result;
          }
        };
        var parseIPv4 = function (input) {
          var parts = input.split('.');
          var partsLength, numbers, index, part, radix, number, ipv4;
          if (parts.length && parts[parts.length - 1] == '') {
            parts.pop();
          }
          partsLength = parts.length;
          if (partsLength > 4) return input;
          numbers = [];
          for (index = 0; index < partsLength; index++) {
            part = parts[index];
            if (part == '') return input;
            radix = 10;
            if (part.length > 1 && part.charAt(0) == '0') {
              radix = HEX_START.test(part) ? 16 : 8;
              part = part.slice(radix == 8 ? 1 : 2);
            }
            if (part === '') {
              number = 0;
            } else {
              if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part)) return input;
              number = parseInt(part, radix);
            }
            numbers.push(number);
          }
          for (index = 0; index < partsLength; index++) {
            number = numbers[index];
            if (index == partsLength - 1) {
              if (number >= pow(256, 5 - partsLength)) return null;
            } else if (number > 255) return null;
          }
          ipv4 = numbers.pop();
          for (index = 0; index < numbers.length; index++) {
            ipv4 += numbers[index] * pow(256, 3 - index);
          }
          return ipv4;
        };

        // eslint-disable-next-line max-statements -- TODO
        var parseIPv6 = function (input) {
          var address = [0, 0, 0, 0, 0, 0, 0, 0];
          var pieceIndex = 0;
          var compress = null;
          var pointer = 0;
          var value, length, numbersSeen, ipv4Piece, number, swaps, swap;
          var char = function () {
            return input.charAt(pointer);
          };
          if (char() == ':') {
            if (input.charAt(1) != ':') return;
            pointer += 2;
            pieceIndex++;
            compress = pieceIndex;
          }
          while (char()) {
            if (pieceIndex == 8) return;
            if (char() == ':') {
              if (compress !== null) return;
              pointer++;
              pieceIndex++;
              compress = pieceIndex;
              continue;
            }
            value = length = 0;
            while (length < 4 && HEX.test(char())) {
              value = value * 16 + parseInt(char(), 16);
              pointer++;
              length++;
            }
            if (char() == '.') {
              if (length == 0) return;
              pointer -= length;
              if (pieceIndex > 6) return;
              numbersSeen = 0;
              while (char()) {
                ipv4Piece = null;
                if (numbersSeen > 0) {
                  if (char() == '.' && numbersSeen < 4) pointer++;else return;
                }
                if (!DIGIT.test(char())) return;
                while (DIGIT.test(char())) {
                  number = parseInt(char(), 10);
                  if (ipv4Piece === null) ipv4Piece = number;else if (ipv4Piece == 0) return;else ipv4Piece = ipv4Piece * 10 + number;
                  if (ipv4Piece > 255) return;
                  pointer++;
                }
                address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
                numbersSeen++;
                if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
              }
              if (numbersSeen != 4) return;
              break;
            } else if (char() == ':') {
              pointer++;
              if (!char()) return;
            } else if (char()) return;
            address[pieceIndex++] = value;
          }
          if (compress !== null) {
            swaps = pieceIndex - compress;
            pieceIndex = 7;
            while (pieceIndex != 0 && swaps > 0) {
              swap = address[pieceIndex];
              address[pieceIndex--] = address[compress + swaps - 1];
              address[compress + --swaps] = swap;
            }
          } else if (pieceIndex != 8) return;
          return address;
        };
        var findLongestZeroSequence = function (ipv6) {
          var maxIndex = null;
          var maxLength = 1;
          var currStart = null;
          var currLength = 0;
          var index = 0;
          for (; index < 8; index++) {
            if (ipv6[index] !== 0) {
              if (currLength > maxLength) {
                maxIndex = currStart;
                maxLength = currLength;
              }
              currStart = null;
              currLength = 0;
            } else {
              if (currStart === null) currStart = index;
              ++currLength;
            }
          }
          if (currLength > maxLength) {
            maxIndex = currStart;
            maxLength = currLength;
          }
          return maxIndex;
        };
        var serializeHost = function (host) {
          var result, index, compress, ignore0;
          // ipv4
          if (typeof host == 'number') {
            result = [];
            for (index = 0; index < 4; index++) {
              result.unshift(host % 256);
              host = floor(host / 256);
            }
            return result.join('.');
            // ipv6
          } else if (typeof host == 'object') {
            result = '';
            compress = findLongestZeroSequence(host);
            for (index = 0; index < 8; index++) {
              if (ignore0 && host[index] === 0) continue;
              if (ignore0) ignore0 = false;
              if (compress === index) {
                result += index ? ':' : '::';
                ignore0 = true;
              } else {
                result += host[index].toString(16);
                if (index < 7) result += ':';
              }
            }
            return '[' + result + ']';
          }
          return host;
        };
        var C0ControlPercentEncodeSet = {};
        var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
          ' ': 1,
          '"': 1,
          '<': 1,
          '>': 1,
          '`': 1
        });
        var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
          '#': 1,
          '?': 1,
          '{': 1,
          '}': 1
        });
        var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
          '/': 1,
          ':': 1,
          ';': 1,
          '=': 1,
          '@': 1,
          '[': 1,
          '\\': 1,
          ']': 1,
          '^': 1,
          '|': 1
        });
        var percentEncode = function (char, set) {
          var code = codeAt(char, 0);
          return code > 0x20 && code < 0x7F && !has(set, char) ? char : encodeURIComponent(char);
        };
        var specialSchemes = {
          ftp: 21,
          file: null,
          http: 80,
          https: 443,
          ws: 80,
          wss: 443
        };
        var isSpecial = function (url) {
          return has(specialSchemes, url.scheme);
        };
        var includesCredentials = function (url) {
          return url.username != '' || url.password != '';
        };
        var cannotHaveUsernamePasswordPort = function (url) {
          return !url.host || url.cannotBeABaseURL || url.scheme == 'file';
        };
        var isWindowsDriveLetter = function (string, normalized) {
          var second;
          return string.length == 2 && ALPHA.test(string.charAt(0)) && ((second = string.charAt(1)) == ':' || !normalized && second == '|');
        };
        var startsWithWindowsDriveLetter = function (string) {
          var third;
          return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (string.length == 2 || (third = string.charAt(2)) === '/' || third === '\\' || third === '?' || third === '#');
        };
        var shortenURLsPath = function (url) {
          var path = url.path;
          var pathSize = path.length;
          if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
            path.pop();
          }
        };
        var isSingleDot = function (segment) {
          return segment === '.' || segment.toLowerCase() === '%2e';
        };
        var isDoubleDot = function (segment) {
          segment = segment.toLowerCase();
          return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
        };

        // States:
        var SCHEME_START = {};
        var SCHEME = {};
        var NO_SCHEME = {};
        var SPECIAL_RELATIVE_OR_AUTHORITY = {};
        var PATH_OR_AUTHORITY = {};
        var RELATIVE = {};
        var RELATIVE_SLASH = {};
        var SPECIAL_AUTHORITY_SLASHES = {};
        var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
        var AUTHORITY = {};
        var HOST = {};
        var HOSTNAME = {};
        var PORT = {};
        var FILE = {};
        var FILE_SLASH = {};
        var FILE_HOST = {};
        var PATH_START = {};
        var PATH = {};
        var CANNOT_BE_A_BASE_URL_PATH = {};
        var QUERY = {};
        var FRAGMENT = {};

        // eslint-disable-next-line max-statements -- TODO
        var parseURL = function (url, input, stateOverride, base) {
          var state = stateOverride || SCHEME_START;
          var pointer = 0;
          var buffer = '';
          var seenAt = false;
          var seenBracket = false;
          var seenPasswordToken = false;
          var codePoints, char, bufferCodePoints, failure;
          if (!stateOverride) {
            url.scheme = '';
            url.username = '';
            url.password = '';
            url.host = null;
            url.port = null;
            url.path = [];
            url.query = null;
            url.fragment = null;
            url.cannotBeABaseURL = false;
            input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
          }
          input = input.replace(TAB_AND_NEW_LINE, '');
          codePoints = arrayFrom(input);
          while (pointer <= codePoints.length) {
            char = codePoints[pointer];
            switch (state) {
              case SCHEME_START:
                if (char && ALPHA.test(char)) {
                  buffer += char.toLowerCase();
                  state = SCHEME;
                } else if (!stateOverride) {
                  state = NO_SCHEME;
                  continue;
                } else return INVALID_SCHEME;
                break;
              case SCHEME:
                if (char && (ALPHANUMERIC.test(char) || char == '+' || char == '-' || char == '.')) {
                  buffer += char.toLowerCase();
                } else if (char == ':') {
                  if (stateOverride && (isSpecial(url) != has(specialSchemes, buffer) || buffer == 'file' && (includesCredentials(url) || url.port !== null) || url.scheme == 'file' && !url.host)) return;
                  url.scheme = buffer;
                  if (stateOverride) {
                    if (isSpecial(url) && specialSchemes[url.scheme] == url.port) url.port = null;
                    return;
                  }
                  buffer = '';
                  if (url.scheme == 'file') {
                    state = FILE;
                  } else if (isSpecial(url) && base && base.scheme == url.scheme) {
                    state = SPECIAL_RELATIVE_OR_AUTHORITY;
                  } else if (isSpecial(url)) {
                    state = SPECIAL_AUTHORITY_SLASHES;
                  } else if (codePoints[pointer + 1] == '/') {
                    state = PATH_OR_AUTHORITY;
                    pointer++;
                  } else {
                    url.cannotBeABaseURL = true;
                    url.path.push('');
                    state = CANNOT_BE_A_BASE_URL_PATH;
                  }
                } else if (!stateOverride) {
                  buffer = '';
                  state = NO_SCHEME;
                  pointer = 0;
                  continue;
                } else return INVALID_SCHEME;
                break;
              case NO_SCHEME:
                if (!base || base.cannotBeABaseURL && char != '#') return INVALID_SCHEME;
                if (base.cannotBeABaseURL && char == '#') {
                  url.scheme = base.scheme;
                  url.path = base.path.slice();
                  url.query = base.query;
                  url.fragment = '';
                  url.cannotBeABaseURL = true;
                  state = FRAGMENT;
                  break;
                }
                state = base.scheme == 'file' ? FILE : RELATIVE;
                continue;
              case SPECIAL_RELATIVE_OR_AUTHORITY:
                if (char == '/' && codePoints[pointer + 1] == '/') {
                  state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                  pointer++;
                } else {
                  state = RELATIVE;
                  continue;
                }
                break;
              case PATH_OR_AUTHORITY:
                if (char == '/') {
                  state = AUTHORITY;
                  break;
                } else {
                  state = PATH;
                  continue;
                }
              case RELATIVE:
                url.scheme = base.scheme;
                if (char == EOF) {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  url.path = base.path.slice();
                  url.query = base.query;
                } else if (char == '/' || char == '\\' && isSpecial(url)) {
                  state = RELATIVE_SLASH;
                } else if (char == '?') {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  url.path = base.path.slice();
                  url.query = '';
                  state = QUERY;
                } else if (char == '#') {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  url.path = base.path.slice();
                  url.query = base.query;
                  url.fragment = '';
                  state = FRAGMENT;
                } else {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  url.path = base.path.slice();
                  url.path.pop();
                  state = PATH;
                  continue;
                }
                break;
              case RELATIVE_SLASH:
                if (isSpecial(url) && (char == '/' || char == '\\')) {
                  state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                } else if (char == '/') {
                  state = AUTHORITY;
                } else {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  state = PATH;
                  continue;
                }
                break;
              case SPECIAL_AUTHORITY_SLASHES:
                state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                if (char != '/' || buffer.charAt(pointer + 1) != '/') continue;
                pointer++;
                break;
              case SPECIAL_AUTHORITY_IGNORE_SLASHES:
                if (char != '/' && char != '\\') {
                  state = AUTHORITY;
                  continue;
                }
                break;
              case AUTHORITY:
                if (char == '@') {
                  if (seenAt) buffer = '%40' + buffer;
                  seenAt = true;
                  bufferCodePoints = arrayFrom(buffer);
                  for (var i = 0; i < bufferCodePoints.length; i++) {
                    var codePoint = bufferCodePoints[i];
                    if (codePoint == ':' && !seenPasswordToken) {
                      seenPasswordToken = true;
                      continue;
                    }
                    var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
                    if (seenPasswordToken) url.password += encodedCodePoints;else url.username += encodedCodePoints;
                  }
                  buffer = '';
                } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\' && isSpecial(url)) {
                  if (seenAt && buffer == '') return INVALID_AUTHORITY;
                  pointer -= arrayFrom(buffer).length + 1;
                  buffer = '';
                  state = HOST;
                } else buffer += char;
                break;
              case HOST:
              case HOSTNAME:
                if (stateOverride && url.scheme == 'file') {
                  state = FILE_HOST;
                  continue;
                } else if (char == ':' && !seenBracket) {
                  if (buffer == '') return INVALID_HOST;
                  failure = parseHost(url, buffer);
                  if (failure) return failure;
                  buffer = '';
                  state = PORT;
                  if (stateOverride == HOSTNAME) return;
                } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\' && isSpecial(url)) {
                  if (isSpecial(url) && buffer == '') return INVALID_HOST;
                  if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null)) return;
                  failure = parseHost(url, buffer);
                  if (failure) return failure;
                  buffer = '';
                  state = PATH_START;
                  if (stateOverride) return;
                  continue;
                } else {
                  if (char == '[') seenBracket = true;else if (char == ']') seenBracket = false;
                  buffer += char;
                }
                break;
              case PORT:
                if (DIGIT.test(char)) {
                  buffer += char;
                } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\' && isSpecial(url) || stateOverride) {
                  if (buffer != '') {
                    var port = parseInt(buffer, 10);
                    if (port > 0xFFFF) return INVALID_PORT;
                    url.port = isSpecial(url) && port === specialSchemes[url.scheme] ? null : port;
                    buffer = '';
                  }
                  if (stateOverride) return;
                  state = PATH_START;
                  continue;
                } else return INVALID_PORT;
                break;
              case FILE:
                url.scheme = 'file';
                if (char == '/' || char == '\\') state = FILE_SLASH;else if (base && base.scheme == 'file') {
                  if (char == EOF) {
                    url.host = base.host;
                    url.path = base.path.slice();
                    url.query = base.query;
                  } else if (char == '?') {
                    url.host = base.host;
                    url.path = base.path.slice();
                    url.query = '';
                    state = QUERY;
                  } else if (char == '#') {
                    url.host = base.host;
                    url.path = base.path.slice();
                    url.query = base.query;
                    url.fragment = '';
                    state = FRAGMENT;
                  } else {
                    if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
                      url.host = base.host;
                      url.path = base.path.slice();
                      shortenURLsPath(url);
                    }
                    state = PATH;
                    continue;
                  }
                } else {
                  state = PATH;
                  continue;
                }
                break;
              case FILE_SLASH:
                if (char == '/' || char == '\\') {
                  state = FILE_HOST;
                  break;
                }
                if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
                  if (isWindowsDriveLetter(base.path[0], true)) url.path.push(base.path[0]);else url.host = base.host;
                }
                state = PATH;
                continue;
              case FILE_HOST:
                if (char == EOF || char == '/' || char == '\\' || char == '?' || char == '#') {
                  if (!stateOverride && isWindowsDriveLetter(buffer)) {
                    state = PATH;
                  } else if (buffer == '') {
                    url.host = '';
                    if (stateOverride) return;
                    state = PATH_START;
                  } else {
                    failure = parseHost(url, buffer);
                    if (failure) return failure;
                    if (url.host == 'localhost') url.host = '';
                    if (stateOverride) return;
                    buffer = '';
                    state = PATH_START;
                  }
                  continue;
                } else buffer += char;
                break;
              case PATH_START:
                if (isSpecial(url)) {
                  state = PATH;
                  if (char != '/' && char != '\\') continue;
                } else if (!stateOverride && char == '?') {
                  url.query = '';
                  state = QUERY;
                } else if (!stateOverride && char == '#') {
                  url.fragment = '';
                  state = FRAGMENT;
                } else if (char != EOF) {
                  state = PATH;
                  if (char != '/') continue;
                }
                break;
              case PATH:
                if (char == EOF || char == '/' || char == '\\' && isSpecial(url) || !stateOverride && (char == '?' || char == '#')) {
                  if (isDoubleDot(buffer)) {
                    shortenURLsPath(url);
                    if (char != '/' && !(char == '\\' && isSpecial(url))) {
                      url.path.push('');
                    }
                  } else if (isSingleDot(buffer)) {
                    if (char != '/' && !(char == '\\' && isSpecial(url))) {
                      url.path.push('');
                    }
                  } else {
                    if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
                      if (url.host) url.host = '';
                      buffer = buffer.charAt(0) + ':'; // normalize windows drive letter
                    }
                    url.path.push(buffer);
                  }
                  buffer = '';
                  if (url.scheme == 'file' && (char == EOF || char == '?' || char == '#')) {
                    while (url.path.length > 1 && url.path[0] === '') {
                      url.path.shift();
                    }
                  }
                  if (char == '?') {
                    url.query = '';
                    state = QUERY;
                  } else if (char == '#') {
                    url.fragment = '';
                    state = FRAGMENT;
                  }
                } else {
                  buffer += percentEncode(char, pathPercentEncodeSet);
                }
                break;
              case CANNOT_BE_A_BASE_URL_PATH:
                if (char == '?') {
                  url.query = '';
                  state = QUERY;
                } else if (char == '#') {
                  url.fragment = '';
                  state = FRAGMENT;
                } else if (char != EOF) {
                  url.path[0] += percentEncode(char, C0ControlPercentEncodeSet);
                }
                break;
              case QUERY:
                if (!stateOverride && char == '#') {
                  url.fragment = '';
                  state = FRAGMENT;
                } else if (char != EOF) {
                  if (char == "'" && isSpecial(url)) url.query += '%27';else if (char == '#') url.query += '%23';else url.query += percentEncode(char, C0ControlPercentEncodeSet);
                }
                break;
              case FRAGMENT:
                if (char != EOF) url.fragment += percentEncode(char, fragmentPercentEncodeSet);
                break;
            }
            pointer++;
          }
        };

        // `URL` constructor
        // https://url.spec.whatwg.org/#url-class
        var URLConstructor = function URL(url /* , base */) {
          var that = anInstance(this, URLConstructor, 'URL');
          var base = arguments.length > 1 ? arguments[1] : undefined;
          var urlString = String(url);
          var state = setInternalState(that, {
            type: 'URL'
          });
          var baseState, failure;
          if (base !== undefined) {
            if (base instanceof URLConstructor) baseState = getInternalURLState(base);else {
              failure = parseURL(baseState = {}, String(base));
              if (failure) throw TypeError(failure);
            }
          }
          failure = parseURL(state, urlString, null, baseState);
          if (failure) throw TypeError(failure);
          var searchParams = state.searchParams = new URLSearchParams();
          var searchParamsState = getInternalSearchParamsState(searchParams);
          searchParamsState.updateSearchParams(state.query);
          searchParamsState.updateURL = function () {
            state.query = String(searchParams) || null;
          };
          if (!DESCRIPTORS) {
            that.href = serializeURL.call(that);
            that.origin = getOrigin.call(that);
            that.protocol = getProtocol.call(that);
            that.username = getUsername.call(that);
            that.password = getPassword.call(that);
            that.host = getHost.call(that);
            that.hostname = getHostname.call(that);
            that.port = getPort.call(that);
            that.pathname = getPathname.call(that);
            that.search = getSearch.call(that);
            that.searchParams = getSearchParams.call(that);
            that.hash = getHash.call(that);
          }
        };
        var URLPrototype = URLConstructor.prototype;
        var serializeURL = function () {
          var url = getInternalURLState(this);
          var scheme = url.scheme;
          var username = url.username;
          var password = url.password;
          var host = url.host;
          var port = url.port;
          var path = url.path;
          var query = url.query;
          var fragment = url.fragment;
          var output = scheme + ':';
          if (host !== null) {
            output += '//';
            if (includesCredentials(url)) {
              output += username + (password ? ':' + password : '') + '@';
            }
            output += serializeHost(host);
            if (port !== null) output += ':' + port;
          } else if (scheme == 'file') output += '//';
          output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
          if (query !== null) output += '?' + query;
          if (fragment !== null) output += '#' + fragment;
          return output;
        };
        var getOrigin = function () {
          var url = getInternalURLState(this);
          var scheme = url.scheme;
          var port = url.port;
          if (scheme == 'blob') try {
            return new URL(scheme.path[0]).origin;
          } catch (error) {
            return 'null';
          }
          if (scheme == 'file' || !isSpecial(url)) return 'null';
          return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');
        };
        var getProtocol = function () {
          return getInternalURLState(this).scheme + ':';
        };
        var getUsername = function () {
          return getInternalURLState(this).username;
        };
        var getPassword = function () {
          return getInternalURLState(this).password;
        };
        var getHost = function () {
          var url = getInternalURLState(this);
          var host = url.host;
          var port = url.port;
          return host === null ? '' : port === null ? serializeHost(host) : serializeHost(host) + ':' + port;
        };
        var getHostname = function () {
          var host = getInternalURLState(this).host;
          return host === null ? '' : serializeHost(host);
        };
        var getPort = function () {
          var port = getInternalURLState(this).port;
          return port === null ? '' : String(port);
        };
        var getPathname = function () {
          var url = getInternalURLState(this);
          var path = url.path;
          return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
        };
        var getSearch = function () {
          var query = getInternalURLState(this).query;
          return query ? '?' + query : '';
        };
        var getSearchParams = function () {
          return getInternalURLState(this).searchParams;
        };
        var getHash = function () {
          var fragment = getInternalURLState(this).fragment;
          return fragment ? '#' + fragment : '';
        };
        var accessorDescriptor = function (getter, setter) {
          return {
            get: getter,
            set: setter,
            configurable: true,
            enumerable: true
          };
        };
        if (DESCRIPTORS) {
          defineProperties(URLPrototype, {
            // `URL.prototype.href` accessors pair
            // https://url.spec.whatwg.org/#dom-url-href
            href: accessorDescriptor(serializeURL, function (href) {
              var url = getInternalURLState(this);
              var urlString = String(href);
              var failure = parseURL(url, urlString);
              if (failure) throw TypeError(failure);
              getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
            }),
            // `URL.prototype.origin` getter
            // https://url.spec.whatwg.org/#dom-url-origin
            origin: accessorDescriptor(getOrigin),
            // `URL.prototype.protocol` accessors pair
            // https://url.spec.whatwg.org/#dom-url-protocol
            protocol: accessorDescriptor(getProtocol, function (protocol) {
              var url = getInternalURLState(this);
              parseURL(url, String(protocol) + ':', SCHEME_START);
            }),
            // `URL.prototype.username` accessors pair
            // https://url.spec.whatwg.org/#dom-url-username
            username: accessorDescriptor(getUsername, function (username) {
              var url = getInternalURLState(this);
              var codePoints = arrayFrom(String(username));
              if (cannotHaveUsernamePasswordPort(url)) return;
              url.username = '';
              for (var i = 0; i < codePoints.length; i++) {
                url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
              }
            }),
            // `URL.prototype.password` accessors pair
            // https://url.spec.whatwg.org/#dom-url-password
            password: accessorDescriptor(getPassword, function (password) {
              var url = getInternalURLState(this);
              var codePoints = arrayFrom(String(password));
              if (cannotHaveUsernamePasswordPort(url)) return;
              url.password = '';
              for (var i = 0; i < codePoints.length; i++) {
                url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
              }
            }),
            // `URL.prototype.host` accessors pair
            // https://url.spec.whatwg.org/#dom-url-host
            host: accessorDescriptor(getHost, function (host) {
              var url = getInternalURLState(this);
              if (url.cannotBeABaseURL) return;
              parseURL(url, String(host), HOST);
            }),
            // `URL.prototype.hostname` accessors pair
            // https://url.spec.whatwg.org/#dom-url-hostname
            hostname: accessorDescriptor(getHostname, function (hostname) {
              var url = getInternalURLState(this);
              if (url.cannotBeABaseURL) return;
              parseURL(url, String(hostname), HOSTNAME);
            }),
            // `URL.prototype.port` accessors pair
            // https://url.spec.whatwg.org/#dom-url-port
            port: accessorDescriptor(getPort, function (port) {
              var url = getInternalURLState(this);
              if (cannotHaveUsernamePasswordPort(url)) return;
              port = String(port);
              if (port == '') url.port = null;else parseURL(url, port, PORT);
            }),
            // `URL.prototype.pathname` accessors pair
            // https://url.spec.whatwg.org/#dom-url-pathname
            pathname: accessorDescriptor(getPathname, function (pathname) {
              var url = getInternalURLState(this);
              if (url.cannotBeABaseURL) return;
              url.path = [];
              parseURL(url, pathname + '', PATH_START);
            }),
            // `URL.prototype.search` accessors pair
            // https://url.spec.whatwg.org/#dom-url-search
            search: accessorDescriptor(getSearch, function (search) {
              var url = getInternalURLState(this);
              search = String(search);
              if (search == '') {
                url.query = null;
              } else {
                if ('?' == search.charAt(0)) search = search.slice(1);
                url.query = '';
                parseURL(url, search, QUERY);
              }
              getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
            }),
            // `URL.prototype.searchParams` getter
            // https://url.spec.whatwg.org/#dom-url-searchparams
            searchParams: accessorDescriptor(getSearchParams),
            // `URL.prototype.hash` accessors pair
            // https://url.spec.whatwg.org/#dom-url-hash
            hash: accessorDescriptor(getHash, function (hash) {
              var url = getInternalURLState(this);
              hash = String(hash);
              if (hash == '') {
                url.fragment = null;
                return;
              }
              if ('#' == hash.charAt(0)) hash = hash.slice(1);
              url.fragment = '';
              parseURL(url, hash, FRAGMENT);
            })
          });
        }

        // `URL.prototype.toJSON` method
        // https://url.spec.whatwg.org/#dom-url-tojson
        redefine(URLPrototype, 'toJSON', function toJSON() {
          return serializeURL.call(this);
        }, {
          enumerable: true
        });

        // `URL.prototype.toString` method
        // https://url.spec.whatwg.org/#URL-stringification-behavior
        redefine(URLPrototype, 'toString', function toString() {
          return serializeURL.call(this);
        }, {
          enumerable: true
        });
        if (NativeURL) {
          var nativeCreateObjectURL = NativeURL.createObjectURL;
          var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
          // `URL.createObjectURL` method
          // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
          // eslint-disable-next-line no-unused-vars -- required for `.length`
          if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) {
            return nativeCreateObjectURL.apply(NativeURL, arguments);
          });
          // `URL.revokeObjectURL` method
          // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
          // eslint-disable-next-line no-unused-vars -- required for `.length`
          if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) {
            return nativeRevokeObjectURL.apply(NativeURL, arguments);
          });
        }
        setToStringTag(URLConstructor, 'URL');
        $({
          global: true,
          forced: !USE_NATIVE_URL,
          sham: !DESCRIPTORS
        }, {
          URL: URLConstructor
        });

        /***/
      })

      /******/
    };
    /************************************************************************/
    /******/ // The module cache
    /******/
    var __webpack_module_cache__ = {};
    /******/
    /******/ // The require function
    /******/
    function __nested_webpack_require_253329__(moduleId) {
      /******/ // Check if module is in cache
      /******/if (__webpack_module_cache__[moduleId]) {
        /******/return __webpack_module_cache__[moduleId].exports;
        /******/
      }
      /******/ // Create a new module (and put it into the cache)
      /******/
      var module = __webpack_module_cache__[moduleId] = {
        /******/ // no module.id needed
        /******/ // no module.loaded needed
        /******/exports: {}
        /******/
      };
      /******/
      /******/ // Execute the module function
      /******/
      __webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_253329__);
      /******/
      /******/ // Return the exports of the module
      /******/
      return module.exports;
      /******/
    }
    /******/
    /************************************************************************/
    /******/ /* webpack/runtime/define property getters */
    /******/
    !function () {
      /******/ // define getter functions for harmony exports
      /******/__nested_webpack_require_253329__.d = function (exports, definition) {
        /******/for (var key in definition) {
          /******/if (__nested_webpack_require_253329__.o(definition, key) && !__nested_webpack_require_253329__.o(exports, key)) {
            /******/Object.defineProperty(exports, key, {
              enumerable: true,
              get: definition[key]
            });
            /******/
          }
          /******/
        }
        /******/
      };
      /******/
    }();
    /******/
    /******/ /* webpack/runtime/global */
    /******/
    !function () {
      /******/__nested_webpack_require_253329__.g = function () {
        /******/if (typeof globalThis === 'object') return globalThis;
        /******/
        try {
          /******/return this || new Function('return this')();
          /******/
        } catch (e) {
          /******/if (typeof window === 'object') return window;
          /******/
        }
        /******/
      }();
      /******/
    }();
    /******/
    /******/ /* webpack/runtime/hasOwnProperty shorthand */
    /******/
    !function () {
      /******/__nested_webpack_require_253329__.o = function (obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      };
      /******/
    }();
    /******/
    /******/ /* webpack/runtime/make namespace object */
    /******/
    !function () {
      /******/ // define __esModule on exports
      /******/__nested_webpack_require_253329__.r = function (exports) {
        /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
          /******/Object.defineProperty(exports, Symbol.toStringTag, {
            value: 'Module'
          });
          /******/
        }
        /******/
        Object.defineProperty(exports, '__esModule', {
          value: true
        });
        /******/
      };
      /******/
    }();
    /******/
    /************************************************************************/
    var __nested_webpack_exports__ = {};
    // This entry need to be wrapped in an IIFE because it need to be in strict mode.
    !function () {
      "use strict";

      // ESM COMPAT FLAG
      __nested_webpack_require_253329__.r(__nested_webpack_exports__);

      // EXPORTS
      __nested_webpack_require_253329__.d(__nested_webpack_exports__, {
        "Dropzone": function () {
          return /* reexport */Dropzone;
        },
        "default": function () {
          return /* binding */dropzone_dist;
        }
      });

      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.concat.js
      var es_array_concat = __nested_webpack_require_253329__(2222);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.filter.js
      var es_array_filter = __nested_webpack_require_253329__(7327);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.index-of.js
      var es_array_index_of = __nested_webpack_require_253329__(2772);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.iterator.js
      var es_array_iterator = __nested_webpack_require_253329__(6992);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.map.js
      var es_array_map = __nested_webpack_require_253329__(1249);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.slice.js
      var es_array_slice = __nested_webpack_require_253329__(7042);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.splice.js
      var es_array_splice = __nested_webpack_require_253329__(561);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array-buffer.constructor.js
      var es_array_buffer_constructor = __nested_webpack_require_253329__(8264);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.function.name.js
      var es_function_name = __nested_webpack_require_253329__(8309);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.get-prototype-of.js
      var es_object_get_prototype_of = __nested_webpack_require_253329__(489);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
      var es_object_to_string = __nested_webpack_require_253329__(1539);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.exec.js
      var es_regexp_exec = __nested_webpack_require_253329__(4916);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.to-string.js
      var es_regexp_to_string = __nested_webpack_require_253329__(9714);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.iterator.js
      var es_string_iterator = __nested_webpack_require_253329__(8783);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.match.js
      var es_string_match = __nested_webpack_require_253329__(4723);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.replace.js
      var es_string_replace = __nested_webpack_require_253329__(5306);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.split.js
      var es_string_split = __nested_webpack_require_253329__(3123);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.trim.js
      var es_string_trim = __nested_webpack_require_253329__(3210);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.uint8-array.js
      var es_typed_array_uint8_array = __nested_webpack_require_253329__(2472);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.copy-within.js
      var es_typed_array_copy_within = __nested_webpack_require_253329__(2990);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.every.js
      var es_typed_array_every = __nested_webpack_require_253329__(8927);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.fill.js
      var es_typed_array_fill = __nested_webpack_require_253329__(3105);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.filter.js
      var es_typed_array_filter = __nested_webpack_require_253329__(5035);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.find.js
      var es_typed_array_find = __nested_webpack_require_253329__(4345);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.find-index.js
      var es_typed_array_find_index = __nested_webpack_require_253329__(7174);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.for-each.js
      var es_typed_array_for_each = __nested_webpack_require_253329__(2846);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.includes.js
      var es_typed_array_includes = __nested_webpack_require_253329__(4731);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.index-of.js
      var es_typed_array_index_of = __nested_webpack_require_253329__(7209);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.iterator.js
      var es_typed_array_iterator = __nested_webpack_require_253329__(6319);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.join.js
      var es_typed_array_join = __nested_webpack_require_253329__(8867);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.last-index-of.js
      var es_typed_array_last_index_of = __nested_webpack_require_253329__(7789);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.map.js
      var es_typed_array_map = __nested_webpack_require_253329__(3739);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.reduce.js
      var es_typed_array_reduce = __nested_webpack_require_253329__(9368);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.reduce-right.js
      var es_typed_array_reduce_right = __nested_webpack_require_253329__(4483);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.reverse.js
      var es_typed_array_reverse = __nested_webpack_require_253329__(2056);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.set.js
      var es_typed_array_set = __nested_webpack_require_253329__(3462);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.slice.js
      var es_typed_array_slice = __nested_webpack_require_253329__(678);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.some.js
      var es_typed_array_some = __nested_webpack_require_253329__(7462);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.sort.js
      var es_typed_array_sort = __nested_webpack_require_253329__(3824);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.subarray.js
      var es_typed_array_subarray = __nested_webpack_require_253329__(5021);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.to-locale-string.js
      var es_typed_array_to_locale_string = __nested_webpack_require_253329__(2974);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.to-string.js
      var es_typed_array_to_string = __nested_webpack_require_253329__(5016);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.for-each.js
      var web_dom_collections_for_each = __nested_webpack_require_253329__(4747);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.iterator.js
      var web_dom_collections_iterator = __nested_webpack_require_253329__(3948);
      // EXTERNAL MODULE: ./node_modules/core-js/modules/web.url.js
      var web_url = __nested_webpack_require_253329__(285);
      ; // CONCATENATED MODULE: ./src/emitter.js

      function _createForOfIteratorHelper(o, allowArrayLike) {
        var it;
        if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
          if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
              s: F,
              n: function n() {
                if (i >= o.length) return {
                  done: true
                };
                return {
                  done: false,
                  value: o[i++]
                };
              },
              e: function e(_e) {
                throw _e;
              },
              f: F
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true,
          didErr = false,
          err;
        return {
          s: function s() {
            it = o[Symbol.iterator]();
          },
          n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
          },
          e: function e(_e2) {
            didErr = true;
            err = _e2;
          },
          f: function f() {
            try {
              if (!normalCompletion && it.return != null) it.return();
            } finally {
              if (didErr) throw err;
            }
          }
        };
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      // The Emitter class provides the ability to call `.on()` on Dropzone to listen
      // to events.
      // It is strongly based on component's emitter class, and I removed the
      // functionality because of the dependency hell with different frameworks.
      var Emitter = /*#__PURE__*/function () {
        function Emitter() {
          _classCallCheck(this, Emitter);
        }
        _createClass(Emitter, [{
          key: "on",
          value:
          // Add an event listener for given event
          function on(event, fn) {
            this._callbacks = this._callbacks || {}; // Create namespace for this event

            if (!this._callbacks[event]) {
              this._callbacks[event] = [];
            }
            this._callbacks[event].push(fn);
            return this;
          }
        }, {
          key: "emit",
          value: function emit(event) {
            this._callbacks = this._callbacks || {};
            var callbacks = this._callbacks[event];
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            if (callbacks) {
              var _iterator = _createForOfIteratorHelper(callbacks, true),
                _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  var callback = _step.value;
                  callback.apply(this, args);
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            } // trigger a corresponding DOM event

            if (this.element) {
              this.element.dispatchEvent(this.makeEvent("dropzone:" + event, {
                args: args
              }));
            }
            return this;
          }
        }, {
          key: "makeEvent",
          value: function makeEvent(eventName, detail) {
            var params = {
              bubbles: true,
              cancelable: true,
              detail: detail
            };
            if (typeof window.CustomEvent === "function") {
              return new CustomEvent(eventName, params);
            } else {
              // IE 11 support
              // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent
              var evt = document.createEvent("CustomEvent");
              evt.initCustomEvent(eventName, params.bubbles, params.cancelable, params.detail);
              return evt;
            }
          } // Remove event listener for given event. If fn is not provided, all event
          // listeners for that event will be removed. If neither is provided, all
          // event listeners will be removed.
        }, {
          key: "off",
          value: function off(event, fn) {
            if (!this._callbacks || arguments.length === 0) {
              this._callbacks = {};
              return this;
            } // specific event

            var callbacks = this._callbacks[event];
            if (!callbacks) {
              return this;
            } // remove all handlers

            if (arguments.length === 1) {
              delete this._callbacks[event];
              return this;
            } // remove specific handler

            for (var i = 0; i < callbacks.length; i++) {
              var callback = callbacks[i];
              if (callback === fn) {
                callbacks.splice(i, 1);
                break;
              }
            }
            return this;
          }
        }]);
        return Emitter;
      }();
      ; // CONCATENATED MODULE: ./src/preview-template.html
      // Module
      var code = "<div class=\"dz-preview dz-file-preview\"> <div class=\"dz-image\"><img data-dz-thumbnail/></div> <div class=\"dz-details\"> <div class=\"dz-size\"><span data-dz-size></span></div> <div class=\"dz-filename\"><span data-dz-name></span></div> </div> <div class=\"dz-progress\"> <span class=\"dz-upload\" data-dz-uploadprogress></span> </div> <div class=\"dz-error-message\"><span data-dz-errormessage></span></div> <div class=\"dz-success-mark\"> <svg width=\"54px\" height=\"54px\" viewBox=\"0 0 54 54\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"> <title>Check</title> <g stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\"> <path d=\"M23.5,31.8431458 L17.5852419,25.9283877 C16.0248253,24.3679711 13.4910294,24.366835 11.9289322,25.9289322 C10.3700136,27.4878508 10.3665912,30.0234455 11.9283877,31.5852419 L20.4147581,40.0716123 C20.5133999,40.1702541 20.6159315,40.2626649 20.7218615,40.3488435 C22.2835669,41.8725651 24.794234,41.8626202 26.3461564,40.3106978 L43.3106978,23.3461564 C44.8771021,21.7797521 44.8758057,19.2483887 43.3137085,17.6862915 C41.7547899,16.1273729 39.2176035,16.1255422 37.6538436,17.6893022 L23.5,31.8431458 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\" stroke-opacity=\"0.198794158\" stroke=\"#747474\" fill-opacity=\"0.816519475\" fill=\"#FFFFFF\"></path> </g> </svg> </div> <div class=\"dz-error-mark\"> <svg width=\"54px\" height=\"54px\" viewBox=\"0 0 54 54\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"> <title>Error</title> <g stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\"> <g stroke=\"#747474\" stroke-opacity=\"0.198794158\" fill=\"#FFFFFF\" fill-opacity=\"0.816519475\"> <path d=\"M32.6568542,29 L38.3106978,23.3461564 C39.8771021,21.7797521 39.8758057,19.2483887 38.3137085,17.6862915 C36.7547899,16.1273729 34.2176035,16.1255422 32.6538436,17.6893022 L27,23.3431458 L21.3461564,17.6893022 C19.7823965,16.1255422 17.2452101,16.1273729 15.6862915,17.6862915 C14.1241943,19.2483887 14.1228979,21.7797521 15.6893022,23.3461564 L21.3431458,29 L15.6893022,34.6538436 C14.1228979,36.2202479 14.1241943,38.7516113 15.6862915,40.3137085 C17.2452101,41.8726271 19.7823965,41.8744578 21.3461564,40.3106978 L27,34.6568542 L32.6538436,40.3106978 C34.2176035,41.8744578 36.7547899,41.8726271 38.3137085,40.3137085 C39.8758057,38.7516113 39.8771021,36.2202479 38.3106978,34.6538436 L32.6568542,29 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\"></path> </g> </g> </svg> </div> </div> ";
      // Exports
      /* harmony default export */
      var preview_template = code;
      ; // CONCATENATED MODULE: ./src/options.js

      function options_createForOfIteratorHelper(o, allowArrayLike) {
        var it;
        if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
          if (Array.isArray(o) || (it = options_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
              s: F,
              n: function n() {
                if (i >= o.length) return {
                  done: true
                };
                return {
                  done: false,
                  value: o[i++]
                };
              },
              e: function e(_e) {
                throw _e;
              },
              f: F
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true,
          didErr = false,
          err;
        return {
          s: function s() {
            it = o[Symbol.iterator]();
          },
          n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
          },
          e: function e(_e2) {
            didErr = true;
            err = _e2;
          },
          f: function f() {
            try {
              if (!normalCompletion && it.return != null) it.return();
            } finally {
              if (didErr) throw err;
            }
          }
        };
      }
      function options_unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return options_arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return options_arrayLikeToArray(o, minLen);
      }
      function options_arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      var defaultOptions = {
        /**
         * Has to be specified on elements other than form (or when the form
         * doesn't have an `action` attribute). You can also
         * provide a function that will be called with `files` and
         * must return the url (since `v3.12.0`)
         */
        url: null,
        /**
         * Can be changed to `"put"` if necessary. You can also provide a function
         * that will be called with `files` and must return the method (since `v3.12.0`).
         */
        method: "post",
        /**
         * Will be set on the XHRequest.
         */
        withCredentials: false,
        /**
         * The timeout for the XHR requests in milliseconds (since `v4.4.0`).
         * If set to null or 0, no timeout is going to be set.
         */
        timeout: null,
        /**
         * How many file uploads to process in parallel (See the
         * Enqueuing file uploads documentation section for more info)
         */
        parallelUploads: 2,
        /**
         * Whether to send multiple files in one request. If
         * this it set to true, then the fallback file input element will
         * have the `multiple` attribute as well. This option will
         * also trigger additional events (like `processingmultiple`). See the events
         * documentation section for more information.
         */
        uploadMultiple: false,
        /**
         * Whether you want files to be uploaded in chunks to your server. This can't be
         * used in combination with `uploadMultiple`.
         *
         * See [chunksUploaded](#config-chunksUploaded) for the callback to finalise an upload.
         */
        chunking: false,
        /**
         * If `chunking` is enabled, this defines whether **every** file should be chunked,
         * even if the file size is below chunkSize. This means, that the additional chunk
         * form data will be submitted and the `chunksUploaded` callback will be invoked.
         */
        forceChunking: false,
        /**
         * If `chunking` is `true`, then this defines the chunk size in bytes.
         */
        chunkSize: 2000000,
        /**
         * If `true`, the individual chunks of a file are being uploaded simultaneously.
         */
        parallelChunkUploads: false,
        /**
         * Whether a chunk should be retried if it fails.
         */
        retryChunks: false,
        /**
         * If `retryChunks` is true, how many times should it be retried.
         */
        retryChunksLimit: 3,
        /**
         * The maximum filesize (in bytes) that is allowed to be uploaded.
         */
        maxFilesize: 256,
        /**
         * The name of the file param that gets transferred.
         * **NOTE**: If you have the option  `uploadMultiple` set to `true`, then
         * Dropzone will append `[]` to the name.
         */
        paramName: "file",
        /**
         * Whether thumbnails for images should be generated
         */
        createImageThumbnails: true,
        /**
         * In MB. When the filename exceeds this limit, the thumbnail will not be generated.
         */
        maxThumbnailFilesize: 10,
        /**
         * If `null`, the ratio of the image will be used to calculate it.
         */
        thumbnailWidth: 120,
        /**
         * The same as `thumbnailWidth`. If both are null, images will not be resized.
         */
        thumbnailHeight: 120,
        /**
         * How the images should be scaled down in case both, `thumbnailWidth` and `thumbnailHeight` are provided.
         * Can be either `contain` or `crop`.
         */
        thumbnailMethod: "crop",
        /**
         * If set, images will be resized to these dimensions before being **uploaded**.
         * If only one, `resizeWidth` **or** `resizeHeight` is provided, the original aspect
         * ratio of the file will be preserved.
         *
         * The `options.transformFile` function uses these options, so if the `transformFile` function
         * is overridden, these options don't do anything.
         */
        resizeWidth: null,
        /**
         * See `resizeWidth`.
         */
        resizeHeight: null,
        /**
         * The mime type of the resized image (before it gets uploaded to the server).
         * If `null` the original mime type will be used. To force jpeg, for example, use `image/jpeg`.
         * See `resizeWidth` for more information.
         */
        resizeMimeType: null,
        /**
         * The quality of the resized images. See `resizeWidth`.
         */
        resizeQuality: 0.8,
        /**
         * How the images should be scaled down in case both, `resizeWidth` and `resizeHeight` are provided.
         * Can be either `contain` or `crop`.
         */
        resizeMethod: "contain",
        /**
         * The base that is used to calculate the **displayed** filesize. You can
         * change this to 1024 if you would rather display kibibytes, mebibytes,
         * etc... 1024 is technically incorrect, because `1024 bytes` are `1 kibibyte`
         * not `1 kilobyte`. You can change this to `1024` if you don't care about
         * validity.
         */
        filesizeBase: 1000,
        /**
         * If not `null` defines how many files this Dropzone handles. If it exceeds,
         * the event `maxfilesexceeded` will be called. The dropzone element gets the
         * class `dz-max-files-reached` accordingly so you can provide visual
         * feedback.
         */
        maxFiles: null,
        /**
         * An optional object to send additional headers to the server. Eg:
         * `{ "My-Awesome-Header": "header value" }`
         */
        headers: null,
        /**
         * If `true`, the dropzone element itself will be clickable, if `false`
         * nothing will be clickable.
         *
         * You can also pass an HTML element, a CSS selector (for multiple elements)
         * or an array of those. In that case, all of those elements will trigger an
         * upload when clicked.
         */
        clickable: true,
        /**
         * Whether hidden files in directories should be ignored.
         */
        ignoreHiddenFiles: true,
        /**
         * The default implementation of `accept` checks the file's mime type or
         * extension against this list. This is a comma separated list of mime
         * types or file extensions.
         *
         * Eg.: `image/*,application/pdf,.psd`
         *
         * If the Dropzone is `clickable` this option will also be used as
         * [`accept`](https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept)
         * parameter on the hidden file input as well.
         */
        acceptedFiles: null,
        /**
         * **Deprecated!**
         * Use acceptedFiles instead.
         */
        acceptedMimeTypes: null,
        /**
         * If false, files will be added to the queue but the queue will not be
         * processed automatically.
         * This can be useful if you need some additional user input before sending
         * files (or if you want want all files sent at once).
         * If you're ready to send the file simply call `myDropzone.processQueue()`.
         *
         * See the [enqueuing file uploads](#enqueuing-file-uploads) documentation
         * section for more information.
         */
        autoProcessQueue: true,
        /**
         * If false, files added to the dropzone will not be queued by default.
         * You'll have to call `enqueueFile(file)` manually.
         */
        autoQueue: true,
        /**
         * If `true`, this will add a link to every file preview to remove or cancel (if
         * already uploading) the file. The `dictCancelUpload`, `dictCancelUploadConfirmation`
         * and `dictRemoveFile` options are used for the wording.
         */
        addRemoveLinks: false,
        /**
         * Defines where to display the file previews – if `null` the
         * Dropzone element itself is used. Can be a plain `HTMLElement` or a CSS
         * selector. The element should have the `dropzone-previews` class so
         * the previews are displayed properly.
         */
        previewsContainer: null,
        /**
         * Set this to `true` if you don't want previews to be shown.
         */
        disablePreviews: false,
        /**
         * This is the element the hidden input field (which is used when clicking on the
         * dropzone to trigger file selection) will be appended to. This might
         * be important in case you use frameworks to switch the content of your page.
         *
         * Can be a selector string, or an element directly.
         */
        hiddenInputContainer: "body",
        /**
         * If null, no capture type will be specified
         * If camera, mobile devices will skip the file selection and choose camera
         * If microphone, mobile devices will skip the file selection and choose the microphone
         * If camcorder, mobile devices will skip the file selection and choose the camera in video mode
         * On apple devices multiple must be set to false.  AcceptedFiles may need to
         * be set to an appropriate mime type (e.g. "image/*", "audio/*", or "video/*").
         */
        capture: null,
        /**
         * **Deprecated**. Use `renameFile` instead.
         */
        renameFilename: null,
        /**
         * A function that is invoked before the file is uploaded to the server and renames the file.
         * This function gets the `File` as argument and can use the `file.name`. The actual name of the
         * file that gets used during the upload can be accessed through `file.upload.filename`.
         */
        renameFile: null,
        /**
         * If `true` the fallback will be forced. This is very useful to test your server
         * implementations first and make sure that everything works as
         * expected without dropzone if you experience problems, and to test
         * how your fallbacks will look.
         */
        forceFallback: false,
        /**
         * The text used before any files are dropped.
         */
        dictDefaultMessage: "Drop files here to upload",
        /**
         * The text that replaces the default message text it the browser is not supported.
         */
        dictFallbackMessage: "Your browser does not support drag'n'drop file uploads.",
        /**
         * The text that will be added before the fallback form.
         * If you provide a  fallback element yourself, or if this option is `null` this will
         * be ignored.
         */
        dictFallbackText: "Please use the fallback form below to upload your files like in the olden days.",
        /**
         * If the filesize is too big.
         * `{{filesize}}` and `{{maxFilesize}}` will be replaced with the respective configuration values.
         */
        dictFileTooBig: "File is too big ({{filesize}}MiB). Max filesize: {{maxFilesize}}MiB.",
        /**
         * If the file doesn't match the file type.
         */
        dictInvalidFileType: "You can't upload files of this type.",
        /**
         * If the server response was invalid.
         * `{{statusCode}}` will be replaced with the servers status code.
         */
        dictResponseError: "Server responded with {{statusCode}} code.",
        /**
         * If `addRemoveLinks` is true, the text to be used for the cancel upload link.
         */
        dictCancelUpload: "Cancel upload",
        /**
         * The text that is displayed if an upload was manually canceled
         */
        dictUploadCanceled: "Upload canceled.",
        /**
         * If `addRemoveLinks` is true, the text to be used for confirmation when cancelling upload.
         */
        dictCancelUploadConfirmation: "Are you sure you want to cancel this upload?",
        /**
         * If `addRemoveLinks` is true, the text to be used to remove a file.
         */
        dictRemoveFile: "Remove file",
        /**
         * If this is not null, then the user will be prompted before removing a file.
         */
        dictRemoveFileConfirmation: null,
        /**
         * Displayed if `maxFiles` is st and exceeded.
         * The string `{{maxFiles}}` will be replaced by the configuration value.
         */
        dictMaxFilesExceeded: "You can not upload any more files.",
        /**
         * Allows you to translate the different units. Starting with `tb` for terabytes and going down to
         * `b` for bytes.
         */
        dictFileSizeUnits: {
          tb: "TB",
          gb: "GB",
          mb: "MB",
          kb: "KB",
          b: "b"
        },
        /**
         * Called when dropzone initialized
         * You can add event listeners here
         */
        init: function init() {},
        /**
         * Can be an **object** of additional parameters to transfer to the server, **or** a `Function`
         * that gets invoked with the `files`, `xhr` and, if it's a chunked upload, `chunk` arguments. In case
         * of a function, this needs to return a map.
         *
         * The default implementation does nothing for normal uploads, but adds relevant information for
         * chunked uploads.
         *
         * This is the same as adding hidden input fields in the form element.
         */
        params: function params(files, xhr, chunk) {
          if (chunk) {
            return {
              dzuuid: chunk.file.upload.uuid,
              dzchunkindex: chunk.index,
              dztotalfilesize: chunk.file.size,
              dzchunksize: this.options.chunkSize,
              dztotalchunkcount: chunk.file.upload.totalChunkCount,
              dzchunkbyteoffset: chunk.index * this.options.chunkSize
            };
          }
        },
        /**
         * A function that gets a [file](https://developer.mozilla.org/en-US/docs/DOM/File)
         * and a `done` function as parameters.
         *
         * If the done function is invoked without arguments, the file is "accepted" and will
         * be processed. If you pass an error message, the file is rejected, and the error
         * message will be displayed.
         * This function will not be called if the file is too big or doesn't match the mime types.
         */
        accept: function accept(file, done) {
          return done();
        },
        /**
         * The callback that will be invoked when all chunks have been uploaded for a file.
         * It gets the file for which the chunks have been uploaded as the first parameter,
         * and the `done` function as second. `done()` needs to be invoked when everything
         * needed to finish the upload process is done.
         */
        chunksUploaded: function chunksUploaded(file, done) {
          done();
        },
        /**
         * Gets called when the browser is not supported.
         * The default implementation shows the fallback input field and adds
         * a text.
         */
        fallback: function fallback() {
          // This code should pass in IE7... :(
          var messageElement;
          this.element.className = "".concat(this.element.className, " dz-browser-not-supported");
          var _iterator = options_createForOfIteratorHelper(this.element.getElementsByTagName("div"), true),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var child = _step.value;
              if (/(^| )dz-message($| )/.test(child.className)) {
                messageElement = child;
                child.className = "dz-message"; // Removes the 'dz-default' class

                break;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          if (!messageElement) {
            messageElement = Dropzone.createElement('<div class="dz-message"><span></span></div>');
            this.element.appendChild(messageElement);
          }
          var span = messageElement.getElementsByTagName("span")[0];
          if (span) {
            if (span.textContent != null) {
              span.textContent = this.options.dictFallbackMessage;
            } else if (span.innerText != null) {
              span.innerText = this.options.dictFallbackMessage;
            }
          }
          return this.element.appendChild(this.getFallbackForm());
        },
        /**
         * Gets called to calculate the thumbnail dimensions.
         *
         * It gets `file`, `width` and `height` (both may be `null`) as parameters and must return an object containing:
         *
         *  - `srcWidth` & `srcHeight` (required)
         *  - `trgWidth` & `trgHeight` (required)
         *  - `srcX` & `srcY` (optional, default `0`)
         *  - `trgX` & `trgY` (optional, default `0`)
         *
         * Those values are going to be used by `ctx.drawImage()`.
         */
        resize: function resize(file, width, height, resizeMethod) {
          var info = {
            srcX: 0,
            srcY: 0,
            srcWidth: file.width,
            srcHeight: file.height
          };
          var srcRatio = file.width / file.height; // Automatically calculate dimensions if not specified

          if (width == null && height == null) {
            width = info.srcWidth;
            height = info.srcHeight;
          } else if (width == null) {
            width = height * srcRatio;
          } else if (height == null) {
            height = width / srcRatio;
          } // Make sure images aren't upscaled

          width = Math.min(width, info.srcWidth);
          height = Math.min(height, info.srcHeight);
          var trgRatio = width / height;
          if (info.srcWidth > width || info.srcHeight > height) {
            // Image is bigger and needs rescaling
            if (resizeMethod === "crop") {
              if (srcRatio > trgRatio) {
                info.srcHeight = file.height;
                info.srcWidth = info.srcHeight * trgRatio;
              } else {
                info.srcWidth = file.width;
                info.srcHeight = info.srcWidth / trgRatio;
              }
            } else if (resizeMethod === "contain") {
              // Method 'contain'
              if (srcRatio > trgRatio) {
                height = width / srcRatio;
              } else {
                width = height * srcRatio;
              }
            } else {
              throw new Error("Unknown resizeMethod '".concat(resizeMethod, "'"));
            }
          }
          info.srcX = (file.width - info.srcWidth) / 2;
          info.srcY = (file.height - info.srcHeight) / 2;
          info.trgWidth = width;
          info.trgHeight = height;
          return info;
        },
        /**
         * Can be used to transform the file (for example, resize an image if necessary).
         *
         * The default implementation uses `resizeWidth` and `resizeHeight` (if provided) and resizes
         * images according to those dimensions.
         *
         * Gets the `file` as the first parameter, and a `done()` function as the second, that needs
         * to be invoked with the file when the transformation is done.
         */
        transformFile: function transformFile(file, done) {
          if ((this.options.resizeWidth || this.options.resizeHeight) && file.type.match(/image.*/)) {
            return this.resizeImage(file, this.options.resizeWidth, this.options.resizeHeight, this.options.resizeMethod, done);
          } else {
            return done(file);
          }
        },
        /**
         * A string that contains the template used for each dropped
         * file. Change it to fulfill your needs but make sure to properly
         * provide all elements.
         *
         * If you want to use an actual HTML element instead of providing a String
         * as a config option, you could create a div with the id `tpl`,
         * put the template inside it and provide the element like this:
         *
         *     document
         *       .querySelector('#tpl')
         *       .innerHTML
         *
         */
        previewTemplate: preview_template,
        /*
         Those functions register themselves to the events on init and handle all
         the user interface specific stuff. Overwriting them won't break the upload
         but can break the way it's displayed.
         You can overwrite them if you don't like the default behavior. If you just
         want to add an additional event handler, register it on the dropzone object
         and don't overwrite those options.
         */
        // Those are self explanatory and simply concern the DragnDrop.
        drop: function drop(e) {
          return this.element.classList.remove("dz-drag-hover");
        },
        dragstart: function dragstart(e) {},
        dragend: function dragend(e) {
          return this.element.classList.remove("dz-drag-hover");
        },
        dragenter: function dragenter(e) {
          return this.element.classList.add("dz-drag-hover");
        },
        dragover: function dragover(e) {
          return this.element.classList.add("dz-drag-hover");
        },
        dragleave: function dragleave(e) {
          return this.element.classList.remove("dz-drag-hover");
        },
        paste: function paste(e) {},
        // Called whenever there are no files left in the dropzone anymore, and the
        // dropzone should be displayed as if in the initial state.
        reset: function reset() {
          return this.element.classList.remove("dz-started");
        },
        // Called when a file is added to the queue
        // Receives `file`
        addedfile: function addedfile(file) {
          var _this = this;
          if (this.element === this.previewsContainer) {
            this.element.classList.add("dz-started");
          }
          if (this.previewsContainer && !this.options.disablePreviews) {
            file.previewElement = Dropzone.createElement(this.options.previewTemplate.trim());
            file.previewTemplate = file.previewElement; // Backwards compatibility

            this.previewsContainer.appendChild(file.previewElement);
            var _iterator2 = options_createForOfIteratorHelper(file.previewElement.querySelectorAll("[data-dz-name]"), true),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var node = _step2.value;
                node.textContent = file.name;
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
            var _iterator3 = options_createForOfIteratorHelper(file.previewElement.querySelectorAll("[data-dz-size]"), true),
              _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                node = _step3.value;
                node.innerHTML = this.filesize(file.size);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
            if (this.options.addRemoveLinks) {
              file._removeLink = Dropzone.createElement("<a class=\"dz-remove\" href=\"javascript:undefined;\" data-dz-remove>".concat(this.options.dictRemoveFile, "</a>"));
              file.previewElement.appendChild(file._removeLink);
            }
            var removeFileEvent = function removeFileEvent(e) {
              e.preventDefault();
              e.stopPropagation();
              if (file.status === Dropzone.UPLOADING) {
                return Dropzone.confirm(_this.options.dictCancelUploadConfirmation, function () {
                  return _this.removeFile(file);
                });
              } else {
                if (_this.options.dictRemoveFileConfirmation) {
                  return Dropzone.confirm(_this.options.dictRemoveFileConfirmation, function () {
                    return _this.removeFile(file);
                  });
                } else {
                  return _this.removeFile(file);
                }
              }
            };
            var _iterator4 = options_createForOfIteratorHelper(file.previewElement.querySelectorAll("[data-dz-remove]"), true),
              _step4;
            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var removeLink = _step4.value;
                removeLink.addEventListener("click", removeFileEvent);
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
          }
        },
        // Called whenever a file is removed.
        removedfile: function removedfile(file) {
          if (file.previewElement != null && file.previewElement.parentNode != null) {
            file.previewElement.parentNode.removeChild(file.previewElement);
          }
          return this._updateMaxFilesReachedClass();
        },
        // Called when a thumbnail has been generated
        // Receives `file` and `dataUrl`
        thumbnail: function thumbnail(file, dataUrl) {
          if (file.previewElement) {
            file.previewElement.classList.remove("dz-file-preview");
            var _iterator5 = options_createForOfIteratorHelper(file.previewElement.querySelectorAll("[data-dz-thumbnail]"), true),
              _step5;
            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var thumbnailElement = _step5.value;
                thumbnailElement.alt = file.name;
                thumbnailElement.src = dataUrl;
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
            return setTimeout(function () {
              return file.previewElement.classList.add("dz-image-preview");
            }, 1);
          }
        },
        // Called whenever an error occurs
        // Receives `file` and `message`
        error: function error(file, message) {
          if (file.previewElement) {
            file.previewElement.classList.add("dz-error");
            if (typeof message !== "string" && message.error) {
              message = message.error;
            }
            var _iterator6 = options_createForOfIteratorHelper(file.previewElement.querySelectorAll("[data-dz-errormessage]"), true),
              _step6;
            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                var node = _step6.value;
                node.textContent = message;
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }
          }
        },
        errormultiple: function errormultiple() {},
        // Called when a file gets processed. Since there is a cue, not all added
        // files are processed immediately.
        // Receives `file`
        processing: function processing(file) {
          if (file.previewElement) {
            file.previewElement.classList.add("dz-processing");
            if (file._removeLink) {
              return file._removeLink.innerHTML = this.options.dictCancelUpload;
            }
          }
        },
        processingmultiple: function processingmultiple() {},
        // Called whenever the upload progress gets updated.
        // Receives `file`, `progress` (percentage 0-100) and `bytesSent`.
        // To get the total number of bytes of the file, use `file.size`
        uploadprogress: function uploadprogress(file, progress, bytesSent) {
          if (file.previewElement) {
            var _iterator7 = options_createForOfIteratorHelper(file.previewElement.querySelectorAll("[data-dz-uploadprogress]"), true),
              _step7;
            try {
              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                var node = _step7.value;
                node.nodeName === "PROGRESS" ? node.value = progress : node.style.width = "".concat(progress, "%");
              }
            } catch (err) {
              _iterator7.e(err);
            } finally {
              _iterator7.f();
            }
          }
        },
        // Called whenever the total upload progress gets updated.
        // Called with totalUploadProgress (0-100), totalBytes and totalBytesSent
        totaluploadprogress: function totaluploadprogress() {},
        // Called just before the file is sent. Gets the `xhr` object as second
        // parameter, so you can modify it (for example to add a CSRF token) and a
        // `formData` object to add additional information.
        sending: function sending() {},
        sendingmultiple: function sendingmultiple() {},
        // When the complete upload is finished and successful
        // Receives `file`
        success: function success(file) {
          if (file.previewElement) {
            return file.previewElement.classList.add("dz-success");
          }
        },
        successmultiple: function successmultiple() {},
        // When the upload is canceled.
        canceled: function canceled(file) {
          return this.emit("error", file, this.options.dictUploadCanceled);
        },
        canceledmultiple: function canceledmultiple() {},
        // When the upload is finished, either with success or an error.
        // Receives `file`
        complete: function complete(file) {
          if (file._removeLink) {
            file._removeLink.innerHTML = this.options.dictRemoveFile;
          }
          if (file.previewElement) {
            return file.previewElement.classList.add("dz-complete");
          }
        },
        completemultiple: function completemultiple() {},
        maxfilesexceeded: function maxfilesexceeded() {},
        maxfilesreached: function maxfilesreached() {},
        queuecomplete: function queuecomplete() {},
        addedfiles: function addedfiles() {}
      };
      /* harmony default export */
      var src_options = defaultOptions;
      ; // CONCATENATED MODULE: ./src/dropzone.js
      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }
        return _typeof(obj);
      }
      function dropzone_createForOfIteratorHelper(o, allowArrayLike) {
        var it;
        if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
          if (Array.isArray(o) || (it = dropzone_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
              s: F,
              n: function n() {
                if (i >= o.length) return {
                  done: true
                };
                return {
                  done: false,
                  value: o[i++]
                };
              },
              e: function e(_e) {
                throw _e;
              },
              f: F
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true,
          didErr = false,
          err;
        return {
          s: function s() {
            it = o[Symbol.iterator]();
          },
          n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
          },
          e: function e(_e2) {
            didErr = true;
            err = _e2;
          },
          f: function f() {
            try {
              if (!normalCompletion && it.return != null) it.return();
            } finally {
              if (didErr) throw err;
            }
          }
        };
      }
      function dropzone_unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return dropzone_arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dropzone_arrayLikeToArray(o, minLen);
      }
      function dropzone_arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      function dropzone_classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function dropzone_defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function dropzone_createClass(Constructor, protoProps, staticProps) {
        if (protoProps) dropzone_defineProperties(Constructor.prototype, protoProps);
        if (staticProps) dropzone_defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
            result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self);
      }
      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }
      var Dropzone = /*#__PURE__*/function (_Emitter) {
        _inherits(Dropzone, _Emitter);
        var _super = _createSuper(Dropzone);
        function Dropzone(el, options) {
          var _this;
          dropzone_classCallCheck(this, Dropzone);
          _this = _super.call(this);
          var fallback, left;
          _this.element = el; // For backwards compatibility since the version was in the prototype previously

          _this.version = Dropzone.version;
          _this.clickableElements = [];
          _this.listeners = [];
          _this.files = []; // All files

          if (typeof _this.element === "string") {
            _this.element = document.querySelector(_this.element);
          } // Not checking if instance of HTMLElement or Element since IE9 is extremely weird.

          if (!_this.element || _this.element.nodeType == null) {
            throw new Error("Invalid dropzone element.");
          }
          if (_this.element.dropzone) {
            throw new Error("Dropzone already attached.");
          } // Now add this dropzone to the instances.

          Dropzone.instances.push(_assertThisInitialized(_this)); // Put the dropzone inside the element itself.

          _this.element.dropzone = _assertThisInitialized(_this);
          var elementOptions = (left = Dropzone.optionsForElement(_this.element)) != null ? left : {};
          _this.options = Dropzone.extend({}, src_options, elementOptions, options != null ? options : {});
          _this.options.previewTemplate = _this.options.previewTemplate.replace(/\n*/g, ""); // If the browser failed, just call the fallback and leave

          if (_this.options.forceFallback || !Dropzone.isBrowserSupported()) {
            return _possibleConstructorReturn(_this, _this.options.fallback.call(_assertThisInitialized(_this)));
          } // @options.url = @element.getAttribute "action" unless @options.url?

          if (_this.options.url == null) {
            _this.options.url = _this.element.getAttribute("action");
          }
          if (!_this.options.url) {
            throw new Error("No URL provided.");
          }
          if (_this.options.acceptedFiles && _this.options.acceptedMimeTypes) {
            throw new Error("You can't provide both 'acceptedFiles' and 'acceptedMimeTypes'. 'acceptedMimeTypes' is deprecated.");
          }
          if (_this.options.uploadMultiple && _this.options.chunking) {
            throw new Error("You cannot set both: uploadMultiple and chunking.");
          } // Backwards compatibility

          if (_this.options.acceptedMimeTypes) {
            _this.options.acceptedFiles = _this.options.acceptedMimeTypes;
            delete _this.options.acceptedMimeTypes;
          } // Backwards compatibility

          if (_this.options.renameFilename != null) {
            _this.options.renameFile = function (file) {
              return _this.options.renameFilename.call(_assertThisInitialized(_this), file.name, file);
            };
          }
          if (typeof _this.options.method === "string") {
            _this.options.method = _this.options.method.toUpperCase();
          }
          if ((fallback = _this.getExistingFallback()) && fallback.parentNode) {
            // Remove the fallback
            fallback.parentNode.removeChild(fallback);
          } // Display previews in the previewsContainer element or the Dropzone element unless explicitly set to false

          if (_this.options.previewsContainer !== false) {
            if (_this.options.previewsContainer) {
              _this.previewsContainer = Dropzone.getElement(_this.options.previewsContainer, "previewsContainer");
            } else {
              _this.previewsContainer = _this.element;
            }
          }
          if (_this.options.clickable) {
            if (_this.options.clickable === true) {
              _this.clickableElements = [_this.element];
            } else {
              _this.clickableElements = Dropzone.getElements(_this.options.clickable, "clickable");
            }
          }
          _this.init();
          return _this;
        } // Returns all files that have been accepted

        dropzone_createClass(Dropzone, [{
          key: "getAcceptedFiles",
          value: function getAcceptedFiles() {
            return this.files.filter(function (file) {
              return file.accepted;
            }).map(function (file) {
              return file;
            });
          } // Returns all files that have been rejected
          // Not sure when that's going to be useful, but added for completeness.
        }, {
          key: "getRejectedFiles",
          value: function getRejectedFiles() {
            return this.files.filter(function (file) {
              return !file.accepted;
            }).map(function (file) {
              return file;
            });
          }
        }, {
          key: "getFilesWithStatus",
          value: function getFilesWithStatus(status) {
            return this.files.filter(function (file) {
              return file.status === status;
            }).map(function (file) {
              return file;
            });
          } // Returns all files that are in the queue
        }, {
          key: "getQueuedFiles",
          value: function getQueuedFiles() {
            return this.getFilesWithStatus(Dropzone.QUEUED);
          }
        }, {
          key: "getUploadingFiles",
          value: function getUploadingFiles() {
            return this.getFilesWithStatus(Dropzone.UPLOADING);
          }
        }, {
          key: "getAddedFiles",
          value: function getAddedFiles() {
            return this.getFilesWithStatus(Dropzone.ADDED);
          } // Files that are either queued or uploading
        }, {
          key: "getActiveFiles",
          value: function getActiveFiles() {
            return this.files.filter(function (file) {
              return file.status === Dropzone.UPLOADING || file.status === Dropzone.QUEUED;
            }).map(function (file) {
              return file;
            });
          } // The function that gets called when Dropzone is initialized. You
          // can (and should) setup event listeners inside this function.
        }, {
          key: "init",
          value: function init() {
            var _this2 = this;

            // In case it isn't set already
            if (this.element.tagName === "form") {
              this.element.setAttribute("enctype", "multipart/form-data");
            }
            if (this.element.classList.contains("dropzone") && !this.element.querySelector(".dz-message")) {
              this.element.appendChild(Dropzone.createElement("<div class=\"dz-default dz-message\"><button class=\"dz-button\" type=\"button\">".concat(this.options.dictDefaultMessage, "</button></div>")));
            }
            if (this.clickableElements.length) {
              var setupHiddenFileInput = function setupHiddenFileInput() {
                if (_this2.hiddenFileInput) {
                  _this2.hiddenFileInput.parentNode.removeChild(_this2.hiddenFileInput);
                }
                _this2.hiddenFileInput = document.createElement("input");
                _this2.hiddenFileInput.setAttribute("type", "file");
                if (_this2.options.maxFiles === null || _this2.options.maxFiles > 1) {
                  _this2.hiddenFileInput.setAttribute("multiple", "multiple");
                }
                _this2.hiddenFileInput.className = "dz-hidden-input";
                if (_this2.options.acceptedFiles !== null) {
                  _this2.hiddenFileInput.setAttribute("accept", _this2.options.acceptedFiles);
                }
                if (_this2.options.capture !== null) {
                  _this2.hiddenFileInput.setAttribute("capture", _this2.options.capture);
                } // Making sure that no one can "tab" into this field.

                _this2.hiddenFileInput.setAttribute("tabindex", "-1"); // Not setting `display="none"` because some browsers don't accept clicks
                // on elements that aren't displayed.

                _this2.hiddenFileInput.style.visibility = "hidden";
                _this2.hiddenFileInput.style.position = "absolute";
                _this2.hiddenFileInput.style.top = "0";
                _this2.hiddenFileInput.style.left = "0";
                _this2.hiddenFileInput.style.height = "0";
                _this2.hiddenFileInput.style.width = "0";
                Dropzone.getElement(_this2.options.hiddenInputContainer, "hiddenInputContainer").appendChild(_this2.hiddenFileInput);
                _this2.hiddenFileInput.addEventListener("change", function () {
                  var files = _this2.hiddenFileInput.files;
                  if (files.length) {
                    var _iterator = dropzone_createForOfIteratorHelper(files, true),
                      _step;
                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done;) {
                        var file = _step.value;
                        _this2.addFile(file);
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }
                  }
                  _this2.emit("addedfiles", files);
                  setupHiddenFileInput();
                });
              };
              setupHiddenFileInput();
            }
            this.URL = window.URL !== null ? window.URL : window.webkitURL; // Setup all event listeners on the Dropzone object itself.
            // They're not in @setupEventListeners() because they shouldn't be removed
            // again when the dropzone gets disabled.

            var _iterator2 = dropzone_createForOfIteratorHelper(this.events, true),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var eventName = _step2.value;
                this.on(eventName, this.options[eventName]);
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
            this.on("uploadprogress", function () {
              return _this2.updateTotalUploadProgress();
            });
            this.on("removedfile", function () {
              return _this2.updateTotalUploadProgress();
            });
            this.on("canceled", function (file) {
              return _this2.emit("complete", file);
            }); // Emit a `queuecomplete` event if all files finished uploading.

            this.on("complete", function (file) {
              if (_this2.getAddedFiles().length === 0 && _this2.getUploadingFiles().length === 0 && _this2.getQueuedFiles().length === 0) {
                // This needs to be deferred so that `queuecomplete` really triggers after `complete`
                return setTimeout(function () {
                  return _this2.emit("queuecomplete");
                }, 0);
              }
            });
            var containsFiles = function containsFiles(e) {
              if (e.dataTransfer.types) {
                // Because e.dataTransfer.types is an Object in
                // IE, we need to iterate like this instead of
                // using e.dataTransfer.types.some()
                for (var i = 0; i < e.dataTransfer.types.length; i++) {
                  if (e.dataTransfer.types[i] === "Files") return true;
                }
              }
              return false;
            };
            var noPropagation = function noPropagation(e) {
              // If there are no files, we don't want to stop
              // propagation so we don't interfere with other
              // drag and drop behaviour.
              if (!containsFiles(e)) return;
              e.stopPropagation();
              if (e.preventDefault) {
                return e.preventDefault();
              } else {
                return e.returnValue = false;
              }
            }; // Create the listeners

            this.listeners = [{
              element: this.element,
              events: {
                dragstart: function dragstart(e) {
                  return _this2.emit("dragstart", e);
                },
                dragenter: function dragenter(e) {
                  noPropagation(e);
                  return _this2.emit("dragenter", e);
                },
                dragover: function dragover(e) {
                  // Makes it possible to drag files from chrome's download bar
                  // http://stackoverflow.com/questions/19526430/drag-and-drop-file-uploads-from-chrome-downloads-bar
                  // Try is required to prevent bug in Internet Explorer 11 (SCRIPT65535 exception)
                  var efct;
                  try {
                    efct = e.dataTransfer.effectAllowed;
                  } catch (error) {}
                  e.dataTransfer.dropEffect = "move" === efct || "linkMove" === efct ? "move" : "copy";
                  noPropagation(e);
                  return _this2.emit("dragover", e);
                },
                dragleave: function dragleave(e) {
                  return _this2.emit("dragleave", e);
                },
                drop: function drop(e) {
                  noPropagation(e);
                  return _this2.drop(e);
                },
                dragend: function dragend(e) {
                  return _this2.emit("dragend", e);
                }
              } // This is disabled right now, because the browsers don't implement it properly.
              // "paste": (e) =>
              //   noPropagation e
              //   @paste e
            }];
            this.clickableElements.forEach(function (clickableElement) {
              return _this2.listeners.push({
                element: clickableElement,
                events: {
                  click: function click(evt) {
                    // Only the actual dropzone or the message element should trigger file selection
                    if (clickableElement !== _this2.element || evt.target === _this2.element || Dropzone.elementInside(evt.target, _this2.element.querySelector(".dz-message"))) {
                      _this2.hiddenFileInput.click(); // Forward the click
                    }
                    return true;
                  }
                }
              });
            });
            this.enable();
            return this.options.init.call(this);
          } // Not fully tested yet
        }, {
          key: "destroy",
          value: function destroy() {
            this.disable();
            this.removeAllFiles(true);
            if (this.hiddenFileInput != null ? this.hiddenFileInput.parentNode : undefined) {
              this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);
              this.hiddenFileInput = null;
            }
            delete this.element.dropzone;
            return Dropzone.instances.splice(Dropzone.instances.indexOf(this), 1);
          }
        }, {
          key: "updateTotalUploadProgress",
          value: function updateTotalUploadProgress() {
            var totalUploadProgress;
            var totalBytesSent = 0;
            var totalBytes = 0;
            var activeFiles = this.getActiveFiles();
            if (activeFiles.length) {
              var _iterator3 = dropzone_createForOfIteratorHelper(this.getActiveFiles(), true),
                _step3;
              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  var file = _step3.value;
                  totalBytesSent += file.upload.bytesSent;
                  totalBytes += file.upload.total;
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
              totalUploadProgress = 100 * totalBytesSent / totalBytes;
            } else {
              totalUploadProgress = 100;
            }
            return this.emit("totaluploadprogress", totalUploadProgress, totalBytes, totalBytesSent);
          } // @options.paramName can be a function taking one parameter rather than a string.
          // A parameter name for a file is obtained simply by calling this with an index number.
        }, {
          key: "_getParamName",
          value: function _getParamName(n) {
            if (typeof this.options.paramName === "function") {
              return this.options.paramName(n);
            } else {
              return "".concat(this.options.paramName).concat(this.options.uploadMultiple ? "[".concat(n, "]") : "");
            }
          } // If @options.renameFile is a function,
          // the function will be used to rename the file.name before appending it to the formData
        }, {
          key: "_renameFile",
          value: function _renameFile(file) {
            if (typeof this.options.renameFile !== "function") {
              return file.name;
            }
            return this.options.renameFile(file);
          } // Returns a form that can be used as fallback if the browser does not support DragnDrop
          //
          // If the dropzone is already a form, only the input field and button are returned. Otherwise a complete form element is provided.
          // This code has to pass in IE7 :(
        }, {
          key: "getFallbackForm",
          value: function getFallbackForm() {
            var existingFallback, form;
            if (existingFallback = this.getExistingFallback()) {
              return existingFallback;
            }
            var fieldsString = '<div class="dz-fallback">';
            if (this.options.dictFallbackText) {
              fieldsString += "<p>".concat(this.options.dictFallbackText, "</p>");
            }
            fieldsString += "<input type=\"file\" name=\"".concat(this._getParamName(0), "\" ").concat(this.options.uploadMultiple ? 'multiple="multiple"' : undefined, " /><input type=\"submit\" value=\"Upload!\"></div>");
            var fields = Dropzone.createElement(fieldsString);
            if (this.element.tagName !== "FORM") {
              form = Dropzone.createElement("<form action=\"".concat(this.options.url, "\" enctype=\"multipart/form-data\" method=\"").concat(this.options.method, "\"></form>"));
              form.appendChild(fields);
            } else {
              // Make sure that the enctype and method attributes are set properly
              this.element.setAttribute("enctype", "multipart/form-data");
              this.element.setAttribute("method", this.options.method);
            }
            return form != null ? form : fields;
          } // Returns the fallback elements if they exist already
          //
          // This code has to pass in IE7 :(
        }, {
          key: "getExistingFallback",
          value: function getExistingFallback() {
            var getFallback = function getFallback(elements) {
              var _iterator4 = dropzone_createForOfIteratorHelper(elements, true),
                _step4;
              try {
                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                  var el = _step4.value;
                  if (/(^| )fallback($| )/.test(el.className)) {
                    return el;
                  }
                }
              } catch (err) {
                _iterator4.e(err);
              } finally {
                _iterator4.f();
              }
            };
            for (var _i = 0, _arr = ["div", "form"]; _i < _arr.length; _i++) {
              var tagName = _arr[_i];
              var fallback;
              if (fallback = getFallback(this.element.getElementsByTagName(tagName))) {
                return fallback;
              }
            }
          } // Activates all listeners stored in @listeners
        }, {
          key: "setupEventListeners",
          value: function setupEventListeners() {
            return this.listeners.map(function (elementListeners) {
              return function () {
                var result = [];
                for (var event in elementListeners.events) {
                  var listener = elementListeners.events[event];
                  result.push(elementListeners.element.addEventListener(event, listener, false));
                }
                return result;
              }();
            });
          } // Deactivates all listeners stored in @listeners
        }, {
          key: "removeEventListeners",
          value: function removeEventListeners() {
            return this.listeners.map(function (elementListeners) {
              return function () {
                var result = [];
                for (var event in elementListeners.events) {
                  var listener = elementListeners.events[event];
                  result.push(elementListeners.element.removeEventListener(event, listener, false));
                }
                return result;
              }();
            });
          } // Removes all event listeners and cancels all files in the queue or being processed.
        }, {
          key: "disable",
          value: function disable() {
            var _this3 = this;
            this.clickableElements.forEach(function (element) {
              return element.classList.remove("dz-clickable");
            });
            this.removeEventListeners();
            this.disabled = true;
            return this.files.map(function (file) {
              return _this3.cancelUpload(file);
            });
          }
        }, {
          key: "enable",
          value: function enable() {
            delete this.disabled;
            this.clickableElements.forEach(function (element) {
              return element.classList.add("dz-clickable");
            });
            return this.setupEventListeners();
          } // Returns a nicely formatted filesize
        }, {
          key: "filesize",
          value: function filesize(size) {
            var selectedSize = 0;
            var selectedUnit = "b";
            if (size > 0) {
              var units = ["tb", "gb", "mb", "kb", "b"];
              for (var i = 0; i < units.length; i++) {
                var unit = units[i];
                var cutoff = Math.pow(this.options.filesizeBase, 4 - i) / 10;
                if (size >= cutoff) {
                  selectedSize = size / Math.pow(this.options.filesizeBase, 4 - i);
                  selectedUnit = unit;
                  break;
                }
              }
              selectedSize = Math.round(10 * selectedSize) / 10; // Cutting of digits
            }
            return "<strong>".concat(selectedSize, "</strong> ").concat(this.options.dictFileSizeUnits[selectedUnit]);
          } // Adds or removes the `dz-max-files-reached` class from the form.
        }, {
          key: "_updateMaxFilesReachedClass",
          value: function _updateMaxFilesReachedClass() {
            if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {
              if (this.getAcceptedFiles().length === this.options.maxFiles) {
                this.emit("maxfilesreached", this.files);
              }
              return this.element.classList.add("dz-max-files-reached");
            } else {
              return this.element.classList.remove("dz-max-files-reached");
            }
          }
        }, {
          key: "drop",
          value: function drop(e) {
            if (!e.dataTransfer) {
              return;
            }
            this.emit("drop", e); // Convert the FileList to an Array
            // This is necessary for IE11

            var files = [];
            for (var i = 0; i < e.dataTransfer.files.length; i++) {
              files[i] = e.dataTransfer.files[i];
            } // Even if it's a folder, files.length will contain the folders.

            if (files.length) {
              var items = e.dataTransfer.items;
              if (items && items.length && items[0].webkitGetAsEntry != null) {
                // The browser supports dropping of folders, so handle items instead of files
                this._addFilesFromItems(items);
              } else {
                this.handleFiles(files);
              }
            }
            this.emit("addedfiles", files);
          }
        }, {
          key: "paste",
          value: function paste(e) {
            if (__guard__(e != null ? e.clipboardData : undefined, function (x) {
              return x.items;
            }) == null) {
              return;
            }
            this.emit("paste", e);
            var items = e.clipboardData.items;
            if (items.length) {
              return this._addFilesFromItems(items);
            }
          }
        }, {
          key: "handleFiles",
          value: function handleFiles(files) {
            var _iterator5 = dropzone_createForOfIteratorHelper(files, true),
              _step5;
            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var file = _step5.value;
                this.addFile(file);
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
          } // When a folder is dropped (or files are pasted), items must be handled
          // instead of files.
        }, {
          key: "_addFilesFromItems",
          value: function _addFilesFromItems(items) {
            var _this4 = this;
            return function () {
              var result = [];
              var _iterator6 = dropzone_createForOfIteratorHelper(items, true),
                _step6;
              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  var item = _step6.value;
                  var entry;
                  if (item.webkitGetAsEntry != null && (entry = item.webkitGetAsEntry())) {
                    if (entry.isFile) {
                      result.push(_this4.addFile(item.getAsFile()));
                    } else if (entry.isDirectory) {
                      // Append all files from that directory to files
                      result.push(_this4._addFilesFromDirectory(entry, entry.name));
                    } else {
                      result.push(undefined);
                    }
                  } else if (item.getAsFile != null) {
                    if (item.kind == null || item.kind === "file") {
                      result.push(_this4.addFile(item.getAsFile()));
                    } else {
                      result.push(undefined);
                    }
                  } else {
                    result.push(undefined);
                  }
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }
              return result;
            }();
          } // Goes through the directory, and adds each file it finds recursively
        }, {
          key: "_addFilesFromDirectory",
          value: function _addFilesFromDirectory(directory, path) {
            var _this5 = this;
            var dirReader = directory.createReader();
            var errorHandler = function errorHandler(error) {
              return __guardMethod__(console, "log", function (o) {
                return o.log(error);
              });
            };
            var readEntries = function readEntries() {
              return dirReader.readEntries(function (entries) {
                if (entries.length > 0) {
                  var _iterator7 = dropzone_createForOfIteratorHelper(entries, true),
                    _step7;
                  try {
                    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                      var entry = _step7.value;
                      if (entry.isFile) {
                        entry.file(function (file) {
                          if (_this5.options.ignoreHiddenFiles && file.name.substring(0, 1) === ".") {
                            return;
                          }
                          file.fullPath = "".concat(path, "/").concat(file.name);
                          return _this5.addFile(file);
                        });
                      } else if (entry.isDirectory) {
                        _this5._addFilesFromDirectory(entry, "".concat(path, "/").concat(entry.name));
                      }
                    } // Recursively call readEntries() again, since browser only handle
                    // the first 100 entries.
                    // See: https://developer.mozilla.org/en-US/docs/Web/API/DirectoryReader#readEntries
                  } catch (err) {
                    _iterator7.e(err);
                  } finally {
                    _iterator7.f();
                  }
                  readEntries();
                }
                return null;
              }, errorHandler);
            };
            return readEntries();
          } // If `done()` is called without argument the file is accepted
          // If you call it with an error message, the file is rejected
          // (This allows for asynchronous validation)
          //
          // This function checks the filesize, and if the file.type passes the
          // `acceptedFiles` check.
        }, {
          key: "accept",
          value: function accept(file, done) {
            if (this.options.maxFilesize && file.size > this.options.maxFilesize * 1024 * 1024) {
              done(this.options.dictFileTooBig.replace("{{filesize}}", Math.round(file.size / 1024 / 10.24) / 100).replace("{{maxFilesize}}", this.options.maxFilesize));
            } else if (!Dropzone.isValidFile(file, this.options.acceptedFiles)) {
              done(this.options.dictInvalidFileType);
            } else if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {
              done(this.options.dictMaxFilesExceeded.replace("{{maxFiles}}", this.options.maxFiles));
              this.emit("maxfilesexceeded", file);
            } else {
              this.options.accept.call(this, file, done);
            }
          }
        }, {
          key: "addFile",
          value: function addFile(file) {
            var _this6 = this;
            file.upload = {
              uuid: Dropzone.uuidv4(),
              progress: 0,
              // Setting the total upload size to file.size for the beginning
              // It's actual different than the size to be transmitted.
              total: file.size,
              bytesSent: 0,
              filename: this._renameFile(file) // Not setting chunking information here, because the acutal data — and
              // thus the chunks — might change if `options.transformFile` is set
              // and does something to the data.
            };
            this.files.push(file);
            file.status = Dropzone.ADDED;
            this.emit("addedfile", file);
            this._enqueueThumbnail(file);
            this.accept(file, function (error) {
              if (error) {
                file.accepted = false;
                _this6._errorProcessing([file], error); // Will set the file.status
              } else {
                file.accepted = true;
                if (_this6.options.autoQueue) {
                  _this6.enqueueFile(file);
                } // Will set .accepted = true
              }
              _this6._updateMaxFilesReachedClass();
            });
          } // Wrapper for enqueueFile
        }, {
          key: "enqueueFiles",
          value: function enqueueFiles(files) {
            var _iterator8 = dropzone_createForOfIteratorHelper(files, true),
              _step8;
            try {
              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                var file = _step8.value;
                this.enqueueFile(file);
              }
            } catch (err) {
              _iterator8.e(err);
            } finally {
              _iterator8.f();
            }
            return null;
          }
        }, {
          key: "enqueueFile",
          value: function enqueueFile(file) {
            var _this7 = this;
            if (file.status === Dropzone.ADDED && file.accepted === true) {
              file.status = Dropzone.QUEUED;
              if (this.options.autoProcessQueue) {
                return setTimeout(function () {
                  return _this7.processQueue();
                }, 0); // Deferring the call
              }
            } else {
              throw new Error("This file can't be queued because it has already been processed or was rejected.");
            }
          }
        }, {
          key: "_enqueueThumbnail",
          value: function _enqueueThumbnail(file) {
            var _this8 = this;
            if (this.options.createImageThumbnails && file.type.match(/image.*/) && file.size <= this.options.maxThumbnailFilesize * 1024 * 1024) {
              this._thumbnailQueue.push(file);
              return setTimeout(function () {
                return _this8._processThumbnailQueue();
              }, 0); // Deferring the call
            }
          }
        }, {
          key: "_processThumbnailQueue",
          value: function _processThumbnailQueue() {
            var _this9 = this;
            if (this._processingThumbnail || this._thumbnailQueue.length === 0) {
              return;
            }
            this._processingThumbnail = true;
            var file = this._thumbnailQueue.shift();
            return this.createThumbnail(file, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.thumbnailMethod, true, function (dataUrl) {
              _this9.emit("thumbnail", file, dataUrl);
              _this9._processingThumbnail = false;
              return _this9._processThumbnailQueue();
            });
          } // Can be called by the user to remove a file
        }, {
          key: "removeFile",
          value: function removeFile(file) {
            if (file.status === Dropzone.UPLOADING) {
              this.cancelUpload(file);
            }
            this.files = without(this.files, file);
            this.emit("removedfile", file);
            if (this.files.length === 0) {
              return this.emit("reset");
            }
          } // Removes all files that aren't currently processed from the list
        }, {
          key: "removeAllFiles",
          value: function removeAllFiles(cancelIfNecessary) {
            // Create a copy of files since removeFile() changes the @files array.
            if (cancelIfNecessary == null) {
              cancelIfNecessary = false;
            }
            var _iterator9 = dropzone_createForOfIteratorHelper(this.files.slice(), true),
              _step9;
            try {
              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                var file = _step9.value;
                if (file.status !== Dropzone.UPLOADING || cancelIfNecessary) {
                  this.removeFile(file);
                }
              }
            } catch (err) {
              _iterator9.e(err);
            } finally {
              _iterator9.f();
            }
            return null;
          } // Resizes an image before it gets sent to the server. This function is the default behavior of
          // `options.transformFile` if `resizeWidth` or `resizeHeight` are set. The callback is invoked with
          // the resized blob.
        }, {
          key: "resizeImage",
          value: function resizeImage(file, width, height, resizeMethod, callback) {
            var _this10 = this;
            return this.createThumbnail(file, width, height, resizeMethod, true, function (dataUrl, canvas) {
              if (canvas == null) {
                // The image has not been resized
                return callback(file);
              } else {
                var resizeMimeType = _this10.options.resizeMimeType;
                if (resizeMimeType == null) {
                  resizeMimeType = file.type;
                }
                var resizedDataURL = canvas.toDataURL(resizeMimeType, _this10.options.resizeQuality);
                if (resizeMimeType === "image/jpeg" || resizeMimeType === "image/jpg") {
                  // Now add the original EXIF information
                  resizedDataURL = ExifRestore.restore(file.dataURL, resizedDataURL);
                }
                return callback(Dropzone.dataURItoBlob(resizedDataURL));
              }
            });
          }
        }, {
          key: "createThumbnail",
          value: function createThumbnail(file, width, height, resizeMethod, fixOrientation, callback) {
            var _this11 = this;
            var fileReader = new FileReader();
            fileReader.onload = function () {
              file.dataURL = fileReader.result; // Don't bother creating a thumbnail for SVG images since they're vector

              if (file.type === "image/svg+xml") {
                if (callback != null) {
                  callback(fileReader.result);
                }
                return;
              }
              _this11.createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback);
            };
            fileReader.readAsDataURL(file);
          } // `mockFile` needs to have these attributes:
          //
          //     { name: 'name', size: 12345, imageUrl: '' }
          //
          // `callback` will be invoked when the image has been downloaded and displayed.
          // `crossOrigin` will be added to the `img` tag when accessing the file.
        }, {
          key: "displayExistingFile",
          value: function displayExistingFile(mockFile, imageUrl, callback, crossOrigin) {
            var _this12 = this;
            var resizeThumbnail = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
            this.emit("addedfile", mockFile);
            this.emit("complete", mockFile);
            if (!resizeThumbnail) {
              this.emit("thumbnail", mockFile, imageUrl);
              if (callback) callback();
            } else {
              var onDone = function onDone(thumbnail) {
                _this12.emit("thumbnail", mockFile, thumbnail);
                if (callback) callback();
              };
              mockFile.dataURL = imageUrl;
              this.createThumbnailFromUrl(mockFile, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.thumbnailMethod, this.options.fixOrientation, onDone, crossOrigin);
            }
          }
        }, {
          key: "createThumbnailFromUrl",
          value: function createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback, crossOrigin) {
            var _this13 = this;

            // Not using `new Image` here because of a bug in latest Chrome versions.
            // See https://github.com/enyo/dropzone/pull/226
            var img = document.createElement("img");
            if (crossOrigin) {
              img.crossOrigin = crossOrigin;
            } // fixOrientation is not needed anymore with browsers handling imageOrientation

            fixOrientation = getComputedStyle(document.body)["imageOrientation"] == "from-image" ? false : fixOrientation;
            img.onload = function () {
              var loadExif = function loadExif(callback) {
                return callback(1);
              };
              if (typeof EXIF !== "undefined" && EXIF !== null && fixOrientation) {
                loadExif = function loadExif(callback) {
                  return EXIF.getData(img, function () {
                    return callback(EXIF.getTag(this, "Orientation"));
                  });
                };
              }
              return loadExif(function (orientation) {
                file.width = img.width;
                file.height = img.height;
                var resizeInfo = _this13.options.resize.call(_this13, file, width, height, resizeMethod);
                var canvas = document.createElement("canvas");
                var ctx = canvas.getContext("2d");
                canvas.width = resizeInfo.trgWidth;
                canvas.height = resizeInfo.trgHeight;
                if (orientation > 4) {
                  canvas.width = resizeInfo.trgHeight;
                  canvas.height = resizeInfo.trgWidth;
                }
                switch (orientation) {
                  case 2:
                    // horizontal flip
                    ctx.translate(canvas.width, 0);
                    ctx.scale(-1, 1);
                    break;
                  case 3:
                    // 180° rotate left
                    ctx.translate(canvas.width, canvas.height);
                    ctx.rotate(Math.PI);
                    break;
                  case 4:
                    // vertical flip
                    ctx.translate(0, canvas.height);
                    ctx.scale(1, -1);
                    break;
                  case 5:
                    // vertical flip + 90 rotate right
                    ctx.rotate(0.5 * Math.PI);
                    ctx.scale(1, -1);
                    break;
                  case 6:
                    // 90° rotate right
                    ctx.rotate(0.5 * Math.PI);
                    ctx.translate(0, -canvas.width);
                    break;
                  case 7:
                    // horizontal flip + 90 rotate right
                    ctx.rotate(0.5 * Math.PI);
                    ctx.translate(canvas.height, -canvas.width);
                    ctx.scale(-1, 1);
                    break;
                  case 8:
                    // 90° rotate left
                    ctx.rotate(-0.5 * Math.PI);
                    ctx.translate(-canvas.height, 0);
                    break;
                } // This is a bugfix for iOS' scaling bug.

                drawImageIOSFix(ctx, img, resizeInfo.srcX != null ? resizeInfo.srcX : 0, resizeInfo.srcY != null ? resizeInfo.srcY : 0, resizeInfo.srcWidth, resizeInfo.srcHeight, resizeInfo.trgX != null ? resizeInfo.trgX : 0, resizeInfo.trgY != null ? resizeInfo.trgY : 0, resizeInfo.trgWidth, resizeInfo.trgHeight);
                var thumbnail = canvas.toDataURL("image/png");
                if (callback != null) {
                  return callback(thumbnail, canvas);
                }
              });
            };
            if (callback != null) {
              img.onerror = callback;
            }
            return img.src = file.dataURL;
          } // Goes through the queue and processes files if there aren't too many already.
        }, {
          key: "processQueue",
          value: function processQueue() {
            var parallelUploads = this.options.parallelUploads;
            var processingLength = this.getUploadingFiles().length;
            var i = processingLength; // There are already at least as many files uploading than should be

            if (processingLength >= parallelUploads) {
              return;
            }
            var queuedFiles = this.getQueuedFiles();
            if (!(queuedFiles.length > 0)) {
              return;
            }
            if (this.options.uploadMultiple) {
              // The files should be uploaded in one request
              return this.processFiles(queuedFiles.slice(0, parallelUploads - processingLength));
            } else {
              while (i < parallelUploads) {
                if (!queuedFiles.length) {
                  return;
                } // Nothing left to process

                this.processFile(queuedFiles.shift());
                i++;
              }
            }
          } // Wrapper for `processFiles`
        }, {
          key: "processFile",
          value: function processFile(file) {
            return this.processFiles([file]);
          } // Loads the file, then calls finishedLoading()
        }, {
          key: "processFiles",
          value: function processFiles(files) {
            var _iterator10 = dropzone_createForOfIteratorHelper(files, true),
              _step10;
            try {
              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                var file = _step10.value;
                file.processing = true; // Backwards compatibility

                file.status = Dropzone.UPLOADING;
                this.emit("processing", file);
              }
            } catch (err) {
              _iterator10.e(err);
            } finally {
              _iterator10.f();
            }
            if (this.options.uploadMultiple) {
              this.emit("processingmultiple", files);
            }
            return this.uploadFiles(files);
          }
        }, {
          key: "_getFilesWithXhr",
          value: function _getFilesWithXhr(xhr) {
            var files;
            return files = this.files.filter(function (file) {
              return file.xhr === xhr;
            }).map(function (file) {
              return file;
            });
          } // Cancels the file upload and sets the status to CANCELED
          // **if** the file is actually being uploaded.
          // If it's still in the queue, the file is being removed from it and the status
          // set to CANCELED.
        }, {
          key: "cancelUpload",
          value: function cancelUpload(file) {
            if (file.status === Dropzone.UPLOADING) {
              var groupedFiles = this._getFilesWithXhr(file.xhr);
              var _iterator11 = dropzone_createForOfIteratorHelper(groupedFiles, true),
                _step11;
              try {
                for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
                  var groupedFile = _step11.value;
                  groupedFile.status = Dropzone.CANCELED;
                }
              } catch (err) {
                _iterator11.e(err);
              } finally {
                _iterator11.f();
              }
              if (typeof file.xhr !== "undefined") {
                file.xhr.abort();
              }
              var _iterator12 = dropzone_createForOfIteratorHelper(groupedFiles, true),
                _step12;
              try {
                for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
                  var _groupedFile = _step12.value;
                  this.emit("canceled", _groupedFile);
                }
              } catch (err) {
                _iterator12.e(err);
              } finally {
                _iterator12.f();
              }
              if (this.options.uploadMultiple) {
                this.emit("canceledmultiple", groupedFiles);
              }
            } else if (file.status === Dropzone.ADDED || file.status === Dropzone.QUEUED) {
              file.status = Dropzone.CANCELED;
              this.emit("canceled", file);
              if (this.options.uploadMultiple) {
                this.emit("canceledmultiple", [file]);
              }
            }
            if (this.options.autoProcessQueue) {
              return this.processQueue();
            }
          }
        }, {
          key: "resolveOption",
          value: function resolveOption(option) {
            if (typeof option === "function") {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              return option.apply(this, args);
            }
            return option;
          }
        }, {
          key: "uploadFile",
          value: function uploadFile(file) {
            return this.uploadFiles([file]);
          }
        }, {
          key: "uploadFiles",
          value: function uploadFiles(files) {
            var _this14 = this;
            this._transformFiles(files, function (transformedFiles) {
              if (_this14.options.chunking) {
                // Chunking is not allowed to be used with `uploadMultiple` so we know
                // that there is only __one__file.
                var transformedFile = transformedFiles[0];
                files[0].upload.chunked = _this14.options.chunking && (_this14.options.forceChunking || transformedFile.size > _this14.options.chunkSize);
                files[0].upload.totalChunkCount = Math.ceil(transformedFile.size / _this14.options.chunkSize);
              }
              if (files[0].upload.chunked) {
                // This file should be sent in chunks!
                // If the chunking option is set, we **know** that there can only be **one** file, since
                // uploadMultiple is not allowed with this option.
                var file = files[0];
                var _transformedFile = transformedFiles[0];
                var startedChunkCount = 0;
                file.upload.chunks = [];
                var handleNextChunk = function handleNextChunk() {
                  var chunkIndex = 0; // Find the next item in file.upload.chunks that is not defined yet.

                  while (file.upload.chunks[chunkIndex] !== undefined) {
                    chunkIndex++;
                  } // This means, that all chunks have already been started.

                  if (chunkIndex >= file.upload.totalChunkCount) return;
                  startedChunkCount++;
                  var start = chunkIndex * _this14.options.chunkSize;
                  var end = Math.min(start + _this14.options.chunkSize, _transformedFile.size);
                  var dataBlock = {
                    name: _this14._getParamName(0),
                    data: _transformedFile.webkitSlice ? _transformedFile.webkitSlice(start, end) : _transformedFile.slice(start, end),
                    filename: file.upload.filename,
                    chunkIndex: chunkIndex
                  };
                  file.upload.chunks[chunkIndex] = {
                    file: file,
                    index: chunkIndex,
                    dataBlock: dataBlock,
                    // In case we want to retry.
                    status: Dropzone.UPLOADING,
                    progress: 0,
                    retries: 0 // The number of times this block has been retried.
                  };
                  _this14._uploadData(files, [dataBlock]);
                };
                file.upload.finishedChunkUpload = function (chunk, response) {
                  var allFinished = true;
                  chunk.status = Dropzone.SUCCESS; // Clear the data from the chunk

                  chunk.dataBlock = null; // Leaving this reference to xhr intact here will cause memory leaks in some browsers

                  chunk.xhr = null;
                  for (var i = 0; i < file.upload.totalChunkCount; i++) {
                    if (file.upload.chunks[i] === undefined) {
                      return handleNextChunk();
                    }
                    if (file.upload.chunks[i].status !== Dropzone.SUCCESS) {
                      allFinished = false;
                    }
                  }
                  if (allFinished) {
                    _this14.options.chunksUploaded(file, function () {
                      _this14._finished(files, response, null);
                    });
                  }
                };
                if (_this14.options.parallelChunkUploads) {
                  for (var i = 0; i < file.upload.totalChunkCount; i++) {
                    handleNextChunk();
                  }
                } else {
                  handleNextChunk();
                }
              } else {
                var dataBlocks = [];
                for (var _i2 = 0; _i2 < files.length; _i2++) {
                  dataBlocks[_i2] = {
                    name: _this14._getParamName(_i2),
                    data: transformedFiles[_i2],
                    filename: files[_i2].upload.filename
                  };
                }
                _this14._uploadData(files, dataBlocks);
              }
            });
          } /// Returns the right chunk for given file and xhr
        }, {
          key: "_getChunk",
          value: function _getChunk(file, xhr) {
            for (var i = 0; i < file.upload.totalChunkCount; i++) {
              if (file.upload.chunks[i] !== undefined && file.upload.chunks[i].xhr === xhr) {
                return file.upload.chunks[i];
              }
            }
          } // This function actually uploads the file(s) to the server.
          // If dataBlocks contains the actual data to upload (meaning, that this could either be transformed
          // files, or individual chunks for chunked upload).
        }, {
          key: "_uploadData",
          value: function _uploadData(files, dataBlocks) {
            var _this15 = this;
            var xhr = new XMLHttpRequest(); // Put the xhr object in the file objects to be able to reference it later.

            var _iterator13 = dropzone_createForOfIteratorHelper(files, true),
              _step13;
            try {
              for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
                var file = _step13.value;
                file.xhr = xhr;
              }
            } catch (err) {
              _iterator13.e(err);
            } finally {
              _iterator13.f();
            }
            if (files[0].upload.chunked) {
              // Put the xhr object in the right chunk object, so it can be associated later, and found with _getChunk
              files[0].upload.chunks[dataBlocks[0].chunkIndex].xhr = xhr;
            }
            var method = this.resolveOption(this.options.method, files);
            var url = this.resolveOption(this.options.url, files);
            xhr.open(method, url, true); // Setting the timeout after open because of IE11 issue: https://gitlab.com/meno/dropzone/issues/8

            var timeout = this.resolveOption(this.options.timeout, files);
            if (timeout) xhr.timeout = this.resolveOption(this.options.timeout, files); // Has to be after `.open()`. See https://github.com/enyo/dropzone/issues/179

            xhr.withCredentials = !!this.options.withCredentials;
            xhr.onload = function (e) {
              _this15._finishedUploading(files, xhr, e);
            };
            xhr.ontimeout = function () {
              _this15._handleUploadError(files, xhr, "Request timedout after ".concat(_this15.options.timeout / 1000, " seconds"));
            };
            xhr.onerror = function () {
              _this15._handleUploadError(files, xhr);
            }; // Some browsers do not have the .upload property

            var progressObj = xhr.upload != null ? xhr.upload : xhr;
            progressObj.onprogress = function (e) {
              return _this15._updateFilesUploadProgress(files, xhr, e);
            };
            var headers = {
              Accept: "application/json",
              "Cache-Control": "no-cache",
              "X-Requested-With": "XMLHttpRequest"
            };
            if (this.options.headers) {
              Dropzone.extend(headers, this.options.headers);
            }
            for (var headerName in headers) {
              var headerValue = headers[headerName];
              if (headerValue) {
                xhr.setRequestHeader(headerName, headerValue);
              }
            }
            var formData = new FormData(); // Adding all @options parameters

            if (this.options.params) {
              var additionalParams = this.options.params;
              if (typeof additionalParams === "function") {
                additionalParams = additionalParams.call(this, files, xhr, files[0].upload.chunked ? this._getChunk(files[0], xhr) : null);
              }
              for (var key in additionalParams) {
                var value = additionalParams[key];
                if (Array.isArray(value)) {
                  // The additional parameter contains an array,
                  // so lets iterate over it to attach each value
                  // individually.
                  for (var i = 0; i < value.length; i++) {
                    formData.append(key, value[i]);
                  }
                } else {
                  formData.append(key, value);
                }
              }
            } // Let the user add additional data if necessary

            var _iterator14 = dropzone_createForOfIteratorHelper(files, true),
              _step14;
            try {
              for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
                var _file = _step14.value;
                this.emit("sending", _file, xhr, formData);
              }
            } catch (err) {
              _iterator14.e(err);
            } finally {
              _iterator14.f();
            }
            if (this.options.uploadMultiple) {
              this.emit("sendingmultiple", files, xhr, formData);
            }
            this._addFormElementData(formData); // Finally add the files
            // Has to be last because some servers (eg: S3) expect the file to be the last parameter

            for (var _i3 = 0; _i3 < dataBlocks.length; _i3++) {
              var dataBlock = dataBlocks[_i3];
              formData.append(dataBlock.name, dataBlock.data, dataBlock.filename);
            }
            this.submitRequest(xhr, formData, files);
          } // Transforms all files with this.options.transformFile and invokes done with the transformed files when done.
        }, {
          key: "_transformFiles",
          value: function _transformFiles(files, done) {
            var _this16 = this;
            var transformedFiles = []; // Clumsy way of handling asynchronous calls, until I get to add a proper Future library.

            var doneCounter = 0;
            var _loop = function _loop(i) {
              _this16.options.transformFile.call(_this16, files[i], function (transformedFile) {
                transformedFiles[i] = transformedFile;
                if (++doneCounter === files.length) {
                  done(transformedFiles);
                }
              });
            };
            for (var i = 0; i < files.length; i++) {
              _loop(i);
            }
          } // Takes care of adding other input elements of the form to the AJAX request
        }, {
          key: "_addFormElementData",
          value: function _addFormElementData(formData) {
            // Take care of other input elements
            if (this.element.tagName === "FORM") {
              var _iterator15 = dropzone_createForOfIteratorHelper(this.element.querySelectorAll("input, textarea, select, button"), true),
                _step15;
              try {
                for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
                  var input = _step15.value;
                  var inputName = input.getAttribute("name");
                  var inputType = input.getAttribute("type");
                  if (inputType) inputType = inputType.toLowerCase(); // If the input doesn't have a name, we can't use it.

                  if (typeof inputName === "undefined" || inputName === null) continue;
                  if (input.tagName === "SELECT" && input.hasAttribute("multiple")) {
                    // Possibly multiple values
                    var _iterator16 = dropzone_createForOfIteratorHelper(input.options, true),
                      _step16;
                    try {
                      for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
                        var option = _step16.value;
                        if (option.selected) {
                          formData.append(inputName, option.value);
                        }
                      }
                    } catch (err) {
                      _iterator16.e(err);
                    } finally {
                      _iterator16.f();
                    }
                  } else if (!inputType || inputType !== "checkbox" && inputType !== "radio" || input.checked) {
                    formData.append(inputName, input.value);
                  }
                }
              } catch (err) {
                _iterator15.e(err);
              } finally {
                _iterator15.f();
              }
            }
          } // Invoked when there is new progress information about given files.
          // If e is not provided, it is assumed that the upload is finished.
        }, {
          key: "_updateFilesUploadProgress",
          value: function _updateFilesUploadProgress(files, xhr, e) {
            if (!files[0].upload.chunked) {
              // Handle file uploads without chunking
              var _iterator17 = dropzone_createForOfIteratorHelper(files, true),
                _step17;
              try {
                for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
                  var file = _step17.value;
                  if (file.upload.total && file.upload.bytesSent && file.upload.bytesSent == file.upload.total) {
                    // If both, the `total` and `bytesSent` have already been set, and
                    // they are equal (meaning progress is at 100%), we can skip this
                    // file, since an upload progress shouldn't go down.
                    continue;
                  }
                  if (e) {
                    file.upload.progress = 100 * e.loaded / e.total;
                    file.upload.total = e.total;
                    file.upload.bytesSent = e.loaded;
                  } else {
                    // No event, so we're at 100%
                    file.upload.progress = 100;
                    file.upload.bytesSent = file.upload.total;
                  }
                  this.emit("uploadprogress", file, file.upload.progress, file.upload.bytesSent);
                }
              } catch (err) {
                _iterator17.e(err);
              } finally {
                _iterator17.f();
              }
            } else {
              // Handle chunked file uploads
              // Chunked upload is not compatible with uploading multiple files in one
              // request, so we know there's only one file.
              var _file2 = files[0]; // Since this is a chunked upload, we need to update the appropriate chunk
              // progress.

              var chunk = this._getChunk(_file2, xhr);
              if (e) {
                chunk.progress = 100 * e.loaded / e.total;
                chunk.total = e.total;
                chunk.bytesSent = e.loaded;
              } else {
                // No event, so we're at 100%
                chunk.progress = 100;
                chunk.bytesSent = chunk.total;
              } // Now tally the *file* upload progress from its individual chunks

              _file2.upload.progress = 0;
              _file2.upload.total = 0;
              _file2.upload.bytesSent = 0;
              for (var i = 0; i < _file2.upload.totalChunkCount; i++) {
                if (_file2.upload.chunks[i] && typeof _file2.upload.chunks[i].progress !== "undefined") {
                  _file2.upload.progress += _file2.upload.chunks[i].progress;
                  _file2.upload.total += _file2.upload.chunks[i].total;
                  _file2.upload.bytesSent += _file2.upload.chunks[i].bytesSent;
                }
              } // Since the process is a percentage, we need to divide by the amount of
              // chunks we've used.

              _file2.upload.progress = _file2.upload.progress / _file2.upload.totalChunkCount;
              this.emit("uploadprogress", _file2, _file2.upload.progress, _file2.upload.bytesSent);
            }
          }
        }, {
          key: "_finishedUploading",
          value: function _finishedUploading(files, xhr, e) {
            var response;
            if (files[0].status === Dropzone.CANCELED) {
              return;
            }
            if (xhr.readyState !== 4) {
              return;
            }
            if (xhr.responseType !== "arraybuffer" && xhr.responseType !== "blob") {
              response = xhr.responseText;
              if (xhr.getResponseHeader("content-type") && ~xhr.getResponseHeader("content-type").indexOf("application/json")) {
                try {
                  response = JSON.parse(response);
                } catch (error) {
                  e = error;
                  response = "Invalid JSON response from server.";
                }
              }
            }
            this._updateFilesUploadProgress(files, xhr);
            if (!(200 <= xhr.status && xhr.status < 300)) {
              this._handleUploadError(files, xhr, response);
            } else {
              if (files[0].upload.chunked) {
                files[0].upload.finishedChunkUpload(this._getChunk(files[0], xhr), response);
              } else {
                this._finished(files, response, e);
              }
            }
          }
        }, {
          key: "_handleUploadError",
          value: function _handleUploadError(files, xhr, response) {
            if (files[0].status === Dropzone.CANCELED) {
              return;
            }
            if (files[0].upload.chunked && this.options.retryChunks) {
              var chunk = this._getChunk(files[0], xhr);
              if (chunk.retries++ < this.options.retryChunksLimit) {
                this._uploadData(files, [chunk.dataBlock]);
                return;
              } else {
                console.warn("Retried this chunk too often. Giving up.");
              }
            }
            this._errorProcessing(files, response || this.options.dictResponseError.replace("{{statusCode}}", xhr.status), xhr);
          }
        }, {
          key: "submitRequest",
          value: function submitRequest(xhr, formData, files) {
            if (xhr.readyState != 1) {
              console.warn("Cannot send this request because the XMLHttpRequest.readyState is not OPENED.");
              return;
            }
            xhr.send(formData);
          } // Called internally when processing is finished.
          // Individual callbacks have to be called in the appropriate sections.
        }, {
          key: "_finished",
          value: function _finished(files, responseText, e) {
            var _iterator18 = dropzone_createForOfIteratorHelper(files, true),
              _step18;
            try {
              for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
                var file = _step18.value;
                file.status = Dropzone.SUCCESS;
                this.emit("success", file, responseText, e);
                this.emit("complete", file);
              }
            } catch (err) {
              _iterator18.e(err);
            } finally {
              _iterator18.f();
            }
            if (this.options.uploadMultiple) {
              this.emit("successmultiple", files, responseText, e);
              this.emit("completemultiple", files);
            }
            if (this.options.autoProcessQueue) {
              return this.processQueue();
            }
          } // Called internally when processing is finished.
          // Individual callbacks have to be called in the appropriate sections.
        }, {
          key: "_errorProcessing",
          value: function _errorProcessing(files, message, xhr) {
            var _iterator19 = dropzone_createForOfIteratorHelper(files, true),
              _step19;
            try {
              for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
                var file = _step19.value;
                file.status = Dropzone.ERROR;
                this.emit("error", file, message, xhr);
                this.emit("complete", file);
              }
            } catch (err) {
              _iterator19.e(err);
            } finally {
              _iterator19.f();
            }
            if (this.options.uploadMultiple) {
              this.emit("errormultiple", files, message, xhr);
              this.emit("completemultiple", files);
            }
            if (this.options.autoProcessQueue) {
              return this.processQueue();
            }
          }
        }], [{
          key: "initClass",
          value: function initClass() {
            // Exposing the emitter class, mainly for tests
            this.prototype.Emitter = Emitter;
            /*
             This is a list of all available events you can register on a dropzone object.
              You can register an event handler like this:
              dropzone.on("dragEnter", function() { });
              */

            this.prototype.events = ["drop", "dragstart", "dragend", "dragenter", "dragover", "dragleave", "addedfile", "addedfiles", "removedfile", "thumbnail", "error", "errormultiple", "processing", "processingmultiple", "uploadprogress", "totaluploadprogress", "sending", "sendingmultiple", "success", "successmultiple", "canceled", "canceledmultiple", "complete", "completemultiple", "reset", "maxfilesexceeded", "maxfilesreached", "queuecomplete"];
            this.prototype._thumbnailQueue = [];
            this.prototype._processingThumbnail = false;
          } // global utility
        }, {
          key: "extend",
          value: function extend(target) {
            for (var _len2 = arguments.length, objects = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              objects[_key2 - 1] = arguments[_key2];
            }
            for (var _i4 = 0, _objects = objects; _i4 < _objects.length; _i4++) {
              var object = _objects[_i4];
              for (var key in object) {
                var val = object[key];
                target[key] = val;
              }
            }
            return target;
          }
        }, {
          key: "uuidv4",
          value: function uuidv4() {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
              var r = Math.random() * 16 | 0,
                v = c === "x" ? r : r & 0x3 | 0x8;
              return v.toString(16);
            });
          }
        }]);
        return Dropzone;
      }(Emitter);
      Dropzone.initClass();
      Dropzone.version = "5.9.3"; // This is a map of options for your different dropzones. Add configurations
      // to this object for your different dropzone elemens.
      //
      // Example:
      //
      //     Dropzone.options.myDropzoneElementId = { maxFilesize: 1 };
      //
      // To disable autoDiscover for a specific element, you can set `false` as an option:
      //
      //     Dropzone.options.myDisabledElementId = false;
      //
      // And in html:
      //
      //     <form action="/upload" id="my-dropzone-element-id" class="dropzone"></form>

      Dropzone.options = {}; // Returns the options for an element or undefined if none available.

      Dropzone.optionsForElement = function (element) {
        // Get the `Dropzone.options.elementId` for this element if it exists
        if (element.getAttribute("id")) {
          return Dropzone.options[camelize(element.getAttribute("id"))];
        } else {
          return undefined;
        }
      }; // Holds a list of all dropzone instances

      Dropzone.instances = []; // Returns the dropzone for given element if any

      Dropzone.forElement = function (element) {
        if (typeof element === "string") {
          element = document.querySelector(element);
        }
        if ((element != null ? element.dropzone : undefined) == null) {
          throw new Error("No Dropzone found for given element. This is probably because you're trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone.");
        }
        return element.dropzone;
      }; // Set to false if you don't want Dropzone to automatically find and attach to .dropzone elements.

      Dropzone.autoDiscover = true; // Looks for all .dropzone elements and creates a dropzone for them

      Dropzone.discover = function () {
        var dropzones;
        if (document.querySelectorAll) {
          dropzones = document.querySelectorAll(".dropzone");
        } else {
          dropzones = []; // IE :(

          var checkElements = function checkElements(elements) {
            return function () {
              var result = [];
              var _iterator20 = dropzone_createForOfIteratorHelper(elements, true),
                _step20;
              try {
                for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
                  var el = _step20.value;
                  if (/(^| )dropzone($| )/.test(el.className)) {
                    result.push(dropzones.push(el));
                  } else {
                    result.push(undefined);
                  }
                }
              } catch (err) {
                _iterator20.e(err);
              } finally {
                _iterator20.f();
              }
              return result;
            }();
          };
          checkElements(document.getElementsByTagName("div"));
          checkElements(document.getElementsByTagName("form"));
        }
        return function () {
          var result = [];
          var _iterator21 = dropzone_createForOfIteratorHelper(dropzones, true),
            _step21;
          try {
            for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
              var dropzone = _step21.value;

              // Create a dropzone unless auto discover has been disabled for specific element
              if (Dropzone.optionsForElement(dropzone) !== false) {
                result.push(new Dropzone(dropzone));
              } else {
                result.push(undefined);
              }
            }
          } catch (err) {
            _iterator21.e(err);
          } finally {
            _iterator21.f();
          }
          return result;
        }();
      }; // Some browsers support drag and drog functionality, but not correctly.
      //
      // So I created a blocklist of userAgents. Yes, yes. Browser sniffing, I know.
      // But what to do when browsers *theoretically* support an API, but crash
      // when using it.
      //
      // This is a list of regular expressions tested against navigator.userAgent
      //
      // ** It should only be used on browser that *do* support the API, but
      // incorrectly **

      Dropzone.blockedBrowsers = [
      // The mac os and windows phone version of opera 12 seems to have a problem with the File drag'n'drop API.
      /opera.*(Macintosh|Windows Phone).*version\/12/i]; // Checks if the browser is supported

      Dropzone.isBrowserSupported = function () {
        var capableBrowser = true;
        if (window.File && window.FileReader && window.FileList && window.Blob && window.FormData && document.querySelector) {
          if (!("classList" in document.createElement("a"))) {
            capableBrowser = false;
          } else {
            if (Dropzone.blacklistedBrowsers !== undefined) {
              // Since this has been renamed, this makes sure we don't break older
              // configuration.
              Dropzone.blockedBrowsers = Dropzone.blacklistedBrowsers;
            } // The browser supports the API, but may be blocked.

            var _iterator22 = dropzone_createForOfIteratorHelper(Dropzone.blockedBrowsers, true),
              _step22;
            try {
              for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
                var regex = _step22.value;
                if (regex.test(navigator.userAgent)) {
                  capableBrowser = false;
                  continue;
                }
              }
            } catch (err) {
              _iterator22.e(err);
            } finally {
              _iterator22.f();
            }
          }
        } else {
          capableBrowser = false;
        }
        return capableBrowser;
      };
      Dropzone.dataURItoBlob = function (dataURI) {
        // convert base64 to raw binary data held in a string
        // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
        var byteString = atob(dataURI.split(",")[1]); // separate out the mime component

        var mimeString = dataURI.split(",")[0].split(":")[1].split(";")[0]; // write the bytes of the string to an ArrayBuffer

        var ab = new ArrayBuffer(byteString.length);
        var ia = new Uint8Array(ab);
        for (var i = 0, end = byteString.length, asc = 0 <= end; asc ? i <= end : i >= end; asc ? i++ : i--) {
          ia[i] = byteString.charCodeAt(i);
        } // write the ArrayBuffer to a blob

        return new Blob([ab], {
          type: mimeString
        });
      }; // Returns an array without the rejected item

      var without = function without(list, rejectedItem) {
        return list.filter(function (item) {
          return item !== rejectedItem;
        }).map(function (item) {
          return item;
        });
      }; // abc-def_ghi -> abcDefGhi

      var camelize = function camelize(str) {
        return str.replace(/[\-_](\w)/g, function (match) {
          return match.charAt(1).toUpperCase();
        });
      }; // Creates an element from string

      Dropzone.createElement = function (string) {
        var div = document.createElement("div");
        div.innerHTML = string;
        return div.childNodes[0];
      }; // Tests if given element is inside (or simply is) the container

      Dropzone.elementInside = function (element, container) {
        if (element === container) {
          return true;
        } // Coffeescript doesn't support do/while loops

        while (element = element.parentNode) {
          if (element === container) {
            return true;
          }
        }
        return false;
      };
      Dropzone.getElement = function (el, name) {
        var element;
        if (typeof el === "string") {
          element = document.querySelector(el);
        } else if (el.nodeType != null) {
          element = el;
        }
        if (element == null) {
          throw new Error("Invalid `".concat(name, "` option provided. Please provide a CSS selector or a plain HTML element."));
        }
        return element;
      };
      Dropzone.getElements = function (els, name) {
        var el, elements;
        if (els instanceof Array) {
          elements = [];
          try {
            var _iterator23 = dropzone_createForOfIteratorHelper(els, true),
              _step23;
            try {
              for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
                el = _step23.value;
                elements.push(this.getElement(el, name));
              }
            } catch (err) {
              _iterator23.e(err);
            } finally {
              _iterator23.f();
            }
          } catch (e) {
            elements = null;
          }
        } else if (typeof els === "string") {
          elements = [];
          var _iterator24 = dropzone_createForOfIteratorHelper(document.querySelectorAll(els), true),
            _step24;
          try {
            for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
              el = _step24.value;
              elements.push(el);
            }
          } catch (err) {
            _iterator24.e(err);
          } finally {
            _iterator24.f();
          }
        } else if (els.nodeType != null) {
          elements = [els];
        }
        if (elements == null || !elements.length) {
          throw new Error("Invalid `".concat(name, "` option provided. Please provide a CSS selector, a plain HTML element or a list of those."));
        }
        return elements;
      }; // Asks the user the question and calls accepted or rejected accordingly
      //
      // The default implementation just uses `window.confirm` and then calls the
      // appropriate callback.

      Dropzone.confirm = function (question, accepted, rejected) {
        if (window.confirm(question)) {
          return accepted();
        } else if (rejected != null) {
          return rejected();
        }
      }; // Validates the mime type like this:
      //
      // https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept

      Dropzone.isValidFile = function (file, acceptedFiles) {
        if (!acceptedFiles) {
          return true;
        } // If there are no accepted mime types, it's OK

        acceptedFiles = acceptedFiles.split(",");
        var mimeType = file.type;
        var baseMimeType = mimeType.replace(/\/.*$/, "");
        var _iterator25 = dropzone_createForOfIteratorHelper(acceptedFiles, true),
          _step25;
        try {
          for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
            var validType = _step25.value;
            validType = validType.trim();
            if (validType.charAt(0) === ".") {
              if (file.name.toLowerCase().indexOf(validType.toLowerCase(), file.name.length - validType.length) !== -1) {
                return true;
              }
            } else if (/\/\*$/.test(validType)) {
              // This is something like a image/* mime type
              if (baseMimeType === validType.replace(/\/.*$/, "")) {
                return true;
              }
            } else {
              if (mimeType === validType) {
                return true;
              }
            }
          }
        } catch (err) {
          _iterator25.e(err);
        } finally {
          _iterator25.f();
        }
        return false;
      }; // Augment jQuery

      if (typeof jQuery !== "undefined" && jQuery !== null) {
        jQuery.fn.dropzone = function (options) {
          return this.each(function () {
            return new Dropzone(this, options);
          });
        };
      } // Dropzone file status codes

      Dropzone.ADDED = "added";
      Dropzone.QUEUED = "queued"; // For backwards compatibility. Now, if a file is accepted, it's either queued
      // or uploading.

      Dropzone.ACCEPTED = Dropzone.QUEUED;
      Dropzone.UPLOADING = "uploading";
      Dropzone.PROCESSING = Dropzone.UPLOADING; // alias

      Dropzone.CANCELED = "canceled";
      Dropzone.ERROR = "error";
      Dropzone.SUCCESS = "success";
      /*
      
       Bugfix for iOS 6 and 7
       Source: http://stackoverflow.com/questions/11929099/html5-canvas-drawimage-ratio-bug-ios
       based on the work of https://github.com/stomita/ios-imagefile-megapixel
      
       */
      // Detecting vertical squash in loaded image.
      // Fixes a bug which squash image vertically while drawing into canvas for some images.
      // This is a bug in iOS6 devices. This function from https://github.com/stomita/ios-imagefile-megapixel

      var detectVerticalSquash = function detectVerticalSquash(img) {
        var iw = img.naturalWidth;
        var ih = img.naturalHeight;
        var canvas = document.createElement("canvas");
        canvas.width = 1;
        canvas.height = ih;
        var ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        var _ctx$getImageData = ctx.getImageData(1, 0, 1, ih),
          data = _ctx$getImageData.data; // search image edge pixel position in case it is squashed vertically.

        var sy = 0;
        var ey = ih;
        var py = ih;
        while (py > sy) {
          var alpha = data[(py - 1) * 4 + 3];
          if (alpha === 0) {
            ey = py;
          } else {
            sy = py;
          }
          py = ey + sy >> 1;
        }
        var ratio = py / ih;
        if (ratio === 0) {
          return 1;
        } else {
          return ratio;
        }
      }; // A replacement for context.drawImage
      // (args are for source and destination).

      var drawImageIOSFix = function drawImageIOSFix(ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {
        var vertSquashRatio = detectVerticalSquash(img);
        return ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh / vertSquashRatio);
      }; // Based on MinifyJpeg
      // Source: http://www.perry.cz/files/ExifRestorer.js
      // http://elicon.blog57.fc2.com/blog-entry-206.html

      var ExifRestore = /*#__PURE__*/function () {
        function ExifRestore() {
          dropzone_classCallCheck(this, ExifRestore);
        }
        dropzone_createClass(ExifRestore, null, [{
          key: "initClass",
          value: function initClass() {
            this.KEY_STR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          }
        }, {
          key: "encode64",
          value: function encode64(input) {
            var output = "";
            var chr1 = undefined;
            var chr2 = undefined;
            var chr3 = "";
            var enc1 = undefined;
            var enc2 = undefined;
            var enc3 = undefined;
            var enc4 = "";
            var i = 0;
            while (true) {
              chr1 = input[i++];
              chr2 = input[i++];
              chr3 = input[i++];
              enc1 = chr1 >> 2;
              enc2 = (chr1 & 3) << 4 | chr2 >> 4;
              enc3 = (chr2 & 15) << 2 | chr3 >> 6;
              enc4 = chr3 & 63;
              if (isNaN(chr2)) {
                enc3 = enc4 = 64;
              } else if (isNaN(chr3)) {
                enc4 = 64;
              }
              output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);
              chr1 = chr2 = chr3 = "";
              enc1 = enc2 = enc3 = enc4 = "";
              if (!(i < input.length)) {
                break;
              }
            }
            return output;
          }
        }, {
          key: "restore",
          value: function restore(origFileBase64, resizedFileBase64) {
            if (!origFileBase64.match("data:image/jpeg;base64,")) {
              return resizedFileBase64;
            }
            var rawImage = this.decode64(origFileBase64.replace("data:image/jpeg;base64,", ""));
            var segments = this.slice2Segments(rawImage);
            var image = this.exifManipulation(resizedFileBase64, segments);
            return "data:image/jpeg;base64,".concat(this.encode64(image));
          }
        }, {
          key: "exifManipulation",
          value: function exifManipulation(resizedFileBase64, segments) {
            var exifArray = this.getExifArray(segments);
            var newImageArray = this.insertExif(resizedFileBase64, exifArray);
            var aBuffer = new Uint8Array(newImageArray);
            return aBuffer;
          }
        }, {
          key: "getExifArray",
          value: function getExifArray(segments) {
            var seg = undefined;
            var x = 0;
            while (x < segments.length) {
              seg = segments[x];
              if (seg[0] === 255 & seg[1] === 225) {
                return seg;
              }
              x++;
            }
            return [];
          }
        }, {
          key: "insertExif",
          value: function insertExif(resizedFileBase64, exifArray) {
            var imageData = resizedFileBase64.replace("data:image/jpeg;base64,", "");
            var buf = this.decode64(imageData);
            var separatePoint = buf.indexOf(255, 3);
            var mae = buf.slice(0, separatePoint);
            var ato = buf.slice(separatePoint);
            var array = mae;
            array = array.concat(exifArray);
            array = array.concat(ato);
            return array;
          }
        }, {
          key: "slice2Segments",
          value: function slice2Segments(rawImageArray) {
            var head = 0;
            var segments = [];
            while (true) {
              var length;
              if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 218) {
                break;
              }
              if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 216) {
                head += 2;
              } else {
                length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3];
                var endPoint = head + length + 2;
                var seg = rawImageArray.slice(head, endPoint);
                segments.push(seg);
                head = endPoint;
              }
              if (head > rawImageArray.length) {
                break;
              }
            }
            return segments;
          }
        }, {
          key: "decode64",
          value: function decode64(input) {
            var output = "";
            var chr1 = undefined;
            var chr2 = undefined;
            var chr3 = "";
            var enc1 = undefined;
            var enc2 = undefined;
            var enc3 = undefined;
            var enc4 = "";
            var i = 0;
            var buf = []; // remove all characters that are not A-Z, a-z, 0-9, +, /, or =

            var base64test = /[^A-Za-z0-9\+\/\=]/g;
            if (base64test.exec(input)) {
              console.warn("There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\nExpect errors in decoding.");
            }
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
            while (true) {
              enc1 = this.KEY_STR.indexOf(input.charAt(i++));
              enc2 = this.KEY_STR.indexOf(input.charAt(i++));
              enc3 = this.KEY_STR.indexOf(input.charAt(i++));
              enc4 = this.KEY_STR.indexOf(input.charAt(i++));
              chr1 = enc1 << 2 | enc2 >> 4;
              chr2 = (enc2 & 15) << 4 | enc3 >> 2;
              chr3 = (enc3 & 3) << 6 | enc4;
              buf.push(chr1);
              if (enc3 !== 64) {
                buf.push(chr2);
              }
              if (enc4 !== 64) {
                buf.push(chr3);
              }
              chr1 = chr2 = chr3 = "";
              enc1 = enc2 = enc3 = enc4 = "";
              if (!(i < input.length)) {
                break;
              }
            }
            return buf;
          }
        }]);
        return ExifRestore;
      }();
      ExifRestore.initClass();
      /*
       * contentloaded.js
       *
       * Author: Diego Perini (diego.perini at gmail.com)
       * Summary: cross-browser wrapper for DOMContentLoaded
       * Updated: 20101020
       * License: MIT
       * Version: 1.2
       *
       * URL:
       * http://javascript.nwbox.com/ContentLoaded/
       * http://javascript.nwbox.com/ContentLoaded/MIT-LICENSE
       */
      // @win window reference
      // @fn function reference

      var contentLoaded = function contentLoaded(win, fn) {
        var done = false;
        var top = true;
        var doc = win.document;
        var root = doc.documentElement;
        var add = doc.addEventListener ? "addEventListener" : "attachEvent";
        var rem = doc.addEventListener ? "removeEventListener" : "detachEvent";
        var pre = doc.addEventListener ? "" : "on";
        var init = function init(e) {
          if (e.type === "readystatechange" && doc.readyState !== "complete") {
            return;
          }
          (e.type === "load" ? win : doc)[rem](pre + e.type, init, false);
          if (!done && (done = true)) {
            return fn.call(win, e.type || e);
          }
        };
        var poll = function poll() {
          try {
            root.doScroll("left");
          } catch (e) {
            setTimeout(poll, 50);
            return;
          }
          return init("poll");
        };
        if (doc.readyState !== "complete") {
          if (doc.createEventObject && root.doScroll) {
            try {
              top = !win.frameElement;
            } catch (error) {}
            if (top) {
              poll();
            }
          }
          doc[add](pre + "DOMContentLoaded", init, false);
          doc[add](pre + "readystatechange", init, false);
          return win[add](pre + "load", init, false);
        }
      }; // As a single function to be able to write tests.

      Dropzone._autoDiscoverFunction = function () {
        if (Dropzone.autoDiscover) {
          return Dropzone.discover();
        }
      };
      contentLoaded(window, Dropzone._autoDiscoverFunction);
      function __guard__(value, transform) {
        return typeof value !== "undefined" && value !== null ? transform(value) : undefined;
      }
      function __guardMethod__(obj, methodName, transform) {
        if (typeof obj !== "undefined" && obj !== null && typeof obj[methodName] === "function") {
          return transform(obj, methodName);
        } else {
          return undefined;
        }
      }
      ; // CONCATENATED MODULE: ./tool/dropzone.dist.js
      /// Make Dropzone a global variable.

      window.Dropzone = Dropzone;
      /* harmony default export */
      var dropzone_dist = Dropzone;
    }();
    /******/
    return __nested_webpack_exports__;
    /******/
  }();
});

/***/ }),

/***/ "./node_modules/fslightbox/index.js":
/*!******************************************!*\
  !*** ./node_modules/fslightbox/index.js ***!
  \******************************************/
/***/ ((module) => {

!function (e, t) {
  if (true) module.exports = t();else { var o, n; }
}(window, function () {
  return function (e) {
    var t = {};
    function n(o) {
      if (t[o]) return t[o].exports;
      var i = t[o] = {
        i: o,
        l: !1,
        exports: {}
      };
      return e[o].call(i.exports, i, i.exports, n), i.l = !0, i.exports;
    }
    return n.m = e, n.c = t, n.d = function (e, t, o) {
      n.o(e, t) || Object.defineProperty(e, t, {
        enumerable: !0,
        get: o
      });
    }, n.r = function (e) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
        value: "Module"
      }), Object.defineProperty(e, "__esModule", {
        value: !0
      });
    }, n.t = function (e, t) {
      if (1 & t && (e = n(e)), 8 & t) return e;
      if (4 & t && "object" == typeof e && e && e.__esModule) return e;
      var o = Object.create(null);
      if (n.r(o), Object.defineProperty(o, "default", {
        enumerable: !0,
        value: e
      }), 2 & t && "string" != typeof e) for (var i in e) n.d(o, i, function (t) {
        return e[t];
      }.bind(null, i));
      return o;
    }, n.n = function (e) {
      var t = e && e.__esModule ? function () {
        return e.default;
      } : function () {
        return e;
      };
      return n.d(t, "a", t), t;
    }, n.o = function (e, t) {
      return Object.prototype.hasOwnProperty.call(e, t);
    }, n.p = "", n(n.s = 0);
  }([function (e, t, n) {
    "use strict";

    n.r(t);
    var o,
      i = "fslightbox-",
      r = "".concat(i, "styles"),
      s = "".concat(i, "cursor-grabbing"),
      a = "".concat(i, "full-dimension"),
      c = "".concat(i, "flex-centered"),
      l = "".concat(i, "open"),
      u = "".concat(i, "transform-transition"),
      d = "".concat(i, "absoluted"),
      f = "".concat(i, "slide-btn"),
      p = "".concat(f, "-container"),
      h = "".concat(i, "fade-in"),
      m = "".concat(i, "fade-out"),
      g = h + "-strong",
      v = m + "-strong",
      b = "".concat(i, "opacity-"),
      x = "".concat(b, "1"),
      y = "".concat(i, "source");
    function w(e) {
      return (w = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e;
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
      })(e);
    }
    function S(e) {
      var t = e.stageIndexes,
        n = e.core.stageManager,
        o = e.props.sources.length - 1;
      n.getPreviousSlideIndex = function () {
        return 0 === t.current ? o : t.current - 1;
      }, n.getNextSlideIndex = function () {
        return t.current === o ? 0 : t.current + 1;
      }, n.updateStageIndexes = 0 === o ? function () {} : 1 === o ? function () {
        0 === t.current ? (t.next = 1, delete t.previous) : (t.previous = 0, delete t.next);
      } : function () {
        t.previous = n.getPreviousSlideIndex(), t.next = n.getNextSlideIndex();
      }, n.i = o <= 2 ? function () {
        return !0;
      } : function (e) {
        var n = t.current;
        if (0 === n && e === o || n === o && 0 === e) return !0;
        var i = n - e;
        return -1 === i || 0 === i || 1 === i;
      };
    }
    "object" === ("undefined" == typeof document ? "undefined" : w(document)) && ((o = document.createElement("style")).className = r, o.appendChild(document.createTextNode(".fslightbox-absoluted{position:absolute;top:0;left:0}.fslightbox-fade-in{animation:fslightbox-fade-in .3s cubic-bezier(0,0,.7,1)}.fslightbox-fade-out{animation:fslightbox-fade-out .3s ease}.fslightbox-fade-in-strong{animation:fslightbox-fade-in-strong .3s cubic-bezier(0,0,.7,1)}.fslightbox-fade-out-strong{animation:fslightbox-fade-out-strong .3s ease}@keyframes fslightbox-fade-in{from{opacity:.65}to{opacity:1}}@keyframes fslightbox-fade-out{from{opacity:.35}to{opacity:0}}@keyframes fslightbox-fade-in-strong{from{opacity:.3}to{opacity:1}}@keyframes fslightbox-fade-out-strong{from{opacity:1}to{opacity:0}}.fslightbox-cursor-grabbing{cursor:grabbing}.fslightbox-full-dimension{width:100%;height:100%}.fslightbox-open{overflow:hidden;height:100%}.fslightbox-flex-centered{display:flex;justify-content:center;align-items:center}.fslightbox-opacity-0{opacity:0!important}.fslightbox-opacity-1{opacity:1!important}.fslightbox-scrollbarfix{padding-right:17px}.fslightbox-transform-transition{transition:transform .3s}.fslightbox-container{font-family:Arial,sans-serif;position:fixed;top:0;left:0;background:linear-gradient(rgba(30,30,30,.9),#000 1810%);touch-action:pinch-zoom;z-index:1000000000;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent}.fslightbox-container *{box-sizing:border-box}.fslightbox-svg-path{transition:fill .15s ease;fill:#ddd}.fslightbox-nav{height:45px;width:100%;position:absolute;top:0;left:0}.fslightbox-slide-number-container{display:flex;justify-content:center;align-items:center;position:relative;height:100%;font-size:15px;color:#d7d7d7;z-index:0;max-width:55px;text-align:left}.fslightbox-slide-number-container .fslightbox-flex-centered{height:100%}.fslightbox-slash{display:block;margin:0 5px;width:1px;height:12px;transform:rotate(15deg);background:#fff}.fslightbox-toolbar{position:absolute;z-index:3;right:0;top:0;height:100%;display:flex;background:rgba(35,35,35,.65)}.fslightbox-toolbar-button{height:100%;width:45px;cursor:pointer}.fslightbox-toolbar-button:hover .fslightbox-svg-path{fill:#fff}.fslightbox-slide-btn-container{display:flex;align-items:center;padding:12px 12px 12px 6px;position:absolute;top:50%;cursor:pointer;z-index:3;transform:translateY(-50%)}@media (min-width:476px){.fslightbox-slide-btn-container{padding:22px 22px 22px 6px}}@media (min-width:768px){.fslightbox-slide-btn-container{padding:30px 30px 30px 6px}}.fslightbox-slide-btn-container:hover .fslightbox-svg-path{fill:#f1f1f1}.fslightbox-slide-btn{padding:9px;font-size:26px;background:rgba(35,35,35,.65)}@media (min-width:768px){.fslightbox-slide-btn{padding:10px}}@media (min-width:1600px){.fslightbox-slide-btn{padding:11px}}.fslightbox-slide-btn-container-previous{left:0}@media (max-width:475.99px){.fslightbox-slide-btn-container-previous{padding-left:3px}}.fslightbox-slide-btn-container-next{right:0;padding-left:12px;padding-right:3px}@media (min-width:476px){.fslightbox-slide-btn-container-next{padding-left:22px}}@media (min-width:768px){.fslightbox-slide-btn-container-next{padding-left:30px}}@media (min-width:476px){.fslightbox-slide-btn-container-next{padding-right:6px}}.fslightbox-down-event-detector{position:absolute;z-index:1}.fslightbox-slide-swiping-hoverer{z-index:4}.fslightbox-invalid-file-wrapper{font-size:22px;color:#eaebeb;margin:auto}.fslightbox-video{object-fit:cover}.fslightbox-youtube-iframe{border:0}.fslightboxl{display:block;margin:auto;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:67px;height:67px}.fslightboxl div{box-sizing:border-box;display:block;position:absolute;width:54px;height:54px;margin:6px;border:5px solid;border-color:#999 transparent transparent transparent;border-radius:50%;animation:fslightboxl 1.2s cubic-bezier(.5,0,.5,1) infinite}.fslightboxl div:nth-child(1){animation-delay:-.45s}.fslightboxl div:nth-child(2){animation-delay:-.3s}.fslightboxl div:nth-child(3){animation-delay:-.15s}@keyframes fslightboxl{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}.fslightbox-source{position:relative;z-index:2;opacity:0}")), document.head.appendChild(o));
    function L(e) {
      var t,
        n = e.props,
        o = 0,
        i = {};
      this.getSourceTypeFromLocalStorageByUrl = function (e) {
        return t[e] ? t[e] : r(e);
      }, this.handleReceivedSourceTypeForUrl = function (e, n) {
        if (!1 === i[n] && (o--, "invalid" !== e ? i[n] = e : delete i[n], 0 === o)) {
          !function (e, t) {
            for (var n in t) e[n] = t[n];
          }(t, i);
          try {
            localStorage.setItem("fslightbox-types", JSON.stringify(t));
          } catch (e) {}
        }
      };
      var r = function (e) {
        o++, i[e] = !1;
      };
      if (n.disableLocalStorage) this.getSourceTypeFromLocalStorageByUrl = function () {}, this.handleReceivedSourceTypeForUrl = function () {};else {
        try {
          t = JSON.parse(localStorage.getItem("fslightbox-types"));
        } catch (e) {}
        t || (t = {}, this.getSourceTypeFromLocalStorageByUrl = r);
      }
    }
    function A(e, t, n, o) {
      e.data;
      var i = e.elements.sources,
        r = n / o,
        s = 0;
      this.adjustSize = function () {
        if ((s = e.mw / r) < e.mh) return n < e.mw && (s = o), a();
        s = o > e.mh ? e.mh : o, a();
      };
      var a = function () {
        i[t].style.width = s * r + "px", i[t].style.height = s + "px";
      };
    }
    function C(e, t) {
      var n = this,
        o = e.collections.sourceSizers,
        i = e.elements,
        r = i.sourceAnimationWrappers,
        s = i.sources,
        a = e.isl,
        c = e.resolve;
      function l(e, n) {
        o[t] = c(A, [t, e, n]), o[t].adjustSize();
      }
      this.runActions = function (e, o) {
        a[t] = !0, s[t].classList.add(x), r[t].classList.add(g), r[t].removeChild(r[t].firstChild), l(e, o), n.runActions = l;
      };
    }
    function E(e, t) {
      var n,
        o = this,
        i = e.elements.sources,
        r = e.props,
        s = (0, e.resolve)(C, [t]);
      this.handleImageLoad = function (e) {
        var t = e.target,
          n = t.naturalWidth,
          o = t.naturalHeight;
        s.runActions(n, o);
      }, this.handleVideoLoad = function (e) {
        var t = e.target,
          o = t.videoWidth,
          i = t.videoHeight;
        n = !0, s.runActions(o, i);
      }, this.handleNotMetaDatedVideoLoad = function () {
        n || o.handleYoutubeLoad();
      }, this.handleYoutubeLoad = function () {
        var e = 1920,
          t = 1080;
        r.maxYoutubeDimensions && (e = r.maxYoutubeDimensions.width, t = r.maxYoutubeDimensions.height), s.runActions(e, t);
      }, this.handleCustomLoad = function () {
        var e = i[t],
          n = e.offsetWidth,
          r = e.offsetHeight;
        n && r ? s.runActions(n, r) : setTimeout(o.handleCustomLoad);
      };
    }
    function F(e, t, n) {
      var o = e.elements.sources,
        i = e.props.customClasses,
        r = i[t] ? i[t] : "";
      o[t].className = n + " " + r;
    }
    function I(e, t) {
      var n = e.elements.sources,
        o = e.props.customAttributes;
      for (var i in o[t]) n[t].setAttribute(i, o[t][i]);
    }
    function N(e, t) {
      var n = e.collections.sourceLoadHandlers,
        o = e.elements,
        i = o.sources,
        r = o.sourceAnimationWrappers,
        s = e.props.sources;
      i[t] = document.createElement("img"), F(e, t, y), i[t].src = s[t], i[t].onload = n[t].handleImageLoad, I(e, t), r[t].appendChild(i[t]);
    }
    function z(e, t) {
      var n = e.collections.sourceLoadHandlers,
        o = e.elements,
        i = o.sources,
        r = o.sourceAnimationWrappers,
        s = e.props,
        a = s.sources,
        c = s.videosPosters;
      i[t] = document.createElement("video"), F(e, t, y), i[t].src = a[t], i[t].onloadedmetadata = function (e) {
        n[t].handleVideoLoad(e);
      }, i[t].controls = !0, I(e, t), c[t] && (i[t].poster = c[t]);
      var l = document.createElement("source");
      l.src = a[t], i[t].appendChild(l), setTimeout(n[t].handleNotMetaDatedVideoLoad, 3e3), r[t].appendChild(i[t]);
    }
    function T(e, t) {
      var n = e.collections.sourceLoadHandlers,
        o = e.elements,
        r = o.sources,
        s = o.sourceAnimationWrappers,
        a = e.props.sources;
      r[t] = document.createElement("iframe"), F(e, t, "".concat(y, " ").concat(i, "youtube-iframe"));
      var c = a[t],
        l = c.split("?")[1];
      r[t].src = "https://www.youtube.com/embed/".concat(c.match(/^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/)[2], "?").concat(l || ""), r[t].allowFullscreen = !0, I(e, t), s[t].appendChild(r[t]), n[t].handleYoutubeLoad();
    }
    function P(e, t) {
      var n = e.collections.sourceLoadHandlers,
        o = e.elements,
        i = o.sources,
        r = o.sourceAnimationWrappers,
        s = e.props.sources;
      i[t] = s[t], F(e, t, "".concat(i[t].className, " ").concat(y)), r[t].appendChild(i[t]), n[t].handleCustomLoad();
    }
    function k(e, t) {
      var n = e.elements,
        o = n.sources,
        r = n.sourceAnimationWrappers;
      e.props.sources;
      o[t] = document.createElement("div"), o[t].className = "".concat(i, "invalid-file-wrapper ").concat(c), o[t].innerHTML = "Invalid source", r[t].classList.add(g), r[t].removeChild(r[t].firstChild), r[t].appendChild(o[t]);
    }
    function R(e) {
      var t = e.collections,
        n = t.sourceLoadHandlers,
        o = t.sourcesRenderFunctions,
        i = e.core.sourceDisplayFacade,
        r = e.resolve;
      this.runActionsForSourceTypeAndIndex = function (t, s) {
        var a;
        switch ("invalid" !== t && (n[s] = r(E, [s])), t) {
          case "image":
            a = N;
            break;
          case "video":
            a = z;
            break;
          case "youtube":
            a = T;
            break;
          case "custom":
            a = P;
            break;
          default:
            a = k;
        }
        o[s] = function () {
          return a(e, s);
        }, i.displaySourcesWhichShouldBeDisplayed();
      };
    }
    function H(e, t, n) {
      var o = e.props,
        i = o.types,
        r = o.type,
        s = o.sources;
      this.getTypeSetByClientForIndex = function (e) {
        var t;
        return i && i[e] ? t = i[e] : r && (t = r), t;
      }, this.retrieveTypeWithXhrForIndex = function (e) {
        !function (e, t) {
          var n = document.createElement("a");
          n.href = e;
          var o = n.hostname;
          if ("www.youtube.com" === o || "youtu.be" === o) return t("youtube");
          var i = new XMLHttpRequest();
          i.onreadystatechange = function () {
            if (4 !== i.readyState) {
              if (2 === i.readyState) {
                var e,
                  n = i.getResponseHeader("content-type");
                switch (n.slice(0, n.indexOf("/"))) {
                  case "image":
                    e = "image";
                    break;
                  case "video":
                    e = "video";
                    break;
                  default:
                    e = "invalid";
                }
                i.onreadystatechange = null, i.abort(), t(e);
              }
            } else t("invalid");
          }, i.open("GET", e), i.send();
        }(s[e], function (o) {
          t.handleReceivedSourceTypeForUrl(o, s[e]), n.runActionsForSourceTypeAndIndex(o, e);
        });
      };
    }
    function W(e, t) {
      var n = e.core.stageManager,
        o = e.elements,
        i = o.smw,
        r = o.sourceWrappersContainer,
        s = e.props,
        l = 0,
        f = document.createElement("div");
      function p(e) {
        f.style.transform = "translateX(".concat(e + l, "px)"), l = 0;
      }
      function h() {
        return (1 + s.slideDistance) * innerWidth;
      }
      f.className = "".concat(d, " ").concat(a, " ").concat(c), f.s = function () {
        f.style.display = "flex";
      }, f.h = function () {
        f.style.display = "none";
      }, f.a = function () {
        f.classList.add(u);
      }, f.d = function () {
        f.classList.remove(u);
      }, f.n = function () {
        f.style.removeProperty("transform");
      }, f.v = function (e) {
        return l = e, f;
      }, f.ne = function () {
        p(-h());
      }, f.z = function () {
        p(0);
      }, f.p = function () {
        p(h());
      }, n.i(t) || f.h(), i[t] = f, r.appendChild(f), function (e, t) {
        var n = e.elements,
          o = n.smw,
          i = n.sourceAnimationWrappers,
          r = document.createElement("div"),
          s = document.createElement("div");
        s.className = "fslightboxl";
        for (var a = 0; a < 3; a++) {
          var c = document.createElement("div");
          s.appendChild(c);
        }
        r.appendChild(s), o[t].appendChild(r), i[t] = r;
      }(e, t);
    }
    function D(e, t, n, o) {
      var r = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      r.setAttributeNS(null, "width", t), r.setAttributeNS(null, "height", t), r.setAttributeNS(null, "viewBox", n);
      var s = document.createElementNS("http://www.w3.org/2000/svg", "path");
      return s.setAttributeNS(null, "class", "".concat(i, "svg-path")), s.setAttributeNS(null, "d", o), r.appendChild(s), e.appendChild(r), r;
    }
    function M(e, t) {
      var n = document.createElement("div");
      return n.className = "".concat(i, "toolbar-button ").concat(c), n.title = t, e.appendChild(n), n;
    }
    function O(e, t) {
      var n = document.createElement("div");
      n.className = "".concat(i, "toolbar"), t.appendChild(n), function (e, t) {
        var n = e.componentsServices,
          o = e.data,
          i = e.fs,
          r = "M4.5 11H3v4h4v-1.5H4.5V11zM3 7h1.5V4.5H7V3H3v4zm10.5 6.5H11V15h4v-4h-1.5v2.5zM11 3v1.5h2.5V7H15V3h-4z",
          s = M(t);
        s.title = "Enter fullscreen";
        var a = D(s, "20px", "0 0 18 18", r);
        n.ofs = function () {
          o.ifs = !0, s.title = "Exit fullscreen", a.setAttributeNS(null, "width", "24px"), a.setAttributeNS(null, "height", "24px"), a.setAttributeNS(null, "viewBox", "0 0 950 1024"), a.firstChild.setAttributeNS(null, "d", "M682 342h128v84h-212v-212h84v128zM598 810v-212h212v84h-128v128h-84zM342 342v-128h84v212h-212v-84h128zM214 682v-84h212v212h-84v-128h-128z");
        }, n.xfs = function () {
          o.ifs = !1, s.title = "Enter fullscreen", a.setAttributeNS(null, "width", "20px"), a.setAttributeNS(null, "height", "20px"), a.setAttributeNS(null, "viewBox", "0 0 18 18"), a.firstChild.setAttributeNS(null, "d", r);
        }, s.onclick = i.t;
      }(e, n), function (e, t) {
        var n = M(t, "Close");
        n.onclick = e.core.lightboxCloser.closeLightbox, D(n, "20px", "0 0 24 24", "M 4.7070312 3.2929688 L 3.2929688 4.7070312 L 10.585938 12 L 3.2929688 19.292969 L 4.7070312 20.707031 L 12 13.414062 L 19.292969 20.707031 L 20.707031 19.292969 L 13.414062 12 L 20.707031 4.7070312 L 19.292969 3.2929688 L 12 10.585938 L 4.7070312 3.2929688 z");
      }(e, n);
    }
    function j(e) {
      var t = e.props.sources,
        n = e.elements.container,
        o = document.createElement("div");
      o.className = "".concat(i, "nav"), n.appendChild(o), O(e, o), t.length > 1 && function (e, t) {
        var n = e.componentsServices,
          o = e.props.sources,
          r = (e.stageIndexes, document.createElement("div"));
        r.className = "".concat(i, "slide-number-container");
        var s = document.createElement("div");
        s.className = c;
        var a = document.createElement("span");
        n.setSlideNumber = function (e) {
          return a.innerHTML = e;
        };
        var l = document.createElement("span");
        l.className = "".concat(i, "slash");
        var u = document.createElement("div");
        u.innerHTML = o.length, r.appendChild(s), s.appendChild(a), s.appendChild(l), s.appendChild(u), t.appendChild(r), setTimeout(function () {
          s.offsetWidth > 55 && (r.style.justifyContent = "flex-start");
        });
      }(e, o);
    }
    function X(e, t, n, o) {
      var i = e.elements.container,
        r = n.charAt(0).toUpperCase() + n.slice(1),
        s = document.createElement("div");
      s.className = "".concat(p, " ").concat(p, "-").concat(n), s.title = "".concat(r, " slide"), s.onclick = t, function (e, t) {
        var n = document.createElement("div");
        n.className = "".concat(f, " ").concat(c), D(n, "20px", "0 0 20 20", t), e.appendChild(n);
      }(s, o), i.appendChild(s);
    }
    function B(e) {
      var t = e.core,
        n = t.lightboxCloser,
        o = t.slideChangeFacade,
        i = e.fs;
      this.listener = function (e) {
        switch (e.key) {
          case "Escape":
            n.closeLightbox();
            break;
          case "ArrowLeft":
            o.changeToPrevious();
            break;
          case "ArrowRight":
            o.changeToNext();
            break;
          case "F11":
            e.preventDefault(), i.t();
        }
      };
    }
    function q(e) {
      var t = e.elements,
        n = e.sourcePointerProps,
        o = e.stageIndexes;
      function i(e, o) {
        t.smw[e].v(n.swipedX)[o]();
      }
      this.runActionsForEvent = function (e) {
        var r, a, c;
        t.container.contains(t.slideSwipingHoverer) || t.container.appendChild(t.slideSwipingHoverer), r = t.container, a = s, (c = r.classList).contains(a) || c.add(a), n.swipedX = e.screenX - n.downScreenX;
        var l = o.previous,
          u = o.next;
        i(o.current, "z"), void 0 !== l && n.swipedX > 0 ? i(l, "ne") : void 0 !== u && n.swipedX < 0 && i(u, "p");
      };
    }
    function V(e) {
      var t = e.props.sources,
        n = e.resolve,
        o = e.sourcePointerProps,
        i = n(q);
      1 === t.length ? this.listener = function () {
        o.swipedX = 1;
      } : this.listener = function (e) {
        o.isPointering && i.runActionsForEvent(e);
      };
    }
    function U(e) {
      var t = e.core.slideIndexChanger,
        n = e.elements.smw,
        o = e.stageIndexes,
        i = e.sws;
      function r(e) {
        var t = n[o.current];
        t.a(), t[e]();
      }
      function s(e, t) {
        void 0 !== e && (n[e].s(), n[e][t]());
      }
      this.runPositiveSwipedXActions = function () {
        var e = o.previous;
        if (void 0 === e) r("z");else {
          r("p");
          var n = o.next;
          t.changeTo(e);
          var a = o.previous;
          i.d(a), i.b(n), r("z"), s(a, "ne");
        }
      }, this.runNegativeSwipedXActions = function () {
        var e = o.next;
        if (void 0 === e) r("z");else {
          r("ne");
          var n = o.previous;
          t.changeTo(e);
          var a = o.next;
          i.d(a), i.b(n), r("z"), s(a, "p");
        }
      };
    }
    function _(e, t) {
      e.contains(t) && e.removeChild(t);
    }
    function Y(e) {
      var t = e.core.lightboxCloser,
        n = e.elements,
        o = e.resolve,
        i = e.sourcePointerProps,
        r = o(U);
      this.runNoSwipeActions = function () {
        _(n.container, n.slideSwipingHoverer), i.isSourceDownEventTarget || t.closeLightbox(), i.isPointering = !1;
      }, this.runActions = function () {
        i.swipedX > 0 ? r.runPositiveSwipedXActions() : r.runNegativeSwipedXActions(), _(n.container, n.slideSwipingHoverer), n.container.classList.remove(s), i.isPointering = !1;
      };
    }
    function J(e) {
      var t = e.resolve,
        n = e.sourcePointerProps,
        o = t(Y);
      this.listener = function () {
        n.isPointering && (n.swipedX ? o.runActions() : o.runNoSwipeActions());
      };
    }
    function G(e) {
      var t = this,
        n = e.core,
        o = n.eventsDispatcher,
        i = n.globalEventsController,
        r = n.scrollbarRecompensor,
        s = e.data,
        a = e.elements,
        c = e.fs,
        u = e.props,
        d = e.sourcePointerProps;
      this.isLightboxFadingOut = !1, this.runActions = function () {
        t.isLightboxFadingOut = !0, a.container.classList.add(v), i.removeListeners(), u.exitFullscreenOnClose && s.ifs && c.x(), setTimeout(function () {
          t.isLightboxFadingOut = !1, d.isPointering = !1, a.container.classList.remove(v), document.documentElement.classList.remove(l), r.removeRecompense(), document.body.removeChild(a.container), o.dispatch("onClose");
        }, 270);
      };
    }
    function $(e, t) {
      var n = e.classList;
      n.contains(t) && n.remove(t);
    }
    function K(e) {
      var t, n, o;
      n = (t = e).core.eventsDispatcher, o = t.props, n.dispatch = function (e) {
        o[e] && o[e]();
      }, function (e) {
        var t = e.componentsServices,
          n = e.data,
          o = e.fs,
          i = ["fullscreenchange", "webkitfullscreenchange", "mozfullscreenchange", "MSFullscreenChange"];
        function r(e) {
          for (var t = 0; t < i.length; t++) document[e](i[t], s);
        }
        function s() {
          document.fullscreenElement || document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement ? t.ofs() : t.xfs();
        }
        o.o = function () {
          t.ofs();
          var e = document.documentElement;
          e.requestFullscreen ? e.requestFullscreen() : e.mozRequestFullScreen ? e.mozRequestFullScreen() : e.webkitRequestFullscreen ? e.webkitRequestFullscreen() : e.msRequestFullscreen && e.msRequestFullscreen();
        }, o.x = function () {
          t.xfs(), document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.msExitFullscreen && document.msExitFullscreen();
        }, o.t = function () {
          n.ifs ? o.x() : o.o();
        }, o.l = function () {
          r("addEventListener");
        }, o.q = function () {
          r("removeEventListener");
        };
      }(e), function (e) {
        var t = e.core,
          n = t.globalEventsController,
          o = t.windowResizeActioner,
          i = e.fs,
          r = e.resolve,
          s = r(B),
          a = r(V),
          c = r(J);
        n.attachListeners = function () {
          document.addEventListener("pointermove", a.listener), document.addEventListener("pointerup", c.listener), addEventListener("resize", o.runActions), document.addEventListener("keydown", s.listener), i.l();
        }, n.removeListeners = function () {
          document.removeEventListener("pointermove", a.listener), document.removeEventListener("pointerup", c.listener), removeEventListener("resize", o.runActions), document.removeEventListener("keydown", s.listener), i.q();
        };
      }(e), function (e) {
        var t = e.core.lightboxCloser,
          n = (0, e.resolve)(G);
        t.closeLightbox = function () {
          n.isLightboxFadingOut || n.runActions();
        };
      }(e), function (e) {
        var t = e.data,
          n = e.core.scrollbarRecompensor;
        function o() {
          document.body.offsetHeight > innerHeight && (document.body.style.marginRight = t.scrollbarWidth + "px");
        }
        n.addRecompense = function () {
          "complete" === document.readyState ? o() : addEventListener("load", function () {
            o(), n.addRecompense = o;
          });
        }, n.removeRecompense = function () {
          document.body.style.removeProperty("margin-right");
        };
      }(e), function (e) {
        var t = e.core,
          n = t.slideChangeFacade,
          o = t.slideIndexChanger,
          i = t.stageManager;
        e.props.sources.length > 1 ? (n.changeToPrevious = function () {
          o.jumpTo(i.getPreviousSlideIndex());
        }, n.changeToNext = function () {
          o.jumpTo(i.getNextSlideIndex());
        }) : (n.changeToPrevious = function () {}, n.changeToNext = function () {});
      }(e), function (e) {
        var t = e.componentsServices,
          n = e.core,
          o = n.slideIndexChanger,
          i = n.sourceDisplayFacade,
          r = n.stageManager,
          s = e.elements,
          a = s.smw,
          c = s.sourceAnimationWrappers,
          l = e.isl,
          u = e.stageIndexes,
          d = e.sws;
        o.changeTo = function (e) {
          u.current = e, r.updateStageIndexes(), t.setSlideNumber(e + 1), i.displaySourcesWhichShouldBeDisplayed();
        }, o.jumpTo = function (e) {
          var t = u.previous,
            n = u.current,
            i = u.next,
            s = l[n],
            f = l[e];
          o.changeTo(e);
          for (var p = 0; p < a.length; p++) a[p].d();
          d.d(n), d.c(), requestAnimationFrame(function () {
            requestAnimationFrame(function () {
              var e = u.previous,
                o = u.next;
              function p() {
                r.i(n) ? n === u.previous ? a[n].ne() : n === u.next && a[n].p() : (a[n].h(), a[n].n());
              }
              s && c[n].classList.add(m), f && c[u.current].classList.add(h), d.a(), void 0 !== e && e !== n && a[e].ne(), a[u.current].n(), void 0 !== o && o !== n && a[o].p(), d.b(t), d.b(i), l[n] ? setTimeout(p, 260) : p();
            });
          });
        };
      }(e), function (e) {
        var t = e.core.sourcesPointerDown,
          n = e.elements,
          o = n.smw,
          i = n.sources,
          r = e.sourcePointerProps,
          s = e.stageIndexes;
        t.listener = function (e) {
          "VIDEO" !== e.target.tagName && e.preventDefault(), r.isPointering = !0, r.downScreenX = e.screenX, r.swipedX = 0;
          var t = i[s.current];
          t && t.contains(e.target) ? r.isSourceDownEventTarget = !0 : r.isSourceDownEventTarget = !1;
          for (var n = 0; n < o.length; n++) o[n].d();
        };
      }(e), function (e) {
        var t = e.collections.sourcesRenderFunctions,
          n = e.core.sourceDisplayFacade,
          o = e.props,
          i = e.stageIndexes;
        function r(e) {
          t[e] && (t[e](), delete t[e]);
        }
        n.displaySourcesWhichShouldBeDisplayed = function () {
          if (o.loadOnlyCurrentSource) r(i.current);else for (var e in i) r(i[e]);
        };
      }(e), function (e) {
        var t = e.core.stageManager,
          n = e.elements,
          o = n.smw,
          i = n.sourceAnimationWrappers,
          r = e.isl,
          s = e.stageIndexes,
          a = e.sws;
        a.a = function () {
          for (var e in s) o[s[e]].s();
        }, a.b = function (e) {
          void 0 === e || t.i(e) || (o[e].h(), o[e].n());
        }, a.c = function () {
          for (var e in s) a.d(s[e]);
        }, a.d = function (e) {
          if (r[e]) {
            var t = i[e];
            $(t, g), $(t, h), $(t, m);
          }
        };
      }(e), function (e) {
        var t = e.collections.sourceSizers,
          n = e.core.windowResizeActioner,
          o = (e.data, e.elements.smw),
          i = e.props.sourceMargin,
          r = e.stageIndexes,
          s = 1 - 2 * i;
        n.runActions = function () {
          innerWidth > 992 ? e.mw = s * innerWidth : e.mw = innerWidth, e.mh = s * innerHeight;
          for (var n = 0; n < o.length; n++) o[n].d(), t[n] && t[n].adjustSize();
          var i = r.previous,
            a = r.next;
          void 0 !== i && o[i].ne(), void 0 !== a && o[a].p();
        };
      }(e);
    }
    function Q(e) {
      var t = e.componentsServices,
        n = e.core,
        o = n.eventsDispatcher,
        r = n.globalEventsController,
        s = n.scrollbarRecompensor,
        c = n.sourceDisplayFacade,
        u = n.stageManager,
        f = n.windowResizeActioner,
        p = e.data,
        h = e.elements,
        m = (e.props, e.stageIndexes),
        v = e.sws;
      function b() {
        var t, n;
        p.i = !0, p.scrollbarWidth = function () {
          var e = document.createElement("div"),
            t = e.style,
            n = document.createElement("div");
          t.visibility = "hidden", t.width = "100px", t.msOverflowStyle = "scrollbar", t.overflow = "scroll", n.style.width = "100%", document.body.appendChild(e);
          var o = e.offsetWidth;
          e.appendChild(n);
          var i = n.offsetWidth;
          return document.body.removeChild(e), o - i;
        }(), K(e), h.container = document.createElement("div"), h.container.className = "".concat(i, "container ").concat(a, " ").concat(g), function (e) {
          var t = e.elements;
          t.slideSwipingHoverer = document.createElement("div"), t.slideSwipingHoverer.className = "".concat(i, "slide-swiping-hoverer ").concat(a, " ").concat(d);
        }(e), j(e), function (e) {
          var t = e.core.sourcesPointerDown,
            n = e.elements,
            o = e.props.sources,
            i = document.createElement("div");
          i.className = "".concat(d, " ").concat(a), n.container.appendChild(i), i.addEventListener("pointerdown", t.listener), n.sourceWrappersContainer = i;
          for (var r = 0; r < o.length; r++) W(e, r);
        }(e), e.props.sources.length > 1 && (n = (t = e).core.slideChangeFacade, X(t, n.changeToPrevious, "previous", "M18.271,9.212H3.615l4.184-4.184c0.306-0.306,0.306-0.801,0-1.107c-0.306-0.306-0.801-0.306-1.107,0L1.21,9.403C1.194,9.417,1.174,9.421,1.158,9.437c-0.181,0.181-0.242,0.425-0.209,0.66c0.005,0.038,0.012,0.071,0.022,0.109c0.028,0.098,0.075,0.188,0.142,0.271c0.021,0.026,0.021,0.061,0.045,0.085c0.015,0.016,0.034,0.02,0.05,0.033l5.484,5.483c0.306,0.307,0.801,0.307,1.107,0c0.306-0.305,0.306-0.801,0-1.105l-4.184-4.185h14.656c0.436,0,0.788-0.353,0.788-0.788S18.707,9.212,18.271,9.212z"), X(t, n.changeToNext, "next", "M1.729,9.212h14.656l-4.184-4.184c-0.307-0.306-0.307-0.801,0-1.107c0.305-0.306,0.801-0.306,1.106,0l5.481,5.482c0.018,0.014,0.037,0.019,0.053,0.034c0.181,0.181,0.242,0.425,0.209,0.66c-0.004,0.038-0.012,0.071-0.021,0.109c-0.028,0.098-0.075,0.188-0.143,0.271c-0.021,0.026-0.021,0.061-0.045,0.085c-0.015,0.016-0.034,0.02-0.051,0.033l-5.483,5.483c-0.306,0.307-0.802,0.307-1.106,0c-0.307-0.305-0.307-0.801,0-1.105l4.184-4.185H1.729c-0.436,0-0.788-0.353-0.788-0.788S1.293,9.212,1.729,9.212z")), function (e) {
          for (var t = e.props.sources, n = e.resolve, o = n(L), i = n(R), r = n(H, [o, i]), s = 0; s < t.length; s++) if ("string" == typeof t[s]) {
            var a = r.getTypeSetByClientForIndex(s);
            if (a) i.runActionsForSourceTypeAndIndex(a, s);else {
              var c = o.getSourceTypeFromLocalStorageByUrl(t[s]);
              c ? i.runActionsForSourceTypeAndIndex(c, s) : r.retrieveTypeWithXhrForIndex(s);
            }
          } else i.runActionsForSourceTypeAndIndex("custom", s);
        }(e), o.dispatch("onInit");
      }
      e.open = function () {
        var n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
          i = m.previous,
          a = m.current,
          d = m.next;
        m.current = n, p.i || S(e), u.updateStageIndexes(), p.i ? (v.c(), v.a(), v.b(i), v.b(a), v.b(d), o.dispatch("onShow")) : b(), c.displaySourcesWhichShouldBeDisplayed(), t.setSlideNumber(n + 1), document.body.appendChild(h.container), document.documentElement.classList.add(l), s.addRecompense(), r.attachListeners(), f.runActions(), h.smw[m.current].n(), o.dispatch("onOpen");
      };
    }
    function Z(e, t, n) {
      return (Z = ee() ? Reflect.construct.bind() : function (e, t, n) {
        var o = [null];
        o.push.apply(o, t);
        var i = new (Function.bind.apply(e, o))();
        return n && te(i, n.prototype), i;
      }).apply(null, arguments);
    }
    function ee() {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
      } catch (e) {
        return !1;
      }
    }
    function te(e, t) {
      return (te = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) {
        return e.__proto__ = t, e;
      })(e, t);
    }
    function ne(e) {
      return function (e) {
        if (Array.isArray(e)) return oe(e);
      }(e) || function (e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e);
      }(e) || function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return oe(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === n && e.constructor && (n = e.constructor.name);
        if ("Map" === n || "Set" === n) return Array.from(e);
        if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return oe(e, t);
      }(e) || function () {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    function oe(e, t) {
      (null == t || t > e.length) && (t = e.length);
      for (var n = 0, o = new Array(t); n < t; n++) o[n] = e[n];
      return o;
    }
    function ie() {
      for (var e = document.getElementsByTagName("a"), t = function (t) {
          if (!e[t].hasAttribute("data-fslightbox")) return "continue";
          var n = e[t].hasAttribute("data-href") ? e[t].getAttribute("data-href") : e[t].getAttribute("href");
          if (!n) return console.warn('The "data-fslightbox" attribute was set without the "href" attribute.'), "continue";
          var o = e[t].getAttribute("data-fslightbox");
          fsLightboxInstances[o] || (fsLightboxInstances[o] = new FsLightbox());
          var i = null;
          "#" === n.charAt(0) ? (i = document.getElementById(n.substring(1)).cloneNode(!0)).removeAttribute("id") : i = n, fsLightboxInstances[o].props.sources.push(i), fsLightboxInstances[o].elements.a.push(e[t]);
          var r = fsLightboxInstances[o].props.sources.length - 1;
          e[t].onclick = function (e) {
            e.preventDefault(), fsLightboxInstances[o].open(r);
          }, d("types", "data-type"), d("videosPosters", "data-video-poster"), d("customClasses", "data-class"), d("customClasses", "data-custom-class");
          for (var s = ["href", "data-fslightbox", "data-href", "data-type", "data-video-poster", "data-class", "data-custom-class"], a = e[t].attributes, c = fsLightboxInstances[o].props.customAttributes, l = 0; l < a.length; l++) if (-1 === s.indexOf(a[l].name) && "data-" === a[l].name.substr(0, 5)) {
            c[r] || (c[r] = {});
            var u = a[l].name.substr(5);
            c[r][u] = a[l].value;
          }
          function d(n, i) {
            e[t].hasAttribute(i) && (fsLightboxInstances[o].props[n][r] = e[t].getAttribute(i));
          }
        }, n = 0; n < e.length; n++) t(n);
      var o = Object.keys(fsLightboxInstances);
      window.fsLightbox = fsLightboxInstances[o[o.length - 1]];
    }
    window.FsLightbox = function () {
      var e = this;
      this.props = {
        sources: [],
        customAttributes: [],
        customClasses: [],
        types: [],
        videosPosters: [],
        sourceMargin: .05,
        slideDistance: .3
      }, this.data = {
        isFullscreenOpen: !1,
        scrollbarWidth: 0
      }, this.isl = [], this.sourcePointerProps = {
        downScreenX: null,
        isPointering: !1,
        isSourceDownEventTarget: !1,
        swipedX: 0
      }, this.stageIndexes = {}, this.elements = {
        a: [],
        container: null,
        slideSwipingHoverer: null,
        smw: [],
        sourceWrappersContainer: null,
        sources: [],
        sourceAnimationWrappers: []
      }, this.componentsServices = {
        setSlideNumber: function () {}
      }, this.resolve = function (t) {
        var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
        return n.unshift(e), Z(t, ne(n));
      }, this.collections = {
        sourceLoadHandlers: [],
        sourcesRenderFunctions: [],
        sourceSizers: []
      }, this.core = {
        eventsDispatcher: {},
        globalEventsController: {},
        lightboxCloser: {},
        lightboxUpdater: {},
        scrollbarRecompensor: {},
        slideChangeFacade: {},
        slideIndexChanger: {},
        sourcesPointerDown: {},
        sourceDisplayFacade: {},
        stageManager: {},
        windowResizeActioner: {}
      }, this.fs = {}, this.sws = {}, Q(this), this.close = function () {
        return e.core.lightboxCloser.closeLightbox();
      };
    }, window.fsLightboxInstances = {}, ie(), window.refreshFsLightbox = function () {
      for (var e in fsLightboxInstances) {
        var t = fsLightboxInstances[e].props;
        fsLightboxInstances[e] = new FsLightbox(), fsLightboxInstances[e].props = t, fsLightboxInstances[e].props.sources = [], fsLightboxInstances[e].elements.a = [];
      }
      ie();
    };
  }]);
});

/***/ }),

/***/ "./node_modules/jsvectormap/dist/jsvectormap.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/jsvectormap/dist/jsvectormap.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ index)
/* harmony export */ });
/**
 * By https://github.com/TehShrike/deepmerge
 */

var isMergeableObject = function isMergeableObject(value) {
  return isNonNullObject(value) && !isSpecial(value);
};
function isNonNullObject(value) {
  return !!value && typeof value === 'object';
}
function isSpecial(value) {
  var stringValue = Object.prototype.toString.call(value);
  return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isNode(value) || isReactElement(value);
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;
function isReactElement(value) {
  return value.$$typeof === REACT_ELEMENT_TYPE;
}
function isNode(value) {
  return value instanceof Node;
}
function emptyTarget(val) {
  return Array.isArray(val) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(value, options) {
  return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
}
function defaultArrayMerge(target, source, options) {
  return target.concat(source).map(function (element) {
    return cloneUnlessOtherwiseSpecified(element, options);
  });
}
function getMergeFunction(key, options) {
  if (!options.customMerge) {
    return deepmerge;
  }
  var customMerge = options.customMerge(key);
  return typeof customMerge === 'function' ? customMerge : deepmerge;
}
function getEnumerableOwnPropertySymbols(target) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function (symbol) {
    return target.propertyIsEnumerable(symbol);
  }) : [];
}
function getKeys(target) {
  return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
}
function propertyIsOnObject(object, property) {
  try {
    return property in object;
  } catch (_) {
    return false;
  }
}

// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
  return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
  && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
  && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.
}
function mergeObject(target, source, options) {
  var destination = {};
  if (options.isMergeableObject(target)) {
    getKeys(target).forEach(function (key) {
      destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    });
  }
  getKeys(source).forEach(function (key) {
    if (propertyIsUnsafe(target, key)) {
      return;
    }
    if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
      destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
    } else {
      destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    }
  });
  return destination;
}
var deepmerge = function deepmerge(target, source, options) {
  options = options || {};
  options.arrayMerge = options.arrayMerge || defaultArrayMerge;
  options.isMergeableObject = options.isMergeableObject || isMergeableObject;
  // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
  // implementations can use it. The caller may not replace it.
  options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
  var sourceIsArray = Array.isArray(source);
  var targetIsArray = Array.isArray(target);
  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
  if (!sourceAndTargetTypesMatch) {
    return cloneUnlessOtherwiseSpecified(source, options);
  } else if (sourceIsArray) {
    return options.arrayMerge(target, source, options);
  } else {
    return mergeObject(target, source, options);
  }
};

/**
 * --------------------------------------------------------------------------
 * Public Util Api
 * --------------------------------------------------------------------------
 */
var getElement = function getElement(selector) {
  if (typeof selector === 'object' && typeof selector.nodeType !== 'undefined') {
    return selector;
  }
  if (typeof selector === 'string') {
    return document.querySelector(selector);
  }
  return null;
};
var createElement = function createElement(type, classes, content, html) {
  if (html === void 0) {
    html = false;
  }
  var el = document.createElement(type);
  if (content) {
    el[!html ? 'textContent' : 'innerHTML'] = content;
  }
  if (classes) {
    el.className = classes;
  }
  return el;
};
var findElement = function findElement(parentElement, selector) {
  return Element.prototype.querySelector.call(parentElement, selector);
};
var removeElement = function removeElement(target) {
  target.parentNode.removeChild(target);
};
var isImageUrl = function isImageUrl(url) {
  return /\.(jpg|gif|png)$/.test(url);
};
var hyphenate = function hyphenate(string) {
  return string.replace(/[\w]([A-Z])/g, function (m) {
    return m[0] + "-" + m[1];
  }).toLowerCase();
};
var merge = function merge(target, source, deep) {
  if (deep === void 0) {
    deep = false;
  }
  if (deep) {
    return deepmerge(target, source);
  }
  return Object.assign(target, source);
};
var getLineUid = function getLineUid(from, to) {
  return from.toLowerCase() + ":to:" + to.toLowerCase();
};
var inherit = function inherit(target, source) {
  Object.assign(target.prototype, source);
};
var eventRegistry = {};
var eventUid = 1;

/**
 * ------------------------------------------------------------------------
 * Event Handler
 * ------------------------------------------------------------------------
 */
var EventHandler = {
  on: function on(element, event, handler, options) {
    if (options === void 0) {
      options = {};
    }
    var uid = "jvm:" + event + "::" + eventUid++;
    eventRegistry[uid] = {
      selector: element,
      handler: handler
    };
    handler._uid = uid;
    element.addEventListener(event, handler, options);
  },
  delegate: function delegate(element, event, selector, handler) {
    event = event.split(' ');
    event.forEach(function (eventName) {
      EventHandler.on(element, eventName, function (e) {
        var target = e.target;
        if (target.matches(selector)) {
          handler.call(target, e);
        }
      });
    });
  },
  off: function off(element, event, handler) {
    var eventType = event.split(':')[1];
    element.removeEventListener(eventType, handler);
    delete eventRegistry[handler._uid];
  },
  flush: function flush() {
    Object.keys(eventRegistry).forEach(function (event) {
      EventHandler.off(eventRegistry[event].selector, event, eventRegistry[event].handler);
    });
  },
  getEventRegistry: function getEventRegistry() {
    return eventRegistry;
  }
};
function setupContainerEvents() {
  var _this = this;
  var map = this;
  var mouseDown = false;
  var oldPageX;
  var oldPageY;
  if (this.params.draggable) {
    EventHandler.on(this.container, 'mousemove', function (e) {
      if (!mouseDown) {
        return false;
      }
      map.transX -= (oldPageX - e.pageX) / map.scale;
      map.transY -= (oldPageY - e.pageY) / map.scale;
      map._applyTransform();
      oldPageX = e.pageX;
      oldPageY = e.pageY;
    });
    EventHandler.on(this.container, 'mousedown', function (e) {
      mouseDown = true;
      oldPageX = e.pageX;
      oldPageY = e.pageY;
      return false;
    });
    EventHandler.on(document.body, 'mouseup', function () {
      mouseDown = false;
    });
  }
  if (this.params.zoomOnScroll) {
    EventHandler.on(this.container, 'wheel', function (event) {
      var deltaY = ((event.deltaY || -event.wheelDelta || event.detail) >> 10 || 1) * 75;
      var rect = _this.container.getBoundingClientRect();
      var offsetX = event.pageX - rect.left - window.pageXOffset;
      var offsetY = event.pageY - rect.top - window.pageYOffset;
      var zoomStep = Math.pow(1 + map.params.zoomOnScrollSpeed / 1000, -1.5 * deltaY);
      if (map.tooltip) {
        map._tooltip.hide();
      }
      map._setScale(map.scale * zoomStep, offsetX, offsetY);
      event.preventDefault();
    });
  }
}
var Events = {
  onLoaded: 'map:loaded',
  onViewportChange: 'viewport:changed',
  onRegionClick: 'region:clicked',
  onMarkerClick: 'marker:clicked',
  onRegionSelected: 'region:selected',
  onMarkerSelected: 'marker:selected',
  onRegionTooltipShow: 'region.tooltip:show',
  onMarkerTooltipShow: 'marker.tooltip:show',
  onDestroyed: 'map:destroyed'
};
var parseEvent = function parseEvent(map, selector, isTooltip) {
  var element = getElement(selector);
  var type = element.getAttribute('class').indexOf('jvm-region') === -1 ? 'marker' : 'region';
  var isRegion = type === 'region';
  var code = isRegion ? element.getAttribute('data-code') : element.getAttribute('data-index');
  var event = isRegion ? Events.onRegionSelected : Events.onMarkerSelected;

  // Init tooltip event
  if (isTooltip) {
    event = isRegion ? Events.onRegionTooltipShow : Events.onMarkerTooltipShow;
  }
  return {
    type: type,
    code: code,
    event: event,
    element: isRegion ? map.regions[code].element : map._markers[code].element,
    tooltipText: isRegion ? map._mapData.paths[code].name || '' : map._markers[code].config.name || ''
  };
};
function setupElementEvents() {
  var map = this;
  var container = this.container;
  var pageX, pageY, mouseMoved;
  EventHandler.on(container, 'mousemove', function (event) {
    if (Math.abs(pageX - event.pageX) + Math.abs(pageY - event.pageY) > 2) {
      mouseMoved = true;
    }
  });

  // When the mouse is pressed
  EventHandler.delegate(container, 'mousedown', '.jvm-element', function (event) {
    pageX = event.pageX;
    pageY = event.pageY;
    mouseMoved = false;
  });

  // When the mouse is over the region/marker | When the mouse is out the region/marker
  EventHandler.delegate(container, 'mouseover mouseout', '.jvm-element', function (event) {
    var data = parseEvent(map, this, true);
    var showTooltip = map.params.showTooltip;
    if (event.type === 'mouseover') {
      data.element.hover(true);
      if (showTooltip) {
        map._tooltip.text(data.tooltipText);
        map._tooltip.show();
        map._emit(data.event, [event, map._tooltip, data.code]);
      }
    } else {
      data.element.hover(false);
      if (showTooltip) {
        map._tooltip.hide();
      }
    }
  });

  // When the click is released
  EventHandler.delegate(container, 'mouseup', '.jvm-element', function (event) {
    var data = parseEvent(map, this);
    if (mouseMoved) {
      return;
    }
    if (data.type === 'region' && map.params.regionsSelectable || data.type === 'marker' && map.params.markersSelectable) {
      var element = data.element;

      // We're checking if regions/markers|SelectableOne option is presented
      if (map.params[data.type + "sSelectableOne"]) {
        map._clearSelected(data.type + "s");
      }
      if (data.element.isSelected) {
        element.select(false);
      } else {
        element.select(true);
      }
      map._emit(data.event, [data.code, element.isSelected, map._getSelected(data.type + "s")]);
    }
  });

  // When region/marker is clicked
  EventHandler.delegate(container, 'click', '.jvm-element', function (event) {
    var _parseEvent = parseEvent(map, this),
      type = _parseEvent.type,
      code = _parseEvent.code;
    map._emit(type === 'region' ? Events.onRegionClick : Events.onMarkerClick, [event, code]);
  });
}
function setupZoomButtons() {
  var _this = this;
  var zoomin = createElement('div', 'jvm-zoom-btn jvm-zoomin', '&#43;', true);
  var zoomout = createElement('div', 'jvm-zoom-btn jvm-zoomout', '&#x2212', true);
  this.container.appendChild(zoomin);
  this.container.appendChild(zoomout);
  var handler = function handler(zoomin) {
    if (zoomin === void 0) {
      zoomin = true;
    }
    return function () {
      return _this._setScale(zoomin ? _this.scale * _this.params.zoomStep : _this.scale / _this.params.zoomStep, _this._width / 2, _this._height / 2, false, _this.params.zoomAnimate);
    };
  };
  EventHandler.on(zoomin, 'click', handler());
  EventHandler.on(zoomout, 'click', handler(false));
}
function setupContainerTouchEvents() {
  var map = this,
    touchStartScale,
    touchStartDistance,
    touchX,
    touchY,
    centerTouchX,
    centerTouchY,
    lastTouchesLength;
  var handleTouchEvent = function handleTouchEvent(e) {
    var touches = e.touches;
    var offset, scale, transXOld, transYOld;
    if (e.type == 'touchstart') {
      lastTouchesLength = 0;
    }
    if (touches.length == 1) {
      if (lastTouchesLength == 1) {
        transXOld = map.transX;
        transYOld = map.transY;
        map.transX -= (touchX - touches[0].pageX) / map.scale;
        map.transY -= (touchY - touches[0].pageY) / map.scale;
        map._tooltip.hide();
        map._applyTransform();
        if (transXOld != map.transX || transYOld != map.transY) {
          e.preventDefault();
        }
      }
      touchX = touches[0].pageX;
      touchY = touches[0].pageY;
    } else if (touches.length == 2) {
      if (lastTouchesLength == 2) {
        scale = Math.sqrt(Math.pow(touches[0].pageX - touches[1].pageX, 2) + Math.pow(touches[0].pageY - touches[1].pageY, 2)) / touchStartDistance;
        map._setScale(touchStartScale * scale, centerTouchX, centerTouchY);
        map._tooltip.hide();
        e.preventDefault();
      } else {
        var rect = map.container.getBoundingClientRect();
        offset = {
          top: rect.top + window.scrollY,
          left: rect.left + window.scrollX
        };
        if (touches[0].pageX > touches[1].pageX) {
          centerTouchX = touches[1].pageX + (touches[0].pageX - touches[1].pageX) / 2;
        } else {
          centerTouchX = touches[0].pageX + (touches[1].pageX - touches[0].pageX) / 2;
        }
        if (touches[0].pageY > touches[1].pageY) {
          centerTouchY = touches[1].pageY + (touches[0].pageY - touches[1].pageY) / 2;
        } else {
          centerTouchY = touches[0].pageY + (touches[1].pageY - touches[0].pageY) / 2;
        }
        centerTouchX -= offset.left;
        centerTouchY -= offset.top;
        touchStartScale = map.scale;
        touchStartDistance = Math.sqrt(Math.pow(touches[0].pageX - touches[1].pageX, 2) + Math.pow(touches[0].pageY - touches[1].pageY, 2));
      }
    }
    lastTouchesLength = touches.length;
  };
  EventHandler.on(map.container, 'touchstart', handleTouchEvent);
  EventHandler.on(map.container, 'touchmove', handleTouchEvent);
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function _createForOfIteratorHelperLoose(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (t) return (t = t.call(r)).next.bind(t);
  if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
    t && (r = t);
    var o = 0;
    return function () {
      return o >= r.length ? {
        done: !0
      } : {
        done: !1,
        value: r[o++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}

/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */
var BaseComponent = /*#__PURE__*/function () {
  function BaseComponent() {}
  var _proto = BaseComponent.prototype;
  _proto.dispose = function dispose() {
    if (this._tooltip) {
      removeElement(this._tooltip);
    } else {
      // @todo: move shape in base component in v2
      this.shape.remove();
    }
    for (var _iterator = _createForOfIteratorHelperLoose(Object.getOwnPropertyNames(this)), _step; !(_step = _iterator()).done;) {
      var propertyName = _step.value;
      this[propertyName] = null;
    }
  };
  return BaseComponent;
}();

/**
 * ------------------------------------------------------------------------
 * Interactable
 * ------------------------------------------------------------------------
 */
var Interactable = {
  getLabelText: function getLabelText(key, label) {
    if (!label) {
      return;
    }
    if (typeof label.render === 'function') {
      var params = [];

      // Pass additional paramater (Marker config object) in case it's a Marker.
      if (this.config && this.config.marker) {
        params.push(this.config.marker);
      }

      // Becuase we need to add the key always at the end
      params.push(key);
      return label.render.apply(this, params);
    }
    return key;
  },
  getLabelOffsets: function getLabelOffsets(key, label) {
    if (typeof label.offsets === 'function') {
      return label.offsets(key);
    }

    // If offsets are an array of offsets e.g offsets: [ [0, 25], [10, 15] ]
    if (Array.isArray(label.offsets)) {
      return label.offsets[key];
    }
    return [0, 0];
  },
  setStyle: function setStyle(property, value) {
    this.shape.setStyle(property, value);
  },
  remove: function remove() {
    this.shape.remove();
    if (this.label) this.label.remove();
  },
  hover: function hover(state) {
    this._setStatus('isHovered', state);
  },
  select: function select(state) {
    this._setStatus('isSelected', state);
  },
  // Private
  _setStatus: function _setStatus(property, state) {
    this.shape[property] = state;
    this.shape.updateStyle();
    this[property] = state;
    if (this.label) {
      this.label[property] = state;
      this.label.updateStyle();
    }
  }
};

/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */
var Region = /*#__PURE__*/function (_BaseComponent) {
  function Region(_ref) {
    var _this;
    var map = _ref.map,
      code = _ref.code,
      path = _ref.path,
      style = _ref.style,
      label = _ref.label,
      labelStyle = _ref.labelStyle,
      labelsGroup = _ref.labelsGroup;
    _this = _BaseComponent.call(this) || this;
    _this._map = map;
    _this.shape = _this._createRegion(path, code, style);
    var text = _this.getLabelText(code, label);

    // If label is passed and render function returns something 
    if (label && text) {
      var bbox = _this.shape.getBBox();
      var offsets = _this.getLabelOffsets(code, label);
      _this.labelX = bbox.x + bbox.width / 2 + offsets[0];
      _this.labelY = bbox.y + bbox.height / 2 + offsets[1];
      _this.label = _this._map.canvas.createText({
        text: text,
        textAnchor: 'middle',
        alignmentBaseline: 'central',
        dataCode: code,
        x: _this.labelX,
        y: _this.labelY
      }, labelStyle, labelsGroup);
      _this.label.addClass('jvm-region jvm-element');
    }
    return _this;
  }
  _inheritsLoose(Region, _BaseComponent);
  var _proto = Region.prototype;
  _proto._createRegion = function _createRegion(path, code, style) {
    path = this._map.canvas.createPath({
      d: path,
      dataCode: code
    }, style);
    path.addClass('jvm-region jvm-element');
    return path;
  };
  _proto.updateLabelPosition = function updateLabelPosition() {
    if (this.label) {
      this.label.set({
        x: this.labelX * this._map.scale + this._map.transX * this._map.scale,
        y: this.labelY * this._map.scale + this._map.transY * this._map.scale
      });
    }
  };
  return Region;
}(BaseComponent);
inherit(Region, Interactable);
function createRegions() {
  this._regionLabelsGroup = this._regionLabelsGroup || this.canvas.createGroup('jvm-regions-labels-group');
  for (var code in this._mapData.paths) {
    var region = new Region({
      map: this,
      code: code,
      path: this._mapData.paths[code].path,
      style: merge({}, this.params.regionStyle),
      labelStyle: this.params.regionLabelStyle,
      labelsGroup: this._regionLabelsGroup,
      label: this.params.labels && this.params.labels.regions
    });
    this.regions[code] = {
      config: this._mapData.paths[code],
      element: region
    };
  }
}

/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */
var Line = /*#__PURE__*/function (_BaseComponent) {
  function Line(_ref) {
    var _this;
    var index = _ref.index,
      map = _ref.map,
      style = _ref.style,
      x1 = _ref.x1,
      y1 = _ref.y1,
      x2 = _ref.x2,
      y2 = _ref.y2,
      group = _ref.group,
      config = _ref.config;
    _this = _BaseComponent.call(this) || this;
    _this.config = config;
    _this.shape = map.canvas.createLine({
      x1: x1,
      y1: y1,
      x2: x2,
      y2: y2,
      dataIndex: index
    }, style, group);
    _this.shape.addClass('jvm-line');
    return _this;
  }
  _inheritsLoose(Line, _BaseComponent);
  var _proto = Line.prototype;
  _proto.setStyle = function setStyle(property, value) {
    this.shape.setStyle(property, value);
  };
  return Line;
}(BaseComponent);
function createLines(lines, markers, isRecentlyCreated) {
  if (isRecentlyCreated === void 0) {
    isRecentlyCreated = false;
  }
  var point1 = false,
    point2 = false;

  // Create group for holding lines
  // we're checking if `linesGroup` exists or not becuase we may add lines
  // after the map has loaded so we will append the futured lines to this group as well.
  this.linesGroup = this.linesGroup || this.canvas.createGroup('jvm-lines-group');
  for (var index in lines) {
    var config = lines[index];
    for (var mindex in markers) {
      var markerConfig = isRecentlyCreated ? markers[mindex].config : markers[mindex];
      if (markerConfig.name === config.from) {
        point1 = this.getMarkerPosition(markerConfig);
      }
      if (markerConfig.name === config.to) {
        point2 = this.getMarkerPosition(markerConfig);
      }
    }
    if (point1 !== false && point2 !== false) {
      // Register lines with unique keys
      this._lines[getLineUid(config.from, config.to)] = new Line({
        index: index,
        map: this,
        // Merge the default `lineStyle` object with the custom `line` config style
        style: merge({
          initial: this.params.lineStyle
        }, {
          initial: config.style || {}
        }, true),
        x1: point1.x,
        y1: point1.y,
        x2: point2.x,
        y2: point2.y,
        group: this.linesGroup,
        config: config
      });
    }
  }
}

/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */
var Marker = /*#__PURE__*/function (_BaseComponent) {
  function Marker(_ref) {
    var _this;
    var index = _ref.index,
      style = _ref.style,
      label = _ref.label,
      cx = _ref.cx,
      cy = _ref.cy,
      map = _ref.map,
      group = _ref.group;
    _this = _BaseComponent.call(this) || this;

    // Private
    _this._map = map;
    _this._isImage = !!style.initial.image;

    // Protected
    _this.config = arguments[0];
    _this.shape = map.canvas[_this._isImage ? 'createImage' : 'createCircle']({
      dataIndex: index,
      cx: cx,
      cy: cy
    }, style, group);
    _this.shape.addClass('jvm-marker jvm-element');
    if (_this._isImage) {
      _this.updateLabelPosition();
    }
    if (label) {
      _this._createLabel(_this.config);
    }
    return _this;
  }
  _inheritsLoose(Marker, _BaseComponent);
  var _proto = Marker.prototype;
  _proto.updateLabelPosition = function updateLabelPosition() {
    if (this.label) {
      this.label.set({
        x: this._labelX * this._map.scale + this._offsets[0] + this._map.transX * this._map.scale + 5 + (this._isImage ? (this.shape.width || 0) / 2 : this.shape.node.r.baseVal.value),
        y: this._labelY * this._map.scale + this._map.transY * this._map.scale + this._offsets[1]
      });
    }
  };
  _proto._createLabel = function _createLabel(_ref2) {
    var index = _ref2.index,
      map = _ref2.map,
      label = _ref2.label,
      labelsGroup = _ref2.labelsGroup,
      cx = _ref2.cx,
      cy = _ref2.cy,
      marker = _ref2.marker,
      isRecentlyCreated = _ref2.isRecentlyCreated;
    var labelText = this.getLabelText(index, label);
    this._labelX = cx / map.scale - map.transX;
    this._labelY = cy / map.scale - map.transY;
    this._offsets = isRecentlyCreated && marker.offsets ? marker.offsets : this.getLabelOffsets(index, label);
    this.label = map.canvas.createText({
      text: labelText,
      dataIndex: index,
      x: this._labelX,
      y: this._labelY,
      dy: '0.6ex'
    }, map.params.markerLabelStyle, labelsGroup);
    this.label.addClass('jvm-marker jvm-element');
    if (isRecentlyCreated) {
      this.updateLabelPosition();
    }
  };
  return Marker;
}(BaseComponent);
inherit(Marker, Interactable);
function createMarkers(markers, isRecentlyCreated) {
  var _this = this;
  if (markers === void 0) {
    markers = {};
  }
  if (isRecentlyCreated === void 0) {
    isRecentlyCreated = false;
  }
  // Create groups for holding markers and markers labels
  // We're checking if `markersGroup` exists or not becuase we may add markers after the map has loaded
  // So we will append the futured markers to this group as well.
  this._markersGroup = this._markersGroup || this.canvas.createGroup('jvm-markers-group');
  this._markerLabelsGroup = this._markerLabelsGroup || this.canvas.createGroup('jvm-markers-labels-group');
  var _loop = function _loop() {
      var config = markers[index];
      var point = _this.getMarkerPosition(config);
      var uid = config.coords.join(':');
      if (!point) {
        return 0; // continue
      }

      // We're checking if recently created marker does already exist
      // If it does we don't need to create it again, so we'll continue
      // Becuase we may have more than one marker submitted via `addMarkers` method.
      if (isRecentlyCreated) {
        if (Object.keys(_this._markers).filter(function (i) {
          return _this._markers[i]._uid === uid;
        }).length) {
          return 0; // continue
        }
        index = Object.keys(_this._markers).length;
      }
      var marker = new Marker({
        index: index,
        map: _this,
        // Merge the `markerStyle` object with the marker config `style` if presented.
        style: merge(_this.params.markerStyle, _extends({}, config.style || {}), true),
        label: _this.params.labels && _this.params.labels.markers,
        labelsGroup: _this._markerLabelsGroup,
        cx: point.x,
        cy: point.y,
        group: _this._markersGroup,
        marker: config,
        isRecentlyCreated: isRecentlyCreated
      });

      // Check for marker duplication
      // this is useful when for example: a user clicks a button for creating marker two times
      // so it will remove the old one and the new one will take its place.
      if (_this._markers[index]) {
        _this.removeMarkers([index]);
      }
      _this._markers[index] = {
        _uid: uid,
        config: config,
        element: marker
      };
    },
    _ret;
  for (var index in markers) {
    _ret = _loop();
    if (_ret === 0) continue;
  }
}

/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */
var Legend = /*#__PURE__*/function () {
  function Legend(options) {
    if (options === void 0) {
      options = {};
    }
    this._options = options;
    this._map = this._options.map;
    this._series = this._options.series;
    this._body = createElement('div', 'jvm-legend');
    if (this._options.cssClass) {
      this._body.setAttribute('class', this._options.cssClass);
    }
    if (options.vertical) {
      this._map.legendVertical.appendChild(this._body);
    } else {
      this._map.legendHorizontal.appendChild(this._body);
    }
    this.render();
  }
  var _proto = Legend.prototype;
  _proto.render = function render() {
    var ticks = this._series.scale.getTicks();
    var inner = createElement('div', 'jvm-legend-inner');
    this._body.innderHTML = '';
    if (this._options.title) {
      var legendTitle = createElement('div', 'jvm-legend-title', this._options.title);
      this._body.appendChild(legendTitle);
    }
    this._body.appendChild(inner);
    for (var i = 0; i < ticks.length; i++) {
      var tick = createElement('div', 'jvm-legend-tick');
      var sample = createElement('div', 'jvm-legend-tick-sample');
      switch (this._series.config.attribute) {
        case 'fill':
          if (isImageUrl(ticks[i].value)) {
            sample.style.background = "url(" + ticks[i].value + ")";
          } else {
            sample.style.background = ticks[i].value;
          }
          break;
        case 'stroke':
          sample.style.background = ticks[i].value;
          break;
        case 'image':
          sample.style.background = "url(" + (typeof ticks[i].value === 'object' ? ticks[i].value.url : ticks[i].value) + ") no-repeat center center";
          sample.style.backgroundSize = 'cover';
          break;
      }
      tick.appendChild(sample);
      var label = ticks[i].label;
      if (this._options.labelRender) {
        label = this._options.labelRender(label);
      }
      var tickText = createElement('div', 'jvm-legend-tick-text', label);
      tick.appendChild(tickText);
      inner.appendChild(tick);
    }
  };
  return Legend;
}();

/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */
var OrdinalScale = /*#__PURE__*/function () {
  function OrdinalScale(scale) {
    this._scale = scale;
  }
  var _proto = OrdinalScale.prototype;
  _proto.getValue = function getValue(value) {
    return this._scale[value];
  };
  _proto.getTicks = function getTicks() {
    var ticks = [];
    for (var key in this._scale) {
      ticks.push({
        label: key,
        value: this._scale[key]
      });
    }
    return ticks;
  };
  return OrdinalScale;
}();

/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */
var Series = /*#__PURE__*/function () {
  function Series(config, elements, map) {
    if (config === void 0) {
      config = {};
    }
    // Private
    this._map = map;
    this._elements = elements; // Could be markers or regions
    this._values = config.values || {};

    // Protected
    this.config = config;
    this.config.attribute = config.attribute || 'fill';

    // Set initial attributes
    if (config.attributes) {
      this.setAttributes(config.attributes);
    }
    if (typeof config.scale === 'object') {
      this.scale = new OrdinalScale(config.scale);
    }
    if (this.config.legend) {
      this.legend = new Legend(merge({
        map: this._map,
        series: this
      }, this.config.legend));
    }
    this.setValues(this._values);
  }
  var _proto = Series.prototype;
  _proto.setValues = function setValues(values) {
    var attrs = {};
    for (var key in values) {
      if (values[key]) {
        attrs[key] = this.scale.getValue(values[key]);
      }
    }
    this.setAttributes(attrs);
  };
  _proto.setAttributes = function setAttributes(attrs) {
    for (var code in attrs) {
      if (this._elements[code]) {
        this._elements[code].element.setStyle(this.config.attribute, attrs[code]);
      }
    }
  };
  _proto.clear = function clear() {
    var key,
      attrs = {};
    for (key in this._values) {
      if (this._elements[key]) {
        attrs[key] = this._elements[key].element.shape.style.initial[this.config.attribute];
      }
    }
    this.setAttributes(attrs);
    this._values = {};
  };
  return Series;
}();
function createSeries() {
  this.series = {
    markers: [],
    regions: []
  };
  for (var key in this.params.series) {
    for (var i = 0; i < this.params.series[key].length; i++) {
      this.series[key][i] = new Series(this.params.series[key][i], key === 'markers' ? this._markers : this.regions, this);
    }
  }
}
function applyTransform() {
  var maxTransX, maxTransY, minTransX, minTransY;
  if (this._defaultWidth * this.scale <= this._width) {
    maxTransX = (this._width - this._defaultWidth * this.scale) / (2 * this.scale);
    minTransX = (this._width - this._defaultWidth * this.scale) / (2 * this.scale);
  } else {
    maxTransX = 0;
    minTransX = (this._width - this._defaultWidth * this.scale) / this.scale;
  }
  if (this._defaultHeight * this.scale <= this._height) {
    maxTransY = (this._height - this._defaultHeight * this.scale) / (2 * this.scale);
    minTransY = (this._height - this._defaultHeight * this.scale) / (2 * this.scale);
  } else {
    maxTransY = 0;
    minTransY = (this._height - this._defaultHeight * this.scale) / this.scale;
  }
  if (this.transY > maxTransY) {
    this.transY = maxTransY;
  } else if (this.transY < minTransY) {
    this.transY = minTransY;
  }
  if (this.transX > maxTransX) {
    this.transX = maxTransX;
  } else if (this.transX < minTransX) {
    this.transX = minTransX;
  }
  this.canvas.applyTransformParams(this.scale, this.transX, this.transY);
  if (this._markers) {
    this._repositionMarkers();
  }
  if (this._lines) {
    this._repositionLines();
  }
  this._repositionLabels();
}
function resize() {
  var curBaseScale = this._baseScale;
  if (this._width / this._height > this._defaultWidth / this._defaultHeight) {
    this._baseScale = this._height / this._defaultHeight;
    this._baseTransX = Math.abs(this._width - this._defaultWidth * this._baseScale) / (2 * this._baseScale);
  } else {
    this._baseScale = this._width / this._defaultWidth;
    this._baseTransY = Math.abs(this._height - this._defaultHeight * this._baseScale) / (2 * this._baseScale);
  }
  this.scale *= this._baseScale / curBaseScale;
  this.transX *= this._baseScale / curBaseScale;
  this.transY *= this._baseScale / curBaseScale;
}
function setScale(scale, anchorX, anchorY, isCentered, animate) {
  var _this = this;
  var zoomStep,
    interval,
    i = 0,
    count = Math.abs(Math.round((scale - this.scale) * 60 / Math.max(scale, this.scale))),
    scaleStart,
    scaleDiff,
    transXStart,
    transXDiff,
    transYStart,
    transYDiff,
    transX,
    transY;
  if (scale > this.params.zoomMax * this._baseScale) {
    scale = this.params.zoomMax * this._baseScale;
  } else if (scale < this.params.zoomMin * this._baseScale) {
    scale = this.params.zoomMin * this._baseScale;
  }
  if (typeof anchorX != 'undefined' && typeof anchorY != 'undefined') {
    zoomStep = scale / this.scale;
    if (isCentered) {
      transX = anchorX + this._defaultWidth * (this._width / (this._defaultWidth * scale)) / 2;
      transY = anchorY + this._defaultHeight * (this._height / (this._defaultHeight * scale)) / 2;
    } else {
      transX = this.transX - (zoomStep - 1) / scale * anchorX;
      transY = this.transY - (zoomStep - 1) / scale * anchorY;
    }
  }
  if (animate && count > 0) {
    scaleStart = this.scale;
    scaleDiff = (scale - scaleStart) / count;
    transXStart = this.transX * this.scale;
    transYStart = this.transY * this.scale;
    transXDiff = (transX * scale - transXStart) / count;
    transYDiff = (transY * scale - transYStart) / count;
    interval = setInterval(function () {
      i += 1;
      _this.scale = scaleStart + scaleDiff * i;
      _this.transX = (transXStart + transXDiff * i) / _this.scale;
      _this.transY = (transYStart + transYDiff * i) / _this.scale;
      _this._applyTransform();
      if (i == count) {
        clearInterval(interval);
        _this._emit(Events.onViewportChange, [_this.scale, _this.transX, _this.transY]);
      }
    }, 10);
  } else {
    this.transX = transX;
    this.transY = transY;
    this.scale = scale;
    this._applyTransform();
    this._emit(Events.onViewportChange, [this.scale, this.transX, this.transY]);
  }
}
function setFocus(config) {
  var _this = this;
  if (config === void 0) {
    config = {};
  }
  var bbox,
    codes = [];
  if (config.region) {
    codes.push(config.region);
  } else if (config.regions) {
    codes = config.regions;
  }
  if (codes.length) {
    codes.forEach(function (code) {
      if (_this.regions[code]) {
        var itemBbox = _this.regions[code].element.shape.getBBox();
        if (itemBbox) {
          // Handle the first loop
          if (typeof bbox == 'undefined') {
            bbox = itemBbox;
          } else {
            // get the old bbox properties plus the current
            // this kinda incrementing the old values and the new values
            bbox = {
              x: Math.min(bbox.x, itemBbox.x),
              y: Math.min(bbox.y, itemBbox.y),
              width: Math.max(bbox.x + bbox.width, itemBbox.x + itemBbox.width) - Math.min(bbox.x, itemBbox.x),
              height: Math.max(bbox.y + bbox.height, itemBbox.y + itemBbox.height) - Math.min(bbox.y, itemBbox.y)
            };
          }
        }
      }
    });
    return this._setScale(Math.min(this._width / bbox.width, this._height / bbox.height), -(bbox.x + bbox.width / 2), -(bbox.y + bbox.height / 2), true, config.animate);
  } else if (config.coords) {
    var point = this.coordsToPoint(config.coords[0], config.coords[1]);
    var x = this.transX - point.x / this.scale;
    var y = this.transY - point.y / this.scale;
    return this._setScale(config.scale * this._baseScale, x, y, true, config.animate);
  }
}
function updateSize() {
  this._width = this.container.offsetWidth;
  this._height = this.container.offsetHeight;
  this._resize();
  this.canvas.setSize(this._width, this._height);
  this._applyTransform();
}

/**
 * ------------------------------------------------------------------------
 * Object
 * ------------------------------------------------------------------------
 */
var Proj = {
  /* sgn(n){
    if (n > 0) {
      return 1;
    } else if (n < 0) {
      return -1;
    } else {
      return n;
    }
  }, */
  mill: function mill(lat, lng, c) {
    return {
      x: this.radius * (lng - c) * this.radDeg,
      y: -this.radius * Math.log(Math.tan((45 + 0.4 * lat) * this.radDeg)) / 0.8
    };
  },
  /* mill_inv(x, y, c) {
    return {
      lat: (2.5 * Math.atan(Math.exp(0.8 * y / this.radius)) - 5 * Math.PI / 8) * this.degRad,
      lng: (c * this.radDeg + x / this.radius) * this.degRad
    };
  }, */
  merc: function merc(lat, lng, c) {
    return {
      x: this.radius * (lng - c) * this.radDeg,
      y: -this.radius * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))
    };
  },
  /* merc_inv(x, y, c) {
    return {
      lat: (2 * Math.atan(Math.exp(y / this.radius)) - Math.PI / 2) * this.degRad,
      lng: (c * this.radDeg + x / this.radius) * this.degRad
    };
  }, */
  aea: function aea(lat, lng, c) {
    var fi0 = 0,
      lambda0 = c * this.radDeg,
      fi1 = 29.5 * this.radDeg,
      fi2 = 45.5 * this.radDeg,
      fi = lat * this.radDeg,
      lambda = lng * this.radDeg,
      n = (Math.sin(fi1) + Math.sin(fi2)) / 2,
      C = Math.cos(fi1) * Math.cos(fi1) + 2 * n * Math.sin(fi1),
      theta = n * (lambda - lambda0),
      ro = Math.sqrt(C - 2 * n * Math.sin(fi)) / n,
      ro0 = Math.sqrt(C - 2 * n * Math.sin(fi0)) / n;
    return {
      x: ro * Math.sin(theta) * this.radius,
      y: -(ro0 - ro * Math.cos(theta)) * this.radius
    };
  },
  /* aea_inv(xCoord, yCoord, c) {
    var x = xCoord / this.radius,
        y = yCoord / this.radius,
        fi0 = 0,
        lambda0 = c * this.radDeg,
        fi1 = 29.5 * this.radDeg,
        fi2 = 45.5 * this.radDeg,
        n = (Math.sin(fi1)+Math.sin(fi2)) / 2,
        C = Math.cos(fi1)*Math.cos(fi1)+2*n*Math.sin(fi1),
        ro0 = Math.sqrt(C-2*n*Math.sin(fi0))/n,
        ro = Math.sqrt(x*x+(ro0-y)*(ro0-y)),
        theta = Math.atan( x / (ro0 - y) );
     return {
      lat: (Math.asin((C - ro * ro * n * n) / (2 * n))) * this.degRad,
      lng: (lambda0 + theta / n) * this.degRad
    };
  }, */
  lcc: function lcc(lat, lng, c) {
    var fi0 = 0,
      lambda0 = c * this.radDeg,
      lambda = lng * this.radDeg,
      fi1 = 33 * this.radDeg,
      fi2 = 45 * this.radDeg,
      fi = lat * this.radDeg,
      n = Math.log(Math.cos(fi1) * (1 / Math.cos(fi2))) / Math.log(Math.tan(Math.PI / 4 + fi2 / 2) * (1 / Math.tan(Math.PI / 4 + fi1 / 2))),
      F = Math.cos(fi1) * Math.pow(Math.tan(Math.PI / 4 + fi1 / 2), n) / n,
      ro = F * Math.pow(1 / Math.tan(Math.PI / 4 + fi / 2), n),
      ro0 = F * Math.pow(1 / Math.tan(Math.PI / 4 + fi0 / 2), n);
    return {
      x: ro * Math.sin(n * (lambda - lambda0)) * this.radius,
      y: -(ro0 - ro * Math.cos(n * (lambda - lambda0))) * this.radius
    };
  }
  /* lcc_inv(xCoord, yCoord, c) {
    var x = xCoord / this.radius,
        y = yCoord / this.radius,
        fi0 = 0,
        lambda0 = c * this.radDeg,
        fi1 = 33 * this.radDeg,
        fi2 = 45 * this.radDeg,
        n = Math.log( Math.cos(fi1) * (1 / Math.cos(fi2)) ) / Math.log( Math.tan( Math.PI / 4 + fi2 / 2) * (1 / Math.tan( Math.PI / 4 + fi1 / 2) ) ),
        F = ( Math.cos(fi1) * Math.pow( Math.tan( Math.PI / 4 + fi1 / 2 ), n ) ) / n,
        ro0 = F * Math.pow( 1 / Math.tan( Math.PI / 4 + fi0 / 2 ), n ),
        ro = this.sgn(n) * Math.sqrt(x*x+(ro0-y)*(ro0-y)),
        theta = Math.atan( x / (ro0 - y) );
     return {
      lat: (2 * Math.atan(Math.pow(F/ro, 1/n)) - Math.PI / 2) * this.degRad,
      lng: (lambda0 + theta / n) * this.degRad
    };
  } */
};
Proj.degRad = 180 / Math.PI;
Proj.radDeg = Math.PI / 180;
Proj.radius = 6381372;
function coordsToPoint(lat, lng) {
  var projection = Map.maps[this.params.map].projection;
  var _Proj$projection$type = Proj[projection.type](lat, lng, projection.centralMeridian),
    x = _Proj$projection$type.x,
    y = _Proj$projection$type.y;
  var inset = this.getInsetForPoint(x, y);
  if (!inset) {
    return false;
  }
  var bbox = inset.bbox;
  x = (x - bbox[0].x) / (bbox[1].x - bbox[0].x) * inset.width * this.scale;
  y = (y - bbox[0].y) / (bbox[1].y - bbox[0].y) * inset.height * this.scale;
  return {
    x: x + this.transX * this.scale + inset.left * this.scale,
    y: y + this.transY * this.scale + inset.top * this.scale
  };
}
function getInsetForPoint(x, y) {
  var insets = Map.maps[this.params.map].insets;
  for (var index = 0; index < insets.length; index++) {
    var _insets$index$bbox = insets[index].bbox,
      start = _insets$index$bbox[0],
      end = _insets$index$bbox[1];
    if (x > start.x && x < end.x && y > start.y && y < end.y) {
      return insets[index];
    }
  }
}
function getMarkerPosition(_ref) {
  var coords = _ref.coords;
  if (Map.maps[this.params.map].projection) {
    return this.coordsToPoint.apply(this, coords);
  }
  return {
    x: coords[0] * this.scale + this.transX * this.scale,
    y: coords[1] * this.scale + this.transY * this.scale
  };
}
function repositionLines() {
  var point1 = false,
    point2 = false;
  for (var index in this._lines) {
    for (var mindex in this._markers) {
      var marker = this._markers[mindex];
      if (marker.config.name === this._lines[index].config.from) {
        point1 = this.getMarkerPosition(marker.config);
      }
      if (marker.config.name === this._lines[index].config.to) {
        point2 = this.getMarkerPosition(marker.config);
      }
    }
    if (point1 !== false && point2 !== false) {
      this._lines[index].setStyle({
        x1: point1.x,
        y1: point1.y,
        x2: point2.x,
        y2: point2.y
      });
    }
  }
}
function repositionMarkers() {
  for (var index in this._markers) {
    var point = this.getMarkerPosition(this._markers[index].config);
    if (point !== false) {
      this._markers[index].element.setStyle({
        cx: point.x,
        cy: point.y
      });
    }
  }
}
function repositionLabels() {
  var labels = this.params.labels;
  if (!labels) {
    return;
  }

  // Regions labels
  if (labels.regions) {
    for (var key in this.regions) {
      this.regions[key].element.updateLabelPosition();
    }
  }

  // Markers labels
  if (labels.markers) {
    for (var _key in this._markers) {
      this._markers[_key].element.updateLabelPosition();
    }
  }
}
var core = {
  _setupContainerEvents: setupContainerEvents,
  _setupElementEvents: setupElementEvents,
  _setupZoomButtons: setupZoomButtons,
  _setupContainerTouchEvents: setupContainerTouchEvents,
  _createRegions: createRegions,
  _createLines: createLines,
  _createMarkers: createMarkers,
  _createSeries: createSeries,
  _applyTransform: applyTransform,
  _resize: resize,
  _setScale: setScale,
  setFocus: setFocus,
  updateSize: updateSize,
  coordsToPoint: coordsToPoint,
  getInsetForPoint: getInsetForPoint,
  getMarkerPosition: getMarkerPosition,
  _repositionLines: repositionLines,
  _repositionMarkers: repositionMarkers,
  _repositionLabels: repositionLabels
};
var Defaults = {
  map: 'world',
  backgroundColor: 'transparent',
  draggable: true,
  zoomButtons: true,
  zoomOnScroll: true,
  zoomOnScrollSpeed: 3,
  zoomMax: 12,
  zoomMin: 1,
  zoomAnimate: true,
  showTooltip: true,
  zoomStep: 1.5,
  bindTouchEvents: true,
  // Line options
  lineStyle: {
    stroke: '#808080',
    strokeWidth: 1,
    strokeLinecap: 'round'
  },
  // Marker options
  markersSelectable: false,
  markersSelectableOne: false,
  markerStyle: {
    initial: {
      r: 7,
      fill: '#374151',
      fillOpacity: 1,
      stroke: '#FFF',
      strokeWidth: 5,
      strokeOpacity: .5
    },
    hover: {
      fill: '#3cc0ff',
      cursor: 'pointer'
    },
    selected: {
      fill: 'blue'
    },
    selectedHover: {}
  },
  markerLabelStyle: {
    initial: {
      fontFamily: 'Verdana',
      fontSize: 12,
      fontWeight: 500,
      cursor: 'default',
      fill: '#374151'
    },
    hover: {
      cursor: 'pointer'
    },
    selected: {},
    selectedHover: {}
  },
  // Region options
  regionsSelectable: false,
  regionsSelectableOne: false,
  regionStyle: {
    initial: {
      fill: '#dee2e8',
      fillOpacity: 1,
      stroke: 'none',
      strokeWidth: 0
    },
    hover: {
      fillOpacity: .7,
      cursor: 'pointer'
    },
    selected: {
      fill: '#9ca3af'
    },
    selectedHover: {}
  },
  regionLabelStyle: {
    initial: {
      fontFamily: 'Verdana',
      fontSize: '12',
      fontWeight: 'bold',
      cursor: 'default',
      fill: '#35373e'
    },
    hover: {
      cursor: 'pointer'
    }
  }
};

/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */
var SVGElement = /*#__PURE__*/function () {
  function SVGElement(name, config) {
    this.node = this._createElement(name);
    if (config) {
      this.set(config);
    }
  }

  // Create new SVG element `svg`, `g`, `path`, `line`, `circle`, `image`, etc.
  // https://developer.mozilla.org/en-US/docs/Web/API/Document/createElementNS#important_namespace_uris
  var _proto = SVGElement.prototype;
  _proto._createElement = function _createElement(tagName) {
    return document.createElementNS('http://www.w3.org/2000/svg', tagName);
  };
  _proto.addClass = function addClass(className) {
    this.node.setAttribute('class', className);
  };
  _proto.getBBox = function getBBox() {
    return this.node.getBBox();
  }

  // Apply attributes on the current node element
  ;
  _proto.set = function set(property, value) {
    if (typeof property === 'object') {
      for (var attr in property) {
        this.applyAttr(attr, property[attr]);
      }
    } else {
      this.applyAttr(property, value);
    }
  };
  _proto.get = function get(property) {
    return this.style.initial[property];
  };
  _proto.applyAttr = function applyAttr(property, value) {
    this.node.setAttribute(hyphenate(property), value);
  };
  _proto.remove = function remove() {
    removeElement(this.node);
  };
  return SVGElement;
}();

/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */
var SVGShapeElement = /*#__PURE__*/function (_SVGElement) {
  function SVGShapeElement(name, config, style) {
    var _this;
    if (style === void 0) {
      style = {};
    }
    _this = _SVGElement.call(this, name, config) || this;
    _this.isHovered = false;
    _this.isSelected = false;
    _this.style = style;
    _this.style.current = {};
    _this.updateStyle();
    return _this;
  }
  _inheritsLoose(SVGShapeElement, _SVGElement);
  var _proto = SVGShapeElement.prototype;
  _proto.setStyle = function setStyle(property, value) {
    if (typeof property === 'object') {
      merge(this.style.current, property);
    } else {
      var _merge;
      merge(this.style.current, (_merge = {}, _merge[property] = value, _merge));
    }
    this.updateStyle();
  };
  _proto.updateStyle = function updateStyle() {
    var attrs = {};
    merge(attrs, this.style.initial);
    merge(attrs, this.style.current);
    if (this.isHovered) {
      merge(attrs, this.style.hover);
    }
    if (this.isSelected) {
      merge(attrs, this.style.selected);
      if (this.isHovered) {
        merge(attrs, this.style.selectedHover);
      }
    }
    this.set(attrs);
  };
  return SVGShapeElement;
}(SVGElement);

/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */
var SVGTextElement = /*#__PURE__*/function (_SVGShapeElement) {
  function SVGTextElement(config, style) {
    return _SVGShapeElement.call(this, 'text', config, style) || this;
  }
  _inheritsLoose(SVGTextElement, _SVGShapeElement);
  var _proto = SVGTextElement.prototype;
  _proto.applyAttr = function applyAttr(attr, value) {
    attr === 'text' ? this.node.textContent = value : _SVGShapeElement.prototype.applyAttr.call(this, attr, value);
  };
  return SVGTextElement;
}(SVGShapeElement);

/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */
var SVGImageElement = /*#__PURE__*/function (_SVGShapeElement) {
  function SVGImageElement(config, style) {
    return _SVGShapeElement.call(this, 'image', config, style) || this;
  }
  _inheritsLoose(SVGImageElement, _SVGShapeElement);
  var _proto = SVGImageElement.prototype;
  _proto.applyAttr = function applyAttr(attr, value) {
    var imageUrl;
    if (attr === 'image') {
      // This get executed when we have url in series.markers[0].scale.someScale.url
      if (typeof value === 'object') {
        imageUrl = value.url;
        this.offset = value.offset || [0, 0];
      } else {
        imageUrl = value;
        this.offset = [0, 0];
      }
      this.node.setAttributeNS('http://www.w3.org/1999/xlink', 'href', imageUrl);

      // Set width and height then call this `applyAttr` again
      this.width = 23;
      this.height = 23;
      this.applyAttr('width', this.width);
      this.applyAttr('height', this.height);
      this.applyAttr('x', this.cx - this.width / 2 + this.offset[0]);
      this.applyAttr('y', this.cy - this.height / 2 + this.offset[1]);
    } else if (attr == 'cx') {
      this.cx = value;
      if (this.width) {
        this.applyAttr('x', value - this.width / 2 + this.offset[0]);
      }
    } else if (attr == 'cy') {
      this.cy = value;
      if (this.height) {
        this.applyAttr('y', value - this.height / 2 + this.offset[1]);
      }
    } else {
      // This time Call SVGElement
      _SVGShapeElement.prototype.applyAttr.apply(this, arguments);
    }
  };
  return SVGImageElement;
}(SVGShapeElement);

/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */
var SVGCanvasElement = /*#__PURE__*/function (_SVGElement) {
  function SVGCanvasElement(container) {
    var _this;
    _this = _SVGElement.call(this, 'svg') || this; // Create svg element for holding the whole map

    _this._container = container;

    // Create the defs element
    _this._defsElement = new SVGElement('defs');

    // Create group element which will hold the paths (regions)
    _this._rootElement = new SVGElement('g', {
      id: 'jvm-regions-group'
    });

    // Append the defs element to the this.node (SVG tag)
    _this.node.appendChild(_this._defsElement.node);

    // Append the group to this.node (SVG tag)
    _this.node.appendChild(_this._rootElement.node);

    // Append this.node (SVG tag) to the container
    _this._container.appendChild(_this.node);
    return _this;
  }
  _inheritsLoose(SVGCanvasElement, _SVGElement);
  var _proto = SVGCanvasElement.prototype;
  _proto.setSize = function setSize(width, height) {
    this.node.setAttribute('width', width);
    this.node.setAttribute('height', height);
  };
  _proto.applyTransformParams = function applyTransformParams(scale, transX, transY) {
    this._rootElement.node.setAttribute('transform', "scale(" + scale + ") translate(" + transX + ", " + transY + ")");
  }

  // Create `path` element
  ;
  _proto.createPath = function createPath(config, style) {
    var path = new SVGShapeElement('path', config, style);
    path.node.setAttribute('fill-rule', 'evenodd');
    return this._add(path);
  }

  // Create `circle` element
  ;
  _proto.createCircle = function createCircle(config, style, group) {
    var circle = new SVGShapeElement('circle', config, style);
    return this._add(circle, group);
  }

  // Create `line` element
  ;
  _proto.createLine = function createLine(config, style, group) {
    var line = new SVGShapeElement('line', config, style);
    return this._add(line, group);
  }

  // Create `text` element
  ;
  _proto.createText = function createText(config, style, group) {
    var text = new SVGTextElement(config, style);
    return this._add(text, group);
  }

  // Create `image` element
  ;
  _proto.createImage = function createImage(config, style, group) {
    var image = new SVGImageElement(config, style);
    return this._add(image, group);
  }

  // Create `g` element
  ;
  _proto.createGroup = function createGroup(id) {
    var group = new SVGElement('g');
    this.node.appendChild(group.node);
    if (id) {
      group.node.id = id;
    }
    group.canvas = this;
    return group;
  }

  // Add some element to a spcific group or the root element if the group isn't given
  ;
  _proto._add = function _add(element, group) {
    group = group || this._rootElement;
    group.node.appendChild(element.node);
    return element;
  };
  return SVGCanvasElement;
}(SVGElement);

/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */
var Tooltip = /*#__PURE__*/function (_BaseComponent) {
  function Tooltip(map) {
    var _this;
    _this = _BaseComponent.call(this) || this;
    var tooltip = createElement('div', 'jvm-tooltip');
    _this._map = map;
    _this._tooltip = document.body.appendChild(tooltip);
    _this._bindEventListeners();
    return _this || _assertThisInitialized(_this);
  }
  _inheritsLoose(Tooltip, _BaseComponent);
  var _proto = Tooltip.prototype;
  _proto._bindEventListeners = function _bindEventListeners() {
    var _this2 = this;
    EventHandler.on(this._map.container, 'mousemove', function (event) {
      if (!_this2._tooltip.classList.contains('active')) {
        return;
      }
      var container = findElement(_this2._map.container, '#jvm-regions-group').getBoundingClientRect();
      var space = 5; // Space between the cursor and tooltip element

      // Tooltip
      var _this2$_tooltip$getBo = _this2._tooltip.getBoundingClientRect(),
        height = _this2$_tooltip$getBo.height,
        width = _this2$_tooltip$getBo.width;
      var topIsPassed = event.clientY <= container.top + height + space;
      var top = event.pageY - height - space;
      var left = event.pageX - width - space;

      // Ensure the tooltip will never cross outside the canvas area(map)
      if (topIsPassed) {
        // Top:
        top += height + space;

        // The cursor is a bit larger from left side
        left -= space * 2;
      }
      if (event.clientX < container.left + width + space) {
        // Left:
        left = event.pageX + space + 2;
        if (topIsPassed) {
          left += space * 2;
        }
      }
      _this2.css({
        top: top + "px",
        left: left + "px"
      });
    });
  };
  _proto.getElement = function getElement() {
    return this._tooltip;
  };
  _proto.show = function show() {
    this._tooltip.classList.add('active');
  };
  _proto.hide = function hide() {
    this._tooltip.classList.remove('active');
  };
  _proto.text = function text(string, html) {
    if (html === void 0) {
      html = false;
    }
    var property = html ? 'innerHTML' : 'textContent';
    if (!string) {
      return this._tooltip[property];
    }
    this._tooltip[property] = string;
  };
  _proto.css = function css(_css) {
    for (var style in _css) {
      this._tooltip.style[style] = _css[style];
    }
    return this;
  };
  return Tooltip;
}(BaseComponent);
var DataVisualization = /*#__PURE__*/function () {
  function DataVisualization(_ref, map) {
    var scale = _ref.scale,
      values = _ref.values;
    this._scale = scale;
    this._values = values;
    this._fromColor = this.hexToRgb(scale[0]);
    this._toColor = this.hexToRgb(scale[1]);
    this._map = map;
    this.setMinMaxValues(values);
    this.visualize();
  }
  var _proto = DataVisualization.prototype;
  _proto.setMinMaxValues = function setMinMaxValues(values) {
    this.min = Number.MAX_VALUE;
    this.max = 0;
    for (var value in values) {
      value = parseFloat(values[value]);
      if (value > this.max) {
        this.max = value;
      }
      if (value < this.min) {
        this.min = value;
      }
    }
  };
  _proto.visualize = function visualize() {
    var attrs = {},
      value;
    for (var regionCode in this._values) {
      value = parseFloat(this._values[regionCode]);
      if (!isNaN(value)) {
        attrs[regionCode] = this.getValue(value);
      }
    }
    this.setAttributes(attrs);
  };
  _proto.setAttributes = function setAttributes(attrs) {
    for (var code in attrs) {
      if (this._map.regions[code]) {
        this._map.regions[code].element.setStyle('fill', attrs[code]);
      }
    }
  };
  _proto.getValue = function getValue(value) {
    if (this.min === this.max) {
      return "#" + this._toColor.join('');
    }
    var hex,
      color = '#';
    for (var i = 0; i < 3; i++) {
      hex = Math.round(this._fromColor[i] + (this._toColor[i] - this._fromColor[i]) * ((value - this.min) / (this.max - this.min))).toString(16);
      color += (hex.length === 1 ? '0' : '') + hex;
    }
    return color;
  };
  _proto.hexToRgb = function hexToRgb(h) {
    var r = 0,
      g = 0,
      b = 0;
    if (h.length == 4) {
      r = '0x' + h[1] + h[1];
      g = '0x' + h[2] + h[2];
      b = '0x' + h[3] + h[3];
    } else if (h.length == 7) {
      r = '0x' + h[1] + h[2];
      g = '0x' + h[3] + h[4];
      b = '0x' + h[5] + h[6];
    }
    return [parseInt(r), parseInt(g), parseInt(b)];
  };
  return DataVisualization;
}();

/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */
var Map = /*#__PURE__*/function () {
  function Map(options) {
    var _this = this;
    if (options === void 0) {
      options = {};
    }
    // Merge the given options with the default options
    this.params = merge(Map.defaults, options, true);

    // Throw an error if the given map name doesn't match
    // the map that was set in map file
    if (!Map.maps[this.params.map]) {
      throw new Error("Attempt to use map which was not loaded: " + options.map);
    }
    this.regions = {};
    this.scale = 1;
    this.transX = 0;
    this.transY = 0;
    this._mapData = Map.maps[this.params.map];
    this._markers = {};
    this._lines = {};
    this._defaultWidth = this._mapData.width;
    this._defaultHeight = this._mapData.height;
    this._height = 0;
    this._width = 0;
    this._baseScale = 1;
    this._baseTransX = 0;
    this._baseTransY = 0;

    // `document` is already ready, just initialise now
    if (document.readyState !== 'loading') {
      this._init();
    } else {
      // Wait until `document` is ready
      window.addEventListener('DOMContentLoaded', function () {
        return _this._init();
      });
    }
  }
  var _proto = Map.prototype;
  _proto._init = function _init() {
    var options = this.params;
    this.container = getElement(options.selector);
    this.container.classList.add('jvm-container');

    // The map canvas element
    this.canvas = new SVGCanvasElement(this.container);

    // Set the map's background color
    this.setBackgroundColor(options.backgroundColor);

    // Create regions
    this._createRegions();

    // Update size
    this.updateSize();

    // Create lines
    this._createLines(options.lines || {}, options.markers || {});

    // Create markers
    this._createMarkers(options.markers);

    // Position labels
    this._repositionLabels();

    // Setup the container events
    this._setupContainerEvents();

    // Setup regions/markers events
    this._setupElementEvents();

    // Create zoom buttons if `zoomButtons` is presented
    if (options.zoomButtons) {
      this._setupZoomButtons();
    }

    // Create toolip
    if (options.showTooltip) {
      this._tooltip = new Tooltip(this);
    }

    // Set selected regions if any
    if (options.selectedRegions) {
      this._setSelected('regions', options.selectedRegions);
    }

    // Set selected regions if any
    if (options.selectedMarkers) {
      this._setSelected('_markers', options.selectedMarkers);
    }

    // Set focus on a spcific region
    if (options.focusOn) {
      this.setFocus(options.focusOn);
    }

    // Data visualization
    if (options.visualizeData) {
      this.dataVisualization = new DataVisualization(options.visualizeData, this);
    }

    // Bind touch events if true
    if (options.bindTouchEvents) {
      if ('ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch) {
        this._setupContainerTouchEvents();
      }
    }

    // Create series if any
    if (options.series) {
      this.container.appendChild(this.legendHorizontal = createElement('div', 'jvm-series-container jvm-series-h'));
      this.container.appendChild(this.legendVertical = createElement('div', 'jvm-series-container jvm-series-v'));
      this._createSeries();
    }

    // Fire loaded event
    this._emit(Events.onLoaded, [this]);
  }

  // Public
  ;
  _proto.setBackgroundColor = function setBackgroundColor(color) {
    this.container.style.backgroundColor = color;
  }

  // Region methods
  ;
  _proto.getSelectedRegions = function getSelectedRegions() {
    return this._getSelected('regions');
  };
  _proto.clearSelectedRegions = function clearSelectedRegions(regions) {
    var _this2 = this;
    if (regions === void 0) {
      regions = undefined;
    }
    regions = this._normalizeRegions(regions) || this._getSelected('regions');
    regions.forEach(function (key) {
      _this2.regions[key].element.select(false);
    });
  };
  _proto.setSelectedRegions = function setSelectedRegions(regions) {
    this.clearSelectedRegions();
    this._setSelected('regions', this._normalizeRegions(regions));
  }

  // Markers methods
  ;
  _proto.getSelectedMarkers = function getSelectedMarkers() {
    return this._getSelected('_markers');
  };
  _proto.clearSelectedMarkers = function clearSelectedMarkers() {
    this._clearSelected('_markers');
  };
  _proto.addMarkers = function addMarkers(config) {
    config = Array.isArray(config) ? config : [config];
    this._createMarkers(config, true);
  };
  _proto.removeMarkers = function removeMarkers(markers) {
    var _this3 = this;
    if (!markers) {
      markers = Object.keys(this._markers);
    }
    markers.forEach(function (index) {
      // Remove the element from the DOM
      _this3._markers[index].element.remove();
      // Remove the element from markers object
      delete _this3._markers[index];
    });
  };
  _proto.addLine = function addLine(from, to, style) {
    if (style === void 0) {
      style = {};
    }
    console.warn('`addLine` method is deprecated, please use `addLines` instead.');
    this._createLines([{
      from: from,
      to: to,
      style: style
    }], this._markers, true);
  };
  _proto.addLines = function addLines(config) {
    var uids = this._getLinesAsUids();
    if (!Array.isArray(config)) {
      config = [config];
    }
    this._createLines(config.filter(function (line) {
      return !(uids.indexOf(getLineUid(line.from, line.to)) > -1);
    }), this._markers, true);
  };
  _proto.removeLines = function removeLines(lines) {
    var _this4 = this;
    if (Array.isArray(lines)) {
      lines = lines.map(function (line) {
        return getLineUid(line.from, line.to);
      });
    } else {
      lines = this._getLinesAsUids();
    }
    lines.forEach(function (uid) {
      _this4._lines[uid].dispose();
      delete _this4._lines[uid];
    });
  };
  _proto.removeLine = function removeLine(from, to) {
    console.warn('`removeLine` method is deprecated, please use `removeLines` instead.');
    var uid = getLineUid(from, to);
    if (this._lines.hasOwnProperty(uid)) {
      this._lines[uid].element.remove();
      delete this._lines[uid];
    }
  }

  // Reset map
  ;
  _proto.reset = function reset() {
    for (var key in this.series) {
      for (var i = 0; i < this.series[key].length; i++) {
        this.series[key][i].clear();
      }
    }
    if (this.legendHorizontal) {
      removeElement(this.legendHorizontal);
      this.legendHorizontal = null;
    }
    if (this.legendVertical) {
      removeElement(this.legendVertical);
      this.legendVertical = null;
    }
    this.scale = this._baseScale;
    this.transX = this._baseTransX;
    this.transY = this._baseTransY;
    this._applyTransform();
    this.clearSelectedMarkers();
    this.clearSelectedRegions();
    this.removeMarkers();
  }

  // Destroy the map
  ;
  _proto.destroy = function destroy(destroyInstance) {
    var _this5 = this;
    if (destroyInstance === void 0) {
      destroyInstance = true;
    }
    // Remove event registry
    EventHandler.flush();

    // Remove tooltip from DOM and memory
    this._tooltip.dispose();

    // Fire destroyed event
    this._emit(Events.onDestroyed);

    // Remove references
    if (destroyInstance) {
      Object.keys(this).forEach(function (key) {
        try {
          delete _this5[key];
        } catch (e) {}
      });
    }
  };
  _proto.extend = function extend(name, callback) {
    if (typeof this[name] === 'function') {
      throw new Error("The method [" + name + "] does already exist, please use another name.");
    }
    Map.prototype[name] = callback;
  }

  // Private
  ;
  _proto._emit = function _emit(eventName, args) {
    for (var event in Events) {
      if (Events[event] === eventName && typeof this.params[event] === 'function') {
        this.params[event].apply(this, args);
      }
    }
  }

  // Get selected markers/regions
  ;
  _proto._getSelected = function _getSelected(type) {
    var selected = [];
    for (var key in this[type]) {
      if (this[type][key].element.isSelected) {
        selected.push(key);
      }
    }
    return selected;
  };
  _proto._setSelected = function _setSelected(type, keys) {
    var _this6 = this;
    keys.forEach(function (key) {
      if (_this6[type][key]) {
        _this6[type][key].element.select(true);
      }
    });
  };
  _proto._clearSelected = function _clearSelected(type) {
    var _this7 = this;
    this._getSelected(type).forEach(function (key) {
      _this7[type][key].element.select(false);
    });
  };
  _proto._getLinesAsUids = function _getLinesAsUids() {
    return Object.keys(this._lines);
  };
  _proto._normalizeRegions = function _normalizeRegions(regions) {
    return typeof regions === 'string' ? [regions] : regions;
  };
  return Map;
}();
Map.maps = {};
Map.defaults = Defaults;
Object.assign(Map.prototype, core);

/**
 * jsVectorMap
 * Copyrights (c) Mustafa Omar https://github.com/themustafaomar
 * Released under the MIT License.
 */

/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */
var jsVectorMap = /*#__PURE__*/function () {
  function jsVectorMap(options) {
    if (options === void 0) {
      options = {};
    }
    if (!options.selector) {
      throw new Error('Selector is not given.');
    }
    return new Map(options);
  }

  // Public
  jsVectorMap.addMap = function addMap(name, map) {
    Map.maps[name] = map;
  };
  return jsVectorMap;
}();
var index = window.jsVectorMap = jsVectorMap;


/***/ }),

/***/ "./node_modules/jsvectormap/dist/maps/world.js":
/*!*****************************************************!*\
  !*** ./node_modules/jsvectormap/dist/maps/world.js ***!
  \*****************************************************/
/***/ (() => {

"use strict";


jsVectorMap.addMap("world", {
  insets: [{
    width: 900,
    top: 0,
    left: 0,
    height: 440.70631074413296,
    bbox: [{
      y: -12671671.123330014,
      x: -20004297.151525836
    }, {
      y: 6930392.025135122,
      x: 20026572.39474939
    }]
  }],
  paths: {
    BD: {
      path: "M651.84,230.21l-0.6,-2.0l-1.36,-1.71l-2.31,-0.11l-0.41,0.48l0.2,0.94l-0.53,0.99l-0.72,-0.36l-0.68,0.35l-1.2,-0.36l-0.37,-2.0l-0.81,-1.86l0.39,-1.46l-0.22,-0.47l-1.14,-0.53l0.29,-0.5l1.48,-0.94l0.03,-0.65l-1.55,-1.22l0.55,-1.14l1.61,0.94l1.04,0.15l0.18,1.54l0.34,0.35l5.64,0.63l-0.84,1.64l-1.22,0.34l-0.77,1.51l0.07,0.47l1.37,1.37l0.67,-0.19l0.42,-1.39l1.21,3.84l-0.03,1.21l-0.33,-0.15l-0.4,0.28Z",
      name: "Bangladesh"
    },
    BE: {
      path: "M429.29,144.05l1.91,0.24l2.1,-0.63l2.63,1.99l-0.21,1.66l-0.69,0.4l-0.18,1.2l-1.66,-1.13l-1.39,0.15l-2.73,-2.7l-1.17,-0.18l-0.16,-0.52l1.54,-0.5Z",
      name: "Belgium"
    },
    BF: {
      path: "M421.42,247.64l-0.11,0.95l0.34,1.16l1.4,1.71l0.07,1.1l0.32,0.37l2.55,0.51l-0.04,1.28l-0.38,0.53l-1.07,0.21l-0.72,1.18l-0.63,0.21l-3.22,-0.25l-0.94,0.39l-5.4,-0.05l-0.39,0.38l0.16,2.73l-1.23,-0.43l-1.17,0.1l-0.89,0.57l-2.27,-1.72l-0.13,-1.11l0.61,-0.96l0.02,-0.93l1.87,-1.98l0.44,-1.81l0.43,-0.39l1.28,0.26l1.05,-0.52l0.47,-0.73l1.84,-1.09l0.55,-0.83l2.2,-1.0l1.15,-0.3l0.72,0.45l1.13,-0.01Z",
      name: "Burkina Faso"
    },
    BG: {
      path: "M491.65,168.18l-0.86,0.88l-0.91,2.17l0.48,1.34l-1.6,-0.24l-2.55,0.95l-0.28,1.51l-1.8,0.22l-2.0,-1.0l-1.92,0.79l-1.42,-0.07l-0.15,-1.63l-1.05,-0.97l0.0,-0.8l1.2,-1.57l0.01,-0.56l-1.14,-1.23l-0.05,-0.94l0.88,0.97l0.88,-0.2l1.91,0.47l3.68,0.16l1.42,-0.81l2.72,-0.66l2.55,1.24Z",
      name: "Bulgaria"
    },
    BA: {
      path: "M463.49,163.65l2.1,0.5l1.72,-0.03l1.52,0.68l-0.36,0.78l0.08,0.45l1.04,1.02l-0.25,0.98l-1.81,1.15l-0.38,1.38l-1.67,-0.87l-0.89,-1.2l-2.11,-1.83l-1.63,-2.22l0.23,-0.57l0.48,0.38l0.55,-0.06l0.43,-0.51l0.94,-0.06Z",
      name: "Bosnia and Herz."
    },
    BN: {
      path: "M707.48,273.58l0.68,-0.65l1.41,-0.91l-0.15,1.63l-0.81,-0.05l-0.61,0.58l-0.53,-0.6Z",
      name: "Brunei"
    },
    BO: {
      path: "M263.83,340.69l-3.09,-0.23l-0.38,0.23l-0.7,1.52l-1.31,-1.53l-3.28,-0.64l-2.37,2.4l-1.31,0.26l-0.88,-3.26l-1.3,-2.86l0.74,-2.37l-0.13,-0.43l-1.2,-1.01l-0.37,-1.89l-1.08,-1.55l1.45,-2.56l-0.96,-2.33l0.47,-1.06l-0.34,-0.73l0.91,-1.32l0.16,-3.84l0.5,-1.18l-1.81,-3.41l2.46,0.07l0.8,-0.85l3.4,-1.91l2.66,-0.35l-0.19,1.38l0.3,1.07l-0.05,1.97l2.72,2.27l2.88,0.49l0.89,0.86l1.79,0.58l0.98,0.7l1.71,0.05l1.17,0.61l0.6,2.7l-0.7,0.54l0.96,2.99l0.37,0.28l4.3,0.1l-0.25,1.2l0.27,1.02l1.43,0.9l0.5,1.35l-0.41,1.86l-0.65,1.08l0.12,1.35l-2.69,-1.65l-2.4,-0.03l-4.36,0.76l-1.49,2.5l-0.11,1.52l-0.75,2.37Z",
      name: "Bolivia"
    },
    JP: {
      path: "M781.12,166.87l1.81,0.68l1.62,-0.97l0.39,2.42l-3.35,0.75l-2.23,2.88l-3.63,-1.9l-0.56,0.2l-1.26,3.05l-2.16,0.03l-0.29,-2.51l1.08,-2.03l2.45,-0.16l0.37,-0.33l1.25,-5.94l2.47,2.71l2.03,1.12ZM773.56,187.34l-0.91,2.22l0.37,1.52l-1.14,1.75l-3.02,1.26l-4.58,0.27l-3.34,3.01l-1.25,-0.8l-0.09,-1.9l-0.46,-0.38l-4.35,0.62l-3.0,1.32l-2.85,0.05l-0.37,0.27l0.13,0.44l2.32,1.89l-1.54,4.34l-1.26,0.9l-0.79,-0.7l0.56,-2.27l-0.21,-0.45l-1.47,-0.75l-0.74,-1.4l2.12,-0.84l1.26,-1.7l2.45,-1.42l1.83,-1.91l4.78,-0.81l2.6,0.57l0.44,-0.21l2.39,-4.66l1.29,1.06l0.5,0.01l5.1,-4.02l1.69,-3.73l-0.38,-3.4l0.9,-1.61l2.14,-0.44l1.23,3.72l-0.07,2.18l-2.23,2.84l-0.04,3.16ZM757.78,196.26l0.19,0.56l-1.01,1.21l-1.16,-0.68l-1.28,0.65l-0.69,1.45l-1.02,-0.5l0.01,-0.93l1.14,-1.38l1.57,0.14l0.85,-0.98l1.4,0.46Z",
      name: "Japan"
    },
    BI: {
      path: "M495.45,295.49l-1.08,-2.99l1.14,-0.11l0.64,-1.19l0.76,0.09l0.65,1.83l-2.1,2.36Z",
      name: "Burundi"
    },
    BJ: {
      path: "M429.57,255.75l-0.05,0.8l0.5,1.34l-0.42,0.86l0.17,0.79l-1.81,2.12l-0.57,1.76l-0.08,5.42l-1.41,0.2l-0.48,-1.36l0.11,-5.71l-0.52,-0.7l-0.2,-1.35l-1.48,-1.48l0.21,-0.9l0.89,-0.43l0.42,-0.92l1.27,-0.36l1.22,-1.34l0.61,-0.0l1.62,1.24Z",
      name: "Benin"
    },
    BT: {
      path: "M650.32,213.86l0.84,0.71l-0.12,1.1l-3.76,-0.11l-1.57,0.4l-1.93,-0.87l1.48,-1.96l1.13,-0.57l1.63,0.57l1.33,0.08l0.99,0.65Z",
      name: "Bhutan"
    },
    JM: {
      path: "M228.38,239.28l-0.8,0.4l-2.26,-1.06l0.84,-0.23l2.14,0.3l1.17,0.56l-1.08,0.03Z",
      name: "Jamaica"
    },
    BW: {
      path: "M483.92,330.07l2.27,4.01l2.83,2.86l0.96,0.31l0.78,2.43l2.13,0.61l1.02,0.76l-3.0,1.64l-2.32,2.02l-1.54,2.69l-1.52,0.45l-0.64,1.94l-1.34,0.52l-1.85,-0.12l-1.21,-0.74l-1.35,-0.3l-1.22,0.62l-0.75,1.37l-2.31,1.9l-1.4,0.21l-0.35,-0.59l0.16,-1.75l-1.48,-2.54l-0.62,-0.43l-0.0,-7.1l2.08,-0.08l0.39,-0.4l0.07,-8.9l5.19,-0.93l0.8,0.89l0.51,0.07l1.5,-0.95l2.21,-0.49Z",
      name: "Botswana"
    },
    BR: {
      path: "M259.98,275.05l3.24,0.7l0.65,-0.53l4.55,-1.32l1.08,-1.06l-0.02,-0.63l0.55,-0.05l0.28,0.28l-0.26,0.87l0.22,0.48l0.73,0.32l0.4,0.81l-0.62,0.86l-0.4,2.13l0.82,2.56l1.69,1.43l1.43,0.2l3.17,-1.68l3.18,0.3l0.65,-0.75l-0.27,-0.92l1.9,-0.09l2.39,0.99l1.06,-0.61l0.84,0.78l1.2,-0.18l1.18,-1.06l0.84,-1.94l1.36,-2.11l0.37,-0.05l1.89,5.45l1.33,0.59l0.05,1.28l-1.77,1.94l0.02,0.56l1.02,0.87l4.07,0.36l0.08,2.16l0.66,0.29l1.74,-1.5l6.97,2.32l1.02,1.22l-0.35,1.18l0.49,0.5l2.81,-0.74l4.77,1.3l3.75,-0.08l3.57,2.0l3.29,2.86l1.93,0.72l2.12,0.12l0.71,0.62l1.21,4.51l-0.95,3.98l-4.72,5.06l-1.64,2.92l-1.72,2.05l-0.8,0.3l-0.72,2.03l0.18,4.75l-0.94,5.53l-0.81,1.13l-0.43,3.36l-2.55,3.5l-0.4,2.51l-1.86,1.04l-0.67,1.53l-2.54,0.01l-3.94,1.01l-1.83,1.2l-2.87,0.82l-3.03,2.19l-2.2,2.83l-0.36,2.0l0.4,1.58l-0.44,2.6l-0.51,1.2l-1.77,1.54l-2.75,4.78l-3.83,3.42l-1.24,2.74l-1.18,1.15l-0.36,-0.83l0.95,-1.14l0.01,-0.5l-1.52,-1.97l-4.56,-3.32l-1.03,-0.0l-2.38,-2.02l-0.81,-0.0l5.34,-5.45l3.77,-2.58l0.22,-2.46l-1.35,-1.81l-0.91,0.07l0.58,-2.33l0.01,-1.54l-1.11,-0.83l-1.75,0.3l-0.44,-3.11l-0.52,-0.95l-1.88,-0.88l-1.24,0.47l-2.17,-0.41l0.15,-3.21l-0.62,-1.34l0.66,-0.73l-0.22,-1.34l0.66,-1.13l0.44,-2.04l-0.61,-1.83l-1.4,-0.86l-0.2,-0.75l0.34,-1.39l-0.38,-0.5l-4.52,-0.1l-0.72,-2.22l0.59,-0.42l-0.03,-1.1l-0.5,-0.87l-0.32,-1.7l-1.45,-0.76l-1.63,-0.02l-1.05,-0.72l-1.6,-0.48l-1.13,-0.99l-2.69,-0.4l-2.47,-2.06l0.13,-4.35l-0.45,-0.45l-3.46,0.5l-3.44,1.94l-0.6,0.74l-2.9,-0.17l-1.47,0.42l-0.72,-0.18l0.15,-3.52l-0.63,-0.34l-1.94,1.41l-1.87,-0.06l-0.83,-1.18l-1.37,-0.26l0.21,-1.01l-1.35,-1.49l-0.88,-1.91l0.56,-0.6l-0.0,-0.81l1.29,-0.62l0.22,-0.43l-0.22,-1.19l0.61,-0.91l0.15,-0.99l2.65,-1.58l1.99,-0.47l0.42,-0.36l2.06,0.11l0.42,-0.33l1.19,-8.0l-0.41,-1.56l-1.1,-1.0l0.01,-1.33l1.91,-0.42l0.08,-0.96l-0.33,-0.43l-1.14,-0.2l-0.02,-0.83l4.47,0.05l0.82,-0.67l0.82,1.81l0.8,0.07l1.15,1.1l2.26,-0.05l0.71,-0.83l2.78,-0.96l0.48,-1.13l1.6,-0.64l0.24,-0.47l-0.48,-0.82l-1.83,-0.19l-0.36,-3.22Z",
      name: "Brazil"
    },
    BS: {
      path: "M226.4,223.87l-0.48,-1.15l-0.84,-0.75l0.36,-1.11l0.95,1.95l0.01,1.06ZM225.56,216.43l-1.87,0.29l-0.04,-0.22l0.74,-0.14l1.17,0.06Z",
      name: "Bahamas"
    },
    BY: {
      path: "M493.84,128.32l0.29,0.7l0.49,0.23l1.19,-0.38l2.09,0.72l0.19,1.26l-0.45,1.24l1.57,2.26l0.89,0.59l0.17,0.81l1.58,0.56l0.4,0.5l-0.53,0.41l-1.87,-0.11l-0.73,0.38l-0.13,0.52l1.04,2.74l-1.91,0.26l-0.89,0.99l-0.11,1.18l-2.73,-0.04l-0.53,-0.62l-0.52,-0.08l-0.75,0.46l-0.91,-0.42l-1.92,-0.07l-2.75,-0.79l-2.6,-0.28l-2.0,0.07l-1.5,0.92l-0.67,0.07l-0.08,-1.22l-0.59,-1.19l1.36,-0.88l0.01,-1.35l-0.7,-1.41l-0.07,-1.0l2.16,-0.02l2.72,-1.3l0.75,-2.04l1.91,-1.04l0.2,-0.41l-0.19,-1.25l3.8,-1.78l2.3,0.77Z",
      name: "Belarus"
    },
    BZ: {
      path: "M198.03,244.38l0.1,-4.49l0.69,-0.06l0.74,-1.3l0.34,0.28l-0.4,1.3l0.17,0.58l-0.34,2.25l-1.3,1.42Z",
      name: "Belize"
    },
    RU: {
      path: "M491.55,115.25l2.55,-1.85l-0.01,-0.65l-2.2,-1.5l7.32,-6.76l1.03,-2.11l-0.13,-0.49l-3.46,-2.52l0.86,-2.7l-2.11,-2.81l1.56,-3.67l-2.77,-4.52l2.15,-2.99l-0.08,-0.55l-3.65,-2.73l0.3,-2.54l1.81,-0.37l4.26,-1.77l2.42,-1.45l4.06,2.61l6.79,1.04l9.34,4.85l1.78,1.88l0.14,2.46l-2.55,2.02l-3.9,1.06l-11.07,-3.14l-2.06,0.53l-0.13,0.7l3.94,2.94l0.31,5.86l0.26,0.36l5.14,2.24l0.58,-0.29l0.32,-1.94l-1.35,-1.78l1.13,-1.09l6.13,2.42l2.11,-0.98l0.18,-0.56l-1.51,-2.67l5.41,-3.76l2.07,0.22l2.26,1.41l0.57,-0.16l1.46,-2.87l-0.05,-0.44l-1.92,-2.32l1.12,-2.32l-1.32,-2.27l5.87,1.16l1.04,1.75l-2.59,0.43l-0.33,0.4l0.02,2.36l2.46,1.83l3.87,-0.91l0.86,-2.8l13.69,-5.65l0.99,0.11l-1.92,2.06l0.23,0.67l3.11,0.45l2.0,-1.48l4.56,-0.12l3.64,-1.73l2.65,2.44l0.56,-0.01l2.85,-2.88l-0.01,-0.57l-2.35,-2.29l0.9,-1.01l7.14,1.3l3.41,1.36l9.05,4.97l0.51,-0.11l1.67,-2.27l-0.05,-0.53l-2.43,-2.21l-0.06,-0.78l-0.34,-0.36l-2.52,-0.36l0.64,-1.93l-1.32,-3.46l-0.06,-1.21l4.48,-4.06l1.69,-4.29l1.6,-0.81l6.23,1.18l0.44,2.21l-2.29,3.64l0.06,0.5l1.47,1.39l0.76,3.0l-0.56,6.03l2.69,2.82l-0.96,2.57l-4.86,5.95l0.23,0.64l2.86,0.61l0.42,-0.17l0.93,-1.4l2.64,-1.03l0.87,-2.24l2.09,-1.96l0.07,-0.5l-1.36,-2.28l1.09,-2.69l-0.32,-0.55l-2.47,-0.33l-0.5,-2.06l1.94,-4.38l-0.06,-0.42l-2.96,-3.4l4.12,-2.88l0.16,-0.4l-0.51,-2.93l0.54,-0.05l1.13,2.25l-0.96,4.35l0.27,0.47l2.68,0.84l0.5,-0.51l-1.02,-2.99l3.79,-1.66l5.01,-0.24l4.53,2.61l0.48,-0.06l0.07,-0.48l-2.18,-3.82l-0.23,-4.67l3.98,-0.9l5.97,0.21l5.49,-0.64l0.27,-0.65l-1.83,-2.31l2.56,-2.9l2.87,-0.17l4.8,-2.47l6.54,-0.67l1.03,-1.42l6.25,-0.45l2.32,1.11l5.53,-2.7l4.5,0.08l0.39,-0.28l0.66,-2.15l2.26,-2.12l5.69,-2.11l3.21,1.29l-2.46,0.94l-0.25,0.42l0.34,0.35l5.41,0.77l0.61,2.33l0.58,0.25l2.2,-1.22l7.13,0.07l5.51,2.47l1.79,1.72l-0.53,2.24l-9.16,4.15l-1.97,1.52l0.16,0.71l6.77,1.91l2.16,-0.78l1.13,2.74l0.67,0.11l1.01,-1.15l3.81,-0.73l7.7,0.77l0.54,1.99l0.36,0.29l10.47,0.71l0.43,-0.38l0.13,-3.23l4.87,0.78l3.95,-0.02l3.83,2.4l1.03,2.71l-1.35,1.79l0.02,0.5l3.15,3.64l4.07,1.96l0.53,-0.18l2.23,-4.47l3.95,1.93l4.16,-1.21l4.73,1.39l2.05,-1.26l3.94,0.62l0.43,-0.55l-1.68,-4.02l2.89,-1.8l22.31,3.03l2.16,2.75l6.55,3.51l10.29,-0.81l4.82,0.73l1.85,1.66l-0.29,3.08l0.25,0.41l3.08,1.26l3.56,-0.88l4.35,-0.11l4.8,0.87l4.57,-0.47l4.23,3.79l0.43,0.07l3.1,-1.4l0.16,-0.6l-1.88,-2.62l0.85,-1.52l7.71,1.21l5.22,-0.26l7.09,2.09l9.59,5.22l6.35,4.11l-0.2,2.38l1.88,1.41l0.6,-0.42l-0.48,-2.53l6.15,0.57l4.4,3.51l-1.97,1.43l-4.0,0.41l-0.36,0.39l-0.06,3.79l-0.74,0.62l-2.07,-0.11l-1.91,-1.39l-3.14,-1.11l-0.78,-1.85l-2.72,-0.68l-2.63,0.49l-1.04,-1.1l0.46,-1.31l-0.5,-0.51l-3.0,0.98l-0.22,0.58l0.99,1.7l-1.21,1.48l-3.04,1.68l-3.12,-0.28l-0.4,0.23l0.09,0.46l2.2,2.09l1.46,3.2l1.15,1.1l0.24,1.33l-0.42,0.67l-4.63,-0.77l-6.96,2.9l-2.19,0.44l-7.6,5.06l-0.84,1.45l-3.61,-2.37l-6.24,2.82l-0.94,-1.15l-0.53,-0.08l-2.28,1.52l-3.2,-0.49l-0.44,0.27l-0.78,2.37l-3.05,3.78l0.09,1.47l0.29,0.36l2.54,0.72l-0.29,4.53l-1.97,0.11l-0.35,0.26l-1.07,2.94l0.8,1.45l-3.91,1.58l-1.05,3.95l-3.48,0.77l-0.3,0.3l-0.72,3.29l-3.09,2.65l-0.7,-1.74l-2.44,-12.44l1.16,-4.71l2.04,-2.06l0.22,-1.64l3.8,-0.86l4.46,-4.61l4.28,-3.81l4.48,-3.01l2.17,-5.63l-0.42,-0.54l-3.04,0.33l-1.77,3.31l-5.86,3.86l-1.86,-4.25l-0.45,-0.23l-6.46,1.3l-6.47,6.44l-0.01,0.55l1.58,1.74l-8.24,1.17l0.15,-2.2l-0.34,-0.42l-3.89,-0.56l-3.25,1.81l-7.62,-0.62l-8.45,1.19l-17.71,15.41l0.22,0.7l3.74,0.41l1.36,2.17l2.43,0.76l1.88,-1.68l2.4,0.2l3.4,3.54l0.08,2.6l-1.95,3.42l-0.21,3.9l-1.1,5.06l-3.71,4.54l-0.87,2.21l-8.29,8.89l-3.19,1.7l-1.32,0.03l-1.45,-1.36l-0.49,-0.04l-2.27,1.5l0.41,-3.65l-0.59,-2.47l1.75,-0.89l2.91,0.53l0.42,-0.2l1.68,-3.03l0.87,-3.46l0.97,-1.18l1.32,-2.88l-0.45,-0.56l-4.14,0.95l-2.19,1.25l-3.41,-0.0l-1.06,-2.93l-2.97,-2.3l-4.28,-1.06l-1.75,-5.07l-2.66,-5.01l-2.29,-1.29l-3.75,-1.01l-3.44,0.08l-3.18,0.62l-2.24,1.77l0.05,0.66l1.18,0.69l0.02,1.43l-1.33,1.05l-2.26,3.51l-0.04,1.43l-3.16,1.84l-2.82,-1.16l-3.01,0.23l-1.35,-1.07l-1.5,-0.35l-3.9,2.31l-3.22,0.52l-2.27,0.79l-3.05,-0.51l-2.21,0.03l-1.48,-1.6l-2.6,-1.63l-2.63,-0.43l-5.46,1.01l-3.23,-1.25l-0.72,-2.57l-5.2,-1.24l-2.75,-1.36l-0.5,0.12l-2.59,3.45l0.84,2.1l-2.06,1.93l-3.41,-0.77l-2.42,-0.12l-1.83,-1.54l-2.53,-0.05l-2.42,-0.98l-3.86,1.57l-4.72,2.78l-3.3,0.75l-1.55,-1.92l-3.0,0.41l-1.11,-1.33l-1.62,-0.59l-1.31,-1.94l-1.38,-0.6l-3.7,0.79l-3.31,-1.83l-0.51,0.11l-0.99,1.29l-5.29,-8.05l-2.96,-2.48l0.65,-0.77l0.01,-0.51l-0.5,-0.11l-6.2,3.21l-1.84,0.15l0.15,-1.39l-0.26,-0.42l-3.22,-1.17l-2.46,0.7l-0.69,-3.16l-0.32,-0.31l-4.5,-0.75l-2.47,1.47l-6.19,1.27l-1.29,0.86l-9.51,1.3l-1.15,1.17l-0.03,0.53l1.47,1.9l-1.89,0.69l-0.22,0.56l0.31,0.6l-2.11,1.44l0.03,0.68l3.75,2.12l-0.39,0.98l-3.23,-0.13l-0.86,0.86l-3.09,-1.59l-3.97,0.07l-2.66,1.35l-8.32,-3.56l-4.07,0.06l-5.39,3.68l-0.39,2.0l-2.03,-1.5l-0.59,0.13l-2.0,3.59l0.57,0.93l-1.28,2.16l0.06,0.48l2.13,2.17l1.95,0.04l1.37,1.82l-0.23,1.46l0.25,0.43l0.83,0.33l-0.8,1.31l-2.49,0.62l-2.49,3.2l0.0,0.49l2.17,2.78l-0.15,2.18l2.5,3.24l-1.58,1.59l-0.7,-0.13l-1.63,-1.72l-2.29,-0.84l-0.94,-1.31l-2.34,-0.63l-1.48,0.4l-0.43,-0.47l-3.51,-1.48l-5.76,-1.01l-0.45,0.19l-2.89,-2.34l-2.9,-1.2l-1.53,-1.29l1.29,-0.43l2.08,-2.61l-0.05,-0.55l-0.89,-0.79l3.05,-1.06l0.27,-0.42l-0.07,-0.69l-0.49,-0.35l-1.73,0.39l0.04,-0.68l1.04,-0.72l2.66,-0.48l0.4,-1.32l-0.5,-1.6l0.92,-1.54l0.03,-1.17l-0.29,-0.37l-3.69,-1.06l-1.41,0.02l-1.42,-1.41l-2.19,0.38l-2.77,-1.01l-0.03,-0.59l-0.89,-1.43l-2.0,-0.32l-0.11,-0.54l0.49,-0.53l0.01,-0.53l-1.6,-1.9l-3.58,0.02l-0.88,0.73l-0.46,-0.07l-1.0,-2.79l2.22,-0.02l0.97,-0.74l0.07,-0.57l-0.9,-1.04l-1.35,-0.48l-0.11,-0.7l-0.95,-0.58l-1.38,-1.99l0.46,-0.98l-0.51,-1.96l-2.45,-0.84l-1.21,0.3l-0.46,-0.76l-2.46,-0.83l-0.72,-1.87l-0.21,-1.69l-0.99,-0.85l0.85,-1.17l-0.7,-3.21l1.66,-1.97l-0.16,-0.79ZM749.2,170.72l-0.6,0.4l-0.13,0.16l-0.01,-0.51l0.74,-0.05ZM874.85,67.94l-5.63,0.48l-0.26,-0.84l3.15,-1.89l1.94,0.01l3.19,1.16l-2.39,1.09ZM797.39,48.49l-2.0,1.36l-3.8,-0.42l-4.25,-1.8l0.35,-0.97l9.69,1.83ZM783.67,46.12l-1.63,3.09l-8.98,-0.13l-4.09,1.14l-4.54,-2.97l1.16,-3.01l3.05,-0.89l6.5,0.22l8.54,2.56ZM778.2,134.98l-0.56,-0.9l0.27,-0.12l0.29,1.01ZM778.34,135.48l0.94,3.53l-0.05,3.38l1.05,3.39l2.18,5.0l-2.89,-0.83l-0.49,0.26l-1.54,4.65l2.42,3.5l-0.04,1.13l-1.24,-1.24l-0.61,0.06l-1.09,1.61l-0.28,-1.61l0.27,-3.1l-0.28,-3.4l0.58,-2.47l0.11,-4.39l-1.46,-3.36l0.21,-4.32l2.15,-1.46l0.07,-0.34ZM771.95,56.61l1.76,-1.42l2.89,-0.42l3.28,1.71l0.14,0.6l-3.27,0.03l-4.81,-0.5ZM683.76,31.09l-13.01,1.93l4.03,-6.35l1.82,-0.56l1.73,0.34l5.99,2.98l-0.56,1.66ZM670.85,27.93l-5.08,0.64l-6.86,-1.57l-3.99,-2.05l-2.1,-4.16l-2.6,-0.87l5.72,-3.5l5.2,-1.28l4.69,2.85l5.59,5.4l-0.56,4.53ZM564.15,68.94l-0.64,0.17l-7.85,-0.57l-0.86,-2.04l-4.28,-1.17l-0.28,-1.94l2.27,-0.89l0.25,-0.39l-0.08,-2.38l4.81,-3.97l-0.15,-0.7l-1.47,-0.38l5.3,-3.81l0.15,-0.44l-0.58,-1.94l5.28,-2.51l8.21,-3.27l8.28,-0.96l4.35,-1.94l4.6,-0.64l1.36,1.61l-1.34,1.28l-16.43,4.94l-7.97,4.88l-7.74,9.63l0.66,4.14l4.16,3.27ZM548.81,18.48l-5.5,1.18l-0.58,1.02l-2.59,0.84l-2.13,-1.07l1.12,-1.42l-0.3,-0.65l-2.33,-0.07l1.68,-0.36l3.47,-0.06l0.42,1.29l0.66,0.16l1.38,-1.34l2.15,-0.88l2.94,1.01l-0.39,0.36ZM477.37,133.15l-4.08,0.05l-2.56,-0.32l0.33,-0.87l3.17,-1.03l3.24,0.96l-0.09,1.23Z",
      name: "Russia"
    },
    RW: {
      path: "M497.0,288.25l0.71,1.01l-0.11,1.09l-1.63,0.03l-1.04,1.39l-0.83,-0.11l0.51,-1.2l0.08,-1.34l0.42,-0.41l0.7,0.14l1.19,-0.61Z",
      name: "Rwanda"
    },
    RS: {
      path: "M469.4,163.99l0.42,-0.5l-0.01,-0.52l-1.15,-1.63l1.43,-0.62l1.33,0.12l1.17,1.06l0.46,1.13l1.34,0.64l0.35,1.35l1.46,0.9l0.76,-0.29l0.2,0.69l-0.48,0.78l0.22,1.12l1.05,1.22l-0.77,0.8l-0.37,1.52l-1.21,0.08l0.24,-0.64l-0.39,-0.54l-2.08,-1.64l-0.9,0.05l-0.48,0.94l-2.12,-1.37l0.53,-1.6l-1.11,-1.37l0.51,-1.1l-0.41,-0.57Z",
      name: "Serbia"
    },
    LT: {
      path: "M486.93,129.3l0.17,1.12l-1.81,0.98l-0.72,2.02l-2.47,1.18l-2.1,-0.02l-0.73,-1.05l-1.06,-0.3l-0.09,-1.87l-3.56,-1.13l-0.43,-2.36l2.48,-0.94l4.12,0.22l2.25,-0.31l0.52,0.69l1.24,0.21l2.19,1.56Z",
      name: "Lithuania"
    },
    LU: {
      path: "M436.08,149.45l-0.48,-0.07l0.3,-1.28l0.27,0.4l-0.09,0.96Z",
      name: "Luxembourg"
    },
    LR: {
      path: "M399.36,265.97l0.18,1.54l-0.48,0.99l0.08,0.47l2.47,1.8l-0.33,2.8l-2.65,-1.13l-5.78,-4.61l0.58,-1.32l2.1,-2.33l0.86,-0.22l0.77,1.14l-0.14,0.85l0.59,0.87l1.0,0.14l0.76,-0.99Z",
      name: "Liberia"
    },
    RO: {
      path: "M487.53,154.23l0.6,0.24l2.87,3.98l-0.17,2.69l0.45,1.42l1.32,0.81l1.35,-0.42l0.76,0.36l0.02,0.31l-0.83,0.45l-0.59,-0.22l-0.54,0.3l-0.62,3.3l-1.0,-0.22l-2.07,-1.13l-2.95,0.71l-1.25,0.76l-3.51,-0.15l-1.89,-0.47l-0.87,0.16l-0.82,-1.3l0.29,-0.26l-0.06,-0.64l-1.09,-0.34l-0.56,0.5l-1.05,-0.64l-0.39,-1.39l-1.36,-0.65l-0.35,-1.0l-0.83,-0.75l1.54,-0.54l2.66,-4.21l2.4,-1.24l2.96,0.34l1.48,0.73l0.79,-0.45l1.78,-0.3l0.75,-0.74l0.79,0.0Z",
      name: "Romania"
    },
    GW: {
      path: "M386.23,253.6l-0.29,0.84l0.15,0.6l-2.21,0.59l-0.86,0.96l-1.04,-0.83l-1.09,-0.23l-0.54,-1.06l-0.66,-0.49l2.41,-0.48l4.13,0.1Z",
      name: "Guinea-Bissau"
    },
    GT: {
      path: "M195.08,249.77l-2.48,-0.37l-1.03,-0.45l-1.14,-0.89l0.3,-0.99l-0.24,-0.68l0.96,-1.66l2.98,-0.01l0.4,-0.37l-0.19,-1.28l-1.67,-1.4l0.51,-0.4l0.0,-1.05l3.85,0.02l-0.21,4.53l0.4,0.43l1.46,0.38l-1.48,0.98l-0.35,0.7l0.12,0.57l-2.2,1.96Z",
      name: "Guatemala"
    },
    GR: {
      path: "M487.07,174.59l-0.59,1.43l-0.37,0.21l-2.84,-0.35l-3.03,0.77l-0.18,0.68l1.28,1.23l-0.61,0.23l-1.14,0.0l-1.2,-1.39l-0.63,0.03l-0.53,1.01l0.56,1.76l1.03,1.19l-0.56,0.38l-0.05,0.62l2.52,2.12l0.02,0.87l-1.78,-0.59l-0.48,0.56l0.5,1.0l-1.07,0.2l-0.3,0.53l0.75,2.01l-0.98,0.02l-1.84,-1.12l-1.37,-4.2l-2.21,-2.95l-0.11,-0.56l1.04,-1.28l0.2,-0.95l0.85,-0.66l0.03,-0.46l1.32,-0.21l1.01,-0.64l1.22,0.05l0.65,-0.56l2.26,-0.0l1.82,-0.75l1.85,1.0l2.28,-0.28l0.35,-0.39l0.01,-0.77l0.34,0.22ZM480.49,192.16l0.58,0.4l-0.68,-0.12l0.11,-0.28ZM482.52,192.82l2.51,0.06l0.24,0.32l-1.99,0.13l-0.77,-0.51Z",
      name: "Greece"
    },
    GQ: {
      path: "M448.79,279.62l0.02,2.22l-4.09,0.0l0.69,-2.27l3.38,0.05Z",
      name: "Eq. Guinea"
    },
    GY: {
      path: "M277.42,270.07l-0.32,1.83l-1.32,0.57l-0.23,0.46l-0.28,2.0l1.11,1.82l0.83,0.19l0.32,1.25l1.13,1.62l-1.21,-0.19l-1.08,0.71l-1.77,0.5l-0.44,0.46l-0.86,-0.09l-1.32,-1.01l-0.77,-2.27l0.36,-1.9l0.68,-1.23l-0.57,-1.17l-0.74,-0.43l0.12,-1.16l-0.9,-0.69l-1.1,0.09l-1.31,-1.48l0.53,-0.72l-0.04,-0.84l1.99,-0.86l0.05,-0.59l-0.71,-0.78l0.14,-0.57l1.66,-1.24l1.36,0.77l1.41,1.49l0.06,1.15l0.37,0.38l0.8,0.05l2.06,1.86Z",
      name: "Guyana"
    },
    GE: {
      path: "M521.71,168.93l5.29,0.89l4.07,2.01l1.41,-0.44l2.07,0.56l0.68,1.1l1.07,0.55l-0.12,0.59l0.98,1.29l-1.01,-0.13l-1.81,-0.83l-0.94,0.47l-3.23,0.43l-2.29,-1.39l-2.33,0.05l0.21,-0.97l-0.76,-2.26l-1.45,-1.12l-1.43,-0.39l-0.41,-0.42Z",
      name: "Georgia"
    },
    GB: {
      path: "M412.61,118.72l-2.19,3.22l-0.0,0.45l5.13,-0.3l-0.53,2.37l-2.2,3.12l0.29,0.63l2.37,0.21l2.33,4.3l1.76,0.69l2.2,5.12l2.94,0.77l-0.23,1.62l-1.15,0.88l-0.1,0.52l0.82,1.42l-1.86,1.43l-3.3,-0.02l-4.12,0.87l-1.04,-0.58l-0.47,0.06l-1.51,1.41l-2.12,-0.34l-1.86,1.18l-0.6,-0.29l3.19,-3.0l2.16,-0.69l0.28,-0.41l-0.34,-0.36l-3.73,-0.53l-0.4,-0.76l2.2,-0.87l0.17,-0.61l-1.26,-1.67l0.36,-1.7l3.38,0.28l0.43,-0.33l0.37,-1.99l-1.79,-2.49l-3.11,-0.72l-0.38,-0.59l0.79,-1.35l-0.04,-0.46l-0.82,-0.97l-0.61,0.01l-0.68,0.84l-0.1,-2.34l-1.23,-1.88l0.85,-3.47l1.77,-2.68l1.85,0.26l2.17,-0.22ZM406.26,132.86l-1.01,1.77l-1.57,-0.59l-1.16,0.01l0.37,-1.54l-0.39,-1.39l1.45,-0.1l2.3,1.84Z",
      name: "United Kingdom"
    },
    GA: {
      path: "M453.24,279.52l-0.08,0.98l0.7,1.29l2.36,0.24l-0.98,2.63l1.18,1.79l0.25,1.78l-0.29,1.52l-0.6,0.93l-1.84,-0.09l-1.23,-1.11l-0.66,0.23l-0.15,0.84l-1.42,0.26l-1.02,0.7l-0.11,0.52l0.77,1.35l-1.34,0.97l-3.94,-4.3l-1.44,-2.45l0.06,-0.6l0.54,-0.81l1.05,-3.46l4.17,-0.07l0.4,-0.4l-0.02,-2.66l2.39,0.21l1.25,-0.27Z",
      name: "Gabon"
    },
    GN: {
      path: "M391.8,254.11l0.47,0.8l1.11,-0.32l0.98,0.7l1.07,0.2l2.26,-1.22l0.64,0.44l1.13,1.56l-0.48,1.4l0.8,0.3l-0.08,0.48l0.46,0.68l-0.35,1.36l1.05,2.61l-1.0,0.69l0.03,1.41l-0.72,-0.06l-1.08,1.0l-0.24,-0.27l0.07,-1.11l-1.05,-1.54l-1.79,0.21l-0.35,-2.01l-1.6,-2.18l-2.0,-0.0l-1.31,0.54l-1.95,2.18l-1.86,-2.19l-1.2,-0.78l-0.3,-1.11l-0.8,-0.85l0.65,-0.72l0.81,-0.03l1.64,-0.8l0.23,-1.87l2.67,0.64l0.89,-0.3l1.21,0.15Z",
      name: "Guinea"
    },
    GM: {
      path: "M379.31,251.39l0.1,-0.35l2.43,-0.07l0.74,-0.61l0.51,-0.03l0.77,0.49l-1.03,-0.3l-1.87,0.9l-1.65,-0.04ZM384.03,250.91l0.91,0.05l0.75,-0.24l-0.59,0.31l-1.08,-0.13Z",
      name: "Gambia"
    },
    GL: {
      path: "M353.02,1.2l14.69,4.67l-3.68,1.89l-22.97,0.86l-0.36,0.27l0.12,0.43l1.55,1.18l8.79,-0.66l7.48,2.07l4.86,-1.77l1.66,1.73l-2.53,3.19l-0.01,0.48l0.46,0.15l6.35,-2.2l12.06,-2.31l7.24,1.13l1.09,1.99l-9.79,4.01l-1.44,1.32l-7.87,0.98l-0.35,0.41l0.38,0.38l5.07,0.24l-2.53,3.58l-2.07,3.81l0.08,6.05l2.57,3.11l-3.22,0.2l-4.12,1.66l-0.05,0.72l4.45,2.65l0.51,3.75l-2.3,0.4l-0.25,0.64l2.79,3.69l-4.82,0.31l-0.36,0.29l0.16,0.44l2.62,1.8l-0.59,1.22l-3.3,0.7l-3.45,0.01l-0.29,0.68l3.03,3.12l0.02,1.34l-4.4,-1.73l-1.72,1.35l0.15,0.66l3.31,1.15l3.13,2.71l0.81,3.16l-3.85,0.75l-4.89,-4.26l-0.47,-0.03l-0.17,0.44l0.79,2.86l-2.71,2.21l-0.13,0.44l0.37,0.27l8.73,0.34l-12.32,6.64l-7.24,1.48l-2.94,0.08l-2.69,1.75l-3.43,4.41l-5.24,2.84l-1.73,0.18l-7.12,2.1l-2.15,2.52l-0.13,2.99l-1.19,2.45l-4.01,3.09l-0.14,0.44l0.97,2.9l-2.28,6.48l-3.1,0.2l-3.83,-3.07l-4.86,-0.02l-2.25,-1.93l-1.7,-3.79l-4.3,-4.84l-1.21,-2.49l-0.44,-3.8l-3.32,-3.63l0.84,-2.86l-1.56,-1.7l2.28,-4.6l3.83,-1.74l1.03,-1.96l0.52,-3.47l-0.59,-0.41l-4.17,2.21l-2.07,0.58l-2.72,-1.28l-0.15,-2.71l0.85,-2.09l2.01,-0.06l5.06,1.2l0.46,-0.23l-0.14,-0.49l-6.54,-4.47l-2.67,0.55l-1.58,-0.86l2.56,-4.01l-0.03,-0.48l-1.5,-1.74l-4.98,-8.5l-3.13,-1.96l0.03,-1.88l-0.24,-0.37l-6.85,-3.02l-5.36,-0.38l-12.7,0.58l-2.78,-1.57l-3.66,-2.77l5.73,-1.45l5.0,-0.28l0.38,-0.38l-0.35,-0.41l-10.67,-1.38l-5.3,-2.06l0.25,-1.54l18.41,-5.26l1.22,-2.27l-0.25,-0.55l-6.14,-1.86l1.68,-1.77l8.55,-4.03l3.59,-0.63l0.3,-0.54l-0.88,-2.27l5.47,-1.47l7.65,-0.95l7.55,-0.05l3.04,1.85l6.48,-3.27l5.81,2.22l3.56,0.5l5.16,1.94l0.5,-0.21l-0.17,-0.52l-5.71,-3.13l0.28,-2.13l8.12,-3.6l8.7,0.28l3.35,-2.34l8.71,-0.6l19.93,0.8Z",
      name: "Greenland"
    },
    KW: {
      path: "M540.81,207.91l0.37,0.86l-0.17,0.76l0.6,1.53l-0.95,0.04l-0.82,-1.28l-1.57,-0.18l1.31,-1.88l1.22,0.17Z",
      name: "Kuwait"
    },
    GH: {
      path: "M420.53,257.51l-0.01,0.72l0.96,1.2l0.24,3.73l0.59,0.95l-0.51,2.1l0.19,1.41l1.02,2.21l-6.97,2.84l-1.8,-0.57l0.04,-0.89l-1.02,-2.04l0.61,-2.65l1.07,-2.32l-0.96,-6.47l5.01,0.07l0.94,-0.39l0.61,0.11Z",
      name: "Ghana"
    },
    OM: {
      path: "M568.09,230.93l-0.91,1.67l-1.22,0.04l-0.6,0.76l-0.41,1.51l0.27,1.58l-1.16,0.05l-1.56,0.97l-0.76,1.74l-1.62,0.05l-0.98,0.65l-0.17,1.15l-0.89,0.52l-1.49,-0.18l-2.4,0.94l-2.47,-5.4l7.35,-2.71l1.67,-5.23l-1.12,-2.09l0.05,-0.83l0.67,-1.0l0.07,-1.05l0.9,-0.42l-0.05,-2.07l0.7,-0.01l1.0,1.62l1.51,1.08l3.3,0.84l1.73,2.29l0.81,0.37l-1.23,2.35l-0.99,0.79Z",
      name: "Oman"
    },
    _2: {
      path: "M531.15,258.94l1.51,0.12l5.13,-0.95l5.3,-1.48l-0.01,4.4l-2.67,3.39l-1.85,0.01l-8.04,-2.94l-2.55,-3.17l1.12,-1.71l2.04,2.34Z",
      name: "Somaliland"
    },
    _1: {
      path: "M472.77,172.64l-1.08,-1.29l0.96,-0.77l0.29,-0.83l1.98,1.64l-0.36,0.67l-1.79,0.58Z",
      name: "Kosovo"
    },
    _0: {
      path: "M504.91,192.87l0.34,0.01l0.27,-0.07l-0.29,0.26l-0.31,-0.2Z",
      name: "N. Cyprus"
    },
    JO: {
      path: "M518.64,201.38l-5.14,1.56l-0.19,0.65l2.16,2.39l-0.89,1.14l-1.71,0.34l-1.71,1.8l-2.34,-0.37l1.21,-4.32l0.56,-4.07l2.8,0.94l4.46,-2.71l0.79,2.66Z",
      name: "Jordan"
    },
    HR: {
      path: "M455.59,162.84l1.09,0.07l-0.82,0.94l-0.27,-1.01ZM456.96,162.92l0.62,-0.41l1.73,0.45l0.42,-0.4l-0.01,-0.59l0.86,-0.52l0.2,-1.05l1.63,-0.68l2.57,1.68l2.07,0.6l0.87,-0.31l1.05,1.57l-0.52,0.63l-1.05,-0.56l-1.68,0.04l-2.1,-0.5l-1.29,0.06l-0.57,0.49l-0.59,-0.47l-0.62,0.16l-0.46,1.7l1.79,2.42l2.79,2.75l-1.18,-0.87l-2.21,-0.87l-1.67,-1.78l0.13,-0.63l-1.05,-1.19l-0.32,-1.27l-1.42,-0.43Z",
      name: "Croatia"
    },
    HT: {
      path: "M237.05,238.38l-1.16,0.43l-0.91,-0.55l0.05,-0.2l2.02,0.31ZM237.53,238.43l1.06,0.12l-0.05,0.01l-1.01,-0.12ZM239.25,238.45l0.79,-0.51l0.06,-0.62l-1.02,-1.0l0.02,-0.82l-0.3,-0.4l-0.93,-0.32l3.16,0.45l0.02,1.84l-0.48,0.34l-0.08,0.58l0.54,0.72l-1.78,-0.26Z",
      name: "Haiti"
    },
    HU: {
      path: "M462.08,157.89l0.65,-1.59l-0.09,-0.44l0.64,-0.0l0.39,-0.34l0.1,-0.69l1.75,0.87l2.32,-0.37l0.43,-0.66l3.49,-0.78l0.69,-0.78l0.57,-0.14l2.57,0.93l0.67,-0.23l1.03,0.65l0.08,0.37l-1.42,0.71l-2.59,4.14l-1.8,0.53l-1.68,-0.1l-2.74,1.23l-1.85,-0.54l-2.54,-1.66l-0.66,-1.1Z",
      name: "Hungary"
    },
    HN: {
      path: "M199.6,249.52l-1.7,-1.21l0.06,-0.94l3.04,-2.14l2.37,0.28l1.27,-0.09l1.1,-0.52l1.3,0.28l1.14,-0.25l1.38,0.37l2.23,1.37l-2.36,0.93l-1.23,-0.39l-0.88,1.3l-1.28,0.99l-0.98,-0.22l-0.42,0.52l-0.96,0.05l-0.36,0.41l0.04,0.88l-0.52,0.6l-0.3,0.04l-0.3,-0.55l-0.66,-0.31l0.11,-0.67l-0.48,-0.65l-0.87,-0.26l-0.73,0.2Z",
      name: "Honduras"
    },
    PR: {
      path: "M256.17,238.73l-0.26,0.27l-2.83,0.05l-0.07,-0.55l1.95,-0.1l1.22,0.33Z",
      name: "Puerto Rico"
    },
    PS: {
      path: "M509.21,203.07l0.1,-0.06l-0.02,0.03l-0.09,0.03ZM509.36,202.91l-0.02,-0.63l-0.33,-0.16l0.31,-1.09l0.24,0.1l-0.2,1.78Z",
      name: "Palestine"
    },
    PT: {
      path: "M401.84,187.38l-0.64,0.47l-1.13,-0.35l-0.91,0.17l0.28,-1.78l-0.24,-1.78l-1.25,-0.56l-0.45,-0.84l0.17,-1.66l1.01,-1.18l0.69,-2.92l-0.04,-1.39l-0.59,-1.9l1.3,-0.85l0.84,1.35l3.1,-0.3l0.46,0.99l-1.05,0.94l-0.03,2.16l-0.41,0.57l-0.08,1.1l-0.79,0.18l-0.26,0.59l0.91,1.6l-0.63,1.75l0.76,1.09l-1.1,1.52l0.07,1.05Z",
      name: "Portugal"
    },
    PY: {
      path: "M274.9,336.12l0.74,1.52l-0.16,3.45l0.32,0.41l2.64,0.5l1.11,-0.47l1.4,0.59l0.36,0.6l0.53,3.42l1.27,0.4l0.98,-0.38l0.51,0.27l-0.0,1.18l-1.21,5.32l-2.09,1.9l-1.8,0.4l-4.71,-0.98l2.2,-3.63l-0.32,-1.5l-2.78,-1.28l-3.03,-1.94l-2.07,-0.44l-4.34,-4.06l0.91,-2.9l0.08,-1.42l1.07,-2.04l4.13,-0.72l2.18,0.03l2.05,1.17l0.03,0.59Z",
      name: "Paraguay"
    },
    PA: {
      path: "M213.8,263.68l0.26,-1.52l-0.36,-0.26l-0.01,-0.49l0.44,-0.1l0.93,1.4l1.26,0.03l0.77,0.49l1.38,-0.23l2.51,-1.11l0.86,-0.72l3.45,0.85l1.4,1.18l0.41,1.74l-0.21,0.34l-0.53,-0.12l-0.47,0.29l-0.16,0.6l-0.68,-1.28l0.45,-0.49l-0.19,-0.66l-0.47,-0.13l-0.54,-0.84l-1.5,-0.75l-1.1,0.16l-0.75,0.99l-1.62,0.84l-0.18,0.96l0.85,0.97l-0.58,0.45l-0.69,0.08l-0.34,-1.18l-1.27,0.03l-0.71,-1.05l-2.59,-0.46Z",
      name: "Panama"
    },
    PG: {
      path: "M808.58,298.86l2.54,2.56l-0.13,0.26l-0.33,0.12l-0.87,-0.78l-1.22,-2.16ZM801.41,293.04l0.5,0.29l0.26,0.27l-0.49,-0.35l-0.27,-0.21ZM803.17,294.58l0.59,0.5l0.08,1.06l-0.29,-0.91l-0.38,-0.65ZM796.68,298.41l0.52,0.75l1.43,-0.19l2.27,-1.81l-0.01,-1.43l1.12,0.16l-0.04,1.1l-0.7,1.28l-1.12,0.18l-0.62,0.79l-2.46,1.11l-1.17,-0.0l-3.08,-1.25l3.41,0.0l0.45,-0.68ZM789.15,303.55l2.31,1.8l1.59,2.61l1.34,0.13l-0.06,0.66l0.31,0.43l1.06,0.24l0.06,0.65l2.25,1.05l-1.22,0.13l-0.72,-0.63l-4.56,-0.65l-3.22,-2.87l-1.49,-2.34l-3.27,-1.1l-2.38,0.72l-1.59,0.86l-0.2,0.42l0.27,1.55l-1.55,0.68l-1.36,-0.4l-2.21,-0.09l-0.08,-15.41l8.39,2.93l2.95,2.4l0.6,1.64l4.02,1.49l0.31,0.68l-1.76,0.21l-0.33,0.52l0.55,1.68Z",
      name: "Papua New Guinea"
    },
    PE: {
      path: "M244.96,295.21l-1.26,-0.07l-0.57,0.42l-1.93,0.45l-2.98,1.75l-0.36,1.36l-0.58,0.8l0.12,1.37l-1.24,0.59l-0.22,1.22l-0.62,0.84l1.04,2.27l1.28,1.44l-0.41,0.84l0.32,0.57l1.48,0.13l1.16,1.37l2.21,0.07l1.63,-1.08l-0.13,3.02l0.3,0.4l1.14,0.29l1.31,-0.34l1.9,3.59l-0.48,0.85l-0.17,3.85l-0.94,1.59l0.35,0.75l-0.47,1.07l0.98,1.97l-2.1,3.82l-0.98,0.5l-2.17,-1.28l-0.39,-1.16l-4.95,-2.58l-4.46,-2.79l-1.84,-1.51l-0.91,-1.84l0.3,-0.96l-2.11,-3.33l-4.82,-9.68l-1.04,-1.2l-0.87,-1.94l-3.4,-2.48l0.58,-1.18l-1.13,-2.23l0.66,-1.49l1.45,-1.15l-0.6,0.98l0.07,0.92l0.47,0.36l1.74,0.03l0.97,1.17l0.54,0.07l1.42,-1.03l0.6,-1.84l1.42,-2.02l3.04,-1.04l2.73,-2.62l0.86,-1.74l-0.1,-1.87l1.44,1.02l0.9,1.25l1.06,0.59l1.7,2.73l1.86,0.31l1.45,-0.61l0.96,0.39l1.36,-0.19l1.45,0.89l-1.4,2.21l0.31,0.61l0.59,0.05l0.47,0.5Z",
      name: "Peru"
    },
    PK: {
      path: "M615.09,192.34l-1.83,1.81l-2.6,0.39l-3.73,-0.68l-1.58,1.33l-0.09,0.42l1.77,4.39l1.7,1.23l-1.69,1.27l-0.12,2.14l-2.33,2.64l-1.6,2.8l-2.46,2.67l-3.03,-0.07l-2.76,2.83l0.05,0.6l1.5,1.11l0.26,1.9l1.44,1.5l0.37,1.68l-5.01,-0.01l-1.78,1.7l-1.42,-0.52l-0.76,-1.87l-2.27,-2.15l-11.61,0.86l0.71,-2.34l3.43,-1.32l0.25,-0.44l-0.21,-1.24l-1.2,-0.65l-0.28,-2.46l-2.29,-1.14l-1.28,-1.94l2.82,0.94l2.62,-0.38l1.42,0.33l0.76,-0.56l1.71,0.19l3.25,-1.14l0.27,-0.36l0.08,-2.19l1.18,-1.32l1.68,0.0l0.58,-0.82l1.6,-0.3l1.19,0.16l0.98,-0.78l0.02,-1.88l0.93,-1.47l1.48,-0.66l0.19,-0.55l-0.66,-1.25l2.04,-0.11l0.69,-1.01l-0.02,-1.16l1.11,-1.06l-0.17,-1.78l-0.49,-1.03l1.15,-0.98l5.42,-0.91l2.6,-0.82l1.6,1.16l0.97,2.34l3.45,0.97Z",
      name: "Pakistan"
    },
    PH: {
      path: "M737.01,263.84l0.39,2.97l-0.44,1.18l-0.55,-1.53l-0.67,-0.14l-1.17,1.28l0.65,2.09l-0.42,0.69l-2.48,-1.23l-0.57,-1.49l0.65,-1.03l-0.1,-0.54l-1.59,-1.19l-0.56,0.08l-0.65,0.87l-1.23,0.0l-1.58,0.97l0.83,-1.8l2.56,-1.42l0.65,0.84l0.45,0.13l1.9,-0.69l0.56,-1.11l1.5,-0.06l0.38,-0.43l-0.09,-1.19l1.21,0.71l0.36,2.02ZM733.59,256.58l0.05,0.75l0.08,0.26l-0.8,-0.42l-0.18,-0.71l0.85,0.12ZM734.08,256.1l-0.12,-1.12l-1.0,-1.27l1.36,0.03l0.53,0.73l0.51,2.04l-1.27,-0.4ZM733.76,257.68l0.38,0.98l-0.32,0.15l-0.07,-1.13ZM724.65,238.43l1.46,0.7l0.72,-0.31l-0.32,1.17l0.79,1.71l-0.57,1.84l-1.53,1.04l-0.39,2.25l0.56,2.04l1.63,0.57l1.16,-0.27l2.71,1.23l-0.19,1.08l0.76,0.84l-0.08,0.36l-1.4,-0.9l-0.88,-1.27l-0.66,0.0l-0.38,0.55l-1.6,-1.31l-2.15,0.36l-0.87,-0.39l0.07,-0.61l0.66,-0.55l-0.01,-0.62l-0.75,-0.59l-0.72,0.44l-0.74,-0.87l-0.39,-2.49l0.32,0.27l0.66,-0.28l0.26,-3.97l0.7,-2.02l1.14,0.0ZM731.03,258.87l-0.88,0.85l-1.19,1.94l-1.05,-1.19l0.93,-1.1l0.32,-1.47l0.52,-0.06l-0.27,1.15l0.22,0.45l0.49,-0.12l1.0,-1.32l-0.08,0.85ZM726.83,255.78l0.83,0.38l1.17,-0.0l-0.02,0.48l-2.0,1.4l0.03,-2.26ZM724.81,252.09l-0.38,1.27l-1.42,-1.95l1.2,0.05l0.6,0.63ZM716.55,261.82l1.1,-0.95l0.03,-0.03l-0.28,0.36l-0.85,0.61ZM719.22,259.06l0.04,-0.06l0.8,-1.53l0.16,0.75l-1.0,0.84Z",
      name: "Philippines"
    },
    PL: {
      path: "M468.44,149.42l-1.11,-1.54l-1.86,-0.33l-0.48,-1.05l-1.72,-0.37l-0.65,0.69l-0.72,-0.36l0.11,-0.61l-0.33,-0.46l-1.75,-0.27l-1.04,-0.93l-0.94,-1.94l0.16,-1.22l-0.62,-1.8l-0.78,-1.07l0.57,-1.04l-0.48,-1.43l1.41,-0.83l6.91,-2.71l2.14,0.5l0.52,0.91l5.51,0.44l4.55,-0.05l1.07,0.31l0.48,0.84l0.15,1.58l0.65,1.2l-0.01,0.99l-1.27,0.58l-0.19,0.54l0.73,1.48l0.08,1.55l1.2,2.76l-0.17,0.58l-1.23,0.44l-2.27,2.72l0.18,0.95l-1.97,-1.03l-1.98,0.4l-1.36,-0.28l-1.24,0.58l-1.07,-0.97l-1.16,0.24Z",
      name: "Poland"
    },
    ZM: {
      path: "M481.47,313.3l0.39,0.31l2.52,0.14l0.99,1.17l2.01,0.35l1.4,-0.64l0.69,1.17l1.78,0.33l1.84,2.35l2.23,0.18l0.4,-0.43l-0.21,-2.74l-0.62,-0.3l-0.48,0.32l-1.98,-1.17l0.72,-5.29l-0.51,-1.18l0.57,-1.3l3.68,-0.62l0.26,0.63l1.21,0.63l0.9,-0.22l2.16,0.67l1.33,0.71l1.07,1.02l0.56,1.87l-0.88,2.7l0.43,2.09l-0.73,0.87l-0.76,2.37l0.59,0.68l-6.6,1.83l-0.29,0.44l0.19,1.45l-1.68,0.35l-1.43,1.02l-0.38,0.87l-0.87,0.26l-3.48,3.69l-4.16,-0.53l-1.52,-1.0l-1.77,-0.13l-1.83,0.52l-3.04,-3.4l0.11,-7.59l4.82,0.03l0.39,-0.49l-0.18,-0.76l0.33,-0.83l-0.4,-1.36l0.24,-1.05Z",
      name: "Zambia"
    },
    EH: {
      path: "M384.42,230.28l0.25,-0.79l1.06,-1.29l0.8,-3.51l3.38,-2.78l0.7,-1.81l0.06,4.84l-1.98,0.2l-0.94,1.59l0.39,3.56l-3.7,-0.01ZM392.01,218.1l0.7,-1.8l1.77,-0.24l2.09,0.34l0.95,-0.62l1.28,-0.07l-0.0,2.51l-6.79,-0.12Z",
      name: "W. Sahara"
    },
    EE: {
      path: "M485.71,115.04l2.64,0.6l2.56,0.11l-1.6,1.91l0.61,3.54l-0.81,0.87l-1.78,-0.01l-3.22,-1.76l-1.8,0.45l0.21,-1.53l-0.58,-0.41l-0.69,0.34l-1.26,-1.03l-0.17,-1.63l2.83,-0.92l3.05,-0.52Z",
      name: "Estonia"
    },
    EG: {
      path: "M492.06,205.03l1.46,0.42l2.95,-1.64l2.04,-0.21l1.53,0.3l0.59,1.19l0.69,0.04l0.41,-0.64l1.81,0.58l1.95,0.16l1.04,-0.51l1.42,4.08l-2.03,4.54l-1.66,-1.77l-1.76,-3.85l-0.64,-0.12l-0.36,0.67l1.04,2.88l3.44,6.95l1.78,3.04l2.03,2.65l-0.36,0.53l0.23,2.01l2.7,2.19l-28.41,0.0l0.0,-18.96l-0.73,-2.2l0.59,-1.56l-0.32,-1.26l0.68,-0.99l3.06,-0.04l4.82,1.52Z",
      name: "Egypt"
    },
    ZA: {
      path: "M467.14,373.21l-0.13,-1.96l-0.68,-1.56l0.7,-0.68l-0.13,-2.33l-4.56,-8.19l0.77,-0.86l0.6,0.45l0.69,1.31l2.83,0.72l1.5,-0.26l2.24,-1.39l0.19,-9.55l1.35,2.3l-0.21,1.5l0.61,1.2l0.4,0.19l1.79,-0.27l2.6,-2.07l0.69,-1.32l0.96,-0.48l2.19,1.04l2.04,0.13l1.77,-0.65l0.85,-2.12l1.38,-0.33l1.59,-2.76l2.15,-1.89l3.41,-1.87l2.0,0.45l1.02,-0.28l0.99,0.2l1.75,5.29l-0.38,3.25l-0.81,-0.23l-1.0,0.46l-0.87,1.68l-0.05,1.16l1.97,1.84l1.47,-0.29l0.69,-1.18l1.09,0.01l-0.76,3.69l-0.58,1.09l-2.2,1.79l-3.17,4.76l-2.8,2.83l-3.57,2.88l-2.53,1.05l-1.22,0.14l-0.51,0.7l-1.18,-0.32l-1.39,0.5l-2.59,-0.52l-1.61,0.33l-1.18,-0.11l-2.55,1.1l-2.1,0.44l-1.6,1.07l-0.85,0.05l-0.93,-0.89l-0.93,-0.15l-0.97,-1.13l-0.25,0.05ZM491.45,364.19l0.62,-0.93l1.48,-0.59l1.18,-2.19l-0.07,-0.49l-1.99,-1.69l-1.66,0.56l-1.43,1.14l-1.34,1.73l0.02,0.51l1.88,2.11l1.31,-0.16Z",
      name: "South Africa"
    },
    EC: {
      path: "M231.86,285.53l0.29,1.59l-0.69,1.45l-2.61,2.51l-3.13,1.11l-1.53,2.18l-0.49,1.68l-1.0,0.73l-1.02,-1.11l-1.78,-0.16l0.67,-1.15l-0.24,-0.86l1.25,-2.13l-0.54,-1.09l-0.67,-0.08l-0.72,0.87l-0.87,-0.64l0.35,-0.69l-0.36,-1.96l0.81,-0.51l0.45,-1.51l0.92,-1.57l-0.07,-0.97l2.65,-1.33l2.75,1.35l0.77,1.05l2.12,0.35l0.76,-0.32l1.96,1.21Z",
      name: "Ecuador"
    },
    AL: {
      path: "M470.32,171.8l0.74,0.03l0.92,0.89l-0.17,1.95l0.36,1.28l1.01,0.82l-1.82,2.83l-0.19,-0.61l-1.25,-0.89l-0.18,-1.2l0.53,-2.82l-0.54,-1.47l0.6,-0.83Z",
      name: "Albania"
    },
    AO: {
      path: "M461.55,300.03l1.26,3.15l1.94,2.36l2.47,-0.53l1.25,0.32l0.44,-0.18l0.93,-1.92l1.31,-0.08l0.41,-0.44l0.47,-0.0l-0.1,0.41l0.39,0.49l2.65,-0.02l0.03,1.19l0.48,1.01l-0.34,1.52l0.18,1.55l0.83,1.04l-0.13,2.85l0.54,0.39l3.96,-0.41l-0.1,1.79l0.39,1.05l-0.24,1.43l-4.7,-0.03l-0.4,0.39l-0.12,8.13l2.92,3.49l-3.83,0.88l-5.89,-0.36l-1.88,-1.24l-10.47,0.22l-1.3,-1.01l-1.85,-0.16l-2.4,0.77l-0.15,-1.06l0.33,-2.16l1.0,-3.45l1.35,-3.2l2.24,-2.8l0.33,-2.06l-0.13,-1.53l-0.8,-1.08l-1.21,-2.87l0.87,-1.62l-1.27,-4.12l-1.17,-1.53l2.47,-0.63l7.03,0.03ZM451.71,298.87l-0.47,-1.25l1.25,-1.11l0.32,0.3l-0.99,1.03l-0.12,1.03Z",
      name: "Angola"
    },
    KZ: {
      path: "M552.8,172.89l0.46,-1.27l-0.48,-1.05l-2.96,-1.19l-1.06,-2.58l-1.37,-0.87l-0.03,-0.3l1.95,0.23l0.45,-0.38l0.08,-1.96l1.75,-0.41l2.1,0.45l0.48,-0.33l0.45,-3.04l-0.45,-2.09l-0.41,-0.31l-2.42,0.15l-2.36,-0.73l-2.87,1.37l-2.17,0.61l-0.85,-0.34l0.13,-1.61l-1.6,-2.12l-2.02,-0.08l-1.78,-1.82l1.29,-2.18l-0.57,-0.95l1.62,-2.91l2.21,1.63l0.63,-0.27l0.29,-2.22l4.92,-3.43l3.71,-0.08l8.4,3.6l2.92,-1.36l3.77,-0.06l3.11,1.66l0.51,-0.11l0.6,-0.81l3.31,0.13l0.39,-0.25l0.63,-1.57l-0.17,-0.5l-3.5,-1.98l1.87,-1.27l-0.13,-1.03l1.98,-0.72l0.18,-0.62l-1.59,-2.06l0.81,-0.82l9.23,-1.18l1.33,-0.88l6.18,-1.26l2.26,-1.42l4.08,0.68l0.73,3.33l0.51,0.3l2.48,-0.8l2.79,1.02l-0.17,1.56l0.43,0.44l2.55,-0.24l4.89,-2.53l0.03,0.32l3.15,2.61l5.56,8.47l0.65,0.02l1.12,-1.46l3.15,1.74l3.76,-0.78l1.15,0.49l1.14,1.8l1.84,0.76l0.99,1.29l3.35,-0.25l1.02,1.52l-1.6,1.81l-1.93,0.28l-0.34,0.38l-0.11,3.05l-1.13,1.16l-4.75,-1.0l-0.46,0.27l-1.76,5.47l-1.1,0.59l-4.91,1.23l-0.27,0.54l2.1,4.97l-1.37,0.63l-0.23,0.41l0.13,1.13l-0.88,-0.25l-1.42,-1.13l-7.89,-0.4l-0.92,0.31l-3.73,-1.22l-1.42,0.63l-0.53,1.66l-3.72,-0.94l-1.85,0.43l-0.76,1.4l-4.65,2.62l-1.13,2.08l-0.44,0.01l-0.92,-1.4l-2.87,-0.09l-0.45,-2.14l-0.38,-0.32l-0.8,-0.01l0.0,-2.96l-3.0,-2.22l-7.31,0.58l-2.35,-2.68l-6.71,-3.69l-6.45,1.83l-0.29,0.39l0.1,10.85l-0.7,0.08l-1.62,-2.17l-1.83,-0.96l-3.11,0.59l-0.64,0.51Z",
      name: "Kazakhstan"
    },
    ET: {
      path: "M516.04,247.79l1.1,0.84l1.63,-0.45l0.68,0.47l1.63,0.03l2.01,0.94l1.73,1.66l1.64,2.07l-1.52,2.04l0.16,1.72l0.39,0.38l2.05,0.0l-0.36,1.03l2.86,3.58l8.32,3.08l1.31,0.02l-6.32,6.75l-3.1,0.11l-2.36,1.77l-1.47,0.04l-0.86,0.79l-1.38,-0.0l-1.32,-0.81l-2.29,1.05l-0.76,0.98l-3.29,-0.41l-3.07,-2.07l-1.8,-0.07l-0.62,-0.6l0.0,-1.24l-0.28,-0.38l-1.15,-0.37l-1.4,-2.59l-1.19,-0.68l-0.47,-1.0l-1.27,-1.23l-1.16,-0.22l0.43,-0.72l1.45,-0.28l0.41,-0.95l-0.03,-2.21l0.68,-2.44l1.05,-0.63l1.43,-3.06l1.57,-1.37l1.02,-2.51l0.35,-1.88l2.52,0.46l0.44,-0.24l0.58,-1.43Z",
      name: "Ethiopia"
    },
    ZW: {
      path: "M498.91,341.09l-1.11,-0.22l-0.92,0.28l-2.09,-0.44l-1.5,-1.11l-1.89,-0.43l-0.62,-1.4l-0.01,-0.84l-0.3,-0.38l-0.97,-0.25l-2.71,-2.74l-1.92,-3.32l3.83,0.45l3.73,-3.82l1.08,-0.44l0.26,-0.77l1.25,-0.9l1.41,-0.26l0.5,0.89l1.99,-0.05l1.72,1.17l1.11,0.17l1.05,0.66l0.01,2.99l-0.59,3.76l0.38,0.86l-0.23,1.23l-0.39,0.35l-0.63,1.81l-2.43,2.75Z",
      name: "Zimbabwe"
    },
    ES: {
      path: "M416.0,169.21l1.07,1.17l4.61,1.38l1.06,-0.57l2.6,1.26l2.71,-0.3l0.09,1.12l-2.14,1.8l-3.11,0.61l-0.31,0.31l-0.2,0.89l-1.54,1.69l-0.97,2.4l0.84,1.74l-1.32,1.27l-0.48,1.68l-1.88,0.65l-1.66,2.07l-5.36,-0.01l-1.79,1.08l-0.89,0.98l-0.88,-0.17l-0.79,-0.82l-0.68,-1.59l-2.37,-0.63l-0.11,-0.5l1.21,-1.82l-0.77,-1.13l0.61,-1.68l-0.76,-1.62l0.87,-0.49l0.09,-1.25l0.42,-0.6l0.03,-2.11l0.99,-0.69l0.13,-0.5l-1.03,-1.73l-1.46,-0.11l-0.61,0.38l-1.06,0.0l-0.52,-1.23l-0.53,-0.21l-1.32,0.67l-0.01,-1.49l-0.75,-0.96l3.03,-1.88l2.99,0.53l3.32,-0.02l2.63,0.51l6.01,-0.06Z",
      name: "Spain"
    },
    ER: {
      path: "M520.38,246.23l3.42,2.43l3.5,3.77l0.84,0.54l-0.95,-0.01l-3.51,-3.89l-2.33,-1.15l-1.73,-0.07l-0.91,-0.51l-1.26,0.51l-1.34,-1.02l-0.61,0.17l-0.66,1.61l-2.35,-0.43l-0.17,-0.67l1.29,-5.29l0.61,-0.61l1.95,-0.53l0.87,-1.01l1.17,2.41l0.68,2.33l1.49,1.43Z",
      name: "Eritrea"
    },
    ME: {
      path: "M468.91,172.53l-1.22,-1.02l0.47,-1.81l0.89,-0.72l2.26,1.51l-0.5,0.57l-0.75,-0.27l-1.14,1.73Z",
      name: "Montenegro"
    },
    MD: {
      path: "M488.41,153.73l1.4,-0.27l1.72,0.93l1.07,0.15l0.85,0.65l-0.14,0.84l0.96,0.85l1.12,2.47l-1.15,-0.07l-0.66,-0.41l-0.52,0.25l-0.09,0.86l-1.08,1.89l-0.27,-0.86l0.25,-1.34l-0.16,-1.6l-3.29,-4.34Z",
      name: "Moldova"
    },
    MG: {
      path: "M545.91,319.14l0.4,3.03l0.62,1.21l-0.21,1.02l-0.57,-0.8l-0.69,-0.01l-0.47,0.76l0.41,2.12l-0.18,0.87l-0.73,0.78l-0.15,2.14l-4.71,15.2l-1.06,2.88l-3.92,1.64l-3.12,-1.49l-0.6,-1.21l-0.19,-2.4l-0.86,-2.05l-0.21,-1.77l0.38,-1.62l1.21,-0.75l0.01,-0.76l1.19,-2.04l0.23,-1.66l-1.06,-2.99l-0.19,-2.21l0.81,-1.33l0.32,-1.46l4.63,-1.22l3.44,-3.0l0.85,-1.4l-0.08,-0.7l0.78,-0.04l1.38,-1.77l0.13,-1.64l0.45,-0.61l1.16,1.69l0.59,1.6Z",
      name: "Madagascar"
    },
    MA: {
      path: "M378.78,230.02l0.06,-0.59l0.92,-0.73l0.82,-1.37l-0.09,-1.04l0.79,-1.7l1.31,-1.58l0.96,-0.59l0.66,-1.55l0.09,-1.47l0.81,-1.48l1.72,-1.07l1.55,-2.69l1.16,-0.96l2.44,-0.39l1.94,-1.82l1.31,-0.78l2.09,-2.28l-0.51,-3.65l1.24,-3.7l1.5,-1.75l4.46,-2.57l2.37,-4.47l1.44,0.01l1.68,1.21l2.32,-0.19l3.47,0.65l0.8,1.54l0.16,1.71l0.86,2.96l0.56,0.59l-0.26,0.61l-3.05,0.44l-1.26,1.05l-1.33,0.22l-0.33,0.37l-0.09,1.78l-2.68,1.0l-1.07,1.42l-4.47,1.13l-4.04,2.01l-0.54,4.64l-1.15,0.06l-0.92,0.61l-1.96,-0.35l-2.42,0.54l-0.74,1.9l-0.86,0.4l-1.14,3.26l-3.53,3.01l-0.8,3.55l-0.96,1.1l-0.29,0.82l-4.95,0.18Z",
      name: "Morocco"
    },
    UZ: {
      path: "M598.64,172.75l-1.63,1.52l0.06,0.64l1.85,1.12l1.97,-0.64l2.21,1.17l-2.52,1.68l-2.59,-0.22l-0.18,-0.41l0.46,-1.23l-0.45,-0.53l-3.35,0.69l-2.1,3.51l-1.87,-0.12l-1.03,1.51l0.22,0.55l1.64,0.62l0.46,1.83l-1.19,2.49l-2.66,-0.53l0.05,-1.36l-0.26,-0.39l-3.3,-1.23l-2.56,-1.4l-4.4,-3.34l-1.34,-3.14l-1.08,-0.6l-2.58,0.13l-0.69,-0.44l-0.47,-2.52l-3.37,-1.6l-0.43,0.05l-2.07,1.72l-2.1,1.01l-0.21,0.47l0.28,1.01l-1.91,0.03l-0.09,-10.5l5.99,-1.7l6.19,3.54l2.71,2.84l7.05,-0.67l2.71,2.01l-0.17,2.81l0.39,0.42l0.9,0.02l0.44,2.14l0.38,0.32l2.94,0.09l0.95,1.42l1.28,-0.24l1.05,-2.04l4.43,-2.5Z",
      name: "Uzbekistan"
    },
    MM: {
      path: "M673.9,230.21l-1.97,1.57l-0.57,0.96l-1.4,0.6l-1.36,1.05l-1.99,0.36l-1.08,2.66l-0.91,0.4l-0.19,0.55l1.21,2.27l2.52,3.43l-0.79,1.91l-0.74,0.41l-0.17,0.52l0.65,1.37l1.61,1.95l0.25,2.58l0.9,2.13l-1.92,3.57l0.68,-2.25l-0.81,-1.74l0.19,-2.65l-1.05,-1.53l-1.24,-6.17l-1.12,-2.26l-0.6,-0.13l-4.34,3.02l-2.39,-0.65l0.77,-2.84l-0.52,-2.61l-1.91,-2.96l0.25,-0.75l-0.29,-0.51l-1.33,-0.3l-1.61,-1.93l-0.1,-1.3l0.82,-0.24l0.04,-1.64l1.02,-0.52l0.21,-0.45l-0.23,-0.95l0.54,-0.96l0.08,-2.22l1.46,0.45l0.47,-0.2l1.12,-2.19l0.16,-1.35l1.33,-2.16l-0.0,-1.52l2.89,-1.66l1.63,0.44l0.5,-0.44l-0.17,-1.4l0.64,-0.36l0.08,-1.04l0.77,-0.11l0.71,1.35l1.06,0.69l-0.03,3.86l-2.38,2.37l-0.3,3.15l0.46,0.43l2.28,-0.38l0.51,2.08l1.47,0.67l-0.6,1.8l0.19,0.48l2.97,1.48l1.64,-0.55l0.02,0.32Z",
      name: "Myanmar"
    },
    ML: {
      path: "M392.61,254.08l-0.19,-2.37l-0.99,-0.87l-0.44,-1.3l-0.09,-1.28l0.81,-0.58l0.35,-1.24l2.37,0.65l1.31,-0.47l0.86,0.15l0.66,-0.56l9.83,-0.04l0.38,-0.28l0.56,-1.8l-0.44,-0.65l-2.35,-21.95l3.27,-0.04l16.7,11.38l0.74,1.31l2.5,1.09l0.02,1.38l0.44,0.39l2.34,-0.21l0.01,5.38l-1.28,1.61l-0.26,1.49l-5.31,0.57l-1.07,0.92l-2.9,0.1l-0.86,-0.48l-1.38,0.36l-2.4,1.08l-0.6,0.87l-1.85,1.09l-0.43,0.7l-0.79,0.39l-1.44,-0.21l-0.81,0.84l-0.34,1.64l-1.91,2.02l-0.06,1.03l-0.67,1.22l0.13,1.16l-0.97,0.39l-0.23,-0.64l-0.52,-0.24l-1.35,0.4l-0.34,0.55l-2.69,-0.28l-0.37,-0.35l-0.02,-0.9l-0.65,-0.35l0.45,-0.64l-0.03,-0.53l-2.12,-2.44l-0.76,-0.01l-2.0,1.16l-0.78,-0.15l-0.8,-0.67l-1.21,0.23Z",
      name: "Mali"
    },
    MN: {
      path: "M676.61,146.48l3.81,1.68l5.67,-1.0l2.37,0.41l2.34,1.5l1.79,1.75l2.29,-0.03l3.12,0.52l2.47,-0.81l3.41,-0.59l3.53,-2.21l1.25,0.29l1.53,1.13l2.27,-0.21l-2.66,5.01l0.64,1.68l0.47,0.21l1.32,-0.38l2.38,0.48l2.02,-1.11l1.76,0.89l2.06,2.02l-0.13,0.53l-1.72,-0.29l-3.77,0.46l-1.88,0.99l-1.76,1.99l-3.71,1.17l-2.45,1.6l-3.83,-0.87l-0.41,0.17l-1.31,1.99l1.04,2.24l-1.52,0.9l-1.74,1.57l-2.79,1.02l-3.78,0.13l-4.05,1.05l-2.77,1.52l-1.16,-0.85l-2.94,0.0l-3.62,-1.79l-2.58,-0.49l-3.4,0.41l-5.12,-0.67l-2.63,0.06l-1.31,-1.6l-1.4,-3.0l-1.48,-0.33l-3.13,-1.94l-6.16,-0.93l-0.71,-1.06l0.86,-3.82l-1.93,-2.71l-3.5,-1.18l-1.95,-1.58l-0.5,-1.72l2.34,-0.52l4.75,-2.8l3.62,-1.47l2.18,0.97l2.46,0.05l1.81,1.53l2.46,0.12l3.95,0.71l2.43,-2.28l0.08,-0.48l-0.9,-1.72l2.24,-2.98l2.62,1.27l4.94,1.17l0.43,2.24Z",
      name: "Mongolia"
    },
    MK: {
      path: "M472.8,173.98l0.49,-0.71l3.57,-0.71l1.0,0.77l0.13,1.45l-0.65,0.53l-1.15,-0.05l-1.12,0.67l-1.39,0.22l-0.79,-0.55l-0.29,-1.03l0.19,-0.6Z",
      name: "Macedonia"
    },
    MW: {
      path: "M505.5,309.31l0.85,1.95l0.15,2.86l-0.69,1.65l0.71,1.8l0.06,1.28l0.49,0.64l0.07,1.06l0.4,0.55l0.8,-0.23l0.55,0.61l0.69,-0.21l0.34,0.6l0.19,2.94l-1.04,0.62l-0.54,1.25l-1.11,-1.08l-0.16,-1.56l0.51,-1.31l-0.32,-1.3l-0.99,-0.65l-0.82,0.12l-2.36,-1.64l0.63,-1.96l0.82,-1.18l-0.46,-2.01l0.9,-2.86l-0.94,-2.51l0.96,0.18l0.29,0.4Z",
      name: "Malawi"
    },
    MR: {
      path: "M407.36,220.66l-2.58,0.03l-0.39,0.44l2.42,22.56l0.36,0.43l-0.39,1.24l-9.75,0.04l-0.56,0.53l-0.91,-0.11l-1.27,0.45l-1.61,-0.66l-0.97,0.03l-0.36,0.29l-0.38,1.35l-0.42,0.23l-2.93,-3.4l-2.96,-1.52l-1.62,-0.03l-1.27,0.54l-1.12,-0.2l-0.65,0.4l-0.08,-0.49l0.68,-1.29l0.31,-2.43l-0.57,-3.91l0.23,-1.21l-0.69,-1.5l-1.15,-1.02l0.25,-0.39l9.58,0.02l0.4,-0.45l-0.46,-3.68l0.47,-1.04l2.12,-0.21l0.36,-0.4l-0.08,-6.4l7.81,0.13l0.41,-0.4l0.01,-3.31l7.76,5.35Z",
      name: "Mauritania"
    },
    UG: {
      path: "M498.55,276.32l0.7,-0.46l1.65,0.5l1.96,-0.57l1.7,0.01l1.45,-0.98l0.91,1.33l1.33,3.95l-2.57,4.03l-1.46,-0.4l-2.54,0.91l-1.37,1.61l-0.01,0.81l-2.42,-0.01l-2.26,1.01l-0.17,-1.59l0.58,-1.04l0.14,-1.94l1.37,-2.28l1.78,-1.58l-0.17,-0.65l-0.72,-0.24l0.13,-2.43Z",
      name: "Uganda"
    },
    MY: {
      path: "M717.47,273.46l-1.39,0.65l-2.12,-0.41l-2.88,-0.0l-0.38,0.28l-0.84,2.75l-0.99,0.96l-1.21,3.29l-1.73,0.45l-2.45,-0.68l-1.39,0.31l-1.33,1.15l-1.59,-0.14l-1.41,0.44l-1.44,-1.19l-0.18,-0.73l1.34,0.53l1.93,-0.47l0.75,-2.22l4.02,-1.03l2.75,-3.21l0.82,0.94l0.64,-0.05l0.4,-0.65l0.96,0.06l0.42,-0.36l0.24,-2.68l1.81,-1.64l1.21,-1.86l0.63,-0.01l1.07,1.05l0.34,1.28l3.44,1.35l-0.06,0.35l-1.37,0.1l-0.35,0.54l0.32,0.88ZM673.68,269.59l0.17,1.09l0.47,0.33l1.65,-0.3l0.87,-0.94l1.61,1.52l0.98,1.56l-0.12,2.81l0.41,2.29l0.95,0.9l0.88,2.44l-1.27,0.12l-5.1,-3.67l-0.34,-1.29l-1.37,-1.59l-0.33,-1.97l-0.88,-1.4l0.25,-1.68l-0.46,-1.05l1.63,0.84Z",
      name: "Malaysia"
    },
    MX: {
      path: "M133.12,200.41l0.2,0.47l9.63,3.33l6.96,-0.02l0.4,-0.4l0.0,-0.74l3.77,0.0l3.55,2.93l1.39,2.83l1.52,1.04l2.08,0.82l0.47,-0.14l1.46,-2.0l1.73,-0.04l1.59,0.98l2.05,3.35l1.47,1.56l1.26,3.14l2.18,1.02l2.26,0.58l-1.18,3.72l-0.42,5.04l1.79,4.89l1.62,1.89l0.61,1.52l1.2,1.42l2.55,0.66l1.37,1.1l7.54,-1.89l1.86,-1.3l1.14,-4.3l4.1,-1.21l3.57,-0.11l0.32,0.3l-0.06,0.94l-1.26,1.45l-0.67,1.71l0.38,0.7l-0.72,2.27l-0.49,-0.3l-1.0,0.08l-1.0,1.39l-0.47,-0.11l-0.53,0.47l-4.26,-0.02l-0.4,0.4l-0.0,1.06l-1.1,0.26l0.1,0.44l1.82,1.44l0.56,0.91l-3.19,0.21l-1.21,2.09l0.24,0.72l-0.2,0.44l-2.24,-2.18l-1.45,-0.93l-2.22,-0.69l-1.52,0.22l-3.07,1.16l-10.55,-3.85l-2.86,-1.96l-3.78,-0.92l-1.08,-1.19l-2.62,-1.43l-1.18,-1.54l-0.38,-0.81l0.66,-0.63l-0.18,-0.53l0.52,-0.76l0.01,-0.91l-2.0,-3.82l-2.21,-2.63l-2.53,-2.09l-1.19,-1.62l-2.2,-1.17l-0.3,-0.43l0.34,-1.48l-0.21,-0.45l-1.23,-0.6l-1.36,-1.2l-0.59,-1.78l-1.54,-0.47l-2.44,-2.55l-0.16,-0.9l-1.33,-2.03l-0.84,-1.99l-0.16,-1.33l-1.81,-1.1l-0.97,0.05l-1.31,-0.7l-0.57,0.22l-0.4,1.12l0.72,3.77l3.51,3.89l0.28,0.78l0.53,0.26l0.41,1.43l1.33,1.73l1.58,1.41l0.8,2.39l1.43,2.41l0.13,1.32l0.37,0.36l1.04,0.08l1.67,2.28l-0.85,0.76l-0.66,-1.51l-1.68,-1.54l-2.91,-1.87l0.06,-1.82l-0.54,-1.68l-2.91,-2.03l-0.55,0.09l-1.95,-1.1l-0.88,-0.94l0.68,-0.08l0.93,-1.01l0.08,-1.78l-1.93,-1.94l-1.46,-0.77l-3.75,-7.56l4.88,-0.42Z",
      name: "Mexico"
    },
    VU: {
      path: "M839.04,322.8l0.22,1.14l-0.44,0.03l-0.2,-1.45l0.42,0.27Z",
      name: "Vanuatu"
    },
    FR: {
      path: "M444.48,172.62l-0.64,1.78l-0.58,-0.31l-0.49,-1.72l0.4,-0.89l1.0,-0.72l0.3,1.85ZM429.64,147.1l1.78,1.58l1.46,-0.13l2.1,1.42l1.35,0.27l1.23,0.83l3.04,0.5l-1.03,1.85l-0.3,2.12l-0.41,0.32l-0.95,-0.24l-0.5,0.43l0.06,0.61l-1.81,1.92l-0.04,1.42l0.55,0.38l0.88,-0.36l0.61,0.97l-0.03,1.0l0.57,0.91l-0.75,1.09l0.65,2.39l1.27,0.57l-0.18,0.82l-2.01,1.53l-4.77,-0.8l-3.82,1.0l-0.53,1.85l-2.49,0.34l-2.71,-1.31l-1.16,0.57l-4.31,-1.29l-0.72,-0.86l1.19,-1.78l0.39,-6.45l-2.58,-3.3l-1.9,-1.66l-3.72,-1.23l-0.19,-1.72l2.81,-0.61l4.12,0.81l0.47,-0.48l-0.6,-2.77l1.94,0.95l5.83,-2.54l0.92,-2.74l1.6,-0.49l0.24,0.78l1.36,0.33l1.05,1.19ZM289.01,278.39l-0.81,0.8l-0.78,0.12l-0.5,-0.66l-0.56,-0.1l-0.91,0.6l-0.46,-0.22l1.09,-2.96l-0.96,-1.77l-0.17,-1.49l1.07,-1.77l2.32,0.75l2.51,2.01l0.3,0.74l-2.14,3.96Z",
      name: "France"
    },
    FI: {
      path: "M492.17,76.39l-0.23,3.5l3.52,2.63l-2.08,2.88l-0.02,0.44l2.8,4.56l-1.59,3.31l2.16,3.24l-0.94,2.39l0.14,0.47l3.44,2.51l-0.77,1.62l-7.52,6.95l-4.5,0.31l-4.38,1.37l-3.8,0.74l-1.44,-1.96l-2.17,-1.11l0.5,-3.66l-1.16,-3.33l1.09,-2.08l2.21,-2.42l5.67,-4.32l1.64,-0.83l0.21,-0.42l-0.46,-2.02l-3.38,-1.89l-0.75,-1.43l-0.22,-6.74l-6.79,-4.8l0.8,-0.62l2.54,2.12l3.46,-0.12l3.0,0.96l2.51,-2.11l1.17,-3.08l3.55,-1.38l2.76,1.53l-0.95,2.79Z",
      name: "Finland"
    },
    FJ: {
      path: "M871.53,326.34l-2.8,1.05l-0.08,-0.23l2.97,-1.21l-0.1,0.39ZM867.58,329.25l0.43,0.37l-0.27,0.88l-1.24,0.28l-1.04,-0.24l-0.14,-0.66l0.63,-0.58l0.92,0.26l0.7,-0.31Z",
      name: "Fiji"
    },
    FK: {
      path: "M274.36,425.85l1.44,1.08l-0.47,0.73l-3.0,0.89l-0.96,-1.0l-0.52,-0.05l-1.83,1.29l-0.73,-0.88l2.46,-1.64l1.93,0.76l1.67,-1.19Z",
      name: "Falkland Is."
    },
    NI: {
      path: "M202.33,252.67l0.81,-0.18l1.03,-1.02l-0.04,-0.88l0.68,-0.0l0.63,-0.54l0.97,0.22l1.53,-1.26l0.58,-0.99l1.17,0.34l2.41,-0.94l0.13,1.32l-0.81,1.94l0.1,2.74l-0.36,0.37l-0.11,1.75l-0.47,0.81l0.18,1.14l-1.73,-0.85l-0.71,0.27l-1.47,-0.6l-0.52,0.16l-4.01,-3.81Z",
      name: "Nicaragua"
    },
    NL: {
      path: "M430.31,143.39l0.6,-0.5l2.13,-4.8l3.2,-1.33l1.74,0.08l0.33,0.8l-0.59,2.92l-0.5,0.99l-1.26,0.0l-0.4,0.45l0.33,2.7l-2.2,-1.78l-2.62,0.58l-0.75,-0.11Z",
      name: "Netherlands"
    },
    NO: {
      path: "M491.44,67.41l6.8,2.89l-2.29,0.86l-0.15,0.65l2.33,2.38l-4.98,1.79l0.84,-2.45l-0.18,-0.48l-3.55,-1.8l-3.89,1.52l-1.42,3.38l-2.12,1.72l-2.64,-1.0l-3.11,0.21l-2.66,-2.22l-0.5,-0.01l-1.41,1.1l-1.44,0.17l-0.35,0.35l-0.32,2.47l-4.32,-0.64l-0.44,0.29l-0.58,2.11l-2.45,0.2l-4.15,7.68l-3.88,5.76l0.78,1.62l-0.64,1.16l-2.24,-0.06l-0.38,0.24l-1.66,3.89l0.15,5.17l1.57,2.04l-0.78,4.16l-2.02,2.48l-0.85,1.63l-1.3,-1.75l-0.58,-0.07l-4.87,4.19l-3.1,0.79l-3.16,-1.7l-0.85,-3.77l-0.77,-8.55l2.14,-2.31l6.55,-3.27l5.02,-4.17l10.63,-13.84l10.98,-8.7l5.35,-1.91l4.34,0.12l3.69,-3.64l4.49,0.19l4.37,-0.89ZM484.55,20.04l4.26,1.75l-3.1,2.55l-7.1,0.65l-7.08,-0.9l-0.37,-1.31l-0.37,-0.29l-3.44,-0.1l-2.08,-2.0l6.87,-1.44l3.9,1.31l2.39,-1.64l6.13,1.4ZM481.69,33.93l-4.45,1.74l-3.54,-0.99l1.12,-0.9l0.05,-0.58l-1.06,-1.22l4.22,-0.89l1.09,1.97l2.57,0.87ZM466.44,24.04l7.43,3.77l-5.41,1.86l-1.58,4.08l-2.26,1.2l-1.12,4.11l-2.61,0.18l-4.79,-2.86l1.84,-1.54l-0.1,-0.68l-3.69,-1.53l-4.77,-4.51l-1.73,-3.89l6.11,-1.82l1.54,1.92l3.57,-0.08l1.2,-1.96l3.32,-0.18l3.05,1.92Z",
      name: "Norway"
    },
    NA: {
      path: "M474.26,330.66l-0.97,0.04l-0.38,0.4l-0.07,8.9l-2.09,0.08l-0.39,0.4l-0.0,17.42l-1.98,1.23l-1.17,0.17l-2.44,-0.66l-0.48,-1.13l-0.99,-0.74l-0.54,0.05l-0.9,1.01l-1.53,-1.68l-0.93,-1.88l-1.99,-8.56l-0.06,-3.12l-0.33,-1.52l-2.3,-3.34l-1.91,-4.83l-1.96,-2.43l-0.12,-1.57l2.33,-0.79l1.43,0.07l1.81,1.13l10.23,-0.25l1.84,1.23l5.87,0.35ZM474.66,330.64l6.51,-1.6l1.9,0.39l-1.69,0.4l-1.31,0.83l-1.12,-0.94l-4.29,0.92Z",
      name: "Namibia"
    },
    NC: {
      path: "M838.78,341.24l-0.33,0.22l-2.9,-1.75l-3.26,-3.37l1.65,0.83l4.85,4.07Z",
      name: "New Caledonia"
    },
    NE: {
      path: "M454.75,226.53l1.33,1.37l0.48,0.07l1.27,-0.7l0.53,3.52l0.94,0.83l0.17,0.92l0.81,0.69l-0.44,0.95l-0.96,5.26l-0.13,3.22l-3.04,2.31l-1.22,3.57l1.02,1.24l-0.0,1.46l0.39,0.4l1.13,0.04l-0.9,1.25l-1.47,-2.42l-0.86,-0.29l-2.09,1.37l-1.74,-0.67l-1.45,-0.17l-0.85,0.35l-1.36,-0.07l-1.64,1.09l-1.06,0.05l-2.94,-1.28l-1.44,0.59l-1.01,-0.03l-0.97,-0.94l-2.7,-0.98l-2.69,0.3l-0.87,0.64l-0.47,1.6l-0.75,1.16l-0.12,1.53l-1.57,-1.1l-1.31,0.24l0.03,-0.81l-0.32,-0.41l-2.59,-0.52l-0.15,-1.16l-1.35,-1.6l-0.29,-1.0l0.13,-0.84l1.29,-0.08l1.08,-0.92l3.31,-0.22l2.22,-0.41l0.32,-0.34l0.2,-1.47l1.39,-1.88l-0.01,-5.66l3.36,-1.12l7.24,-5.12l8.42,-4.92l3.69,1.06Z",
      name: "Niger"
    },
    NG: {
      path: "M456.32,253.89l0.64,0.65l-0.28,1.04l-2.11,2.01l-2.03,5.18l-1.37,1.16l-1.15,3.18l-1.33,0.66l-1.46,-0.97l-1.21,0.16l-1.38,1.36l-0.91,0.24l-1.79,4.06l-2.33,0.81l-1.11,-0.07l-0.86,0.5l-1.71,-0.05l-1.19,-1.39l-0.89,-1.89l-1.77,-1.66l-3.95,-0.08l0.07,-5.21l0.42,-1.43l1.95,-2.3l-0.14,-0.91l0.43,-1.18l-0.53,-1.41l0.25,-2.92l0.72,-1.07l0.32,-1.34l0.46,-0.39l2.47,-0.28l2.34,0.89l1.15,1.02l1.28,0.04l1.22,-0.58l3.03,1.27l1.49,-0.14l1.36,-1.0l1.33,0.07l0.82,-0.35l3.45,0.8l1.82,-1.32l1.84,2.67l0.66,0.16Z",
      name: "Nigeria"
    },
    NZ: {
      path: "M857.8,379.65l1.86,3.12l0.44,0.18l0.3,-0.38l0.03,-1.23l0.38,0.27l0.57,2.31l2.02,0.94l1.81,0.27l1.57,-1.06l0.7,0.18l-1.15,3.59l-1.98,0.11l-0.74,1.2l0.2,1.11l-2.42,3.98l-1.49,0.92l-1.04,-0.85l1.21,-2.05l-0.81,-2.01l-2.63,-1.25l0.04,-0.57l1.82,-1.19l0.43,-2.34l-0.16,-2.03l-0.95,-1.82l-0.06,-0.72l-3.11,-3.64l-0.79,-1.52l1.56,1.45l1.76,0.66l0.65,2.34ZM853.83,393.59l0.57,1.24l0.59,0.16l1.42,-0.97l0.46,0.79l0.0,1.03l-2.47,3.48l-1.26,1.2l-0.06,0.5l0.55,0.87l-1.41,0.07l-2.33,1.38l-2.03,5.02l-3.02,2.16l-2.06,-0.06l-1.71,-1.04l-2.47,-0.2l-0.27,-0.73l1.22,-2.1l3.05,-2.94l1.62,-0.59l4.02,-2.82l1.57,-1.67l1.07,-2.16l0.88,-0.7l0.48,-1.75l1.24,-0.97l0.35,0.79Z",
      name: "New Zealand"
    },
    NP: {
      path: "M641.14,213.62l0.01,3.19l-1.74,0.04l-4.8,-0.86l-1.58,-1.39l-3.37,-0.34l-7.65,-3.7l0.8,-2.09l2.33,-1.7l1.77,0.75l2.49,1.76l1.38,0.41l0.99,1.35l1.9,0.52l1.99,1.17l5.49,0.9Z",
      name: "Nepal"
    },
    CI: {
      path: "M407.4,259.27l0.86,0.42l0.56,0.9l1.13,0.53l1.19,-0.61l0.97,-0.08l1.42,0.54l0.6,3.24l-1.03,2.08l-0.65,2.84l1.06,2.33l-0.06,0.53l-2.54,-0.47l-1.66,0.03l-3.06,0.46l-4.11,1.6l0.32,-3.06l-1.18,-1.31l-1.32,-0.66l0.42,-0.85l-0.2,-1.4l0.5,-0.67l0.01,-1.59l0.84,-0.32l0.26,-0.5l-1.15,-3.01l0.12,-0.5l0.51,-0.25l0.66,0.31l1.93,0.02l0.67,-0.71l0.71,-0.14l0.25,0.69l0.57,0.22l1.4,-0.61Z",
      name: "Côte d'Ivoire"
    },
    CH: {
      path: "M444.62,156.35l-0.29,0.87l0.18,0.53l1.13,0.58l1.0,0.1l-0.1,0.65l-0.79,0.38l-1.72,-0.37l-0.45,0.23l-0.45,1.04l-0.75,0.06l-0.84,-0.4l-1.32,1.0l-0.96,0.12l-0.88,-0.55l-0.81,-1.3l-0.49,-0.16l-0.63,0.26l0.02,-0.65l1.71,-1.66l0.1,-0.56l0.93,0.08l0.58,-0.46l1.99,0.02l0.66,-0.61l2.19,0.79Z",
      name: "Switzerland"
    },
    CO: {
      path: "M242.07,254.93l-1.7,0.59l-0.59,1.18l-1.7,1.69l-0.38,1.93l-0.67,1.43l0.31,0.57l1.03,0.13l0.25,0.9l0.57,0.64l-0.04,2.34l1.64,1.42l3.16,-0.24l1.26,0.28l1.67,2.06l0.41,0.13l4.09,-0.39l0.45,0.22l-0.92,1.95l-0.2,1.8l0.52,1.83l0.75,1.05l-1.12,1.1l0.07,0.63l0.84,0.51l0.74,1.29l-0.39,-0.45l-0.59,-0.01l-0.71,0.74l-4.71,-0.05l-0.4,0.41l0.03,1.57l0.33,0.39l1.11,0.2l-1.68,0.4l-0.29,0.38l-0.01,1.82l1.16,1.14l0.34,1.25l-1.05,7.05l-1.04,-0.87l1.26,-1.99l-0.13,-0.56l-2.18,-1.23l-1.38,0.2l-1.14,-0.38l-1.27,0.61l-1.55,-0.26l-1.38,-2.46l-1.23,-0.75l-0.85,-1.2l-1.67,-1.19l-0.86,0.13l-2.11,-1.32l-1.01,0.31l-1.8,-0.29l-0.52,-0.91l-3.09,-1.68l0.77,-0.52l-0.1,-1.12l0.41,-0.64l1.34,-0.32l2.0,-2.88l-0.11,-0.57l-0.66,-0.43l0.39,-1.38l-0.52,-2.1l0.49,-0.83l-0.4,-2.13l-0.97,-1.35l0.17,-0.66l0.86,-0.08l0.47,-0.75l-0.46,-1.63l1.41,-0.07l1.8,-1.69l0.93,-0.24l0.3,-0.38l0.45,-2.76l1.22,-1.0l1.44,-0.04l0.45,-0.5l1.91,0.12l2.93,-1.84l1.15,-1.14l0.91,0.46l-0.25,0.45Z",
      name: "Colombia"
    },
    CN: {
      path: "M740.23,148.97l4.57,1.3l2.8,2.17l0.98,2.9l0.38,0.27l3.8,0.0l2.32,-1.28l3.29,-0.75l-0.96,2.09l-1.02,1.28l-0.85,3.4l-1.52,2.73l-2.76,-0.5l-2.4,1.13l-0.21,0.45l0.64,2.57l-0.32,3.2l-0.94,0.06l-0.37,0.89l-0.91,-1.01l-0.64,0.07l-0.92,1.57l-3.73,1.25l-0.26,0.48l0.26,1.06l-1.5,-0.08l-1.09,-0.86l-0.56,0.06l-1.67,2.06l-2.7,1.56l-2.03,1.88l-3.4,0.83l-1.93,1.4l-1.15,0.34l0.33,-0.7l-0.41,-0.89l1.79,-1.79l0.02,-0.54l-1.32,-1.56l-0.48,-0.1l-2.24,1.09l-2.83,2.06l-1.51,1.83l-2.28,0.13l-1.55,1.49l-0.04,0.5l1.32,1.97l2.0,0.58l0.31,1.35l1.98,0.84l3.0,-1.96l2.0,1.02l1.49,0.11l0.22,0.83l-3.37,0.86l-1.12,1.48l-2.5,1.52l-1.29,1.99l0.14,0.56l2.57,1.48l0.97,2.7l3.17,4.63l-0.03,1.66l-1.35,0.65l-0.2,0.51l0.6,1.47l1.4,0.91l-0.89,3.82l-1.43,0.38l-3.85,6.44l-2.27,3.11l-6.78,4.57l-2.73,0.29l-1.45,1.04l-0.62,-0.61l-0.55,-0.01l-1.36,1.25l-3.39,1.27l-2.61,0.4l-1.1,2.79l-0.81,0.09l-0.49,-1.42l0.5,-0.85l-0.25,-0.59l-3.36,-0.84l-1.3,0.4l-2.31,-0.62l-0.94,-0.84l0.33,-1.28l-0.3,-0.49l-2.19,-0.46l-1.13,-0.93l-0.47,-0.02l-2.06,1.36l-4.29,0.28l-2.76,1.05l-0.28,0.43l0.32,2.53l-0.59,-0.03l-0.19,-1.34l-0.55,-0.34l-1.68,0.7l-2.46,-1.23l0.62,-1.87l-0.26,-0.51l-1.37,-0.44l-0.54,-2.22l-0.45,-0.3l-2.13,0.35l0.24,-2.48l2.39,-2.4l0.03,-4.31l-1.19,-0.92l-0.78,-1.49l-0.41,-0.21l-1.41,0.19l-1.98,-0.3l0.46,-1.07l-1.17,-1.7l-0.55,-0.11l-1.63,1.05l-2.25,-0.57l-2.89,1.73l-2.25,1.98l-1.75,0.29l-1.17,-0.71l-3.31,-0.65l-1.48,0.79l-1.04,1.27l-0.12,-1.17l-0.54,-0.34l-1.44,0.54l-5.55,-0.86l-1.98,-1.16l-1.89,-0.54l-0.99,-1.35l-1.34,-0.37l-2.55,-1.79l-2.01,-0.84l-1.21,0.56l-5.57,-3.45l-0.53,-2.31l1.19,0.25l0.48,-0.37l0.08,-1.42l-0.98,-1.56l0.15,-2.44l-2.69,-3.32l-4.12,-1.23l-0.67,-2.0l-1.92,-1.48l-0.38,-0.7l-0.51,-3.01l-1.52,-0.66l-0.7,0.13l-0.48,-2.05l0.55,-0.51l-0.09,-0.82l2.03,-1.19l1.6,-0.54l2.56,0.38l0.42,-0.22l0.85,-1.7l3.0,-0.33l1.1,-1.26l4.05,-1.77l0.39,-0.91l-0.17,-1.44l1.45,-0.67l0.2,-0.52l-2.07,-4.9l4.51,-1.12l1.37,-0.73l1.89,-5.51l4.98,0.86l1.51,-1.7l0.11,-2.87l1.99,-0.38l1.83,-2.06l0.49,-0.13l0.68,2.08l2.23,1.77l3.44,1.16l1.55,2.29l-0.92,3.49l0.96,1.67l6.54,1.13l2.95,1.87l1.47,0.35l1.06,2.62l1.53,1.91l3.05,0.08l5.14,0.67l3.37,-0.41l2.36,0.43l3.65,1.8l3.06,0.04l1.45,0.88l2.87,-1.59l3.95,-1.02l3.83,-0.14l3.06,-1.14l1.77,-1.6l1.72,-1.01l0.17,-0.49l-1.1,-2.05l1.02,-1.54l4.02,0.8l2.45,-1.61l3.76,-1.19l1.96,-2.13l1.63,-0.83l3.51,-0.4l1.92,0.34l0.46,-0.3l0.17,-1.5l-2.27,-2.22l-2.11,-1.09l-2.18,1.11l-2.32,-0.47l-1.29,0.32l-0.4,-0.82l2.73,-5.16l3.02,1.06l3.53,-2.06l0.18,-1.68l2.16,-3.35l1.49,-1.35l-0.03,-1.85l-1.07,-0.85l1.54,-1.26l2.98,-0.59l3.23,-0.09l3.64,0.99l2.04,1.16l3.29,6.71l0.92,3.19ZM696.92,237.31l-1.87,1.08l-1.63,-0.64l-0.06,-1.79l1.03,-0.98l2.58,-0.69l1.16,0.05l0.3,0.54l-0.98,1.06l-0.53,1.37Z",
      name: "China"
    },
    CM: {
      path: "M457.92,257.49l1.05,1.91l-1.4,0.16l-1.05,-0.23l-0.45,0.22l-0.54,1.19l0.08,0.45l1.48,1.47l1.05,0.45l1.01,2.46l-1.52,2.99l-0.68,0.68l-0.13,3.69l2.38,3.84l1.09,0.8l0.24,2.48l-3.67,-1.14l-11.27,-0.13l0.23,-1.79l-0.98,-1.66l-1.19,-0.54l-0.44,-0.97l-0.6,-0.42l1.71,-4.27l0.75,-0.13l1.38,-1.36l0.65,-0.03l1.71,0.99l1.93,-1.12l1.14,-3.18l1.38,-1.17l2.0,-5.14l2.17,-2.13l0.3,-1.64l-0.86,-0.88l0.03,-0.33l0.94,1.28l0.07,3.22Z",
      name: "Cameroon"
    },
    CL: {
      path: "M246.5,429.18l-3.14,1.83l-0.57,3.16l-0.64,0.05l-2.68,-1.06l-2.82,-2.33l-3.04,-1.89l-0.69,-1.85l0.63,-2.14l-1.21,-2.11l-0.31,-5.37l1.01,-2.91l2.57,-2.38l-0.18,-0.68l-3.16,-0.77l2.05,-2.47l0.77,-4.65l2.32,0.9l0.54,-0.29l1.31,-6.31l-0.22,-0.44l-1.68,-0.8l-0.56,0.28l-0.7,3.36l-0.81,-0.22l1.56,-9.41l1.15,-2.24l-0.71,-2.82l-0.18,-2.84l1.01,-0.33l3.26,-9.14l1.07,-4.22l-0.56,-4.21l0.74,-2.34l-0.29,-3.27l1.46,-3.34l2.04,-16.59l-0.66,-7.76l1.03,-0.53l0.54,-0.9l0.79,1.14l0.32,1.78l1.25,1.16l-0.69,2.55l1.33,2.9l0.97,3.59l0.46,0.29l1.5,-0.3l0.11,0.23l-0.76,2.44l-2.57,1.23l-0.23,0.37l0.08,4.33l-0.46,0.77l0.56,1.21l-1.58,1.51l-1.68,2.62l-0.89,2.47l0.2,2.7l-1.48,2.73l1.12,5.09l0.64,0.61l-0.01,2.29l-1.38,2.68l0.01,2.4l-1.89,2.04l0.02,2.75l0.69,2.57l-1.43,1.13l-1.26,5.68l0.39,3.51l-0.97,0.89l0.58,3.5l1.02,1.14l-0.65,1.02l0.15,0.57l1.0,0.53l0.16,0.69l-1.03,0.85l0.26,1.75l-0.89,4.03l-1.31,2.66l0.24,1.75l-0.71,1.83l-1.99,1.7l0.3,3.67l0.88,1.19l1.58,0.01l0.01,2.21l1.04,1.95l5.98,0.63ZM248.69,430.79l0.0,7.33l0.4,0.4l3.52,0.05l-0.44,0.75l-1.94,0.98l-2.49,-0.37l-1.88,-1.06l-2.55,-0.49l-5.59,-3.71l-2.38,-2.63l4.1,2.48l3.32,1.23l0.45,-0.12l1.29,-1.57l0.83,-2.32l2.05,-1.24l1.31,0.29Z",
      name: "Chile"
    },
    CA: {
      path: "M280.06,145.6l-1.67,2.88l0.07,0.49l0.5,0.04l1.46,-0.98l1.0,0.42l-0.56,0.72l0.17,0.62l2.22,0.89l1.35,-0.71l1.95,0.78l-0.66,2.01l0.5,0.51l1.32,-0.42l0.98,3.17l-0.91,2.41l-0.8,0.08l-1.23,-0.45l0.47,-2.25l-0.89,-0.83l-0.48,0.06l-2.78,2.63l-0.34,-0.02l1.02,-0.85l-0.14,-0.69l-2.4,-0.77l-7.4,0.08l-0.17,-0.41l1.3,-0.94l0.02,-0.64l-0.73,-0.58l1.85,-1.74l2.57,-5.16l1.47,-1.79l1.99,-1.05l0.46,0.06l-1.53,2.45ZM68.32,74.16l4.13,0.95l4.02,2.14l2.61,0.4l2.47,-1.89l2.88,-1.31l3.85,0.48l3.71,-1.94l3.82,-1.04l1.56,1.68l0.49,0.08l1.87,-1.04l0.65,-1.98l1.24,0.35l4.16,3.94l0.54,0.01l2.75,-2.49l0.26,2.59l0.49,0.35l3.08,-0.73l1.04,-1.27l2.73,0.23l3.83,1.86l5.86,1.61l3.47,0.75l2.44,-0.26l2.73,1.78l-2.98,1.81l-0.19,0.41l0.31,0.32l4.53,0.92l6.87,-0.5l2.0,-0.69l2.49,2.39l0.53,0.02l2.72,-2.16l-0.02,-0.64l-2.16,-1.54l1.15,-1.06l4.83,-0.61l1.84,0.95l2.48,2.31l3.01,-0.23l4.55,1.92l3.85,-0.67l3.61,0.1l0.41,-0.44l-0.25,-2.36l1.79,-0.61l3.49,1.32l-0.01,3.77l0.31,0.39l0.45,-0.22l1.48,-3.16l1.74,0.1l0.41,-0.3l1.13,-4.37l-2.78,-3.11l-2.8,-1.74l0.19,-4.64l2.71,-3.07l2.98,0.67l2.41,1.95l3.19,4.8l-1.99,1.97l0.21,0.68l4.33,0.84l-0.01,4.15l0.25,0.37l0.44,-0.09l3.07,-3.15l2.54,2.39l-0.61,3.33l2.42,2.88l0.61,0.0l2.61,-3.08l1.88,-3.82l0.17,-4.58l6.72,0.94l3.13,2.04l0.13,1.82l-1.76,2.19l-0.01,0.49l1.66,2.16l-0.26,1.71l-4.68,2.8l-3.28,0.61l-2.47,-1.2l-0.55,0.23l-0.73,2.04l-2.38,3.43l-0.74,1.77l-2.74,2.57l-3.44,0.25l-2.21,1.78l-0.28,2.53l-2.82,0.55l-3.12,3.22l-2.72,4.31l-1.03,3.17l-0.14,4.31l0.33,0.41l3.44,0.57l2.24,5.95l0.45,0.23l3.4,-0.69l4.52,1.51l2.43,1.31l1.91,1.73l3.1,0.96l2.62,1.46l6.6,0.54l-0.35,2.74l0.81,3.53l1.81,3.78l3.83,3.3l0.45,0.04l2.1,-1.28l1.37,-3.69l-1.31,-5.38l-1.45,-1.58l3.57,-1.47l2.84,-2.46l1.52,-2.8l-0.25,-2.55l-1.7,-3.07l-2.85,-2.61l2.8,-3.95l-1.08,-3.37l-0.79,-5.67l1.36,-0.7l6.76,1.41l2.12,-0.96l5.12,3.36l1.05,1.61l4.08,0.26l-0.06,2.87l0.83,4.7l0.3,0.32l2.16,0.54l1.73,2.06l0.5,0.09l3.63,-2.03l2.52,-4.19l1.26,-1.32l7.6,11.72l-0.92,2.04l0.16,0.51l3.3,1.97l2.22,1.98l4.1,0.98l1.43,0.99l0.95,2.79l2.1,0.68l0.84,1.08l0.17,3.45l-3.37,2.26l-4.22,1.24l-3.06,2.63l-4.06,0.51l-5.35,-0.69l-6.39,0.2l-2.3,2.41l-3.26,1.51l-6.47,7.15l-0.06,0.48l0.44,0.19l2.13,-0.52l4.17,-4.24l5.12,-2.62l3.52,-0.3l1.69,1.21l-2.12,2.21l0.81,3.47l1.02,2.61l3.47,1.6l4.14,-0.45l2.15,-2.8l0.26,1.48l1.14,0.8l-2.56,1.69l-5.5,1.82l-2.54,1.27l-2.74,2.15l-1.4,-0.16l-0.07,-2.01l4.14,-2.44l0.18,-0.45l-0.39,-0.29l-6.63,0.45l-1.39,-1.49l-0.14,-4.43l-1.11,-0.91l-1.82,0.39l-0.66,-0.66l-0.6,0.03l-1.91,2.39l-0.82,2.52l-0.8,1.27l-1.67,0.56l-0.46,0.76l-8.31,0.07l-1.21,0.62l-2.35,1.97l-0.71,-0.14l-1.37,0.96l-1.12,-0.48l-4.74,1.26l-0.9,1.17l0.21,0.62l1.73,0.3l-1.81,0.31l-1.85,0.81l-2.11,-0.13l-2.95,1.78l-0.69,-0.09l1.39,-2.1l1.73,-1.21l0.1,-2.29l1.16,-1.99l0.49,0.53l2.03,0.42l1.2,-1.16l0.02,-0.47l-2.66,-3.51l-2.28,-0.61l-5.64,-0.71l-0.4,-0.57l-0.79,0.13l0.2,-0.41l-0.22,-0.55l-0.68,-0.26l0.19,-1.26l-0.78,-0.73l0.31,-0.64l-0.29,-0.57l-2.6,-0.44l-0.75,-1.63l-0.94,-0.66l-4.31,-0.65l-1.13,1.19l-1.48,0.59l-0.85,1.06l-2.83,-0.76l-2.09,0.39l-2.39,-0.97l-4.24,-0.7l-0.57,-0.4l-0.41,-1.63l-0.4,-0.3l-0.85,0.02l-0.39,0.4l-0.01,0.85l-69.13,-0.01l-6.51,-4.52l-4.5,-1.38l-1.26,-2.66l0.33,-1.93l-0.23,-0.43l-3.01,-1.35l-0.55,-2.77l-2.89,-2.38l-0.04,-1.45l1.39,-1.83l-0.28,-2.55l-4.16,-2.2l-4.07,-6.6l-4.02,-3.22l-1.3,-1.88l-0.5,-0.13l-2.51,1.21l-2.23,1.87l-3.85,-3.88l-2.44,-1.04l-2.22,-0.13l0.03,-37.49ZM260.37,148.65l3.04,0.76l2.26,1.2l-3.78,-0.95l-1.53,-1.01ZM249.4,3.81l6.68,0.49l5.32,0.79l4.26,1.57l-0.07,1.1l-5.85,2.53l-6.02,1.21l-2.39,1.39l-0.18,0.45l0.39,0.29l4.01,-0.02l-4.65,2.82l-4.2,1.74l-4.19,4.59l-5.03,0.92l-1.67,1.15l-7.47,0.59l-0.37,0.37l0.32,0.42l2.41,0.49l-0.81,0.47l-0.12,0.59l1.83,2.41l-2.02,1.59l-3.81,1.51l-1.32,2.16l-3.38,1.53l-0.22,0.48l0.35,1.19l0.4,0.29l3.88,-0.18l0.03,0.61l-6.33,2.95l-6.41,-1.4l-7.43,0.79l-3.72,-0.62l-4.4,-0.25l-0.23,-1.83l4.29,-1.11l0.28,-0.51l-1.1,-3.45l1.0,-0.25l6.58,2.28l0.47,-0.16l-0.05,-0.49l-3.41,-3.45l-3.58,-0.98l1.48,-1.55l4.34,-1.29l0.97,-2.19l-0.16,-0.48l-3.42,-2.13l-0.81,-2.26l6.2,0.22l2.24,0.58l3.91,-2.1l0.2,-0.43l-0.35,-0.32l-5.64,-0.67l-8.73,0.36l-4.26,-1.9l-2.12,-2.4l-2.78,-1.66l-0.41,-1.52l3.31,-1.03l2.93,-0.2l4.91,-0.99l3.7,-2.27l2.87,0.3l2.62,1.67l0.56,-0.14l1.82,-3.2l3.13,-0.94l4.44,-0.69l7.53,-0.26l1.48,0.67l7.19,-1.06l10.8,0.79ZM203.85,57.54l0.01,0.42l1.97,2.97l0.68,-0.02l2.24,-3.72l5.95,-1.86l4.01,4.64l-0.35,2.91l0.5,0.43l4.95,-1.36l2.32,-1.8l5.31,2.28l3.27,2.11l0.3,1.84l0.48,0.33l4.42,-0.99l2.64,2.87l5.97,1.77l2.06,1.72l2.11,3.71l-4.19,1.86l-0.01,0.73l5.9,2.83l3.94,0.94l3.78,3.95l3.46,0.25l-0.63,2.37l-4.11,4.47l-2.76,-1.56l-3.9,-3.94l-3.59,0.41l-0.33,0.34l-0.19,2.72l2.63,2.38l3.42,1.89l0.94,0.97l1.55,3.75l-0.7,2.29l-2.74,-0.92l-6.25,-3.15l-0.51,0.13l0.05,0.52l6.07,5.69l0.18,0.59l-6.09,-1.39l-5.31,-2.24l-2.63,-1.66l0.6,-0.77l-0.12,-0.6l-7.39,-4.01l-0.59,0.37l0.03,0.79l-6.73,0.6l-1.69,-1.1l1.36,-2.46l4.51,-0.07l5.15,-0.52l0.31,-0.6l-0.74,-1.3l0.78,-1.84l3.21,-4.05l-0.67,-2.35l-1.11,-1.6l-3.84,-2.1l-4.35,-1.28l0.91,-0.63l0.06,-0.61l-2.65,-2.75l-2.34,-0.36l-1.89,-1.46l-0.53,0.03l-1.24,1.23l-4.36,0.55l-9.04,-0.99l-9.26,-1.98l-1.6,-1.22l2.22,-1.77l0.13,-0.44l-0.38,-0.27l-3.22,-0.02l-0.72,-4.25l1.83,-4.04l2.42,-1.85l5.5,-1.1l-1.39,2.35ZM261.19,159.33l2.07,0.61l1.44,-0.04l-1.15,0.63l-2.94,-1.23l-0.4,-0.68l0.36,-0.37l0.61,1.07ZM230.83,84.39l-2.37,0.18l-0.49,-1.63l0.93,-2.09l1.94,-0.51l1.62,0.99l0.02,1.52l-1.66,1.54ZM229.43,58.25l0.11,0.65l-4.87,-0.21l-2.72,0.62l-3.1,-2.57l0.08,-1.26l0.86,-0.23l5.57,0.51l4.08,2.5ZM222.0,105.02l-0.72,1.49l-0.63,-0.19l-0.48,-0.84l0.81,-0.99l0.65,0.05l0.37,0.46ZM183.74,38.32l2.9,1.7l4.79,-0.01l1.84,1.46l-0.49,1.68l0.23,0.48l2.82,1.14l1.76,1.26l7.01,0.65l4.1,-1.1l5.03,-0.43l3.93,0.35l2.48,1.77l0.46,1.7l-1.3,1.1l-3.56,1.01l-3.23,-0.59l-7.17,0.76l-5.09,0.09l-3.99,-0.6l-6.42,-1.54l-0.79,-2.51l-0.3,-2.49l-2.64,-2.5l-5.32,-0.72l-2.52,-1.4l0.68,-1.57l4.78,0.31ZM207.38,91.35l0.4,1.56l0.56,0.26l1.06,-0.52l1.32,0.96l5.42,2.57l0.2,1.68l0.46,0.35l1.68,-0.28l1.15,0.85l-1.55,0.87l-3.61,-0.88l-1.32,-1.69l-0.57,-0.06l-2.45,2.1l-3.12,1.79l-0.7,-1.87l-0.42,-0.26l-2.16,0.24l1.39,-1.39l0.32,-3.14l0.76,-3.35l1.18,0.22ZM215.49,102.6l-2.67,1.95l-1.4,-0.07l-0.3,-0.58l1.53,-1.48l2.84,0.18ZM202.7,24.12l2.53,1.59l-2.87,1.4l-4.53,4.05l-4.25,0.38l-5.03,-0.68l-2.45,-2.04l0.03,-1.62l1.82,-1.37l0.14,-0.45l-0.38,-0.27l-4.45,0.04l-2.59,-1.76l-1.41,-2.29l1.57,-2.32l1.62,-1.66l2.44,-0.39l0.25,-0.65l-0.6,-0.74l4.86,-0.25l3.24,3.11l8.16,2.3l1.9,3.61ZM187.47,59.2l-2.76,3.49l-2.38,-0.15l-1.44,-3.84l0.04,-2.2l1.19,-1.88l2.3,-1.23l5.07,0.17l4.11,1.02l-3.24,3.72l-2.88,0.89ZM186.07,48.79l-1.08,1.53l-3.34,-0.34l-2.56,-1.1l1.03,-1.75l3.25,-1.23l1.95,1.58l0.75,1.3ZM185.71,35.32l-5.3,-0.2l-0.32,-0.71l4.31,0.07l1.3,0.84ZM180.68,32.48l-3.34,1.0l-1.79,-1.1l-0.98,-1.87l-0.15,-1.73l4.1,0.53l2.67,1.7l-0.51,1.47ZM180.9,76.31l-1.1,1.08l-3.13,-1.23l-2.12,0.43l-2.71,-1.57l1.72,-1.09l1.55,-1.72l3.81,1.9l1.98,2.2ZM169.74,54.87l2.96,0.97l4.17,-0.57l0.41,0.88l-2.14,2.11l0.09,0.64l3.55,1.92l-0.4,3.72l-3.79,1.65l-2.17,-0.35l-1.72,-1.74l-6.02,-3.5l0.03,-0.85l4.68,0.54l0.4,-0.21l-0.05,-0.45l-2.48,-2.81l2.46,-1.95ZM174.45,40.74l1.37,1.73l0.07,2.44l-1.05,3.45l-3.79,0.47l-2.32,-0.69l0.05,-2.64l-0.44,-0.41l-3.68,0.35l-0.12,-3.1l2.45,0.1l3.67,-1.73l3.41,0.29l0.37,-0.26ZM170.05,31.55l0.67,1.56l-3.33,-0.49l-4.22,-1.77l-4.35,-0.16l1.4,-0.94l-0.06,-0.7l-2.81,-1.23l-0.12,-1.39l4.39,0.68l6.62,1.98l1.81,2.47ZM134.5,58.13l-1.02,1.82l0.45,0.58l5.4,-1.39l3.33,2.29l0.49,-0.03l2.6,-2.23l1.94,1.32l2.0,4.5l0.7,0.06l1.3,-2.29l-1.63,-4.46l1.69,-0.54l2.31,0.71l2.65,1.81l2.49,7.92l8.48,4.27l-0.19,1.35l-3.79,0.33l-0.26,0.67l1.4,1.49l-0.58,1.1l-4.23,-0.64l-4.43,-1.19l-3.0,0.28l-4.66,1.47l-10.52,1.04l-1.43,-2.02l-3.42,-1.2l-2.21,0.43l-2.51,-2.86l4.84,-1.05l3.6,0.19l3.27,-0.78l0.31,-0.39l-0.31,-0.39l-4.84,-1.06l-8.79,0.27l-0.85,-1.07l5.26,-1.66l0.27,-0.45l-0.4,-0.34l-3.8,0.06l-3.81,-1.06l1.81,-3.01l1.66,-1.79l6.48,-2.81l1.97,0.71ZM158.7,56.61l-1.7,2.44l-3.2,-2.75l0.37,-0.3l3.11,-0.18l1.42,0.79ZM149.61,42.73l1.01,1.89l0.5,0.18l2.14,-0.82l2.23,0.19l0.36,2.04l-1.33,2.09l-8.28,0.76l-6.35,2.15l-3.41,0.1l-0.19,-0.96l4.9,-2.08l0.23,-0.46l-0.41,-0.31l-11.25,0.59l-2.89,-0.74l3.04,-4.44l2.14,-1.32l6.81,1.69l4.58,3.06l4.37,0.39l0.36,-0.63l-3.36,-4.6l1.85,-1.53l2.18,0.51l0.77,2.26ZM144.76,34.41l-4.36,1.44l-3.0,-1.4l1.46,-1.24l3.47,-0.52l2.96,0.71l-0.52,1.01ZM145.13,29.83l-1.9,0.66l-3.67,-0.0l2.27,-1.61l3.3,0.95ZM118.92,65.79l-6.03,2.02l-1.33,-1.9l-5.38,-2.28l2.59,-5.05l2.16,-3.14l-0.02,-0.48l-1.97,-2.41l7.64,-0.7l3.6,1.02l6.3,0.27l4.42,2.95l-2.53,0.98l-6.24,3.43l-3.1,3.28l-0.11,2.01ZM129.54,35.53l-0.28,3.37l-1.72,1.62l-2.33,0.28l-4.61,2.19l-3.86,0.76l-2.64,-0.87l3.72,-3.4l5.01,-3.34l3.72,0.07l3.0,-0.67ZM111.09,152.69l-0.67,0.24l-3.85,-1.37l-0.83,-1.17l-2.12,-1.07l-0.66,-1.02l-2.4,-0.55l-0.74,-1.71l6.02,1.45l2.0,2.55l2.52,1.39l0.73,1.27ZM87.8,134.64l0.89,0.29l1.86,-0.21l-0.65,3.34l1.69,2.33l-1.31,-1.33l-0.99,-1.62l-1.17,-0.98l-0.33,-1.82Z",
      name: "Canada"
    },
    CG: {
      path: "M466.72,276.48l-0.1,1.03l-1.25,2.97l-0.19,3.62l-0.46,1.78l-0.23,0.63l-1.61,1.19l-1.21,1.39l-1.09,2.43l0.04,2.09l-3.25,3.24l-0.5,-0.24l-0.5,-0.83l-1.36,-0.02l-0.98,0.89l-1.68,-0.99l-1.54,1.24l-1.52,-1.96l1.57,-1.14l0.11,-0.52l-0.77,-1.35l2.1,-0.66l0.39,-0.73l1.05,0.82l2.21,0.11l1.12,-1.37l0.37,-1.81l-0.27,-2.09l-1.13,-1.5l1.0,-2.69l-0.13,-0.45l-0.92,-0.58l-1.6,0.17l-0.51,-0.94l0.1,-0.61l2.75,0.09l3.97,1.24l0.51,-0.33l0.17,-1.28l1.24,-2.21l1.28,-1.14l2.76,0.49Z",
      name: "Congo"
    },
    CF: {
      path: "M461.16,278.2l-0.26,-1.19l-1.09,-0.77l-0.84,-1.17l-0.29,-1.0l-1.04,-1.15l0.08,-3.43l0.58,-0.49l1.16,-2.35l1.85,-0.17l0.61,-0.62l0.97,0.58l3.15,-0.96l2.48,-1.92l0.02,-0.96l2.81,0.02l2.36,-1.17l1.93,-2.85l1.16,-0.93l1.11,-0.3l0.27,0.86l1.34,1.47l-0.39,2.01l0.3,1.01l4.01,2.75l0.17,0.93l2.63,2.31l0.6,1.44l2.08,1.4l-3.84,-0.21l-1.94,0.88l-1.23,-0.49l-2.67,1.2l-1.29,-0.18l-0.51,0.36l-0.6,1.22l-3.35,-0.65l-1.57,-0.91l-2.42,-0.83l-1.45,0.91l-0.97,1.27l-0.26,1.56l-3.22,-0.43l-1.49,1.33l-0.94,1.62Z",
      name: "Central African Rep."
    },
    CD: {
      path: "M487.01,272.38l2.34,-0.14l1.35,1.84l1.34,0.45l0.86,-0.39l1.21,0.12l1.07,-0.41l0.54,0.89l2.04,1.54l-0.14,2.72l0.7,0.54l-1.38,1.13l-1.53,2.54l-0.17,2.05l-0.59,1.08l-0.02,1.72l-0.72,0.84l-0.66,3.01l0.63,1.32l-0.44,4.26l0.64,1.47l-0.37,1.22l0.86,1.8l1.53,1.41l0.3,1.26l0.44,0.5l-4.08,0.75l-0.92,1.81l0.51,1.34l-0.74,5.43l0.17,0.38l2.45,1.46l0.54,-0.1l0.12,1.62l-1.28,-0.01l-1.85,-2.35l-1.94,-0.45l-0.48,-1.13l-0.55,-0.2l-1.41,0.74l-1.71,-0.3l-1.01,-1.18l-2.49,-0.19l-0.44,-0.77l-1.98,-0.21l-2.88,0.36l0.11,-2.41l-0.85,-1.13l-0.16,-1.36l0.32,-1.73l-0.46,-0.89l-0.04,-1.49l-0.4,-0.39l-2.53,0.02l0.1,-0.41l-0.39,-0.49l-1.28,0.01l-0.43,0.45l-1.62,0.32l-0.83,1.79l-1.09,-0.28l-2.4,0.52l-1.37,-1.91l-1.3,-3.3l-0.38,-0.27l-7.39,-0.03l-2.46,0.42l0.5,-0.45l0.37,-1.47l0.66,-0.38l0.92,0.08l0.73,-0.82l0.87,0.02l0.31,0.68l1.4,0.36l3.59,-3.63l0.01,-2.23l1.02,-2.29l2.69,-2.39l0.43,-0.99l0.49,-1.96l0.17,-3.51l1.25,-2.95l0.36,-3.14l0.86,-1.13l1.1,-0.66l3.57,1.73l3.65,0.73l0.46,-0.21l0.8,-1.46l1.24,0.19l2.61,-1.17l0.81,0.44l1.04,-0.03l0.59,-0.66l0.7,-0.16l1.81,0.25Z",
      name: "Dem. Rep. Congo"
    },
    CZ: {
      path: "M458.46,144.88l1.22,1.01l1.47,0.23l0.13,0.93l1.36,0.68l0.54,-0.2l0.24,-0.55l1.15,0.25l0.53,1.09l1.68,0.18l0.6,0.84l-1.04,0.73l-0.96,1.28l-1.6,0.17l-0.55,0.56l-1.04,-0.46l-1.05,0.15l-2.12,-0.96l-1.05,0.34l-1.2,1.12l-1.56,-0.87l-2.57,-2.1l-0.53,-1.88l4.7,-2.52l0.71,0.26l0.9,-0.28Z",
      name: "Czech Rep."
    },
    CY: {
      path: "M504.36,193.47l0.43,0.28l-1.28,0.57l-0.92,-0.28l-0.24,-0.46l2.01,-0.13Z",
      name: "Cyprus"
    },
    CR: {
      path: "M211.34,258.05l0.48,0.99l1.6,1.6l-0.54,0.45l0.29,1.42l-0.25,1.19l-1.09,-0.59l-0.05,-1.25l-2.46,-1.42l-0.28,-0.77l-0.66,-0.45l-0.45,-0.0l-0.11,1.04l-1.32,-0.95l0.31,-1.3l-0.36,-0.6l0.31,-0.27l1.42,0.58l1.29,-0.14l0.56,0.56l0.74,0.17l0.55,-0.27Z",
      name: "Costa Rica"
    },
    CU: {
      path: "M221.21,227.25l1.27,1.02l2.19,-0.28l4.43,3.33l2.08,0.43l-0.1,0.38l0.36,0.5l1.75,0.1l1.48,0.84l-3.11,0.51l-4.15,-0.03l0.77,-0.67l-0.04,-0.64l-1.2,-0.74l-1.49,-0.16l-0.7,-0.61l-0.56,-1.4l-0.4,-0.25l-1.34,0.1l-2.2,-0.66l-0.88,-0.58l-3.18,-0.4l-0.27,-0.16l0.58,-0.74l-0.36,-0.29l-2.72,-0.05l-1.7,1.29l-0.91,0.03l-0.61,0.69l-1.01,0.22l1.11,-1.29l1.01,-0.52l3.69,-1.01l3.98,0.21l2.21,0.84Z",
      name: "Cuba"
    },
    SZ: {
      path: "M500.35,351.36l0.5,2.04l-0.38,0.89l-1.05,0.21l-1.23,-1.2l-0.02,-0.64l0.83,-1.57l1.34,0.27Z",
      name: "Swaziland"
    },
    SY: {
      path: "M511.0,199.79l0.05,-1.33l0.54,-1.36l1.28,-0.99l0.13,-0.45l-0.41,-1.11l-1.14,-0.36l-0.19,-1.74l0.52,-1.0l1.29,-1.21l0.2,-1.18l0.59,0.23l2.62,-0.76l1.36,0.52l2.06,-0.01l2.95,-1.08l3.25,-0.26l-0.67,0.94l-1.28,0.66l-0.21,0.4l0.23,2.01l-0.88,3.19l-10.15,5.73l-2.15,-0.85Z",
      name: "Syria"
    },
    KG: {
      path: "M621.35,172.32l-3.87,1.69l-0.96,1.18l-3.04,0.34l-1.13,1.86l-2.36,-0.35l-1.99,0.63l-2.39,1.4l0.06,0.95l-0.4,0.37l-4.52,0.43l-3.02,-0.93l-2.37,0.17l0.11,-0.79l2.32,0.42l1.13,-0.88l1.99,0.2l3.21,-2.14l-0.03,-0.69l-2.97,-1.57l-1.94,0.65l-1.22,-0.74l1.71,-1.58l-0.12,-0.67l-0.36,-0.15l0.32,-0.77l1.36,-0.35l4.02,1.02l0.49,-0.3l0.35,-1.59l1.09,-0.48l3.42,1.22l1.11,-0.31l7.64,0.39l1.16,1.0l1.23,0.39Z",
      name: "Kyrgyzstan"
    },
    KE: {
      path: "M506.26,284.69l1.87,-2.56l0.93,-2.15l-1.38,-4.08l-1.06,-1.6l2.82,-2.75l0.79,0.26l0.12,1.41l0.86,0.83l1.9,0.11l3.28,2.13l3.57,0.44l1.05,-1.12l1.96,-0.9l0.82,0.68l1.16,0.09l-1.78,2.45l0.03,9.12l1.3,1.94l-1.37,0.78l-0.67,1.03l-1.08,0.46l-0.34,1.67l-0.81,1.07l-0.45,1.55l-0.68,0.56l-3.2,-2.23l-0.35,-1.58l-8.86,-4.98l0.14,-1.6l-0.57,-1.04Z",
      name: "Kenya"
    },
    SS: {
      path: "M481.71,263.34l1.07,-0.72l1.2,-3.18l1.36,-0.26l1.61,1.99l0.87,0.34l1.1,-0.41l1.5,0.07l0.57,0.53l2.49,0.0l0.44,-0.63l1.07,-0.4l0.45,-0.84l0.59,-0.33l1.9,1.33l1.6,-0.2l2.83,-3.33l-0.32,-2.21l1.59,-0.52l-0.24,1.6l0.3,1.83l1.35,1.18l0.2,1.87l0.35,0.41l0.02,1.53l-0.23,0.47l-1.42,0.25l-0.85,1.44l0.3,0.6l1.4,0.16l1.11,1.08l0.59,1.13l1.03,0.53l1.28,2.36l-4.41,3.98l-1.74,0.01l-1.89,0.55l-1.47,-0.52l-1.15,0.57l-2.96,-2.62l-1.3,0.49l-1.06,-0.15l-0.79,0.39l-0.82,-0.22l-1.8,-2.7l-1.91,-1.1l-0.66,-1.5l-2.62,-2.32l-0.18,-0.94l-2.37,-1.6Z",
      name: "S. Sudan"
    },
    SR: {
      path: "M283.12,270.19l2.1,0.53l-1.08,1.95l0.2,1.72l0.93,1.49l-0.59,2.03l-0.43,0.71l-1.12,-0.42l-1.32,0.22l-0.93,-0.2l-0.46,0.26l-0.25,0.73l0.33,0.7l-0.89,-0.13l-1.39,-1.97l-0.31,-1.34l-0.97,-0.31l-0.89,-1.47l0.35,-1.61l1.45,-0.82l0.33,-1.87l2.61,0.44l0.57,-0.47l1.75,-0.16Z",
      name: "Suriname"
    },
    KH: {
      path: "M689.52,249.39l0.49,1.45l-0.28,2.74l-4.0,1.86l-0.16,0.6l0.68,0.95l-2.06,0.17l-2.05,0.97l-1.82,-0.32l-2.12,-3.7l-0.55,-2.85l1.4,-1.85l3.02,-0.45l2.23,0.35l2.01,0.98l0.51,-0.14l0.95,-1.48l1.74,0.74Z",
      name: "Cambodia"
    },
    SV: {
      path: "M195.8,250.13l1.4,-1.19l2.24,1.45l0.98,-0.27l0.44,0.2l-0.27,1.05l-1.14,-0.03l-3.64,-1.21Z",
      name: "El Salvador"
    },
    SK: {
      path: "M476.82,151.17l-1.14,1.9l-2.73,-0.92l-0.82,0.2l-0.74,0.8l-3.46,0.73l-0.47,0.69l-1.76,0.33l-1.88,-1.0l-0.18,-0.81l0.38,-0.75l1.87,-0.32l1.74,-1.89l0.83,0.16l0.79,-0.34l1.51,1.04l1.34,-0.63l1.25,0.3l1.65,-0.42l1.81,0.95Z",
      name: "Slovakia"
    },
    KR: {
      path: "M737.51,185.84l0.98,-0.1l0.87,-1.17l2.69,-0.32l0.33,-0.29l1.76,2.79l0.58,1.76l0.02,3.12l-0.8,1.32l-2.21,0.55l-1.93,1.13l-1.8,0.19l-0.2,-1.1l0.43,-2.28l-0.95,-2.56l1.43,-0.37l0.23,-0.62l-1.43,-2.06Z",
      name: "Korea"
    },
    SI: {
      path: "M456.18,162.07l-0.51,-1.32l0.18,-1.05l1.69,0.2l1.42,-0.71l2.09,-0.07l0.62,-0.51l0.21,0.47l-1.61,0.67l-0.44,1.34l-0.66,0.24l-0.26,0.82l-1.22,-0.49l-0.84,0.46l-0.69,-0.04Z",
      name: "Slovenia"
    },
    KP: {
      path: "M736.77,185.16l-0.92,-0.42l-0.88,0.62l-1.21,-0.88l0.96,-1.15l0.59,-2.59l-0.46,-0.74l-2.09,-0.77l1.64,-1.52l2.72,-1.58l1.58,-1.91l1.11,0.78l2.17,0.11l0.41,-0.5l-0.3,-1.22l3.52,-1.18l0.94,-1.4l0.98,1.08l-2.19,2.18l0.01,2.14l-1.06,0.54l-1.41,1.4l-1.7,0.52l-1.25,1.09l-0.14,1.98l0.94,0.45l1.15,1.04l-0.13,0.26l-2.6,0.29l-1.13,1.29l-1.22,0.08Z",
      name: "Dem. Rep. Korea"
    },
    SO: {
      path: "M525.13,288.48l-1.13,-1.57l-0.03,-8.86l2.66,-3.38l1.67,-0.13l2.13,-1.69l3.41,-0.23l7.08,-7.55l2.91,-3.69l0.08,-4.82l2.98,-0.67l1.24,-0.86l0.45,-0.0l-0.2,3.0l-1.21,3.62l-2.73,5.97l-2.13,3.65l-5.03,6.16l-8.56,6.4l-2.78,3.08l-0.8,1.56Z",
      name: "Somalia"
    },
    SN: {
      path: "M390.09,248.21l0.12,1.55l0.49,1.46l0.96,0.82l0.05,1.28l-1.26,-0.19l-0.75,0.33l-1.84,-0.61l-5.84,-0.13l-2.54,0.51l-0.22,-1.03l1.77,0.04l2.01,-0.91l1.03,0.48l1.09,0.04l1.29,-0.62l0.14,-0.58l-0.51,-0.74l-1.81,0.25l-1.13,-0.63l-0.79,0.04l-0.72,0.61l-2.31,0.06l-0.92,-1.77l-0.81,-0.64l0.64,-0.35l2.46,-3.74l1.04,0.19l1.38,-0.56l1.19,-0.02l2.72,1.37l3.03,3.48Z",
      name: "Senegal"
    },
    SL: {
      path: "M394.46,264.11l-1.73,1.98l-0.58,1.33l-2.07,-1.06l-1.22,-1.26l-0.65,-2.39l1.16,-0.96l0.67,-1.17l1.21,-0.52l1.66,0.0l1.03,1.64l0.52,2.41Z",
      name: "Sierra Leone"
    },
    SB: {
      path: "M826.69,311.6l-0.61,0.09l-0.2,-0.33l0.37,0.15l0.44,0.09ZM824.18,307.38l-0.26,-0.3l-0.31,-0.91l0.03,0.0l0.54,1.21ZM823.04,309.33l-1.66,-0.22l-0.2,-0.52l1.16,0.28l0.69,0.46ZM819.28,304.68l1.14,0.65l0.02,0.03l-0.81,-0.44l-0.35,-0.23Z",
      name: "Solomon Is."
    },
    SA: {
      path: "M537.53,210.34l2.0,0.24l0.9,1.32l1.49,-0.06l0.87,2.08l1.29,0.76l0.51,0.99l1.56,1.03l-0.1,1.9l0.32,0.9l1.58,2.47l0.76,0.53l0.7,-0.04l1.68,4.23l7.53,1.33l0.51,-0.29l0.77,1.25l-1.55,4.87l-7.29,2.52l-7.3,1.03l-2.34,1.17l-1.88,2.74l-0.76,0.28l-0.82,-0.78l-0.91,0.12l-2.88,-0.51l-3.51,0.25l-0.86,-0.56l-0.57,0.15l-0.66,1.27l0.16,1.11l-0.43,0.32l-0.93,-1.4l-0.33,-1.16l-1.23,-0.88l-1.27,-2.06l-0.78,-2.22l-1.73,-1.79l-1.14,-0.48l-1.54,-2.31l-0.21,-3.41l-1.44,-2.93l-1.27,-1.16l-1.33,-0.57l-1.31,-3.37l-0.77,-0.67l-0.97,-1.97l-2.8,-4.03l-1.06,-0.17l0.37,-1.96l0.2,-0.72l2.74,0.3l1.08,-0.84l0.6,-0.94l1.74,-0.35l0.65,-1.03l0.71,-0.4l0.1,-0.62l-2.06,-2.28l4.39,-1.22l0.48,-0.37l2.77,0.69l3.66,1.9l7.03,5.5l4.87,0.3Z",
      name: "Saudi Arabia"
    },
    SE: {
      path: "M480.22,89.3l-4.03,1.17l-2.43,2.86l0.26,2.57l-8.77,6.64l-1.78,5.79l1.78,2.68l2.22,1.96l-2.07,3.77l-2.72,1.13l-0.95,6.04l-1.29,3.01l-2.74,-0.31l-0.4,0.22l-1.31,2.59l-2.34,0.13l-0.75,-3.09l-2.08,-4.03l-1.83,-4.96l1.0,-1.93l2.14,-2.7l0.83,-4.45l-1.6,-2.17l-0.15,-4.94l1.48,-3.39l2.58,-0.15l0.87,-1.59l-0.78,-1.57l3.76,-5.59l4.04,-7.48l2.17,0.01l0.39,-0.29l0.57,-2.07l4.37,0.64l0.46,-0.34l0.33,-2.56l1.1,-0.13l6.94,4.87l0.06,6.32l0.66,1.36Z",
      name: "Sweden"
    },
    SD: {
      path: "M505.98,259.4l-0.34,-0.77l-1.17,-0.9l-0.26,-1.61l0.29,-1.81l-0.34,-0.46l-1.16,-0.17l-0.54,0.59l-1.23,0.11l-0.28,0.65l0.53,0.65l0.17,1.22l-2.44,3.0l-0.96,0.19l-2.39,-1.4l-0.95,0.52l-0.38,0.78l-1.11,0.41l-0.29,0.5l-1.94,0.0l-0.54,-0.52l-1.81,-0.09l-0.95,0.4l-2.45,-2.35l-2.07,0.54l-0.73,1.26l-0.6,2.1l-1.25,0.58l-0.75,-0.62l0.27,-2.65l-1.48,-1.78l-0.22,-1.48l-0.92,-0.96l-0.02,-1.29l-0.57,-1.16l-0.68,-0.16l0.69,-1.29l-0.18,-1.14l0.65,-0.62l0.03,-0.55l-0.36,-0.41l1.55,-2.97l1.91,0.16l0.43,-0.4l-0.1,-10.94l2.49,-0.01l0.4,-0.4l-0.0,-4.82l29.02,0.0l0.64,2.04l-0.49,0.66l0.36,2.69l0.93,3.16l2.12,1.55l-0.89,1.04l-1.72,0.39l-0.98,0.9l-1.43,5.65l0.24,1.15l-0.38,2.06l-0.96,2.38l-1.53,1.31l-1.32,2.91l-1.22,0.86l-0.37,1.34Z",
      name: "Sudan"
    },
    DO: {
      path: "M241.8,239.2l0.05,-0.65l-0.46,-0.73l0.42,-0.44l0.19,-1.0l-0.09,-1.53l1.66,0.01l1.99,0.63l0.33,0.67l1.28,0.19l0.33,0.76l1.0,0.08l0.8,0.62l-0.45,0.51l-1.13,-0.47l-1.88,-0.01l-1.27,0.59l-0.75,-0.55l-1.01,0.54l-0.79,1.4l-0.23,-0.61Z",
      name: "Dominican Rep."
    },
    DJ: {
      path: "M528.43,256.18l-0.45,0.66l-0.58,-0.25l-1.51,0.13l-0.18,-1.01l1.45,-1.95l0.83,0.17l0.77,-0.44l0.2,1.0l-1.2,0.51l-0.06,0.7l0.73,0.47Z",
      name: "Djibouti"
    },
    DK: {
      path: "M452.28,129.07l-1.19,2.24l-2.13,-1.6l-0.23,-0.95l2.98,-0.95l0.57,1.26ZM447.74,126.31l-0.26,0.57l-0.88,-0.07l-1.8,2.53l0.48,1.69l-1.09,0.36l-1.61,-0.39l-0.89,-1.69l-0.07,-3.43l0.96,-1.73l2.02,-0.2l1.09,-1.07l1.33,-0.67l-0.05,1.06l-0.73,1.41l0.3,1.0l1.2,0.64Z",
      name: "Denmark"
    },
    DE: {
      path: "M453.14,155.55l-0.55,-0.36l-1.2,-0.1l-1.87,0.57l-2.13,-0.13l-0.56,0.63l-0.86,-0.6l-0.96,0.09l-2.57,-0.93l-0.85,0.67l-1.47,-0.02l0.24,-1.75l1.23,-2.14l-0.28,-0.59l-3.52,-0.58l-0.92,-0.66l0.12,-1.2l-0.48,-0.88l0.27,-2.17l-0.37,-3.03l1.41,-0.22l0.63,-1.26l0.66,-3.19l-0.41,-1.18l0.26,-0.39l1.66,-0.15l0.33,0.54l0.62,0.07l1.7,-1.69l-0.54,-3.02l1.37,0.33l1.31,-0.37l0.31,1.18l2.25,0.71l-0.02,0.92l0.5,0.4l2.55,-0.65l1.34,-0.87l2.57,1.24l1.06,0.98l0.48,1.44l-0.57,0.74l-0.0,0.48l0.87,1.15l0.57,1.64l-0.14,1.29l0.82,1.7l-1.5,-0.07l-0.56,0.57l-4.47,2.15l-0.22,0.54l0.68,2.26l2.58,2.16l-0.66,1.11l-0.79,0.36l-0.23,0.43l0.32,1.87Z",
      name: "Germany"
    },
    YE: {
      path: "M528.27,246.72l0.26,-0.42l-0.22,-1.01l0.19,-1.5l0.92,-0.69l-0.07,-1.35l0.39,-0.75l1.01,0.47l3.34,-0.27l3.76,0.41l0.95,0.81l1.36,-0.58l1.74,-2.62l2.18,-1.09l6.86,-0.94l2.48,5.41l-1.64,0.76l-0.56,1.9l-6.23,2.16l-2.29,1.8l-1.93,0.05l-1.41,1.02l-4.24,0.74l-1.72,1.49l-3.28,0.19l-0.52,-1.18l0.02,-1.51l-1.34,-3.29Z",
      name: "Yemen"
    },
    AT: {
      path: "M462.89,152.8l0.04,2.25l-1.07,0.0l-0.33,0.63l0.36,0.51l-1.04,2.13l-2.02,0.07l-1.33,0.7l-5.29,-0.99l-0.47,-0.93l-0.44,-0.21l-2.47,0.55l-0.42,0.51l-3.18,-0.81l0.43,-0.91l1.12,0.78l0.6,-0.17l0.25,-0.58l1.93,0.12l1.86,-0.56l1.0,0.08l0.68,0.57l0.62,-0.15l0.26,-0.77l-0.3,-1.78l0.8,-0.44l0.68,-1.15l1.52,0.85l0.47,-0.06l1.34,-1.25l0.64,-0.17l1.81,0.92l1.28,-0.11l0.7,0.37Z",
      name: "Austria"
    },
    DZ: {
      path: "M441.46,188.44l-0.32,1.07l0.39,2.64l-0.54,2.16l-1.58,1.82l0.37,2.39l1.91,1.55l0.18,0.8l1.42,1.03l1.84,7.23l0.12,1.16l-0.57,5.0l0.2,1.51l-0.87,0.99l-0.02,0.51l1.41,1.86l0.14,1.2l0.89,1.48l0.5,0.16l0.98,-0.41l1.73,1.08l0.82,1.23l-8.22,4.81l-7.23,5.11l-3.43,1.13l-2.3,0.21l-0.28,-1.59l-2.56,-1.09l-0.67,-1.25l-26.12,-17.86l0.01,-3.47l3.77,-1.88l2.44,-0.41l2.12,-0.75l1.08,-1.42l2.81,-1.05l0.35,-2.08l1.33,-0.29l1.04,-0.94l3.47,-0.69l0.46,-1.08l-0.1,-0.45l-0.58,-0.52l-0.82,-2.81l-0.19,-1.83l-0.78,-1.49l2.03,-1.31l2.63,-0.48l1.7,-1.22l2.31,-0.84l8.24,-0.73l1.49,0.38l2.28,-1.1l2.46,-0.02l0.92,0.6l1.35,-0.05Z",
      name: "Algeria"
    },
    US: {
      path: "M892.72,99.2l1.31,0.53l1.41,-0.37l1.89,0.98l1.89,0.42l-1.32,0.58l-2.9,-1.53l-2.08,0.22l-0.26,-0.15l0.07,-0.67ZM183.22,150.47l0.37,1.47l1.12,0.85l4.23,0.7l2.39,0.98l2.17,-0.38l1.85,0.5l-1.55,0.65l-3.49,2.61l-0.16,0.77l0.5,0.39l2.33,-0.61l1.77,1.02l5.15,-2.4l-0.31,0.65l0.25,0.56l1.36,0.38l1.71,1.16l4.7,-0.88l0.67,0.85l1.31,0.21l0.58,0.58l-1.34,0.17l-2.18,-0.32l-3.6,0.89l-2.71,3.25l0.35,0.9l0.59,-0.0l0.55,-0.6l-1.36,4.65l0.29,3.09l0.67,1.58l0.61,0.45l1.77,-0.44l1.6,-1.96l0.14,-2.21l-0.82,-1.96l0.11,-1.13l1.19,-2.37l0.44,-0.33l0.48,0.75l0.4,-0.29l0.4,-1.37l0.6,-0.47l0.24,-0.8l1.69,0.49l1.65,1.08l-0.03,2.37l-1.27,1.13l-0.0,1.13l0.87,0.36l1.66,-1.29l0.5,0.17l0.5,2.6l-2.49,3.75l0.17,0.61l1.54,0.62l1.48,0.17l1.92,-0.44l4.72,-2.15l2.16,-1.8l-0.05,-1.24l0.75,-0.22l3.92,0.36l2.12,-1.05l0.21,-0.4l-0.28,-1.48l3.27,-2.4l8.32,-0.02l0.56,-0.82l1.9,-0.77l0.93,-1.51l0.74,-2.37l1.58,-1.98l0.92,0.62l1.47,-0.47l0.8,0.66l-0.0,4.09l1.96,2.6l-2.34,1.31l-5.37,2.09l-1.83,2.72l0.02,1.79l0.83,1.59l0.54,0.23l-6.19,0.94l-2.2,0.89l-0.23,0.48l0.45,0.29l2.99,-0.46l-2.19,0.56l-1.13,0.0l-0.15,-0.32l-0.48,0.08l-0.76,0.82l0.22,0.67l0.32,0.06l-0.41,1.62l-1.27,1.58l-1.48,-1.07l-0.49,-0.04l-0.16,0.46l0.52,1.58l0.61,0.59l0.03,0.79l-0.95,1.38l-1.21,-1.22l-0.27,-2.27l-0.35,-0.35l-0.42,0.25l-0.48,1.27l0.33,1.41l-0.97,-0.27l-0.48,0.24l0.18,0.5l1.52,0.83l0.1,2.52l0.79,0.51l0.52,3.42l-1.42,1.88l-2.47,0.8l-1.71,1.66l-1.31,0.25l-1.27,1.03l-0.43,0.99l-2.69,1.78l-2.64,3.03l-0.45,2.12l0.45,2.08l0.85,2.38l1.09,1.9l0.04,1.2l1.16,3.06l-0.18,2.69l-0.55,1.43l-0.47,0.21l-0.89,-0.23l-0.49,-1.18l-0.87,-0.56l-2.75,-5.16l0.48,-1.68l-0.72,-1.78l-2.01,-2.38l-1.12,-0.53l-2.72,1.18l-1.47,-1.35l-1.57,-0.68l-2.99,0.31l-2.17,-0.3l-2.0,0.19l-1.15,0.46l-0.19,0.58l0.39,0.63l0.14,1.34l-0.84,-0.2l-0.84,0.46l-1.58,-0.07l-2.08,-1.44l-2.09,0.33l-1.91,-0.62l-3.73,0.84l-2.39,2.07l-2.54,1.22l-1.45,1.41l-0.61,1.38l0.34,3.71l-0.29,0.02l-3.5,-1.33l-1.25,-3.11l-1.44,-1.5l-2.24,-3.56l-1.76,-1.09l-2.27,-0.01l-1.71,2.07l-1.76,-0.69l-1.16,-0.74l-1.52,-2.98l-3.93,-3.16l-4.34,-0.0l-0.4,0.4l-0.0,0.74l-6.5,0.02l-9.02,-3.14l-0.34,-0.71l-5.7,0.49l-0.43,-1.29l-1.62,-1.61l-1.14,-0.38l-0.55,-0.88l-1.28,-0.13l-1.01,-0.77l-2.22,-0.27l-0.43,-0.3l-0.36,-1.58l-2.4,-2.83l-2.01,-3.85l-0.06,-0.9l-2.92,-3.26l-0.33,-2.29l-1.3,-1.66l0.52,-2.37l-0.09,-2.57l-0.78,-2.3l0.95,-2.82l0.61,-5.68l-0.47,-4.27l-1.46,-4.08l3.19,0.79l1.26,2.83l0.69,0.08l0.69,-1.14l-1.1,-4.79l68.76,-0.0l0.4,-0.4l0.14,-0.86ZM32.44,67.52l1.73,1.97l0.55,0.05l0.99,-0.79l3.65,0.24l-0.09,0.62l0.32,0.45l3.83,0.77l2.61,-0.43l5.19,1.4l4.84,0.43l1.89,0.57l3.42,-0.7l6.14,1.87l-0.03,38.06l0.38,0.4l2.39,0.11l2.31,0.98l3.9,3.99l0.55,0.04l2.4,-2.03l2.16,-1.04l1.2,1.71l3.95,3.14l4.09,6.63l4.2,2.29l0.06,1.83l-1.02,1.23l-1.16,-1.08l-2.04,-1.03l-0.67,-2.89l-3.28,-3.03l-1.65,-3.57l-6.35,-0.32l-2.82,-1.01l-5.26,-3.85l-6.77,-2.04l-3.53,0.3l-4.81,-1.69l-3.25,-1.63l-2.78,0.8l-0.28,0.46l0.44,2.21l-3.91,0.96l-2.26,1.27l-2.3,0.65l-0.27,-1.65l1.05,-3.42l2.49,-1.09l0.16,-0.6l-0.69,-0.96l-0.55,-0.1l-3.19,2.12l-1.78,2.56l-3.55,2.61l-0.04,0.61l1.56,1.52l-2.07,2.29l-5.11,2.57l-0.77,1.66l-3.76,1.77l-0.92,1.73l-2.69,1.38l-1.81,-0.22l-6.95,3.32l-3.97,0.91l4.85,-2.5l2.59,-1.86l3.26,-0.52l1.19,-1.4l3.42,-2.1l2.59,-2.27l0.42,-2.68l1.23,-2.1l-0.04,-0.46l-0.45,-0.11l-2.68,1.03l-0.63,-0.49l-0.53,0.03l-1.05,1.04l-1.36,-1.54l-0.66,0.08l-0.32,0.62l-0.58,-1.14l-0.56,-0.16l-2.41,1.42l-1.07,-0.0l-0.17,-1.75l0.3,-1.71l-1.61,-1.33l-3.41,0.59l-1.96,-1.63l-1.57,-0.84l-0.15,-2.21l-1.7,-1.43l0.82,-1.88l1.99,-2.12l0.88,-1.92l1.71,-0.24l2.04,0.51l1.87,-1.77l1.91,0.25l1.91,-1.23l0.17,-0.43l-0.47,-1.82l-1.07,-0.7l1.39,-1.17l0.12,-0.45l-0.39,-0.26l-1.65,0.07l-2.66,0.88l-0.75,0.78l-1.92,-0.8l-3.46,0.44l-3.44,-0.91l-1.06,-1.61l-2.65,-1.99l2.91,-1.43l5.5,-2.0l1.52,0.0l-0.26,1.62l0.41,0.46l5.29,-0.16l0.3,-0.65l-2.03,-2.59l-3.14,-1.68l-1.79,-2.12l-2.4,-1.83l-3.09,-1.24l1.04,-1.69l4.23,-0.14l3.36,-2.07l0.73,-2.27l2.39,-1.99l2.42,-0.52l4.65,-1.97l2.46,0.23l3.71,-2.35l3.5,0.89ZM37.6,123.41l-2.25,1.23l-0.95,-0.69l-0.29,-1.24l3.21,-1.63l1.42,0.21l0.67,0.7l-1.8,1.42ZM31.06,234.03l0.98,0.47l0.74,0.87l-1.77,1.07l-0.44,-1.53l0.49,-0.89ZM29.34,232.07l0.18,0.05l0.08,0.05l-0.16,0.03l-0.11,-0.14ZM25.16,230.17l0.05,-0.03l0.18,0.22l-0.13,-0.01l-0.1,-0.18ZM5.89,113.26l-1.08,0.41l-2.21,-1.12l1.53,-0.4l1.62,0.28l0.14,0.83Z",
      name: "United States"
    },
    LV: {
      path: "M489.16,122.85l0.96,0.66l0.22,1.65l0.68,1.76l-3.65,1.7l-2.23,-1.58l-1.29,-0.26l-0.68,-0.77l-2.42,0.34l-4.16,-0.23l-2.47,0.9l0.06,-1.98l1.13,-2.06l1.95,-1.02l2.12,2.58l2.01,-0.07l0.38,-0.33l0.44,-2.52l1.76,-0.53l3.06,1.7l2.15,0.07Z",
      name: "Latvia"
    },
    UY: {
      path: "M286.85,372.74l-0.92,1.5l-2.59,1.44l-1.69,-0.52l-1.42,0.26l-2.39,-1.19l-1.52,0.08l-1.27,-1.3l0.16,-1.5l0.56,-0.79l-0.02,-2.73l1.21,-4.74l1.19,-0.21l2.37,2.0l1.08,0.03l4.36,3.17l1.22,1.6l-0.96,1.5l0.61,1.4Z",
      name: "Uruguay"
    },
    LB: {
      path: "M510.37,198.01l-0.88,0.51l1.82,-3.54l0.62,0.08l0.22,0.61l-1.13,0.88l-0.65,1.47Z",
      name: "Lebanon"
    },
    LA: {
      path: "M689.54,248.53l-1.76,-0.74l-0.49,0.15l-0.94,1.46l-1.32,-0.64l0.62,-0.98l0.11,-2.17l-2.04,-2.42l-0.25,-2.65l-1.9,-2.1l-2.15,-0.31l-0.78,0.91l-1.12,0.06l-1.05,-0.4l-2.06,1.2l-0.04,-1.59l0.61,-2.68l-0.36,-0.49l-1.35,-0.1l-0.11,-1.23l-0.96,-0.88l1.96,-1.89l0.39,0.36l1.33,0.07l0.42,-0.45l-0.34,-2.66l0.7,-0.21l1.28,1.81l1.11,2.35l0.36,0.23l2.82,0.02l0.71,1.67l-1.39,0.65l-0.72,0.93l0.13,0.6l2.91,1.51l3.6,5.25l1.88,1.78l0.56,1.62l-0.35,1.96Z",
      name: "Lao PDR"
    },
    TW: {
      path: "M724.01,226.68l-0.74,1.48l-0.9,-1.52l-0.25,-1.74l1.38,-2.44l1.73,-1.74l0.64,0.44l-1.85,5.52Z",
      name: "Taiwan"
    },
    TT: {
      path: "M266.64,259.32l0.28,-1.16l1.13,-0.22l-0.06,1.2l-1.35,0.18Z",
      name: "Trinidad and Tobago"
    },
    TR: {
      path: "M513.21,175.47l3.64,1.17l3.05,-0.44l2.1,0.26l3.11,-1.56l2.46,-0.13l2.19,1.33l0.33,0.82l-0.22,1.33l0.25,0.44l2.28,1.13l-1.17,0.57l-0.21,0.45l0.75,3.2l-0.41,1.16l1.13,1.92l-0.55,0.22l-0.9,-0.67l-2.91,-0.37l-1.24,0.46l-4.23,0.41l-2.81,1.05l-1.91,0.01l-1.52,-0.53l-2.58,0.75l-0.66,-0.45l-0.62,0.3l-0.12,1.45l-0.89,0.84l-0.47,-0.67l0.79,-1.3l-0.41,-0.2l-1.43,0.23l-2.0,-0.63l-2.02,1.65l-3.51,0.3l-2.13,-1.53l-2.7,-0.1l-0.86,1.24l-1.38,0.27l-2.29,-1.44l-2.71,-0.01l-1.37,-2.65l-1.68,-1.52l1.07,-1.99l-0.09,-0.49l-1.27,-1.12l2.37,-2.41l3.7,-0.11l1.28,-2.24l4.49,0.37l3.21,-1.97l2.81,-0.82l3.99,-0.06l4.29,2.07ZM488.79,176.72l-1.72,1.31l-0.5,-0.88l1.37,-2.57l-0.7,-0.85l1.7,-0.63l1.8,0.34l0.46,1.17l1.76,0.78l-2.87,0.32l-1.3,1.01Z",
      name: "Turkey"
    },
    LK: {
      path: "M624.16,268.99l-1.82,0.48l-0.99,-1.67l-0.42,-3.46l0.95,-3.43l1.21,0.98l2.26,4.19l-0.34,2.33l-0.85,0.58Z",
      name: "Sri Lanka"
    },
    TN: {
      path: "M448.1,188.24l-1.0,1.27l-0.02,1.32l0.84,0.88l-0.28,2.09l-1.53,1.32l-0.12,0.42l0.48,1.54l1.42,0.32l0.53,1.11l0.9,0.52l-0.11,1.67l-3.54,2.64l-0.1,2.38l-0.58,0.3l-0.96,-4.45l-1.54,-1.25l-0.16,-0.78l-1.92,-1.56l-0.18,-1.76l1.51,-1.62l0.59,-2.34l-0.38,-2.78l0.42,-1.21l2.45,-1.05l1.29,0.26l-0.06,1.11l0.58,0.38l1.47,-0.73Z",
      name: "Tunisia"
    },
    TL: {
      path: "M734.55,307.93l-0.1,-0.97l4.5,-0.86l-2.82,1.28l-1.59,0.55Z",
      name: "Timor-Leste"
    },
    TM: {
      path: "M553.03,173.76l-0.04,0.34l-0.09,-0.22l0.13,-0.12ZM555.87,172.66l0.45,-0.1l1.48,0.74l2.06,2.43l4.07,-0.18l0.38,-0.51l-0.32,-1.19l1.92,-0.94l1.91,-1.59l2.94,1.39l0.43,2.47l1.19,0.67l2.58,-0.13l0.62,0.4l1.32,3.12l4.54,3.44l2.67,1.45l3.06,1.14l-0.04,1.05l-1.33,-0.75l-0.59,0.19l-0.32,0.84l-2.2,0.81l-0.46,2.13l-1.21,0.74l-1.91,0.42l-0.73,1.33l-1.56,0.31l-2.22,-0.94l-0.2,-2.17l-0.38,-0.36l-1.73,-0.09l-2.76,-2.46l-2.14,-0.4l-2.84,-1.48l-1.78,-0.27l-1.24,0.53l-1.57,-0.08l-2.0,1.69l-1.7,0.43l-0.36,-1.58l0.36,-2.98l-0.22,-0.4l-1.65,-0.84l0.54,-1.69l-0.34,-0.52l-1.22,-0.13l0.36,-1.64l2.22,0.59l2.2,-0.95l0.12,-0.65l-1.77,-1.74l-0.66,-1.57Z",
      name: "Turkmenistan"
    },
    TJ: {
      path: "M597.75,178.82l-2.54,-0.44l-0.47,0.34l-0.24,1.7l0.43,0.45l2.64,-0.22l3.18,0.95l4.39,-0.41l0.56,2.37l0.52,0.29l0.67,-0.24l1.11,0.49l0.21,2.13l-3.76,-0.21l-1.8,1.32l-1.76,0.74l-0.61,-0.58l0.21,-2.23l-0.64,-0.49l-0.07,-0.93l-1.36,-0.66l-0.45,0.07l-1.08,1.01l-0.55,1.48l-1.31,-0.05l-0.95,1.16l-0.9,-0.35l-1.86,0.74l1.26,-2.83l-0.54,-2.17l-1.67,-0.82l0.33,-0.66l2.18,-0.04l1.19,-1.63l0.76,-1.79l2.43,-0.5l-0.26,1.0l0.73,1.05Z",
      name: "Tajikistan"
    },
    LS: {
      path: "M491.06,363.48l-0.49,0.15l-1.49,-1.67l1.1,-1.43l2.19,-1.44l1.51,1.27l-0.98,1.82l-1.23,0.38l-0.62,0.93Z",
      name: "Lesotho"
    },
    TH: {
      path: "M670.27,255.86l-1.41,3.87l0.15,2.0l0.38,0.36l1.38,0.07l0.9,2.04l0.55,2.34l1.4,1.44l1.61,0.38l0.96,0.97l-0.5,0.64l-1.1,0.2l-0.34,-1.18l-2.04,-1.1l-0.63,0.23l-0.63,-0.62l-0.48,-1.3l-2.56,-2.63l-0.73,0.41l0.95,-3.89l2.16,-4.22ZM670.67,254.77l-0.92,-2.18l-0.26,-2.61l-2.14,-3.06l0.71,-0.49l0.89,-2.59l-3.61,-5.45l0.87,-0.51l1.05,-2.58l1.74,-0.18l2.6,-1.59l0.76,0.56l0.13,1.39l0.37,0.36l1.23,0.09l-0.51,2.28l0.05,2.42l0.6,0.34l2.43,-1.42l0.77,0.39l1.47,-0.07l0.71,-0.88l1.48,0.14l1.71,1.88l0.25,2.65l1.92,2.11l-0.1,1.89l-0.61,0.86l-2.22,-0.33l-3.5,0.64l-1.6,2.12l0.36,2.58l-1.51,-0.79l-1.84,-0.01l0.28,-1.52l-0.4,-0.47l-2.21,0.01l-0.4,0.37l-0.19,2.74l-0.34,0.93Z",
      name: "Thailand"
    },
    TF: {
      path: "M596.68,420.38l-3.2,0.18l-0.05,-1.26l0.39,-1.41l1.3,0.78l2.08,0.35l-0.52,1.36Z",
      name: "Fr. S. Antarctic Lands"
    },
    TG: {
      path: "M422.7,257.63l-0.09,1.23l1.53,1.52l0.08,1.09l0.5,0.65l-0.11,5.62l0.49,1.47l-1.31,0.35l-1.02,-2.13l-0.18,-1.12l0.53,-2.19l-0.63,-1.16l-0.22,-3.68l-1.01,-1.4l0.07,-0.28l1.37,0.03Z",
      name: "Togo"
    },
    TD: {
      path: "M480.25,235.49l0.12,9.57l-2.1,0.05l-1.14,1.89l-0.69,1.63l0.34,0.73l-0.66,0.91l0.24,0.89l-0.86,1.95l0.45,0.5l0.6,-0.1l0.34,0.64l0.03,1.38l0.9,1.04l-1.45,0.43l-1.27,1.03l-1.83,2.76l-2.16,1.07l-2.31,-0.15l-0.86,0.25l-0.26,0.49l0.17,0.61l-2.11,1.68l-2.85,0.87l-1.09,-0.57l-0.73,0.66l-1.12,0.1l-1.1,-3.12l-1.25,-0.64l-1.22,-1.22l0.29,-0.64l3.01,0.04l0.35,-0.6l-1.3,-2.2l-0.08,-3.31l-0.97,-1.66l0.22,-1.04l-0.38,-0.48l-1.22,-0.04l0.0,-1.25l-0.98,-1.07l0.96,-3.01l3.25,-2.65l0.13,-3.33l0.95,-5.18l0.52,-1.07l-0.1,-0.48l-0.91,-0.78l-0.2,-0.96l-0.8,-0.58l-0.55,-3.65l2.1,-1.2l19.57,9.83Z",
      name: "Chad"
    },
    LY: {
      path: "M483.48,203.15l-0.75,1.1l0.29,1.39l-0.6,1.83l0.73,2.14l0.0,24.12l-2.48,0.01l-0.41,0.85l-19.41,-9.76l-4.41,2.28l-1.37,-1.33l-3.82,-1.1l-1.14,-1.65l-1.98,-1.23l-1.22,0.32l-0.66,-1.11l-0.17,-1.26l-1.28,-1.69l0.87,-1.19l-0.07,-4.34l0.43,-2.27l-0.86,-3.45l1.13,-0.76l0.22,-1.16l-0.2,-1.03l3.48,-2.61l0.29,-1.94l2.45,0.8l1.18,-0.21l1.98,0.44l3.15,1.18l1.37,2.54l5.72,1.67l2.64,1.35l1.61,-0.72l1.29,-1.34l-0.44,-2.34l0.66,-1.13l1.67,-1.21l1.57,-0.35l3.14,0.53l1.08,1.28l3.99,0.78l0.36,0.54Z",
      name: "Libya"
    },
    AE: {
      path: "M550.76,223.97l1.88,-0.4l3.84,0.02l4.78,-4.75l0.19,0.36l0.26,1.58l-0.81,0.01l-0.39,0.35l-0.08,2.04l-0.81,0.63l-0.01,0.96l-0.66,0.99l-0.39,1.41l-7.08,-1.25l-0.7,-1.96Z",
      name: "United Arab Emirates"
    },
    VE: {
      path: "M240.68,256.69l0.53,0.75l-0.02,1.06l-1.07,1.78l0.95,2.0l0.42,0.22l1.4,-0.44l0.56,-1.83l-0.77,-1.17l-0.1,-1.47l2.82,-0.93l0.26,-0.49l-0.28,-0.96l0.3,-0.28l0.66,1.31l1.96,0.26l1.4,1.22l0.08,0.68l0.39,0.35l4.81,-0.22l1.49,1.11l1.92,0.31l1.67,-0.84l0.22,-0.6l3.44,-0.14l-0.17,0.55l0.86,1.19l2.19,0.35l1.67,1.1l0.37,1.86l0.41,0.32l1.55,0.17l-1.66,1.35l-0.22,0.92l0.65,0.97l-1.67,0.54l-0.3,0.4l0.04,0.99l-0.56,0.57l-0.01,0.55l1.85,2.27l-0.66,0.69l-4.47,1.29l-0.72,0.54l-3.69,-0.9l-0.71,0.27l-0.02,0.7l0.91,0.53l-0.08,1.54l0.35,1.58l0.35,0.31l1.66,0.17l-1.3,0.52l-0.48,1.13l-2.68,0.91l-0.6,0.77l-1.57,0.13l-1.17,-1.13l-0.8,-2.52l-1.25,-1.26l1.02,-1.23l-1.29,-2.95l0.18,-1.62l1.0,-2.21l-0.2,-0.49l-1.14,-0.46l-4.02,0.36l-1.82,-2.1l-1.57,-0.33l-2.99,0.22l-1.06,-0.97l0.25,-1.23l-0.2,-1.01l-0.59,-0.69l-0.29,-1.06l-1.08,-0.39l0.78,-2.79l1.9,-2.11Z",
      name: "Venezuela"
    },
    AF: {
      path: "M600.7,188.88l-1.57,1.3l-0.1,0.48l0.8,2.31l-1.09,1.04l-0.03,1.27l-0.48,0.71l-2.16,-0.08l-0.37,0.59l0.78,1.48l-1.38,0.69l-1.06,1.69l0.06,1.7l-0.65,0.52l-0.91,-0.21l-1.91,0.36l-0.48,0.77l-1.88,0.13l-1.4,1.56l-0.18,2.32l-2.91,1.02l-1.65,-0.23l-0.71,0.55l-1.41,-0.3l-2.41,0.39l-3.52,-1.17l1.96,-2.35l-0.21,-1.78l-0.3,-0.34l-1.63,-0.4l-0.19,-1.58l-0.75,-2.03l0.95,-1.36l-0.19,-0.6l-0.73,-0.28l1.47,-4.8l2.14,0.9l2.12,-0.36l0.74,-1.34l1.77,-0.39l1.54,-0.92l0.63,-2.31l1.87,-0.5l0.49,-0.81l0.94,0.56l2.13,0.11l2.55,0.92l1.95,-0.83l0.65,0.43l0.56,-0.13l0.69,-1.12l1.57,-0.08l0.72,-1.66l0.79,-0.74l0.8,0.39l-0.17,0.56l0.71,0.58l-0.08,2.39l1.11,0.95ZM601.37,188.71l1.73,-0.71l1.43,-1.18l4.03,0.35l-2.23,0.74l-4.95,0.8Z",
      name: "Afghanistan"
    },
    IQ: {
      path: "M530.82,187.47l0.79,0.66l1.26,-0.28l1.46,3.08l1.63,0.94l0.14,1.23l-1.22,1.05l-0.53,2.52l1.73,2.67l3.12,1.62l1.15,1.88l-0.38,1.85l0.39,0.48l0.41,-0.0l0.02,1.07l0.76,0.94l-2.47,-0.1l-1.71,2.44l-4.31,-0.2l-7.02,-5.48l-3.73,-1.94l-2.88,-0.73l-0.85,-2.87l5.45,-3.02l0.95,-3.43l-0.19,-1.96l1.27,-0.7l1.22,-1.7l0.87,-0.36l2.69,0.34Z",
      name: "Iraq"
    },
    IS: {
      path: "M384.14,88.06l-0.37,2.61l2.54,2.51l-2.9,2.75l-9.19,3.4l-9.25,-1.66l1.7,-1.22l-0.1,-0.7l-4.05,-1.47l2.96,-0.53l0.33,-0.43l-0.11,-1.2l-0.33,-0.36l-4.67,-0.85l1.28,-2.04l3.45,-0.56l3.77,2.72l0.44,0.02l3.64,-2.16l3.3,1.08l3.98,-2.16l3.58,0.26Z",
      name: "Iceland"
    },
    IR: {
      path: "M533.43,187.16l-1.27,-2.15l0.42,-0.98l-0.71,-3.04l1.03,-0.5l0.33,0.83l1.26,1.35l2.05,0.51l1.11,-0.16l2.89,-2.11l0.62,-0.14l0.39,0.46l-0.72,1.2l0.06,0.49l1.56,1.53l0.65,0.04l0.67,1.81l2.56,0.83l1.87,1.48l3.69,0.49l3.91,-0.76l0.47,-0.73l2.17,-0.6l1.66,-1.54l1.51,0.08l1.18,-0.53l1.59,0.24l2.83,1.48l1.88,0.3l2.77,2.47l1.77,0.18l0.18,1.99l-1.68,5.49l0.24,0.5l0.61,0.23l-0.82,1.48l0.8,2.18l0.19,1.71l0.3,0.34l1.63,0.4l0.15,1.32l-2.15,2.35l-0.01,0.53l2.21,3.03l2.34,1.24l0.06,2.14l1.24,0.72l0.11,0.69l-3.31,1.27l-1.08,3.03l-9.68,-1.68l-0.99,-3.05l-1.43,-0.73l-2.17,0.46l-2.47,1.26l-2.83,-0.82l-2.46,-2.02l-2.41,-0.8l-3.42,-6.06l-0.48,-0.2l-1.18,0.39l-1.44,-0.82l-0.5,0.08l-0.65,0.74l-0.97,-1.01l-0.02,-1.31l-0.71,-0.39l0.26,-1.81l-1.29,-2.11l-3.13,-1.63l-1.58,-2.43l0.5,-1.9l1.31,-1.26l-0.19,-1.66l-1.74,-1.1l-1.57,-3.3Z",
      name: "Iran"
    },
    AM: {
      path: "M536.99,182.33l-0.28,0.03l-1.23,-2.13l-0.93,0.01l-0.62,-0.66l-0.69,-0.07l-0.96,-0.81l-1.56,-0.62l0.19,-1.12l-0.26,-0.79l2.72,-0.36l1.09,1.01l-0.17,0.92l1.02,0.78l-0.47,0.62l0.08,0.56l2.04,1.23l0.04,1.4Z",
      name: "Armenia"
    },
    IT: {
      path: "M451.59,158.63l3.48,0.94l-0.21,1.17l0.3,0.83l-1.49,-0.24l-2.04,1.1l-0.21,0.39l0.13,1.45l-0.25,1.12l0.82,1.57l2.39,1.63l1.31,2.54l2.79,2.43l2.05,0.08l0.21,0.23l-0.39,0.33l0.09,0.67l4.05,1.97l2.17,1.76l-0.16,0.36l-1.17,-1.08l-2.18,-0.49l-0.44,0.2l-1.05,1.91l0.14,0.54l1.57,0.95l-0.19,0.98l-1.06,0.33l-1.25,2.34l-0.37,0.08l0.0,-0.33l1.0,-2.45l-1.73,-3.17l-1.12,-0.51l-0.88,-1.33l-1.51,-0.51l-1.27,-1.25l-1.75,-0.18l-4.12,-3.21l-1.62,-1.65l-1.03,-3.19l-3.53,-1.36l-1.3,0.51l-1.69,1.41l0.16,-0.72l-0.28,-0.47l-1.14,-0.33l-0.53,-1.96l0.72,-0.78l0.04,-0.48l-0.65,-1.17l0.8,0.39l1.4,-0.23l1.11,-0.84l0.52,0.35l1.19,-0.1l0.75,-1.2l1.53,0.33l1.36,-0.56l0.35,-1.14l1.08,0.32l0.68,-0.64l1.98,-0.44l0.42,0.82ZM459.19,184.75l-0.65,1.65l0.32,1.05l-0.31,0.89l-1.5,-0.85l-4.5,-1.67l0.19,-0.82l2.67,0.23l3.78,-0.48ZM443.93,176.05l1.18,1.66l-0.3,3.32l-1.06,-0.01l-0.77,0.73l-0.53,-0.44l-0.1,-3.37l-0.39,-1.22l1.04,0.01l0.92,-0.68Z",
      name: "Italy"
    },
    VN: {
      path: "M690.56,230.25l-2.7,1.82l-2.09,2.46l-0.63,1.95l4.31,6.45l2.32,1.65l1.43,1.94l1.11,4.59l-0.32,4.24l-1.93,1.54l-2.84,1.61l-2.11,2.15l-2.73,2.06l-0.59,-1.05l0.63,-1.53l-0.13,-0.47l-1.34,-1.04l1.51,-0.71l2.55,-0.18l0.3,-0.63l-0.82,-1.14l4.0,-2.07l0.31,-3.05l-0.57,-1.77l0.42,-2.66l-0.73,-1.97l-1.86,-1.76l-3.63,-5.29l-2.72,-1.46l0.36,-0.47l1.5,-0.64l0.21,-0.52l-0.97,-2.27l-0.37,-0.24l-2.83,-0.02l-2.24,-3.9l0.83,-0.4l4.39,-0.29l2.06,-1.31l1.15,0.89l1.88,0.4l-0.17,1.51l1.35,1.16l1.67,0.45Z",
      name: "Vietnam"
    },
    AR: {
      path: "M249.29,428.93l-2.33,-0.52l-5.83,-0.43l-0.89,-1.66l0.05,-2.37l-0.45,-0.4l-1.43,0.18l-0.67,-0.91l-0.2,-3.13l1.88,-1.47l0.79,-2.04l-0.25,-1.7l1.3,-2.68l0.91,-4.15l-0.22,-1.69l0.85,-0.45l0.2,-0.44l-0.27,-1.16l-0.98,-0.68l0.59,-0.92l-0.05,-0.5l-1.04,-1.07l-0.52,-3.1l0.97,-0.86l-0.42,-3.58l1.2,-5.43l1.38,-0.98l0.16,-0.43l-0.75,-2.79l-0.01,-2.43l1.78,-1.75l0.06,-2.57l1.43,-2.85l0.01,-2.58l-0.69,-0.74l-1.09,-4.52l1.47,-2.7l-0.18,-2.79l0.85,-2.35l1.59,-2.46l1.73,-1.64l0.05,-0.52l-0.6,-0.84l0.44,-0.85l-0.07,-4.19l2.7,-1.44l0.86,-2.75l-0.21,-0.71l1.76,-2.01l2.9,0.57l1.38,1.78l0.68,-0.08l0.87,-1.87l2.39,0.09l4.95,4.77l2.17,0.49l3.0,1.92l2.47,1.0l0.25,0.82l-2.37,3.93l0.23,0.59l5.39,1.16l2.12,-0.44l2.45,-2.16l0.5,-2.38l0.76,-0.31l0.98,1.2l-0.04,1.8l-3.67,2.51l-2.85,2.66l-3.43,3.88l-1.3,5.07l0.01,2.72l-0.54,0.73l-0.36,3.28l3.14,2.64l-0.16,2.11l1.4,1.11l-0.1,1.09l-2.29,3.52l-3.55,1.49l-4.92,0.6l-2.71,-0.29l-0.43,0.51l0.5,1.65l-0.49,2.1l0.38,1.42l-1.19,0.83l-2.36,0.38l-2.3,-1.04l-1.38,0.83l0.41,3.64l1.69,0.91l1.4,-0.71l0.36,0.76l-2.04,0.86l-2.01,1.89l-0.97,4.63l-2.34,0.1l-2.09,1.78l-0.61,2.75l2.46,2.31l2.17,0.63l-0.7,2.32l-2.83,1.73l-1.73,3.86l-2.17,1.22l-1.16,1.67l0.75,3.76l1.04,1.28ZM256.71,438.88l-2.0,0.15l-1.4,-1.22l-3.82,-0.1l-0.0,-5.83l1.6,3.05l3.26,2.07l3.08,0.78l-0.71,1.1Z",
      name: "Argentina"
    },
    AU: {
      path: "M705.8,353.26l0.26,0.04l0.17,-0.47l-0.48,-1.42l0.92,1.11l0.45,0.15l0.27,-0.39l-0.1,-1.56l-1.98,-3.63l1.09,-3.31l-0.24,-1.57l0.34,-0.62l0.38,1.06l0.43,-0.19l0.99,-1.7l1.91,-0.83l1.29,-1.15l1.81,-0.91l0.96,-0.17l0.92,0.26l1.92,-0.95l1.47,-0.28l1.03,-0.8l1.43,0.04l2.78,-0.84l1.36,-1.15l0.71,-1.45l1.41,-1.26l0.3,-2.58l1.27,-1.59l0.78,1.65l0.54,0.19l1.07,-0.51l0.15,-0.6l-0.73,-1.0l0.45,-0.71l0.78,0.39l0.58,-0.3l0.28,-1.82l1.87,-2.14l1.12,-0.39l0.28,-0.58l0.62,0.17l0.53,-0.73l1.87,-0.57l1.65,1.05l1.35,1.48l3.39,0.38l0.43,-0.54l-0.46,-1.23l1.05,-1.79l1.04,-0.61l0.14,-0.55l-0.25,-0.41l0.88,-1.17l1.31,-0.77l1.3,0.27l2.1,-0.48l0.31,-0.4l-0.05,-1.3l-0.92,-0.77l1.48,0.56l1.41,1.07l2.11,0.65l0.81,-0.2l1.4,0.7l1.69,-0.66l0.8,0.19l0.64,-0.33l0.71,0.77l-1.33,1.94l-0.71,0.07l-0.35,0.51l0.24,0.86l-1.52,2.35l0.12,1.05l2.15,1.65l1.97,0.85l3.04,2.36l1.97,0.65l0.55,0.88l2.72,0.85l1.84,-1.1l2.07,-5.97l-0.42,-3.59l0.3,-1.73l0.47,-0.87l-0.31,-0.68l1.09,-3.28l0.46,-0.47l0.4,0.71l0.16,1.51l0.65,0.52l0.16,1.04l0.85,1.21l0.12,2.38l0.9,2.0l0.57,0.18l1.3,-0.78l1.69,1.7l-0.2,1.08l0.53,2.2l0.39,1.3l0.68,0.48l0.6,1.95l-0.19,1.48l0.81,1.76l6.01,3.69l-0.11,0.76l1.38,1.58l0.95,2.77l0.58,0.22l0.72,-0.41l0.8,0.9l0.61,0.01l0.46,2.41l4.81,4.71l0.66,2.02l-0.07,3.31l1.14,2.2l-0.13,2.24l-1.1,3.68l0.03,1.64l-0.47,1.89l-1.05,2.4l-1.9,1.47l-1.72,3.51l-2.38,6.09l-0.24,2.82l-1.14,0.8l-2.85,0.15l-2.31,1.19l-2.51,2.25l-3.09,-1.57l0.3,-1.15l-0.54,-0.47l-1.5,0.63l-2.01,1.94l-7.12,-2.18l-1.48,-1.63l-1.14,-3.74l-1.45,-1.26l-1.81,-0.26l0.56,-1.18l-0.61,-2.1l-0.72,-0.1l-1.14,1.82l-0.9,0.21l0.63,-0.82l0.36,-1.55l0.92,-1.31l-0.13,-2.34l-0.7,-0.22l-2.0,2.34l-1.51,0.93l-0.94,2.01l-1.35,-0.81l-0.02,-1.52l-1.57,-2.04l-1.09,-0.88l0.24,-0.33l-0.14,-0.59l-3.21,-1.69l-1.83,-0.12l-2.54,-1.35l-4.58,0.28l-6.02,1.9l-2.53,-0.13l-2.62,1.41l-2.13,0.63l-1.49,2.6l-3.49,0.31l-2.29,-0.5l-3.48,0.43l-1.6,1.47l-0.81,-0.04l-2.37,1.63l-3.26,-0.1l-3.72,-2.21l0.04,-1.05l1.19,-0.46l0.49,-0.89l0.21,-2.97l-0.28,-1.64l-1.34,-2.86l-0.38,-1.47l0.05,-1.72l-0.95,-1.7l-0.18,-0.97l-1.01,-0.99l-0.29,-1.98l-1.13,-1.75ZM784.92,393.44l2.65,1.02l3.23,-0.96l1.09,0.14l0.15,3.06l-0.85,1.13l-0.17,1.63l-0.87,-0.24l-1.57,1.91l-1.68,-0.18l-1.4,-2.36l-0.37,-2.04l-1.39,-2.51l0.04,-0.8l1.15,0.18Z",
      name: "Australia"
    },
    IL: {
      path: "M507.76,203.05l0.4,-0.78l0.18,0.4l-0.33,1.03l0.52,0.44l0.68,-0.22l-0.86,3.6l-1.16,-3.32l0.59,-0.74l-0.03,-0.41ZM508.73,200.34l0.37,-1.02l0.64,0.0l0.52,-0.51l-0.49,1.53l-0.56,-0.24l-0.48,0.23Z",
      name: "Israel"
    },
    IN: {
      path: "M623.34,207.03l-1.24,1.04l-0.97,2.55l0.22,0.51l8.04,3.87l3.42,0.37l1.57,1.38l4.92,0.88l2.18,-0.04l0.38,-0.3l0.29,-1.24l-0.32,-1.64l0.14,-0.87l0.82,-0.31l0.45,2.48l2.28,1.02l1.77,-0.38l4.14,0.1l0.38,-0.36l0.18,-1.66l-0.5,-0.65l1.37,-0.29l2.25,-1.99l2.7,-1.62l1.93,0.62l1.8,-0.98l0.79,1.14l-0.68,0.91l0.26,0.63l2.42,0.36l0.09,0.47l-0.83,0.75l0.13,1.07l-1.52,-0.29l-3.24,1.86l-0.13,1.78l-1.32,2.14l-0.18,1.39l-0.93,1.82l-1.64,-0.5l-0.52,0.37l-0.09,2.63l-0.56,1.11l0.19,0.81l-0.53,0.27l-1.18,-3.73l-1.08,-0.27l-0.38,0.31l-0.24,1.0l-0.66,-0.66l0.54,-1.06l1.22,-0.34l1.15,-2.25l-0.24,-0.56l-1.57,-0.47l-4.34,-0.28l-0.18,-1.56l-0.35,-0.35l-1.11,-0.12l-1.91,-1.12l-0.56,0.17l-0.88,1.82l0.11,0.49l1.36,1.07l-1.09,0.69l-0.69,1.11l0.18,0.56l1.24,0.57l-0.32,1.54l0.85,1.94l0.36,2.01l-0.22,0.59l-4.58,0.52l-0.33,0.42l0.13,1.8l-1.17,1.36l-3.65,1.81l-2.79,3.03l-4.32,3.28l-0.18,1.27l-4.65,1.79l-0.77,2.16l0.64,5.3l-1.06,2.49l-0.01,3.94l-1.24,0.28l-1.14,1.93l0.39,0.84l-1.68,0.53l-1.04,1.83l-0.65,0.47l-2.06,-2.05l-2.1,-6.02l-2.2,-3.64l-1.05,-4.75l-2.29,-3.57l-1.76,-8.2l0.01,-3.11l-0.49,-2.53l-0.55,-0.29l-3.53,1.52l-1.53,-0.27l-2.86,-2.77l0.85,-0.67l0.08,-0.55l-0.74,-1.03l-2.67,-2.06l1.24,-1.32l5.34,0.01l0.39,-0.49l-0.5,-2.29l-1.42,-1.46l-0.27,-1.93l-1.43,-1.2l2.31,-2.37l3.05,0.06l2.62,-2.85l1.6,-2.81l2.4,-2.73l0.07,-2.04l1.97,-1.48l-0.02,-0.65l-1.93,-1.31l-0.82,-1.78l-0.8,-2.21l0.9,-0.89l3.59,0.65l2.92,-0.42l2.33,-2.19l2.31,2.85l-0.24,2.13l0.99,1.59l-0.05,0.82l-1.34,-0.28l-0.47,0.48l0.7,3.06l2.62,1.99l2.99,1.65Z",
      name: "India"
    },
    TZ: {
      path: "M495.56,296.42l2.8,-3.12l-0.02,-0.81l-0.64,-1.3l0.68,-0.52l0.14,-1.47l-0.76,-1.25l0.31,-0.11l2.26,0.03l-0.51,2.76l0.76,1.3l0.5,0.12l1.05,-0.53l1.19,-0.12l0.61,0.24l1.43,-0.62l0.1,-0.67l-0.71,-0.62l1.57,-1.7l8.65,4.86l0.32,1.53l3.34,2.33l-1.05,2.8l0.13,1.61l1.63,1.12l-0.6,1.76l-0.01,2.33l1.89,4.03l0.57,0.43l-1.46,1.08l-2.61,0.94l-1.43,-0.04l-1.06,0.77l-2.29,0.36l-2.87,-0.68l-0.83,0.07l-0.63,-0.75l-0.31,-2.78l-1.32,-1.35l-3.25,-0.77l-3.96,-1.58l-1.18,-2.41l-0.32,-1.75l-1.76,-1.49l0.42,-1.05l-0.44,-0.89l0.08,-0.96l-0.46,-0.58l0.06,-0.56Z",
      name: "Tanzania"
    },
    AZ: {
      path: "M539.29,175.73l1.33,0.32l1.94,-1.8l2.3,3.34l1.43,0.43l-1.26,0.15l-0.35,0.32l-0.8,3.14l-0.99,0.96l0.05,1.11l-1.26,-1.13l0.7,-1.18l-0.04,-0.47l-0.74,-0.86l-1.48,0.15l-2.34,1.71l-0.03,-1.27l-2.03,-1.35l0.47,-0.62l-0.08,-0.56l-1.03,-0.79l0.29,-0.43l-0.14,-0.58l-1.13,-0.86l1.89,0.68l1.69,0.06l0.37,-0.87l-0.81,-1.37l0.42,0.06l1.63,1.72ZM533.78,180.57l0.61,0.46l0.69,-0.0l0.59,1.15l-0.68,-0.15l-1.21,-1.45Z",
      name: "Azerbaijan"
    },
    IE: {
      path: "M405.08,135.42l0.35,2.06l-1.75,2.78l-4.22,1.88l-2.84,-0.4l1.73,-3.0l-1.18,-3.53l4.6,-3.74l0.32,1.15l-0.49,1.74l0.4,0.51l1.47,-0.04l1.6,0.6Z",
      name: "Ireland"
    },
    ID: {
      path: "M756.47,287.89l0.69,4.01l2.79,1.78l0.51,-0.1l2.04,-2.59l2.71,-1.43l2.05,-0.0l3.9,1.73l2.46,0.45l0.08,15.12l-1.75,-1.54l-2.54,-0.51l-0.88,0.71l-2.32,0.06l0.69,-1.33l1.45,-0.64l0.23,-0.46l-0.65,-2.74l-1.24,-2.21l-5.04,-2.29l-2.09,-0.23l-3.68,-2.27l-0.55,0.13l-0.65,1.07l-0.52,0.12l-0.55,-1.89l-1.21,-0.78l1.84,-0.62l1.72,0.05l0.39,-0.52l-0.21,-0.66l-0.38,-0.28l-3.45,-0.0l-1.13,-1.48l-2.1,-0.43l-0.52,-0.6l2.69,-0.48l1.28,-0.78l3.66,0.94l0.3,0.71ZM757.91,300.34l-0.62,0.82l-0.1,-0.8l0.59,-1.12l0.13,1.1ZM747.38,292.98l0.34,0.72l-1.22,-0.57l-4.68,-0.1l0.27,-0.62l2.78,-0.09l2.52,0.67ZM741.05,285.25l-0.67,-2.88l0.64,-2.01l0.41,0.86l1.21,0.18l0.16,0.7l-0.1,1.68l-0.84,-0.16l-0.46,0.3l-0.34,1.34ZM739.05,293.5l-0.5,0.44l-1.34,-0.36l-0.17,-0.37l1.73,-0.08l0.27,0.36ZM721.45,284.51l-0.19,1.97l2.24,2.23l0.54,0.02l1.27,-1.07l2.75,-0.5l-0.9,1.21l-2.11,0.93l-0.16,0.6l2.22,3.01l-0.3,1.07l1.36,1.74l-2.26,0.85l-0.28,-0.31l0.12,-1.19l-1.64,-1.34l0.17,-2.23l-0.56,-0.39l-1.67,0.76l-0.23,0.39l0.3,6.17l-1.1,0.25l-0.69,-0.47l0.64,-2.21l-0.39,-2.42l-0.39,-0.34l-0.8,-0.01l-0.58,-1.29l0.98,-1.6l0.35,-1.96l1.32,-3.87ZM728.59,296.27l0.38,0.49l-0.02,1.28l-0.88,0.49l-0.53,-0.47l1.04,-1.79ZM729.04,286.98l0.27,-0.05l-0.02,0.13l-0.24,-0.08ZM721.68,284.05l0.16,-0.32l1.89,-1.65l1.83,0.68l3.16,0.35l2.94,-0.1l2.39,-1.66l-1.73,2.13l-1.66,0.43l-2.41,-0.48l-4.17,0.13l-2.39,0.51ZM730.55,310.47l1.11,-1.93l2.03,-0.82l0.08,0.62l-1.45,1.67l-1.77,0.46ZM728.12,305.88l-0.1,0.38l-3.46,0.66l-2.91,-0.27l-0.0,-0.25l1.54,-0.41l1.66,0.73l1.67,-0.19l1.61,-0.65ZM722.9,310.24l-0.64,0.03l-2.26,-1.2l1.11,-0.24l1.78,1.41ZM716.26,305.77l0.88,0.51l1.28,-0.17l0.2,0.35l-4.65,0.73l0.39,-0.67l1.15,-0.02l0.75,-0.73ZM711.66,293.84l-0.38,-0.16l-2.54,1.01l-1.12,-1.44l-1.69,-0.13l-1.16,-0.75l-3.04,0.77l-1.1,-1.15l-3.31,-0.11l-0.35,-3.05l-1.35,-0.95l-1.11,-1.98l-0.33,-2.06l0.27,-2.14l0.9,-1.01l0.37,1.15l2.09,1.49l1.53,-0.48l1.82,0.08l1.38,-1.19l1.0,-0.18l2.28,0.67l2.26,-0.53l1.52,-3.64l1.01,-0.99l0.78,-2.57l4.1,0.3l-1.11,1.77l0.02,0.46l1.7,2.2l-0.23,1.39l2.07,1.71l-2.33,0.42l-0.88,1.9l0.1,2.05l-2.4,1.9l-0.06,2.45l-0.7,2.79ZM692.58,302.03l0.35,0.26l4.8,0.25l0.78,-0.97l4.17,1.09l1.13,1.68l3.69,0.45l2.13,1.04l-1.8,0.6l-2.77,-0.99l-4.8,-0.12l-5.24,-1.41l-1.84,-0.25l-1.11,0.3l-4.26,-0.97l-0.7,-1.14l-1.59,-0.13l1.18,-1.65l2.74,0.13l2.87,1.13l0.26,0.68ZM685.53,299.17l-2.22,0.04l-2.06,-2.03l-3.15,-2.01l-2.93,-3.51l-3.11,-5.33l-2.2,-2.12l-1.64,-4.06l-2.32,-1.69l-1.27,-2.07l-1.96,-1.5l-2.51,-2.65l-0.11,-0.66l4.81,0.53l2.15,2.38l3.31,2.74l2.35,2.66l2.7,0.17l1.95,1.59l1.54,2.17l1.59,0.95l-0.84,1.71l0.15,0.52l1.44,0.87l0.79,0.1l0.4,1.58l0.87,1.4l1.96,0.39l1.0,1.31l-0.6,3.01l-0.09,3.5Z",
      name: "Indonesia"
    },
    UA: {
      path: "M492.5,162.44l1.28,-2.49l1.82,0.19l0.66,-0.23l0.09,-0.71l-0.25,-0.75l-0.79,-0.72l-0.33,-1.21l-0.86,-0.62l-0.02,-1.19l-1.13,-0.86l-1.15,-0.19l-2.04,-1.0l-1.66,0.32l-0.66,0.47l-0.92,-0.0l-0.84,0.78l-2.48,0.7l-1.18,-0.71l-3.07,-0.36l-0.89,0.43l-0.24,-0.55l-1.11,-0.7l0.35,-0.93l1.26,-1.02l-0.54,-1.23l2.04,-2.43l1.4,-0.62l0.25,-1.19l-1.04,-2.39l0.83,-0.13l1.28,-0.84l1.8,-0.07l2.47,0.26l2.86,0.81l1.88,0.06l0.86,0.44l1.04,-0.41l0.77,0.66l2.18,-0.15l0.92,0.3l0.52,-0.34l0.15,-1.53l0.56,-0.54l2.85,-0.05l0.84,-0.72l3.04,-0.18l1.23,1.46l-0.48,0.77l0.21,1.03l0.36,0.32l1.8,0.14l0.93,2.08l3.18,1.15l1.94,-0.45l1.67,1.49l1.4,-0.03l3.35,0.96l0.02,0.54l-0.96,1.59l0.47,1.97l-0.26,0.7l-2.36,0.28l-1.29,0.89l-0.23,1.38l-1.83,0.27l-1.58,0.97l-2.41,0.21l-2.16,1.17l-0.21,0.38l0.34,2.26l1.23,0.75l2.13,-0.08l-0.14,0.31l-2.65,0.53l-3.23,1.69l-0.87,-0.39l0.42,-1.1l-0.25,-0.52l-2.21,-0.73l2.35,-1.06l0.12,-0.65l-0.93,-0.82l-3.62,-0.74l-0.13,-0.89l-0.46,-0.34l-2.61,0.59l-0.91,1.69l-1.71,2.04l-0.86,-0.4l-1.62,0.27Z",
      name: "Ukraine"
    },
    QA: {
      path: "M549.33,221.64l-0.76,-0.23l-0.14,-1.64l0.84,-1.29l0.47,0.52l0.04,1.34l-0.45,1.3Z",
      name: "Qatar"
    },
    MZ: {
      path: "M508.58,318.75l-0.34,-2.57l0.51,-2.05l3.55,0.63l2.5,-0.38l1.02,-0.76l1.49,0.01l2.74,-0.98l1.66,-1.2l0.5,9.24l0.41,1.23l-0.68,1.67l-0.93,1.71l-1.5,1.5l-5.16,2.28l-2.78,2.73l-1.02,0.53l-1.71,1.8l-0.98,0.57l-0.35,2.41l1.16,1.94l0.49,2.17l0.43,0.31l-0.06,2.06l-0.39,1.17l0.5,0.72l-0.25,0.73l-0.92,0.83l-5.12,2.39l-1.22,1.36l0.21,1.13l0.58,0.39l-0.11,0.72l-1.22,-0.01l-0.73,-2.97l0.42,-3.09l-1.78,-5.37l2.49,-2.81l0.69,-1.89l0.44,-0.43l0.28,-1.53l-0.39,-0.93l0.59,-3.65l-0.01,-3.26l-1.49,-1.16l-1.2,-0.22l-1.74,-1.17l-1.92,0.01l-0.29,-2.08l7.06,-1.96l1.28,1.09l0.89,-0.1l0.67,0.44l0.1,0.73l-0.51,1.29l0.19,1.81l1.75,1.83l0.65,-0.13l0.71,-1.65l1.17,-0.86l-0.26,-3.47l-1.05,-1.85l-1.04,-0.94Z",
      name: "Mozambique"
    }
  },
  height: 440.70631074413296,
  width: 900,
  projection: {
    type: "mill",
    centralMeridian: 11.5
  }
});

/***/ }),

/***/ "./node_modules/pristinejs/dist/pristine.js":
/*!**************************************************!*\
  !*** ./node_modules/pristinejs/dist/pristine.js ***!
  \**************************************************/
/***/ (function(module) {

(function (global, factory) {
   true ? module.exports = factory() : 0;
})(this, function () {
  'use strict';

  var lang = {
    en: {
      required: "This field is required",
      email: "This field requires a valid e-mail address",
      number: "This field requires a number",
      integer: "This field requires an integer value",
      url: "This field requires a valid website URL",
      tel: "This field requires a valid telephone number",
      maxlength: "This fields length must be < ${1}",
      minlength: "This fields length must be > ${1}",
      min: "Minimum value for this field is ${1}",
      max: "Maximum value for this field is ${1}",
      pattern: "Please match the requested format",
      equals: "The two fields do not match",
      default: "Please enter a correct value"
    }
  };
  function findAncestor(el, cls) {
    while ((el = el.parentElement) && !el.classList.contains(cls)) {}
    return el;
  }
  function tmpl(o) {
    var _arguments = arguments;
    return this.replace(/\${([^{}]*)}/g, function (a, b) {
      return _arguments[b];
    });
  }
  function groupedElemCount(input) {
    return input.pristine.self.form.querySelectorAll('input[name="' + input.getAttribute('name') + '"]:checked').length;
  }
  function mergeConfig(obj1, obj2) {
    for (var attr in obj2) {
      if (!(attr in obj1)) {
        obj1[attr] = obj2[attr];
      }
    }
    return obj1;
  }
  var defaultConfig = {
    classTo: 'form-group',
    errorClass: 'has-danger',
    successClass: 'has-success',
    errorTextParent: 'form-group',
    errorTextTag: 'div',
    errorTextClass: 'text-help'
  };
  var PRISTINE_ERROR = 'pristine-error';
  var SELECTOR = "input:not([type^=hidden]):not([type^=submit]), select, textarea";
  var ALLOWED_ATTRIBUTES = ["required", "min", "max", 'minlength', 'maxlength', 'pattern'];
  var EMAIL_REGEX = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  var MESSAGE_REGEX = /-message(?:-([a-z]{2}(?:_[A-Z]{2})?))?/; // matches, -message, -message-en, -message-en_US
  var currentLocale = 'en';
  var validators = {};
  var _ = function _(name, validator) {
    validator.name = name;
    if (validator.priority === undefined) validator.priority = 1;
    validators[name] = validator;
  };
  _('text', {
    fn: function fn(val) {
      return true;
    },
    priority: 0
  });
  _('required', {
    fn: function fn(val) {
      return this.type === 'radio' || this.type === 'checkbox' ? groupedElemCount(this) : val !== undefined && val.trim() !== '';
    },
    priority: 99,
    halt: true
  });
  _('email', {
    fn: function fn(val) {
      return !val || EMAIL_REGEX.test(val);
    }
  });
  _('number', {
    fn: function fn(val) {
      return !val || !isNaN(parseFloat(val));
    },
    priority: 2
  });
  _('integer', {
    fn: function fn(val) {
      return !val || /^\d+$/.test(val);
    }
  });
  _('minlength', {
    fn: function fn(val, length) {
      return !val || val.length >= parseInt(length);
    }
  });
  _('maxlength', {
    fn: function fn(val, length) {
      return !val || val.length <= parseInt(length);
    }
  });
  _('min', {
    fn: function fn(val, limit) {
      return !val || (this.type === 'checkbox' ? groupedElemCount(this) >= parseInt(limit) : parseFloat(val) >= parseFloat(limit));
    }
  });
  _('max', {
    fn: function fn(val, limit) {
      return !val || (this.type === 'checkbox' ? groupedElemCount(this) <= parseInt(limit) : parseFloat(val) <= parseFloat(limit));
    }
  });
  _('pattern', {
    fn: function fn(val, pattern) {
      var m = pattern.match(new RegExp('^/(.*?)/([gimy]*)$'));
      return !val || new RegExp(m[1], m[2]).test(val);
    }
  });
  _('equals', {
    fn: function fn(val, otherFieldSelector) {
      var other = document.querySelector(otherFieldSelector);
      return other && (!val && !other.value || other.value === val);
    }
  });
  function Pristine(form, config, live) {
    var self = this;
    init(form, config, live);
    function init(form, config, live) {
      form.setAttribute("novalidate", "true");
      self.form = form;
      self.config = mergeConfig(config || {}, defaultConfig);
      self.live = !(live === false);
      self.fields = Array.from(form.querySelectorAll(SELECTOR)).map(function (input) {
        var fns = [];
        var params = {};
        var messages = {};
        [].forEach.call(input.attributes, function (attr) {
          if (/^data-pristine-/.test(attr.name)) {
            var name = attr.name.substr(14);
            var messageMatch = name.match(MESSAGE_REGEX);
            if (messageMatch !== null) {
              var locale = messageMatch[1] === undefined ? 'en' : messageMatch[1];
              if (!messages.hasOwnProperty(locale)) messages[locale] = {};
              messages[locale][name.slice(0, name.length - messageMatch[0].length)] = attr.value;
              return;
            }
            if (name === 'type') name = attr.value;
            _addValidatorToField(fns, params, name, attr.value);
          } else if (~ALLOWED_ATTRIBUTES.indexOf(attr.name)) {
            _addValidatorToField(fns, params, attr.name, attr.value);
          } else if (attr.name === 'type') {
            _addValidatorToField(fns, params, attr.value);
          }
        });
        fns.sort(function (a, b) {
          return b.priority - a.priority;
        });
        self.live && input.addEventListener(!~['radio', 'checkbox'].indexOf(input.getAttribute('type')) ? 'input' : 'change', function (e) {
          self.validate(e.target);
        }.bind(self));
        return input.pristine = {
          input: input,
          validators: fns,
          params: params,
          messages: messages,
          self: self
        };
      }.bind(self));
    }
    function _addValidatorToField(fns, params, name, value) {
      var validator = validators[name];
      if (validator) {
        fns.push(validator);
        if (value) {
          var valueParams = name === "pattern" ? [value] : value.split(',');
          valueParams.unshift(null); // placeholder for input's value
          params[name] = valueParams;
        }
      }
    }

    /***
     * Checks whether the form/input elements are valid
     * @param input => input element(s) or a jquery selector, null for full form validation
     * @param silent => do not show error messages, just return true/false
     * @returns {boolean} return true when valid false otherwise
     */
    self.validate = function (input, silent) {
      silent = input && silent === true || input === true;
      var fields = self.fields;
      if (input !== true && input !== false) {
        if (input instanceof HTMLElement) {
          fields = [input.pristine];
        } else if (input instanceof NodeList || input instanceof (window.$ || Array) || input instanceof Array) {
          fields = Array.from(input).map(function (el) {
            return el.pristine;
          });
        }
      }
      var valid = true;
      for (var i = 0; fields[i]; i++) {
        var field = fields[i];
        if (_validateField(field)) {
          !silent && _showSuccess(field);
        } else {
          valid = false;
          !silent && _showError(field);
        }
      }
      return valid;
    };

    /***
     * Get errors of a specific field or the whole form
     * @param input
     * @returns {Array|*}
     */
    self.getErrors = function (input) {
      if (!input) {
        var erroneousFields = [];
        for (var i = 0; i < self.fields.length; i++) {
          var field = self.fields[i];
          if (field.errors.length) {
            erroneousFields.push({
              input: field.input,
              errors: field.errors
            });
          }
        }
        return erroneousFields;
      }
      if (input.tagName && input.tagName.toLowerCase() === "select") {
        return input.pristine.errors;
      }
      return input.length ? input[0].pristine.errors : input.pristine.errors;
    };

    /***
     * Validates a single field, all validator functions are called and error messages are generated
     * when a validator fails
     * @param field
     * @returns {boolean}
     * @private
     */
    function _validateField(field) {
      var errors = [];
      var valid = true;
      for (var i = 0; field.validators[i]; i++) {
        var validator = field.validators[i];
        var params = field.params[validator.name] ? field.params[validator.name] : [];
        params[0] = field.input.value;
        if (!validator.fn.apply(field.input, params)) {
          valid = false;
          if (typeof validator.msg === "function") {
            errors.push(validator.msg(field.input.value, params));
          } else if (typeof validator.msg === "string") {
            errors.push(tmpl.apply(validator.msg, params));
          } else if (validator.msg === Object(validator.msg) && validator.msg[currentLocale]) {
            // typeof generates unnecessary babel code
            errors.push(tmpl.apply(validator.msg[currentLocale], params));
          } else if (field.messages[currentLocale] && field.messages[currentLocale][validator.name]) {
            errors.push(tmpl.apply(field.messages[currentLocale][validator.name], params));
          } else if (lang[currentLocale] && lang[currentLocale][validator.name]) {
            errors.push(tmpl.apply(lang[currentLocale][validator.name], params));
          } else {
            errors.push(tmpl.apply(lang[currentLocale].default, params));
          }
          if (validator.halt === true) {
            break;
          }
        }
      }
      field.errors = errors;
      return valid;
    }

    /***
     * Add a validator to a specific dom element in a form
     * @param elem => The dom element where the validator is applied to
     * @param fn => validator function
     * @param msg => message to show when validation fails. Supports templating. ${0} for the input's value, ${1} and
     * so on are for the attribute values
     * @param priority => priority of the validator function, higher valued function gets called first.
     * @param halt => whether validation should stop for this field after current validation function
     */
    self.addValidator = function (elem, fn, msg, priority, halt) {
      if (elem instanceof HTMLElement) {
        elem.pristine.validators.push({
          fn: fn,
          msg: msg,
          priority: priority,
          halt: halt
        });
        elem.pristine.validators.sort(function (a, b) {
          return b.priority - a.priority;
        });
      } else {
        console.warn("The parameter elem must be a dom element");
      }
    };

    /***
     * An utility function that returns a 2-element array, first one is the element where error/success class is
     * applied. 2nd one is the element where error message is displayed. 2nd element is created if doesn't exist and cached.
     * @param field
     * @returns {*}
     * @private
     */
    function _getErrorElements(field) {
      if (field.errorElements) {
        return field.errorElements;
      }
      var errorClassElement = findAncestor(field.input, self.config.classTo);
      var errorTextParent = null,
        errorTextElement = null;
      if (self.config.classTo === self.config.errorTextParent) {
        errorTextParent = errorClassElement;
      } else {
        errorTextParent = errorClassElement.querySelector('.' + self.config.errorTextParent);
      }
      if (errorTextParent) {
        errorTextElement = errorTextParent.querySelector('.' + PRISTINE_ERROR);
        if (!errorTextElement) {
          errorTextElement = document.createElement(self.config.errorTextTag);
          errorTextElement.className = PRISTINE_ERROR + ' ' + self.config.errorTextClass;
          errorTextParent.appendChild(errorTextElement);
          errorTextElement.pristineDisplay = errorTextElement.style.display;
        }
      }
      return field.errorElements = [errorClassElement, errorTextElement];
    }
    function _showError(field) {
      var errorElements = _getErrorElements(field);
      var errorClassElement = errorElements[0],
        errorTextElement = errorElements[1];
      var input = field.input;
      var inputId = input.id || Math.floor(new Date().valueOf() * Math.random());
      var errorId = 'error-' + inputId;
      if (errorClassElement) {
        errorClassElement.classList.remove(self.config.successClass);
        errorClassElement.classList.add(self.config.errorClass);
        input.setAttribute('aria-describedby', errorId);
        input.setAttribute('aria-invalid', 'true');
      }
      if (errorTextElement) {
        errorTextElement.setAttribute('id', errorId);
        errorTextElement.setAttribute('role', 'alert');
        errorTextElement.innerHTML = field.errors.join('<br/>');
        errorTextElement.style.display = errorTextElement.pristineDisplay || '';
      }
    }

    /***
     * Adds error to a specific field
     * @param input
     * @param error
     */
    self.addError = function (input, error) {
      input = input.length ? input[0] : input;
      input.pristine.errors.push(error);
      _showError(input.pristine);
    };
    function _removeError(field) {
      var errorElements = _getErrorElements(field);
      var errorClassElement = errorElements[0],
        errorTextElement = errorElements[1];
      var input = field.input;
      if (errorClassElement) {
        // IE > 9 doesn't support multiple class removal
        errorClassElement.classList.remove(self.config.errorClass);
        errorClassElement.classList.remove(self.config.successClass);
        input.removeAttribute('aria-describedby');
        input.removeAttribute('aria-invalid');
      }
      if (errorTextElement) {
        errorTextElement.removeAttribute('id');
        errorTextElement.removeAttribute('role');
        errorTextElement.innerHTML = '';
        errorTextElement.style.display = 'none';
      }
      return errorElements;
    }
    function _showSuccess(field) {
      var errorClassElement = _removeError(field)[0];
      errorClassElement && errorClassElement.classList.add(self.config.successClass);
    }

    /***
     * Resets the errors
     */
    self.reset = function () {
      for (var i = 0; self.fields[i]; i++) {
        self.fields[i].errorElements = null;
      }
      Array.from(self.form.querySelectorAll('.' + PRISTINE_ERROR)).map(function (elem) {
        elem.parentNode.removeChild(elem);
      });
      Array.from(self.form.querySelectorAll('.' + self.config.classTo)).map(function (elem) {
        elem.classList.remove(self.config.successClass);
        elem.classList.remove(self.config.errorClass);
      });
    };

    /***
     * Resets the errors and deletes all pristine fields
     */
    self.destroy = function () {
      self.reset();
      self.fields.forEach(function (field) {
        delete field.input.pristine;
      });
      self.fields = [];
    };
    self.setGlobalConfig = function (config) {
      defaultConfig = config;
    };
    return self;
  }

  /***
   *
   * @param name => Name of the global validator
   * @param fn => validator function
   * @param msg => message to show when validation fails. Supports templating. ${0} for the input's value, ${1} and
   * so on are for the attribute values
   * @param priority => priority of the validator function, higher valued function gets called first.
   * @param halt => whether validation should stop for this field after current validation function
   */
  Pristine.addValidator = function (name, fn, msg, priority, halt) {
    _(name, {
      fn: fn,
      msg: msg,
      priority: priority,
      halt: halt
    });
  };
  Pristine.addMessages = function (locale, messages) {
    var langObj = lang.hasOwnProperty(locale) ? lang[locale] : lang[locale] = {};
    Object.keys(messages).forEach(function (key, index) {
      langObj[key] = messages[key];
    });
  };
  Pristine.setLocale = function (locale) {
    currentLocale = locale;
  };
  return Pristine;
});

/***/ }),

/***/ "./node_modules/simple-datatables/dist/module.js":
/*!*******************************************************!*\
  !*** ./node_modules/simple-datatables/dist/module.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataTable: () => (/* binding */ at),
/* harmony export */   addColumnFilter: () => (/* binding */ bt),
/* harmony export */   convertCSV: () => (/* binding */ ot),
/* harmony export */   convertJSON: () => (/* binding */ rt),
/* harmony export */   createElement: () => (/* binding */ s),
/* harmony export */   exportCSV: () => (/* binding */ lt),
/* harmony export */   exportJSON: () => (/* binding */ dt),
/* harmony export */   exportSQL: () => (/* binding */ ct),
/* harmony export */   exportTXT: () => (/* binding */ ht),
/* harmony export */   isJson: () => (/* binding */ e),
/* harmony export */   isObject: () => (/* binding */ t),
/* harmony export */   makeEditable: () => (/* binding */ ft)
/* harmony export */ });
const t = t => "[object Object]" === Object.prototype.toString.call(t),
  e = e => {
    let s = !1;
    try {
      s = JSON.parse(e);
    } catch (t) {
      return !1;
    }
    return !(null === s || !Array.isArray(s) && !t(s)) && s;
  },
  s = (t, e) => {
    const s = document.createElement(t);
    if (e && "object" == typeof e) for (const t in e) "html" === t ? s.innerHTML = e[t] : s.setAttribute(t, e[t]);
    return s;
  },
  i = t => ["#text", "#comment"].includes(t.nodeName) ? t.data : t.childNodes ? t.childNodes.map(t => i(t)).join("") : "",
  n = t => {
    if (null == t) return "";
    if (t.hasOwnProperty("text") || t.hasOwnProperty("data")) {
      const e = t;
      return e.text ?? n(e.data);
    }
    return t.hasOwnProperty("nodeName") ? i(t) : String(t);
  },
  a = function (t) {
    return t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
  },
  o = function (t, e) {
    let s = 0,
      i = 0;
    for (; s < t + 1;) {
      e[i].hidden || (s += 1), i += 1;
    }
    return i - 1;
  },
  r = function (t) {
    const e = {};
    if (t) for (const s of t) e[s.name] = s.value;
    return e;
  },
  l = t => t ? t.trim().split(" ").map(t => `.${t}`).join("") : null,
  d = (t, e) => {
    const s = e?.split(" ").some(e => !t.classList.contains(e));
    return !s;
  },
  c = (t, e) => t ? e ? `${t} ${e}` : t : e || "",
  h = function (t, e = 300) {
    let s;
    return (...i) => {
      clearTimeout(s), s = window.setTimeout(() => t(), e);
    };
  };
var u = function () {
  return u = Object.assign || function (t) {
    for (var e, s = arguments, i = 1, n = arguments.length; i < n; i++) for (var a in e = s[i]) Object.prototype.hasOwnProperty.call(e, a) && (t[a] = e[a]);
    return t;
  }, u.apply(this, arguments);
};
function p(t, e, s) {
  if (s || 2 === arguments.length) for (var i, n = 0, a = e.length; n < a; n++) !i && n in e || (i || (i = Array.prototype.slice.call(e, 0, n)), i[n] = e[n]);
  return t.concat(i || Array.prototype.slice.call(e));
}
"function" == typeof SuppressedError && SuppressedError;
var f = function () {
  function t(t) {
    void 0 === t && (t = {});
    var e = this;
    Object.entries(t).forEach(function (t) {
      var s = t[0],
        i = t[1];
      return e[s] = i;
    });
  }
  return t.prototype.toString = function () {
    return JSON.stringify(this);
  }, t.prototype.setValue = function (t, e) {
    return this[t] = e, this;
  }, t;
}();
function m(t) {
  for (var e = arguments, s = [], i = 1; i < arguments.length; i++) s[i - 1] = e[i];
  return null != t && s.some(function (e) {
    var s, i;
    return "function" == typeof (null === (i = null === (s = null == t ? void 0 : t.ownerDocument) || void 0 === s ? void 0 : s.defaultView) || void 0 === i ? void 0 : i[e]) && t instanceof t.ownerDocument.defaultView[e];
  });
}
function g(t, e, s) {
  var i;
  return "#text" === t.nodeName ? i = s.document.createTextNode(t.data) : "#comment" === t.nodeName ? i = s.document.createComment(t.data) : (e ? (i = s.document.createElementNS("http://www.w3.org/2000/svg", t.nodeName), "foreignObject" === t.nodeName && (e = !1)) : "svg" === t.nodeName.toLowerCase() ? (i = s.document.createElementNS("http://www.w3.org/2000/svg", "svg"), e = !0) : i = s.document.createElement(t.nodeName), t.attributes && Object.entries(t.attributes).forEach(function (t) {
    var e = t[0],
      s = t[1];
    return i.setAttribute(e, s);
  }), t.childNodes && t.childNodes.forEach(function (t) {
    return i.appendChild(g(t, e, s));
  }), s.valueDiffing && (t.value && m(i, "HTMLButtonElement", "HTMLDataElement", "HTMLInputElement", "HTMLLIElement", "HTMLMeterElement", "HTMLOptionElement", "HTMLProgressElement", "HTMLParamElement") && (i.value = t.value), t.checked && m(i, "HTMLInputElement") && (i.checked = t.checked), t.selected && m(i, "HTMLOptionElement") && (i.selected = t.selected))), i;
}
var b = function (t, e) {
  for (e = e.slice(); e.length > 0;) {
    var s = e.splice(0, 1)[0];
    t = t.childNodes[s];
  }
  return t;
};
function v(t, e, s) {
  var i,
    n,
    a,
    o = e[s._const.action],
    r = e[s._const.route];
  [s._const.addElement, s._const.addTextElement].includes(o) || (i = b(t, r));
  var l = {
    diff: e,
    node: i
  };
  if (s.preDiffApply(l)) return !0;
  switch (o) {
    case s._const.addAttribute:
      if (!i || !m(i, "Element")) return !1;
      i.setAttribute(e[s._const.name], e[s._const.value]);
      break;
    case s._const.modifyAttribute:
      if (!i || !m(i, "Element")) return !1;
      i.setAttribute(e[s._const.name], e[s._const.newValue]), m(i, "HTMLInputElement") && "value" === e[s._const.name] && (i.value = e[s._const.newValue]);
      break;
    case s._const.removeAttribute:
      if (!i || !m(i, "Element")) return !1;
      i.removeAttribute(e[s._const.name]);
      break;
    case s._const.modifyTextElement:
      if (!i || !m(i, "Text")) return !1;
      s.textDiff(i, i.data, e[s._const.oldValue], e[s._const.newValue]), m(i.parentNode, "HTMLTextAreaElement") && (i.parentNode.value = e[s._const.newValue]);
      break;
    case s._const.modifyValue:
      if (!i || void 0 === i.value) return !1;
      i.value = e[s._const.newValue];
      break;
    case s._const.modifyComment:
      if (!i || !m(i, "Comment")) return !1;
      s.textDiff(i, i.data, e[s._const.oldValue], e[s._const.newValue]);
      break;
    case s._const.modifyChecked:
      if (!i || void 0 === i.checked) return !1;
      i.checked = e[s._const.newValue];
      break;
    case s._const.modifySelected:
      if (!i || void 0 === i.selected) return !1;
      i.selected = e[s._const.newValue];
      break;
    case s._const.replaceElement:
      var d = "svg" === e[s._const.newValue].nodeName.toLowerCase() || "http://www.w3.org/2000/svg" === i.parentNode.namespaceURI;
      i.parentNode.replaceChild(g(e[s._const.newValue], d, s), i);
      break;
    case s._const.relocateGroup:
      p([], new Array(e[s._const.groupLength]), !0).map(function () {
        return i.removeChild(i.childNodes[e[s._const.from]]);
      }).forEach(function (t, n) {
        0 === n && (a = i.childNodes[e[s._const.to]]), i.insertBefore(t, a || null);
      });
      break;
    case s._const.removeElement:
      i.parentNode.removeChild(i);
      break;
    case s._const.addElement:
      var c = (u = r.slice()).splice(u.length - 1, 1)[0];
      if (!m(i = b(t, u), "Element")) return !1;
      i.insertBefore(g(e[s._const.element], "http://www.w3.org/2000/svg" === i.namespaceURI, s), i.childNodes[c] || null);
      break;
    case s._const.removeTextElement:
      if (!i || 3 !== i.nodeType) return !1;
      var h = i.parentNode;
      h.removeChild(i), m(h, "HTMLTextAreaElement") && (h.value = "");
      break;
    case s._const.addTextElement:
      var u;
      c = (u = r.slice()).splice(u.length - 1, 1)[0];
      if (n = s.document.createTextNode(e[s._const.value]), !(i = b(t, u)).childNodes) return !1;
      i.insertBefore(n, i.childNodes[c] || null), m(i.parentNode, "HTMLTextAreaElement") && (i.parentNode.value = e[s._const.value]);
      break;
    default:
      console.log("unknown action");
  }
  return s.postDiffApply({
    diff: l.diff,
    node: l.node,
    newNode: n
  }), !0;
}
function _(t, e, s) {
  var i = t[e];
  t[e] = t[s], t[s] = i;
}
function w(t, e, s) {
  (e = e.slice()).reverse(), e.forEach(function (e) {
    !function (t, e, s) {
      switch (e[s._const.action]) {
        case s._const.addAttribute:
          e[s._const.action] = s._const.removeAttribute, v(t, e, s);
          break;
        case s._const.modifyAttribute:
          _(e, s._const.oldValue, s._const.newValue), v(t, e, s);
          break;
        case s._const.removeAttribute:
          e[s._const.action] = s._const.addAttribute, v(t, e, s);
          break;
        case s._const.modifyTextElement:
        case s._const.modifyValue:
        case s._const.modifyComment:
        case s._const.modifyChecked:
        case s._const.modifySelected:
        case s._const.replaceElement:
          _(e, s._const.oldValue, s._const.newValue), v(t, e, s);
          break;
        case s._const.relocateGroup:
          _(e, s._const.from, s._const.to), v(t, e, s);
          break;
        case s._const.removeElement:
          e[s._const.action] = s._const.addElement, v(t, e, s);
          break;
        case s._const.addElement:
          e[s._const.action] = s._const.removeElement, v(t, e, s);
          break;
        case s._const.removeTextElement:
          e[s._const.action] = s._const.addTextElement, v(t, e, s);
          break;
        case s._const.addTextElement:
          e[s._const.action] = s._const.removeTextElement, v(t, e, s);
          break;
        default:
          console.log("unknown action");
      }
    }(t, e, s);
  });
}
var y = function (t) {
    var e = [];
    return e.push(t.nodeName), "#text" !== t.nodeName && "#comment" !== t.nodeName && t.attributes && (t.attributes.class && e.push("".concat(t.nodeName, ".").concat(t.attributes.class.replace(/ /g, "."))), t.attributes.id && e.push("".concat(t.nodeName, "#").concat(t.attributes.id))), e;
  },
  M = function (t) {
    var e = {},
      s = {};
    return t.forEach(function (t) {
      y(t).forEach(function (t) {
        var i = t in e;
        i || t in s ? i && (delete e[t], s[t] = !0) : e[t] = !0;
      });
    }), e;
  },
  D = function (t, e) {
    var s = M(t),
      i = M(e),
      n = {};
    return Object.keys(s).forEach(function (t) {
      i[t] && (n[t] = !0);
    }), n;
  },
  N = function (t) {
    return delete t.outerDone, delete t.innerDone, delete t.valueDone, !t.childNodes || t.childNodes.every(N);
  },
  x = function (t) {
    if (Object.prototype.hasOwnProperty.call(t, "data")) return {
      nodeName: "#text" === t.nodeName ? "#text" : "#comment",
      data: t.data
    };
    var e = {
      nodeName: t.nodeName
    };
    return Object.prototype.hasOwnProperty.call(t, "attributes") && (e.attributes = u({}, t.attributes)), Object.prototype.hasOwnProperty.call(t, "checked") && (e.checked = t.checked), Object.prototype.hasOwnProperty.call(t, "value") && (e.value = t.value), Object.prototype.hasOwnProperty.call(t, "selected") && (e.selected = t.selected), Object.prototype.hasOwnProperty.call(t, "childNodes") && (e.childNodes = t.childNodes.map(function (t) {
      return x(t);
    })), e;
  },
  O = function (t, e) {
    if (!["nodeName", "value", "checked", "selected", "data"].every(function (s) {
      return t[s] === e[s];
    })) return !1;
    if (Object.prototype.hasOwnProperty.call(t, "data")) return !0;
    if (Boolean(t.attributes) !== Boolean(e.attributes)) return !1;
    if (Boolean(t.childNodes) !== Boolean(e.childNodes)) return !1;
    if (t.attributes) {
      var s = Object.keys(t.attributes),
        i = Object.keys(e.attributes);
      if (s.length !== i.length) return !1;
      if (!s.every(function (s) {
        return t.attributes[s] === e.attributes[s];
      })) return !1;
    }
    if (t.childNodes) {
      if (t.childNodes.length !== e.childNodes.length) return !1;
      if (!t.childNodes.every(function (t, s) {
        return O(t, e.childNodes[s]);
      })) return !1;
    }
    return !0;
  },
  E = function (t, e, s, i, n) {
    if (void 0 === n && (n = !1), !t || !e) return !1;
    if (t.nodeName !== e.nodeName) return !1;
    if (["#text", "#comment"].includes(t.nodeName)) return !!n || t.data === e.data;
    if (t.nodeName in s) return !0;
    if (t.attributes && e.attributes) {
      if (t.attributes.id) {
        if (t.attributes.id !== e.attributes.id) return !1;
        if ("".concat(t.nodeName, "#").concat(t.attributes.id) in s) return !0;
      }
      if (t.attributes.class && t.attributes.class === e.attributes.class) if ("".concat(t.nodeName, ".").concat(t.attributes.class.replace(/ /g, ".")) in s) return !0;
    }
    if (i) return !0;
    var a = t.childNodes ? t.childNodes.slice().reverse() : [],
      o = e.childNodes ? e.childNodes.slice().reverse() : [];
    if (a.length !== o.length) return !1;
    if (n) return a.every(function (t, e) {
      return t.nodeName === o[e].nodeName;
    });
    var r = D(a, o);
    return a.every(function (t, e) {
      return E(t, o[e], r, !0, !0);
    });
  },
  V = function (t, e) {
    return p([], new Array(t), !0).map(function () {
      return e;
    });
  },
  $ = function (t, e) {
    for (var s = t.childNodes ? t.childNodes : [], i = e.childNodes ? e.childNodes : [], n = V(s.length, !1), a = V(i.length, !1), o = [], r = function () {
        return arguments[1];
      }, l = !1, d = function () {
        var t = function (t, e, s, i) {
          var n = 0,
            a = [],
            o = t.length,
            r = e.length,
            l = p([], new Array(o + 1), !0).map(function () {
              return [];
            }),
            d = D(t, e),
            c = o === r;
          c && t.some(function (t, s) {
            var i = y(t),
              n = y(e[s]);
            return i.length !== n.length ? (c = !1, !0) : (i.some(function (t, e) {
              if (t !== n[e]) return c = !1, !0;
            }), !c || void 0);
          });
          for (var h = 0; h < o; h++) for (var u = t[h], f = 0; f < r; f++) {
            var m = e[f];
            s[h] || i[f] || !E(u, m, d, c) ? l[h + 1][f + 1] = 0 : (l[h + 1][f + 1] = l[h][f] ? l[h][f] + 1 : 1, l[h + 1][f + 1] >= n && (n = l[h + 1][f + 1], a = [h + 1, f + 1]));
          }
          return 0 !== n && {
            oldValue: a[0] - n,
            newValue: a[1] - n,
            length: n
          };
        }(s, i, n, a);
        t ? (o.push(t), p([], new Array(t.length), !0).map(r).forEach(function (e) {
          return function (t, e, s, i) {
            t[s.oldValue + i] = !0, e[s.newValue + i] = !0;
          }(n, a, t, e);
        })) : l = !0;
      }; !l;) d();
    return t.subsets = o, t.subsetsAge = 100, o;
  },
  C = function () {
    function t() {
      this.list = [];
    }
    return t.prototype.add = function (t) {
      var e;
      (e = this.list).push.apply(e, t);
    }, t.prototype.forEach = function (t) {
      this.list.forEach(function (e) {
        return t(e);
      });
    }, t;
  }();
function k(t, e) {
  var s,
    i,
    n = t;
  for (e = e.slice(); e.length > 0;) i = e.splice(0, 1)[0], s = n, n = n.childNodes ? n.childNodes[i] : void 0;
  return {
    node: n,
    parentNode: s,
    nodeIndex: i
  };
}
function S(t, e, s) {
  return e.forEach(function (e) {
    !function (t, e, s) {
      var i, n, a, o;
      if (![s._const.addElement, s._const.addTextElement].includes(e[s._const.action])) {
        var r = k(t, e[s._const.route]);
        n = r.node, a = r.parentNode, o = r.nodeIndex;
      }
      var l,
        d,
        c = [],
        h = {
          diff: e,
          node: n
        };
      if (s.preVirtualDiffApply(h)) return !0;
      switch (e[s._const.action]) {
        case s._const.addAttribute:
          n.attributes || (n.attributes = {}), n.attributes[e[s._const.name]] = e[s._const.value], "checked" === e[s._const.name] ? n.checked = !0 : "selected" === e[s._const.name] ? n.selected = !0 : "INPUT" === n.nodeName && "value" === e[s._const.name] && (n.value = e[s._const.value]);
          break;
        case s._const.modifyAttribute:
          n.attributes[e[s._const.name]] = e[s._const.newValue];
          break;
        case s._const.removeAttribute:
          delete n.attributes[e[s._const.name]], 0 === Object.keys(n.attributes).length && delete n.attributes, "checked" === e[s._const.name] ? n.checked = !1 : "selected" === e[s._const.name] ? delete n.selected : "INPUT" === n.nodeName && "value" === e[s._const.name] && delete n.value;
          break;
        case s._const.modifyTextElement:
          n.data = e[s._const.newValue], "TEXTAREA" === a.nodeName && (a.value = e[s._const.newValue]);
          break;
        case s._const.modifyValue:
          n.value = e[s._const.newValue];
          break;
        case s._const.modifyComment:
          n.data = e[s._const.newValue];
          break;
        case s._const.modifyChecked:
          n.checked = e[s._const.newValue];
          break;
        case s._const.modifySelected:
          n.selected = e[s._const.newValue];
          break;
        case s._const.replaceElement:
          l = x(e[s._const.newValue]), a.childNodes[o] = l;
          break;
        case s._const.relocateGroup:
          n.childNodes.splice(e[s._const.from], e[s._const.groupLength]).reverse().forEach(function (t) {
            return n.childNodes.splice(e[s._const.to], 0, t);
          }), n.subsets && n.subsets.forEach(function (t) {
            if (e[s._const.from] < e[s._const.to] && t.oldValue <= e[s._const.to] && t.oldValue > e[s._const.from]) t.oldValue -= e[s._const.groupLength], (i = t.oldValue + t.length - e[s._const.to]) > 0 && (c.push({
              oldValue: e[s._const.to] + e[s._const.groupLength],
              newValue: t.newValue + t.length - i,
              length: i
            }), t.length -= i);else if (e[s._const.from] > e[s._const.to] && t.oldValue > e[s._const.to] && t.oldValue < e[s._const.from]) {
              var i;
              t.oldValue += e[s._const.groupLength], (i = t.oldValue + t.length - e[s._const.to]) > 0 && (c.push({
                oldValue: e[s._const.to] + e[s._const.groupLength],
                newValue: t.newValue + t.length - i,
                length: i
              }), t.length -= i);
            } else t.oldValue === e[s._const.from] && (t.oldValue = e[s._const.to]);
          });
          break;
        case s._const.removeElement:
          a.childNodes.splice(o, 1), a.subsets && a.subsets.forEach(function (t) {
            t.oldValue > o ? t.oldValue -= 1 : t.oldValue === o ? t.delete = !0 : t.oldValue < o && t.oldValue + t.length > o && (t.oldValue + t.length - 1 === o ? t.length-- : (c.push({
              newValue: t.newValue + o - t.oldValue,
              oldValue: o,
              length: t.length - o + t.oldValue - 1
            }), t.length = o - t.oldValue));
          }), n = a;
          break;
        case s._const.addElement:
          var u = (d = e[s._const.route].slice()).splice(d.length - 1, 1)[0];
          n = null === (i = k(t, d)) || void 0 === i ? void 0 : i.node, l = x(e[s._const.element]), n.childNodes || (n.childNodes = []), u >= n.childNodes.length ? n.childNodes.push(l) : n.childNodes.splice(u, 0, l), n.subsets && n.subsets.forEach(function (t) {
            if (t.oldValue >= u) t.oldValue += 1;else if (t.oldValue < u && t.oldValue + t.length > u) {
              var e = t.oldValue + t.length - u;
              c.push({
                newValue: t.newValue + t.length - e,
                oldValue: u + 1,
                length: e
              }), t.length -= e;
            }
          });
          break;
        case s._const.removeTextElement:
          a.childNodes.splice(o, 1), "TEXTAREA" === a.nodeName && delete a.value, a.subsets && a.subsets.forEach(function (t) {
            t.oldValue > o ? t.oldValue -= 1 : t.oldValue === o ? t.delete = !0 : t.oldValue < o && t.oldValue + t.length > o && (t.oldValue + t.length - 1 === o ? t.length-- : (c.push({
              newValue: t.newValue + o - t.oldValue,
              oldValue: o,
              length: t.length - o + t.oldValue - 1
            }), t.length = o - t.oldValue));
          }), n = a;
          break;
        case s._const.addTextElement:
          var p = (d = e[s._const.route].slice()).splice(d.length - 1, 1)[0];
          l = {
            nodeName: "#text",
            data: e[s._const.value]
          }, (n = k(t, d).node).childNodes || (n.childNodes = []), p >= n.childNodes.length ? n.childNodes.push(l) : n.childNodes.splice(p, 0, l), "TEXTAREA" === n.nodeName && (n.value = e[s._const.newValue]), n.subsets && n.subsets.forEach(function (t) {
            if (t.oldValue >= p && (t.oldValue += 1), t.oldValue < p && t.oldValue + t.length > p) {
              var e = t.oldValue + t.length - p;
              c.push({
                newValue: t.newValue + t.length - e,
                oldValue: p + 1,
                length: e
              }), t.length -= e;
            }
          });
          break;
        default:
          console.log("unknown action");
      }
      n.subsets && (n.subsets = n.subsets.filter(function (t) {
        return !t.delete && t.oldValue !== t.newValue;
      }), c.length && (n.subsets = n.subsets.concat(c))), s.postVirtualDiffApply({
        node: h.node,
        diff: h.diff,
        newNode: l
      });
    }(t, e, s);
  }), !0;
}
function T(t, e) {
  void 0 === e && (e = {
    valueDiffing: !0
  });
  var s = {
    nodeName: t.nodeName
  };
  if (m(t, "Text", "Comment")) s.data = t.data;else {
    if (t.attributes && t.attributes.length > 0) s.attributes = {}, Array.prototype.slice.call(t.attributes).forEach(function (t) {
      return s.attributes[t.name] = t.value;
    });
    if (t.childNodes && t.childNodes.length > 0) s.childNodes = [], Array.prototype.slice.call(t.childNodes).forEach(function (t) {
      return s.childNodes.push(T(t, e));
    });
    e.valueDiffing && (m(t, "HTMLTextAreaElement") && (s.value = t.value), m(t, "HTMLInputElement") && ["radio", "checkbox"].includes(t.type.toLowerCase()) && void 0 !== t.checked ? s.checked = t.checked : m(t, "HTMLButtonElement", "HTMLDataElement", "HTMLInputElement", "HTMLLIElement", "HTMLMeterElement", "HTMLOptionElement", "HTMLProgressElement", "HTMLParamElement") && (s.value = t.value), m(t, "HTMLOptionElement") && (s.selected = t.selected));
  }
  return s;
}
var A = /<\s*\/*[a-zA-Z:_][a-zA-Z0-9:_\-.]*\s*(?:"[^"]*"['"]*|'[^']*'['"]*|[^'"/>])*\/*\s*>|<!--(?:.|\n|\r)*?-->/g,
  L = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;
function P(t) {
  return t.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
}
var R = {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    menuItem: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
  },
  H = function (t, e) {
    var s = {
        nodeName: "",
        attributes: {}
      },
      i = !1,
      n = t.match(/<\/?([^\s]+?)[/\s>]/);
    if (n && (s.nodeName = e || "svg" === n[1] ? n[1] : n[1].toUpperCase(), (R[n[1]] || "/" === t.charAt(t.length - 2)) && (i = !0), s.nodeName.startsWith("!--"))) {
      var a = t.indexOf("--\x3e");
      return {
        type: "comment",
        node: {
          nodeName: "#comment",
          data: -1 !== a ? t.slice(4, a) : ""
        },
        voidElement: i
      };
    }
    for (var o = new RegExp(L), r = null, l = !1; !l;) if (null === (r = o.exec(t))) l = !0;else if (r[0].trim()) if (r[1]) {
      var d = r[1].trim(),
        c = [d, ""];
      d.indexOf("=") > -1 && (c = d.split("=")), s.attributes[c[0]] = c[1], o.lastIndex--;
    } else r[2] && (s.attributes[r[2]] = r[3].trim().substring(1, r[3].length - 1));
    return {
      type: "tag",
      node: s,
      voidElement: i
    };
  },
  I = function (t, e) {
    void 0 === e && (e = {
      valueDiffing: !0,
      caseSensitive: !1
    });
    var s,
      i = [],
      n = -1,
      a = [],
      o = !1;
    if (0 !== t.indexOf("<")) {
      var r = t.indexOf("<");
      i.push({
        nodeName: "#text",
        data: -1 === r ? t : t.substring(0, r)
      });
    }
    return t.replace(A, function (r, l) {
      var d = "/" !== r.charAt(1),
        c = r.startsWith("\x3c!--"),
        h = l + r.length,
        u = t.charAt(h);
      if (c) {
        var p = H(r, e.caseSensitive).node;
        if (n < 0) return i.push(p), "";
        var f = a[n];
        return f && p.nodeName && (f.node.childNodes || (f.node.childNodes = []), f.node.childNodes.push(p)), "";
      }
      if (d) {
        if ("svg" === (s = H(r, e.caseSensitive || o)).node.nodeName && (o = !0), n++, !s.voidElement && u && "<" !== u) {
          s.node.childNodes || (s.node.childNodes = []);
          var m = P(t.slice(h, t.indexOf("<", h)));
          s.node.childNodes.push({
            nodeName: "#text",
            data: m
          }), e.valueDiffing && "TEXTAREA" === s.node.nodeName && (s.node.value = m);
        }
        0 === n && s.node.nodeName && i.push(s.node);
        var g = a[n - 1];
        g && s.node.nodeName && (g.node.childNodes || (g.node.childNodes = []), g.node.childNodes.push(s.node)), a[n] = s;
      }
      if ((!d || s.voidElement) && (n > -1 && (s.voidElement || e.caseSensitive && s.node.nodeName === r.slice(2, -1) || !e.caseSensitive && s.node.nodeName.toUpperCase() === r.slice(2, -1).toUpperCase()) && --n > -1 && ("svg" === s.node.nodeName && (o = !1), s = a[n]), "<" !== u && u)) {
        var b = -1 === n ? i : a[n].node.childNodes || [],
          v = t.indexOf("<", h);
        m = P(t.slice(h, -1 === v ? void 0 : v));
        b.push({
          nodeName: "#text",
          data: m
        });
      }
      return "";
    }), i[0];
  },
  Y = function () {
    function t(t, e, s) {
      this.options = s, this.t1 = "undefined" != typeof Element && m(t, "Element") ? T(t, this.options) : "string" == typeof t ? I(t, this.options) : JSON.parse(JSON.stringify(t)), this.t2 = "undefined" != typeof Element && m(e, "Element") ? T(e, this.options) : "string" == typeof e ? I(e, this.options) : JSON.parse(JSON.stringify(e)), this.diffcount = 0, this.foundAll = !1, this.debug && (this.t1Orig = "undefined" != typeof Element && m(t, "Element") ? T(t, this.options) : "string" == typeof t ? I(t, this.options) : JSON.parse(JSON.stringify(t)), this.t2Orig = "undefined" != typeof Element && m(e, "Element") ? T(e, this.options) : "string" == typeof e ? I(e, this.options) : JSON.parse(JSON.stringify(e))), this.tracker = new C();
    }
    return t.prototype.init = function () {
      return this.findDiffs(this.t1, this.t2);
    }, t.prototype.findDiffs = function (t, e) {
      var s;
      do {
        if (this.options.debug && (this.diffcount += 1, this.diffcount > this.options.diffcap)) throw new Error("surpassed diffcap:".concat(JSON.stringify(this.t1Orig), " -> ").concat(JSON.stringify(this.t2Orig)));
        0 === (s = this.findNextDiff(t, e, [])).length && (O(t, e) || (this.foundAll ? console.error("Could not find remaining diffs!") : (this.foundAll = !0, N(t), s = this.findNextDiff(t, e, [])))), s.length > 0 && (this.foundAll = !1, this.tracker.add(s), S(t, s, this.options));
      } while (s.length > 0);
      return this.tracker.list;
    }, t.prototype.findNextDiff = function (t, e, s) {
      var i, n;
      if (this.options.maxDepth && s.length > this.options.maxDepth) return [];
      if (!t.outerDone) {
        if (i = this.findOuterDiff(t, e, s), this.options.filterOuterDiff && (n = this.options.filterOuterDiff(t, e, i)) && (i = n), i.length > 0) return t.outerDone = !0, i;
        t.outerDone = !0;
      }
      if (Object.prototype.hasOwnProperty.call(t, "data")) return [];
      if (!t.innerDone) {
        if ((i = this.findInnerDiff(t, e, s)).length > 0) return i;
        t.innerDone = !0;
      }
      if (this.options.valueDiffing && !t.valueDone) {
        if ((i = this.findValueDiff(t, e, s)).length > 0) return t.valueDone = !0, i;
        t.valueDone = !0;
      }
      return [];
    }, t.prototype.findOuterDiff = function (t, e, s) {
      var i,
        n,
        a,
        o,
        r,
        l,
        d = [];
      if (t.nodeName !== e.nodeName) {
        if (!s.length) throw new Error("Top level nodes have to be of the same kind.");
        return [new f().setValue(this.options._const.action, this.options._const.replaceElement).setValue(this.options._const.oldValue, x(t)).setValue(this.options._const.newValue, x(e)).setValue(this.options._const.route, s)];
      }
      if (s.length && this.options.diffcap < Math.abs((t.childNodes || []).length - (e.childNodes || []).length)) return [new f().setValue(this.options._const.action, this.options._const.replaceElement).setValue(this.options._const.oldValue, x(t)).setValue(this.options._const.newValue, x(e)).setValue(this.options._const.route, s)];
      if (Object.prototype.hasOwnProperty.call(t, "data") && t.data !== e.data) return "#text" === t.nodeName ? [new f().setValue(this.options._const.action, this.options._const.modifyTextElement).setValue(this.options._const.route, s).setValue(this.options._const.oldValue, t.data).setValue(this.options._const.newValue, e.data)] : [new f().setValue(this.options._const.action, this.options._const.modifyComment).setValue(this.options._const.route, s).setValue(this.options._const.oldValue, t.data).setValue(this.options._const.newValue, e.data)];
      for (n = t.attributes ? Object.keys(t.attributes).sort() : [], a = e.attributes ? Object.keys(e.attributes).sort() : [], o = n.length, l = 0; l < o; l++) i = n[l], -1 === (r = a.indexOf(i)) ? d.push(new f().setValue(this.options._const.action, this.options._const.removeAttribute).setValue(this.options._const.route, s).setValue(this.options._const.name, i).setValue(this.options._const.value, t.attributes[i])) : (a.splice(r, 1), t.attributes[i] !== e.attributes[i] && d.push(new f().setValue(this.options._const.action, this.options._const.modifyAttribute).setValue(this.options._const.route, s).setValue(this.options._const.name, i).setValue(this.options._const.oldValue, t.attributes[i]).setValue(this.options._const.newValue, e.attributes[i])));
      for (o = a.length, l = 0; l < o; l++) i = a[l], d.push(new f().setValue(this.options._const.action, this.options._const.addAttribute).setValue(this.options._const.route, s).setValue(this.options._const.name, i).setValue(this.options._const.value, e.attributes[i]));
      return d;
    }, t.prototype.findInnerDiff = function (t, e, s) {
      var i = t.childNodes ? t.childNodes.slice() : [],
        n = e.childNodes ? e.childNodes.slice() : [],
        a = Math.max(i.length, n.length),
        o = Math.abs(i.length - n.length),
        r = [],
        l = 0;
      if (!this.options.maxChildCount || a < this.options.maxChildCount) {
        var d = Boolean(t.subsets && t.subsetsAge--),
          c = d ? t.subsets : t.childNodes && e.childNodes ? $(t, e) : [];
        if (c.length > 0 && (r = this.attemptGroupRelocation(t, e, c, s, d)).length > 0) return r;
      }
      for (var h = 0; h < a; h += 1) {
        var u = i[h],
          p = n[h];
        o && (u && !p ? "#text" === u.nodeName ? (r.push(new f().setValue(this.options._const.action, this.options._const.removeTextElement).setValue(this.options._const.route, s.concat(l)).setValue(this.options._const.value, u.data)), l -= 1) : (r.push(new f().setValue(this.options._const.action, this.options._const.removeElement).setValue(this.options._const.route, s.concat(l)).setValue(this.options._const.element, x(u))), l -= 1) : p && !u && ("#text" === p.nodeName ? r.push(new f().setValue(this.options._const.action, this.options._const.addTextElement).setValue(this.options._const.route, s.concat(l)).setValue(this.options._const.value, p.data)) : r.push(new f().setValue(this.options._const.action, this.options._const.addElement).setValue(this.options._const.route, s.concat(l)).setValue(this.options._const.element, x(p))))), u && p && (!this.options.maxChildCount || a < this.options.maxChildCount ? r = r.concat(this.findNextDiff(u, p, s.concat(l))) : O(u, p) || (i.length > n.length ? ("#text" === u.nodeName ? r.push(new f().setValue(this.options._const.action, this.options._const.removeTextElement).setValue(this.options._const.route, s.concat(l)).setValue(this.options._const.value, u.data)) : r.push(new f().setValue(this.options._const.action, this.options._const.removeElement).setValue(this.options._const.element, x(u)).setValue(this.options._const.route, s.concat(l))), i.splice(h, 1), h -= 1, l -= 1, o -= 1) : i.length < n.length ? (r = r.concat([new f().setValue(this.options._const.action, this.options._const.addElement).setValue(this.options._const.element, x(p)).setValue(this.options._const.route, s.concat(l))]), i.splice(h, 0, x(p)), o -= 1) : r = r.concat([new f().setValue(this.options._const.action, this.options._const.replaceElement).setValue(this.options._const.oldValue, x(u)).setValue(this.options._const.newValue, x(p)).setValue(this.options._const.route, s.concat(l))]))), l += 1;
      }
      return t.innerDone = !0, r;
    }, t.prototype.attemptGroupRelocation = function (t, e, s, i, n) {
      for (var a, o, r, l, d, c = function (t, e, s) {
          var i = t.childNodes ? V(t.childNodes.length, !0) : [],
            n = e.childNodes ? V(e.childNodes.length, !0) : [],
            a = 0;
          return s.forEach(function (t) {
            for (var e = t.oldValue + t.length, s = t.newValue + t.length, o = t.oldValue; o < e; o += 1) i[o] = a;
            for (o = t.newValue; o < s; o += 1) n[o] = a;
            a += 1;
          }), {
            gaps1: i,
            gaps2: n
          };
        }(t, e, s), h = c.gaps1, u = c.gaps2, p = t.childNodes.slice(), m = e.childNodes.slice(), g = Math.min(h.length, u.length), b = [], v = 0, _ = 0; v < g; _ += 1, v += 1) if (!n || !0 !== h[v] && !0 !== u[v]) {
        if (!0 === h[_]) {
          if ("#text" === (l = p[_]).nodeName) {
            if ("#text" === m[v].nodeName) {
              if (l.data !== m[v].data) {
                for (var w = _; p.length > w + 1 && "#text" === p[w + 1].nodeName;) if (w += 1, m[v].data === p[w].data) {
                  d = !0;
                  break;
                }
                d || b.push(new f().setValue(this.options._const.action, this.options._const.modifyTextElement).setValue(this.options._const.route, i.concat(_)).setValue(this.options._const.oldValue, l.data).setValue(this.options._const.newValue, m[v].data));
              }
            } else b.push(new f().setValue(this.options._const.action, this.options._const.removeTextElement).setValue(this.options._const.route, i.concat(_)).setValue(this.options._const.value, l.data)), h.splice(_, 1), p.splice(_, 1), g = Math.min(h.length, u.length), _ -= 1, v -= 1;
          } else !0 === u[v] ? b.push(new f().setValue(this.options._const.action, this.options._const.replaceElement).setValue(this.options._const.oldValue, x(l)).setValue(this.options._const.newValue, x(m[v])).setValue(this.options._const.route, i.concat(_))) : (b.push(new f().setValue(this.options._const.action, this.options._const.removeElement).setValue(this.options._const.route, i.concat(_)).setValue(this.options._const.element, x(l))), h.splice(_, 1), p.splice(_, 1), g = Math.min(h.length, u.length), _ -= 1, v -= 1);
        } else if (!0 === u[v]) "#text" === (l = m[v]).nodeName ? (b.push(new f().setValue(this.options._const.action, this.options._const.addTextElement).setValue(this.options._const.route, i.concat(_)).setValue(this.options._const.value, l.data)), h.splice(_, 0, !0), p.splice(_, 0, {
          nodeName: "#text",
          data: l.data
        }), g = Math.min(h.length, u.length)) : (b.push(new f().setValue(this.options._const.action, this.options._const.addElement).setValue(this.options._const.route, i.concat(_)).setValue(this.options._const.element, x(l))), h.splice(_, 0, !0), p.splice(_, 0, x(l)), g = Math.min(h.length, u.length));else if (h[_] !== u[v]) {
          if (b.length > 0) return b;
          if (r = s[h[_]], (o = Math.min(r.newValue, p.length - r.length)) !== r.oldValue) {
            a = !1;
            for (var y = 0; y < r.length; y += 1) E(p[o + y], p[r.oldValue + y], {}, !1, !0) || (a = !0);
            if (a) return [new f().setValue(this.options._const.action, this.options._const.relocateGroup).setValue(this.options._const.groupLength, r.length).setValue(this.options._const.from, r.oldValue).setValue(this.options._const.to, o).setValue(this.options._const.route, i)];
          }
        }
      } else ;
      return b;
    }, t.prototype.findValueDiff = function (t, e, s) {
      var i = [];
      return t.selected !== e.selected && i.push(new f().setValue(this.options._const.action, this.options._const.modifySelected).setValue(this.options._const.oldValue, t.selected).setValue(this.options._const.newValue, e.selected).setValue(this.options._const.route, s)), (t.value || e.value) && t.value !== e.value && "OPTION" !== t.nodeName && i.push(new f().setValue(this.options._const.action, this.options._const.modifyValue).setValue(this.options._const.oldValue, t.value || "").setValue(this.options._const.newValue, e.value || "").setValue(this.options._const.route, s)), t.checked !== e.checked && i.push(new f().setValue(this.options._const.action, this.options._const.modifyChecked).setValue(this.options._const.oldValue, t.checked).setValue(this.options._const.newValue, e.checked).setValue(this.options._const.route, s)), i;
    }, t;
  }(),
  j = {
    debug: !1,
    diffcap: 10,
    maxDepth: !1,
    maxChildCount: 50,
    valueDiffing: !0,
    textDiff: function (t, e, s, i) {
      t.data = i;
    },
    preVirtualDiffApply: function () {},
    postVirtualDiffApply: function () {},
    preDiffApply: function () {},
    postDiffApply: function () {},
    filterOuterDiff: null,
    compress: !1,
    _const: !1,
    document: !("undefined" == typeof window || !window.document) && window.document,
    components: []
  },
  q = function () {
    function t(t) {
      if (void 0 === t && (t = {}), Object.entries(j).forEach(function (e) {
        var s = e[0],
          i = e[1];
        Object.prototype.hasOwnProperty.call(t, s) || (t[s] = i);
      }), !t._const) {
        var e = ["addAttribute", "modifyAttribute", "removeAttribute", "modifyTextElement", "relocateGroup", "removeElement", "addElement", "removeTextElement", "addTextElement", "replaceElement", "modifyValue", "modifyChecked", "modifySelected", "modifyComment", "action", "route", "oldValue", "newValue", "element", "group", "groupLength", "from", "to", "name", "value", "data", "attributes", "nodeName", "childNodes", "checked", "selected"],
          s = {};
        t.compress ? e.forEach(function (t, e) {
          return s[t] = e;
        }) : e.forEach(function (t) {
          return s[t] = t;
        }), t._const = s;
      }
      this.options = t;
    }
    return t.prototype.apply = function (t, e) {
      return function (t, e, s) {
        return e.every(function (e) {
          return v(t, e, s);
        });
      }(t, e, this.options);
    }, t.prototype.undo = function (t, e) {
      return w(t, e, this.options);
    }, t.prototype.diff = function (t, e) {
      return new Y(t, e, this.options).init();
    }, t;
  }();
const F = (t, e, s, {
    classes: i,
    format: n,
    hiddenHeader: a,
    sortable: o,
    scrollY: r,
    type: l
  }, {
    noColumnWidths: d,
    unhideHeader: h
  }) => ({
    nodeName: "TR",
    childNodes: t.map((t, u) => {
      const p = e[u] || {
        type: l,
        format: n,
        sortable: !0,
        searchable: !0
      };
      if (p.hidden) return;
      const f = t.attributes ? {
        ...t.attributes
      } : {};
      if (p.sortable && o && (!r.length || h) && (p.filter ? f["data-filterable"] = "true" : f["data-sortable"] = "true"), p.headerClass && (f.class = c(f.class, p.headerClass)), s.sort && s.sort.column === u) {
        const t = "asc" === s.sort.dir ? i.ascending : i.descending;
        f.class = c(f.class, t), f["aria-sort"] = "asc" === s.sort.dir ? "ascending" : "descending";
      } else s.filters[u] && (f.class = c(f.class, i.filterActive));
      if (s.widths[u] && !d) {
        const t = `width: ${s.widths[u]}%;`;
        f.style = c(f.style, t);
      }
      if (r.length && !h) {
        const t = "padding-bottom: 0;padding-top: 0;border: 0;";
        f.style = c(f.style, t);
      }
      const m = "html" === t.type ? t.data : [{
        nodeName: "#text",
        data: t.text ?? String(t.data)
      }];
      return {
        nodeName: "TH",
        attributes: f,
        childNodes: !a && !r.length || h ? p.sortable && o ? [{
          nodeName: "BUTTON",
          attributes: {
            class: p.filter ? i.filter : i.sorter
          },
          childNodes: m
        }] : m : [{
          nodeName: "#text",
          data: ""
        }]
      };
    }).filter(t => t)
  }),
  B = (t, e, s, i, a, o, {
    classes: r,
    hiddenHeader: l,
    header: d,
    footer: h,
    format: u,
    sortable: p,
    scrollY: f,
    type: m,
    rowRender: g,
    tabIndex: b
  }, {
    noColumnWidths: v,
    unhideHeader: _,
    renderHeader: w
  }, y, M) => {
    const D = {
      nodeName: "TABLE",
      attributes: {
        ...t
      },
      childNodes: [{
        nodeName: "TBODY",
        childNodes: s.map(({
          row: t,
          index: e
        }) => {
          const s = {
            nodeName: "TR",
            attributes: {
              ...t.attributes,
              "data-index": String(e)
            },
            childNodes: t.cells.map((t, s) => {
              const o = i[s] || {
                type: m,
                format: u,
                sortable: !0,
                searchable: !0
              };
              if (o.hidden) return;
              const r = {
                nodeName: "TD",
                attributes: t.attributes ? {
                  ...t.attributes
                } : {},
                childNodes: "html" === o.type ? t.data : [{
                  nodeName: "#text",
                  data: n(t)
                }]
              };
              if (d || h || !a.widths[s] || v || (r.attributes.style = c(r.attributes.style, `width: ${a.widths[s]}%;`)), o.cellClass && (r.attributes.class = c(r.attributes.class, o.cellClass)), o.render) {
                const i = o.render(t.data, r, e, s);
                if (i) {
                  if ("string" != typeof i) return i;
                  {
                    const t = I(`<td>${i}</td>`);
                    1 === t.childNodes.length && ["#text", "#comment"].includes(t.childNodes[0].nodeName) ? r.childNodes[0].data = i : r.childNodes = t.childNodes;
                  }
                }
              }
              return r;
            }).filter(t => t)
          };
          if (e === o && (s.attributes.class = c(s.attributes.class, r.cursor)), g) {
            const i = g(t, s, e);
            if (i) {
              if ("string" != typeof i) return i;
              {
                const t = I(`<tr>${i}</tr>`);
                !t.childNodes || 1 === t.childNodes.length && ["#text", "#comment"].includes(t.childNodes[0].nodeName) ? s.childNodes[0].data = i : s.childNodes = t.childNodes;
              }
            }
          }
          return s;
        })
      }]
    };
    if (D.attributes.class = c(D.attributes.class, r.table), d || h || w) {
      const t = F(e, i, a, {
        classes: r,
        hiddenHeader: l,
        sortable: p,
        scrollY: f
      }, {
        noColumnWidths: v,
        unhideHeader: _
      });
      if (d || w) {
        const e = {
          nodeName: "THEAD",
          childNodes: [t]
        };
        !f.length && !l || _ || (e.attributes = {
          style: "height: 0px;"
        }), D.childNodes.unshift(e);
      }
      if (h) {
        const e = {
          nodeName: "TFOOT",
          childNodes: [d ? structuredClone(t) : t]
        };
        !f.length && !l || _ || (e.attributes = {
          style: "height: 0px;"
        }), D.childNodes.push(e);
      }
    }
    return y.forEach(t => D.childNodes.push(t)), M.forEach(t => D.childNodes.push(t)), !1 !== b && (D.attributes.tabindex = String(b)), D;
  };
"undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof __webpack_require__.g ? __webpack_require__.g : "undefined" != typeof self && self;
function z(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var U = {
    exports: {}
  },
  W = z(U.exports = function () {
    var t = 1e3,
      e = 6e4,
      s = 36e5,
      i = "millisecond",
      n = "second",
      a = "minute",
      o = "hour",
      r = "day",
      l = "week",
      d = "month",
      c = "quarter",
      h = "year",
      u = "date",
      p = "Invalid Date",
      f = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
      m = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
      g = {
        name: "en",
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        ordinal: function (t) {
          var e = ["th", "st", "nd", "rd"],
            s = t % 100;
          return "[" + t + (e[(s - 20) % 10] || e[s] || e[0]) + "]";
        }
      },
      b = function (t, e, s) {
        var i = String(t);
        return !i || i.length >= e ? t : "" + Array(e + 1 - i.length).join(s) + t;
      },
      v = {
        s: b,
        z: function (t) {
          var e = -t.utcOffset(),
            s = Math.abs(e),
            i = Math.floor(s / 60),
            n = s % 60;
          return (e <= 0 ? "+" : "-") + b(i, 2, "0") + ":" + b(n, 2, "0");
        },
        m: function t(e, s) {
          if (e.date() < s.date()) return -t(s, e);
          var i = 12 * (s.year() - e.year()) + (s.month() - e.month()),
            n = e.clone().add(i, d),
            a = s - n < 0,
            o = e.clone().add(i + (a ? -1 : 1), d);
          return +(-(i + (s - n) / (a ? n - o : o - n)) || 0);
        },
        a: function (t) {
          return t < 0 ? Math.ceil(t) || 0 : Math.floor(t);
        },
        p: function (t) {
          return {
            M: d,
            y: h,
            w: l,
            d: r,
            D: u,
            h: o,
            m: a,
            s: n,
            ms: i,
            Q: c
          }[t] || String(t || "").toLowerCase().replace(/s$/, "");
        },
        u: function (t) {
          return void 0 === t;
        }
      },
      _ = "en",
      w = {};
    w[_] = g;
    var y = "$isDayjsObject",
      M = function (t) {
        return t instanceof O || !(!t || !t[y]);
      },
      D = function t(e, s, i) {
        var n;
        if (!e) return _;
        if ("string" == typeof e) {
          var a = e.toLowerCase();
          w[a] && (n = a), s && (w[a] = s, n = a);
          var o = e.split("-");
          if (!n && o.length > 1) return t(o[0]);
        } else {
          var r = e.name;
          w[r] = e, n = r;
        }
        return !i && n && (_ = n), n || !i && _;
      },
      N = function (t, e) {
        if (M(t)) return t.clone();
        var s = "object" == typeof e ? e : {};
        return s.date = t, s.args = arguments, new O(s);
      },
      x = v;
    x.l = D, x.i = M, x.w = function (t, e) {
      return N(t, {
        locale: e.$L,
        utc: e.$u,
        x: e.$x,
        $offset: e.$offset
      });
    };
    var O = function () {
        function g(t) {
          this.$L = D(t.locale, null, !0), this.parse(t), this.$x = this.$x || t.x || {}, this[y] = !0;
        }
        var b = g.prototype;
        return b.parse = function (t) {
          this.$d = function (t) {
            var e = t.date,
              s = t.utc;
            if (null === e) return new Date(NaN);
            if (x.u(e)) return new Date();
            if (e instanceof Date) return new Date(e);
            if ("string" == typeof e && !/Z$/i.test(e)) {
              var i = e.match(f);
              if (i) {
                var n = i[2] - 1 || 0,
                  a = (i[7] || "0").substring(0, 3);
                return s ? new Date(Date.UTC(i[1], n, i[3] || 1, i[4] || 0, i[5] || 0, i[6] || 0, a)) : new Date(i[1], n, i[3] || 1, i[4] || 0, i[5] || 0, i[6] || 0, a);
              }
            }
            return new Date(e);
          }(t), this.init();
        }, b.init = function () {
          var t = this.$d;
          this.$y = t.getFullYear(), this.$M = t.getMonth(), this.$D = t.getDate(), this.$W = t.getDay(), this.$H = t.getHours(), this.$m = t.getMinutes(), this.$s = t.getSeconds(), this.$ms = t.getMilliseconds();
        }, b.$utils = function () {
          return x;
        }, b.isValid = function () {
          return !(this.$d.toString() === p);
        }, b.isSame = function (t, e) {
          var s = N(t);
          return this.startOf(e) <= s && s <= this.endOf(e);
        }, b.isAfter = function (t, e) {
          return N(t) < this.startOf(e);
        }, b.isBefore = function (t, e) {
          return this.endOf(e) < N(t);
        }, b.$g = function (t, e, s) {
          return x.u(t) ? this[e] : this.set(s, t);
        }, b.unix = function () {
          return Math.floor(this.valueOf() / 1e3);
        }, b.valueOf = function () {
          return this.$d.getTime();
        }, b.startOf = function (t, e) {
          var s = this,
            i = !!x.u(e) || e,
            c = x.p(t),
            p = function (t, e) {
              var n = x.w(s.$u ? Date.UTC(s.$y, e, t) : new Date(s.$y, e, t), s);
              return i ? n : n.endOf(r);
            },
            f = function (t, e) {
              return x.w(s.toDate()[t].apply(s.toDate("s"), (i ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e)), s);
            },
            m = this.$W,
            g = this.$M,
            b = this.$D,
            v = "set" + (this.$u ? "UTC" : "");
          switch (c) {
            case h:
              return i ? p(1, 0) : p(31, 11);
            case d:
              return i ? p(1, g) : p(0, g + 1);
            case l:
              var _ = this.$locale().weekStart || 0,
                w = (m < _ ? m + 7 : m) - _;
              return p(i ? b - w : b + (6 - w), g);
            case r:
            case u:
              return f(v + "Hours", 0);
            case o:
              return f(v + "Minutes", 1);
            case a:
              return f(v + "Seconds", 2);
            case n:
              return f(v + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, b.endOf = function (t) {
          return this.startOf(t, !1);
        }, b.$set = function (t, e) {
          var s,
            l = x.p(t),
            c = "set" + (this.$u ? "UTC" : ""),
            p = (s = {}, s[r] = c + "Date", s[u] = c + "Date", s[d] = c + "Month", s[h] = c + "FullYear", s[o] = c + "Hours", s[a] = c + "Minutes", s[n] = c + "Seconds", s[i] = c + "Milliseconds", s)[l],
            f = l === r ? this.$D + (e - this.$W) : e;
          if (l === d || l === h) {
            var m = this.clone().set(u, 1);
            m.$d[p](f), m.init(), this.$d = m.set(u, Math.min(this.$D, m.daysInMonth())).$d;
          } else p && this.$d[p](f);
          return this.init(), this;
        }, b.set = function (t, e) {
          return this.clone().$set(t, e);
        }, b.get = function (t) {
          return this[x.p(t)]();
        }, b.add = function (i, c) {
          var u,
            p = this;
          i = Number(i);
          var f = x.p(c),
            m = function (t) {
              var e = N(p);
              return x.w(e.date(e.date() + Math.round(t * i)), p);
            };
          if (f === d) return this.set(d, this.$M + i);
          if (f === h) return this.set(h, this.$y + i);
          if (f === r) return m(1);
          if (f === l) return m(7);
          var g = (u = {}, u[a] = e, u[o] = s, u[n] = t, u)[f] || 1,
            b = this.$d.getTime() + i * g;
          return x.w(b, this);
        }, b.subtract = function (t, e) {
          return this.add(-1 * t, e);
        }, b.format = function (t) {
          var e = this,
            s = this.$locale();
          if (!this.isValid()) return s.invalidDate || p;
          var i = t || "YYYY-MM-DDTHH:mm:ssZ",
            n = x.z(this),
            a = this.$H,
            o = this.$m,
            r = this.$M,
            l = s.weekdays,
            d = s.months,
            c = s.meridiem,
            h = function (t, s, n, a) {
              return t && (t[s] || t(e, i)) || n[s].slice(0, a);
            },
            u = function (t) {
              return x.s(a % 12 || 12, t, "0");
            },
            f = c || function (t, e, s) {
              var i = t < 12 ? "AM" : "PM";
              return s ? i.toLowerCase() : i;
            };
          return i.replace(m, function (t, i) {
            return i || function (t) {
              switch (t) {
                case "YY":
                  return String(e.$y).slice(-2);
                case "YYYY":
                  return x.s(e.$y, 4, "0");
                case "M":
                  return r + 1;
                case "MM":
                  return x.s(r + 1, 2, "0");
                case "MMM":
                  return h(s.monthsShort, r, d, 3);
                case "MMMM":
                  return h(d, r);
                case "D":
                  return e.$D;
                case "DD":
                  return x.s(e.$D, 2, "0");
                case "d":
                  return String(e.$W);
                case "dd":
                  return h(s.weekdaysMin, e.$W, l, 2);
                case "ddd":
                  return h(s.weekdaysShort, e.$W, l, 3);
                case "dddd":
                  return l[e.$W];
                case "H":
                  return String(a);
                case "HH":
                  return x.s(a, 2, "0");
                case "h":
                  return u(1);
                case "hh":
                  return u(2);
                case "a":
                  return f(a, o, !0);
                case "A":
                  return f(a, o, !1);
                case "m":
                  return String(o);
                case "mm":
                  return x.s(o, 2, "0");
                case "s":
                  return String(e.$s);
                case "ss":
                  return x.s(e.$s, 2, "0");
                case "SSS":
                  return x.s(e.$ms, 3, "0");
                case "Z":
                  return n;
              }
              return null;
            }(t) || n.replace(":", "");
          });
        }, b.utcOffset = function () {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, b.diff = function (i, u, p) {
          var f,
            m = this,
            g = x.p(u),
            b = N(i),
            v = (b.utcOffset() - this.utcOffset()) * e,
            _ = this - b,
            w = function () {
              return x.m(m, b);
            };
          switch (g) {
            case h:
              f = w() / 12;
              break;
            case d:
              f = w();
              break;
            case c:
              f = w() / 3;
              break;
            case l:
              f = (_ - v) / 6048e5;
              break;
            case r:
              f = (_ - v) / 864e5;
              break;
            case o:
              f = _ / s;
              break;
            case a:
              f = _ / e;
              break;
            case n:
              f = _ / t;
              break;
            default:
              f = _;
          }
          return p ? f : x.a(f);
        }, b.daysInMonth = function () {
          return this.endOf(d).$D;
        }, b.$locale = function () {
          return w[this.$L];
        }, b.locale = function (t, e) {
          if (!t) return this.$L;
          var s = this.clone(),
            i = D(t, e, !0);
          return i && (s.$L = i), s;
        }, b.clone = function () {
          return x.w(this.$d, this);
        }, b.toDate = function () {
          return new Date(this.valueOf());
        }, b.toJSON = function () {
          return this.isValid() ? this.toISOString() : null;
        }, b.toISOString = function () {
          return this.$d.toISOString();
        }, b.toString = function () {
          return this.$d.toUTCString();
        }, g;
      }(),
      E = O.prototype;
    return N.prototype = E, [["$ms", i], ["$s", n], ["$m", a], ["$H", o], ["$W", r], ["$M", d], ["$y", h], ["$D", u]].forEach(function (t) {
      E[t[1]] = function (e) {
        return this.$g(e, t[0], t[1]);
      };
    }), N.extend = function (t, e) {
      return t.$i || (t(e, O, N), t.$i = !0), N;
    }, N.locale = D, N.isDayjs = M, N.unix = function (t) {
      return N(1e3 * t);
    }, N.en = w[_], N.Ls = w, N.p = {}, N;
  }()),
  J = {
    exports: {}
  },
  Q = z(J.exports = function () {
    var t = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      },
      e = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,
      s = /\d\d/,
      i = /\d\d?/,
      n = /\d*[^-_:/,()\s\d]+/,
      a = {},
      o = function (t) {
        return (t = +t) + (t > 68 ? 1900 : 2e3);
      },
      r = function (t) {
        return function (e) {
          this[t] = +e;
        };
      },
      l = [/[+-]\d\d:?(\d\d)?|Z/, function (t) {
        (this.zone || (this.zone = {})).offset = function (t) {
          if (!t) return 0;
          if ("Z" === t) return 0;
          var e = t.match(/([+-]|\d\d)/g),
            s = 60 * e[1] + (+e[2] || 0);
          return 0 === s ? 0 : "+" === e[0] ? -s : s;
        }(t);
      }],
      d = function (t) {
        var e = a[t];
        return e && (e.indexOf ? e : e.s.concat(e.f));
      },
      c = function (t, e) {
        var s,
          i = a.meridiem;
        if (i) {
          for (var n = 1; n <= 24; n += 1) if (t.indexOf(i(n, 0, e)) > -1) {
            s = n > 12;
            break;
          }
        } else s = t === (e ? "pm" : "PM");
        return s;
      },
      h = {
        A: [n, function (t) {
          this.afternoon = c(t, !1);
        }],
        a: [n, function (t) {
          this.afternoon = c(t, !0);
        }],
        S: [/\d/, function (t) {
          this.milliseconds = 100 * +t;
        }],
        SS: [s, function (t) {
          this.milliseconds = 10 * +t;
        }],
        SSS: [/\d{3}/, function (t) {
          this.milliseconds = +t;
        }],
        s: [i, r("seconds")],
        ss: [i, r("seconds")],
        m: [i, r("minutes")],
        mm: [i, r("minutes")],
        H: [i, r("hours")],
        h: [i, r("hours")],
        HH: [i, r("hours")],
        hh: [i, r("hours")],
        D: [i, r("day")],
        DD: [s, r("day")],
        Do: [n, function (t) {
          var e = a.ordinal,
            s = t.match(/\d+/);
          if (this.day = s[0], e) for (var i = 1; i <= 31; i += 1) e(i).replace(/\[|\]/g, "") === t && (this.day = i);
        }],
        M: [i, r("month")],
        MM: [s, r("month")],
        MMM: [n, function (t) {
          var e = d("months"),
            s = (d("monthsShort") || e.map(function (t) {
              return t.slice(0, 3);
            })).indexOf(t) + 1;
          if (s < 1) throw new Error();
          this.month = s % 12 || s;
        }],
        MMMM: [n, function (t) {
          var e = d("months").indexOf(t) + 1;
          if (e < 1) throw new Error();
          this.month = e % 12 || e;
        }],
        Y: [/[+-]?\d+/, r("year")],
        YY: [s, function (t) {
          this.year = o(t);
        }],
        YYYY: [/\d{4}/, r("year")],
        Z: l,
        ZZ: l
      };
    function u(s) {
      var i, n;
      i = s, n = a && a.formats;
      for (var o = (s = i.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function (e, s, i) {
          var a = i && i.toUpperCase();
          return s || n[i] || t[i] || n[a].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function (t, e, s) {
            return e || s.slice(1);
          });
        })).match(e), r = o.length, l = 0; l < r; l += 1) {
        var d = o[l],
          c = h[d],
          u = c && c[0],
          p = c && c[1];
        o[l] = p ? {
          regex: u,
          parser: p
        } : d.replace(/^\[|\]$/g, "");
      }
      return function (t) {
        for (var e = {}, s = 0, i = 0; s < r; s += 1) {
          var n = o[s];
          if ("string" == typeof n) i += n.length;else {
            var a = n.regex,
              l = n.parser,
              d = t.slice(i),
              c = a.exec(d)[0];
            l.call(e, c), t = t.replace(c, "");
          }
        }
        return function (t) {
          var e = t.afternoon;
          if (void 0 !== e) {
            var s = t.hours;
            e ? s < 12 && (t.hours += 12) : 12 === s && (t.hours = 0), delete t.afternoon;
          }
        }(e), e;
      };
    }
    return function (t, e, s) {
      s.p.customParseFormat = !0, t && t.parseTwoDigitYear && (o = t.parseTwoDigitYear);
      var i = e.prototype,
        n = i.parse;
      i.parse = function (t) {
        var e = t.date,
          i = t.utc,
          o = t.args;
        this.$u = i;
        var r = o[1];
        if ("string" == typeof r) {
          var l = !0 === o[2],
            d = !0 === o[3],
            c = l || d,
            h = o[2];
          d && (h = o[2]), a = this.$locale(), !l && h && (a = s.Ls[h]), this.$d = function (t, e, s) {
            try {
              if (["x", "X"].indexOf(e) > -1) return new Date(("X" === e ? 1e3 : 1) * t);
              var i = u(e)(t),
                n = i.year,
                a = i.month,
                o = i.day,
                r = i.hours,
                l = i.minutes,
                d = i.seconds,
                c = i.milliseconds,
                h = i.zone,
                p = new Date(),
                f = o || (n || a ? 1 : p.getDate()),
                m = n || p.getFullYear(),
                g = 0;
              n && !a || (g = a > 0 ? a - 1 : p.getMonth());
              var b = r || 0,
                v = l || 0,
                _ = d || 0,
                w = c || 0;
              return h ? new Date(Date.UTC(m, g, f, b, v, _, w + 60 * h.offset * 1e3)) : s ? new Date(Date.UTC(m, g, f, b, v, _, w)) : new Date(m, g, f, b, v, _, w);
            } catch (t) {
              return new Date("");
            }
          }(e, r, i), this.init(), h && !0 !== h && (this.$L = this.locale(h).$L), c && e != this.format(r) && (this.$d = new Date("")), a = {};
        } else if (r instanceof Array) for (var p = r.length, f = 1; f <= p; f += 1) {
          o[1] = r[f - 1];
          var m = s.apply(this, o);
          if (m.isValid()) {
            this.$d = m.$d, this.$L = m.$L, this.init();
            break;
          }
          f === p && (this.$d = new Date(""));
        } else n.call(this, t);
      };
    };
  }());
W.extend(Q);
const X = (t, e) => {
    let s;
    if (e) switch (e) {
      case "ISO_8601":
        s = t;
        break;
      case "RFC_2822":
        s = W(t.slice(5), "DD MMM YYYY HH:mm:ss ZZ").unix();
        break;
      case "MYSQL":
        s = W(t, "YYYY-MM-DD hh:mm:ss").unix();
        break;
      case "UNIX":
        s = W(t).unix();
        break;
      default:
        s = W(t, e, !0).valueOf();
    }
    return s;
  },
  Z = (t, e) => {
    if (t?.constructor === Object && Object.prototype.hasOwnProperty.call(t, "data") && !Object.keys(t).find(t => !["text", "order", "data", "attributes"].includes(t))) return t;
    const s = {
      data: t
    };
    switch (e.type) {
      case "string":
        "string" != typeof t && (s.text = String(s.data), s.order = s.text);
        break;
      case "date":
        e.format && (s.order = X(String(s.data), e.format));
        break;
      case "number":
        s.text = String(s.data), s.data = parseFloat(s.data), s.order = s.data;
        break;
      case "html":
        {
          const t = Array.isArray(s.data) ? {
            nodeName: "TD",
            childNodes: s.data
          } : I(`<td>${String(s.data)}</td>`);
          s.data = t.childNodes || [];
          const e = i(t);
          s.text = e, s.order = e;
          break;
        }
      case "boolean":
        "string" == typeof s.data && (s.data = s.data.toLowerCase().trim()), s.data = !["false", !1, null, void 0, 0].includes(s.data), s.order = s.data ? 1 : 0, s.text = String(s.data);
        break;
      case "other":
        s.text = "", s.order = 0;
        break;
      default:
        s.text = JSON.stringify(s.data);
    }
    return s;
  },
  G = t => {
    if (t instanceof Object && t.constructor === Object && t.hasOwnProperty("data") && ("string" == typeof t.text || "string" == typeof t.data)) return t;
    const e = {
      data: t
    };
    if ("string" == typeof t) {
      if (t.length) {
        const s = I(`<th>${t}</th>`);
        if (s.childNodes && (1 !== s.childNodes.length || "#text" !== s.childNodes[0].nodeName)) {
          e.data = s.childNodes, e.type = "html";
          const t = i(s);
          e.text = t;
        }
      }
    } else [null, void 0].includes(t) ? e.text = "" : e.text = JSON.stringify(t);
    return e;
  },
  K = (t, e = void 0, s, n, a) => {
    const o = {
      data: [],
      headings: []
    };
    if (t.headings) o.headings = t.headings.map(t => G(t));else if (e?.tHead) o.headings = Array.from(e.tHead.querySelectorAll("th")).map((t, e) => {
      const o = (t => {
        const e = T(t, {
          valueDiffing: !1
        });
        let s;
        return s = !e.childNodes || 1 === e.childNodes.length && "#text" === e.childNodes[0].nodeName ? {
          data: t.innerText,
          type: "string"
        } : {
          data: e.childNodes,
          type: "html",
          text: i(e)
        }, s.attributes = e.attributes, s;
      })(t);
      s[e] || (s[e] = {
        type: n,
        format: a,
        searchable: !0,
        sortable: !0
      });
      const r = s[e];
      return "false" !== t.dataset.sortable?.trim().toLowerCase() && "false" !== t.dataset.sort?.trim().toLowerCase() || (r.sortable = !1), "false" === t.dataset.searchable?.trim().toLowerCase() && (r.searchable = !1), "true" !== t.dataset.hidden?.trim().toLowerCase() && "true" !== t.getAttribute("hidden")?.trim().toLowerCase() || (r.hidden = !0), ["number", "string", "html", "date", "boolean", "other"].includes(t.dataset.type) && (r.type = t.dataset.type, "date" === r.type && t.dataset.format && (r.format = t.dataset.format)), o;
    });else if (t.data?.length) {
      const e = t.data[0],
        s = Array.isArray(e) ? e : e.cells;
      o.headings = s.map(t => G(""));
    } else e?.tBodies.length && (o.headings = Array.from(e.tBodies[0].rows[0].cells).map(t => G("")));
    for (let t = 0; t < o.headings.length; t++) s[t] || (s[t] = {
      type: n,
      format: a,
      sortable: !0,
      searchable: !0
    });
    if (t.data) {
      const e = o.headings.map(t => t.data ? String(t.data) : t.text);
      o.data = t.data.map(t => {
        let i, n;
        return Array.isArray(t) ? (i = {}, n = t) : t.hasOwnProperty("cells") && Object.keys(t).every(t => ["cells", "attributes"].includes(t)) ? (i = t.attributes, n = t.cells) : (i = {}, n = [], Object.entries(t).forEach(([t, s]) => {
          const i = e.indexOf(t);
          i > -1 && (n[i] = s);
        })), {
          attributes: i,
          cells: n.map((t, e) => Z(t, s[e]))
        };
      });
    } else e?.tBodies?.length && (o.data = Array.from(e.tBodies[0].rows).map(t => ({
      attributes: r(t.attributes),
      cells: Array.from(t.cells).map((t, e) => {
        const i = t.dataset.content ? Z(t.dataset.content, s[e]) : ((t, e) => {
          let s;
          switch (e.type) {
            case "string":
              s = {
                data: t.innerText
              };
              break;
            case "date":
              {
                const i = t.innerText;
                s = {
                  data: i,
                  order: X(i, e.format)
                };
                break;
              }
            case "number":
              {
                const e = parseFloat(t.innerText);
                s = {
                  data: e,
                  order: e,
                  text: t.innerText
                };
                break;
              }
            case "boolean":
              {
                const e = !["false", "0", "null", "undefined"].includes(t.innerText.toLowerCase().trim());
                s = {
                  data: e,
                  text: e ? "1" : "0",
                  order: e ? 1 : 0
                };
                break;
              }
            default:
              s = {
                data: T(t, {
                  valueDiffing: !1
                }).childNodes || [],
                text: t.innerText,
                order: t.innerText
              };
          }
          return s.attributes = r(t.attributes), s;
        })(t, s[e]);
        return t.dataset.order && (i.order = isNaN(parseFloat(t.dataset.order)) ? t.dataset.order : parseFloat(t.dataset.order)), i;
      })
    })));
    if (o.data.length && o.data[0].cells.length !== o.headings.length) throw new Error("Data heading length mismatch.");
    return o;
  };
class tt {
  cursor;
  dt;
  constructor(t) {
    this.dt = t, this.cursor = !1;
  }
  setCursor(t = !1) {
    if (t === this.cursor) return;
    const e = this.cursor;
    if (this.cursor = t, this.dt._renderTable(), !1 !== t && this.dt.options.scrollY) {
      const t = l(this.dt.options.classes.cursor),
        e = this.dt.dom.querySelector(`tr${t}`);
      e && e.scrollIntoView({
        block: "nearest"
      });
    }
    this.dt.emit("datatable.cursormove", this.cursor, e);
  }
  add(t) {
    if (!Array.isArray(t) || t.length < 1) return;
    const e = {
      cells: t.map((t, e) => {
        const s = this.dt.columns.settings[e];
        return Z(t, s);
      })
    };
    this.dt.data.data.push(e), this.dt.hasRows = !0, this.dt.update(!0);
  }
  remove(t) {
    if (!Array.isArray(t)) return this.remove([t]);
    this.dt.data.data = this.dt.data.data.filter((e, s) => !t.includes(s)), this.dt.data.data.length || (this.dt.hasRows = !1), this.dt.update(!0);
  }
  findRowIndex(t, e) {
    return this.dt.data.data.findIndex(s => {
      const i = s.cells[t];
      return n(i).toLowerCase().includes(String(e).toLowerCase());
    });
  }
  findRow(t, e) {
    const s = this.findRowIndex(t, e);
    if (s < 0) return {
      index: -1,
      row: null,
      cols: []
    };
    const i = this.dt.data.data[s],
      n = i.cells.map(t => t.data);
    return {
      index: s,
      row: i,
      cols: n
    };
  }
  updateRow(t, e) {
    const s = {
      cells: e.map((t, e) => {
        const s = this.dt.columns.settings[e];
        return Z(t, s);
      })
    };
    this.dt.data.data.splice(t, 1, s), this.dt.update(!0);
  }
}
class et {
  dt;
  settings;
  _state;
  constructor(t) {
    this.dt = t, this.init();
  }
  init() {
    [this.settings, this._state] = ((t = [], e, s) => {
      let i = [],
        n = !1;
      const a = [];
      return t.forEach(t => {
        (Array.isArray(t.select) ? t.select : [t.select]).forEach(o => {
          i[o] ? t.type && (i[o].type = t.type) : i[o] = {
            type: t.type || e,
            sortable: !0,
            searchable: !0
          };
          const r = i[o];
          t.render && (r.render = t.render), t.format ? r.format = t.format : "date" === t.type && (r.format = s), t.cellClass && (r.cellClass = t.cellClass), t.headerClass && (r.headerClass = t.headerClass), t.locale && (r.locale = t.locale), !1 === t.sortable ? r.sortable = !1 : (t.numeric && (r.numeric = t.numeric), t.caseFirst && (r.caseFirst = t.caseFirst)), !1 === t.searchable ? r.searchable = !1 : t.sensitivity && (r.sensitivity = t.sensitivity), (r.searchable || r.sortable) && void 0 !== t.ignorePunctuation && (r.ignorePunctuation = t.ignorePunctuation), t.searchMethod && (r.searchMethod = t.searchMethod), t.hidden && (r.hidden = !0), t.filter && (r.filter = t.filter), t.sortSequence && (r.sortSequence = t.sortSequence), t.sort && (t.filter ? a[o] = t.sort : n = {
            column: o,
            dir: t.sort
          }), void 0 !== t.searchItemSeparator && (r.searchItemSeparator = t.searchItemSeparator);
        });
      }), i = i.map(t => t || {
        type: e,
        format: "date" === e ? s : void 0,
        sortable: !0,
        searchable: !0
      }), [i, {
        filters: a,
        sort: n,
        widths: []
      }];
    })(this.dt.options.columns, this.dt.options.type, this.dt.options.format);
  }
  get(t) {
    return t < 0 || t >= this.size() ? null : {
      ...this.settings[t]
    };
  }
  size() {
    return this.settings.length;
  }
  swap(t) {
    if (2 === t.length) {
      const e = this.dt.data.headings.map((t, e) => e),
        s = t[0],
        i = t[1],
        n = e[i];
      return e[i] = e[s], e[s] = n, this.order(e);
    }
  }
  order(t) {
    this.dt.data.headings = t.map(t => this.dt.data.headings[t]), this.dt.data.data.forEach(e => e.cells = t.map(t => e.cells[t])), this.settings = t.map(t => this.settings[t]), this.dt.update();
  }
  hide(t) {
    Array.isArray(t) || (t = [t]), t.length && (t.forEach(t => {
      this.settings[t] || (this.settings[t] = {
        type: "string"
      });
      this.settings[t].hidden = !0;
    }), this.dt.update());
  }
  show(t) {
    Array.isArray(t) || (t = [t]), t.length && (t.forEach(t => {
      this.settings[t] || (this.settings[t] = {
        type: "string",
        sortable: !0
      });
      delete this.settings[t].hidden;
    }), this.dt.update());
  }
  visible(t) {
    return void 0 === t && (t = [...Array(this.dt.data.headings.length).keys()]), Array.isArray(t) ? t.map(t => !this.settings[t]?.hidden) : !this.settings[t]?.hidden;
  }
  add(t) {
    const e = this.dt.data.headings.length;
    if (this.dt.data.headings = this.dt.data.headings.concat([G(t.heading)]), this.dt.data.data.forEach((e, s) => {
      e.cells = e.cells.concat([Z(t.data[s], t)]);
    }), this.settings[e] = {
      type: t.type || "string",
      sortable: !0,
      searchable: !0
    }, t.type || t.format || t.sortable || t.render || t.filter) {
      const s = this.settings[e];
      t.render && (s.render = t.render), t.format && (s.format = t.format), t.cellClass && (s.cellClass = t.cellClass), t.headerClass && (s.headerClass = t.headerClass), t.locale && (s.locale = t.locale), !1 === t.sortable ? s.sortable = !1 : (t.numeric && (s.numeric = t.numeric), t.caseFirst && (s.caseFirst = t.caseFirst)), !1 === t.searchable ? s.searchable = !1 : t.sensitivity && (s.sensitivity = t.sensitivity), (s.searchable || s.sortable) && t.ignorePunctuation && (s.ignorePunctuation = t.ignorePunctuation), t.hidden && (s.hidden = !0), t.filter && (s.filter = t.filter), t.sortSequence && (s.sortSequence = t.sortSequence);
    }
    this.dt.update(!0);
  }
  remove(t) {
    Array.isArray(t) || (t = [t]), this.dt.data.headings = this.dt.data.headings.filter((e, s) => !t.includes(s)), this.dt.data.data.forEach(e => e.cells = e.cells.filter((e, s) => !t.includes(s))), this.dt.update(!0);
  }
  filter(t, e = !1) {
    if (!this.settings[t]?.filter?.length) return;
    const s = this._state.filters[t];
    let i;
    if (s) {
      let e = !1;
      i = this.settings[t].filter.find(t => !!e || (t === s && (e = !0), !1));
    } else {
      const e = this.settings[t].filter;
      i = e ? e[0] : void 0;
    }
    i ? this._state.filters[t] = i : s && (this._state.filters[t] = void 0), this.dt._currentPage = 1, this.dt.update(), e || this.dt.emit("datatable.filter", t, i);
  }
  sort(t, e = void 0, s = !1) {
    const i = this.settings[t];
    if (s || this.dt.emit("datatable.sorting", t, e), !e) {
      const s = !(!this._state.sort || this._state.sort.column !== t) && this._state.sort?.dir,
        n = i?.sortSequence || ["asc", "desc"];
      if (s) {
        const t = n.indexOf(s);
        e = -1 === t ? n[0] || "asc" : t === n.length - 1 ? n[0] : n[t + 1];
      } else e = n.length ? n[0] : "asc";
    }
    const a = !!["string", "html"].includes(i.type) && new Intl.Collator(i.locale || this.dt.options.locale, {
      usage: "sort",
      numeric: i.numeric || this.dt.options.numeric,
      caseFirst: i.caseFirst || this.dt.options.caseFirst,
      ignorePunctuation: i.ignorePunctuation || this.dt.options.ignorePunctuation
    });
    this.dt.data.data.sort((s, i) => {
      const o = s.cells[t],
        r = i.cells[t];
      let l = o.order ?? n(o),
        d = r.order ?? n(r);
      if ("desc" === e) {
        const t = l;
        l = d, d = t;
      }
      return a && "number" != typeof l && "number" != typeof d ? a.compare(String(l), String(d)) : l < d ? -1 : l > d ? 1 : 0;
    }), this._state.sort = {
      column: t,
      dir: e
    }, this.dt._searchQueries.length ? (this.dt.multiSearch(this.dt._searchQueries), this.dt.emit("datatable.sort", t, e)) : s || (this.dt._currentPage = 1, this.dt.update(), this.dt.emit("datatable.sort", t, e));
  }
  _measureWidths() {
    const t = this.dt.data.headings.filter((t, e) => !this.settings[e]?.hidden);
    if ((this.dt.options.scrollY.length || this.dt.options.fixedColumns) && t?.length) {
      this._state.widths = [];
      const t = {
        noPaging: !0
      };
      if (this.dt.options.header || this.dt.options.footer) {
        this.dt.options.scrollY.length && (t.unhideHeader = !0), this.dt.headerDOM && this.dt.headerDOM.parentElement.removeChild(this.dt.headerDOM), t.noColumnWidths = !0, this.dt._renderTable(t);
        const e = Array.from(this.dt.dom.querySelector("thead, tfoot")?.firstElementChild?.querySelectorAll("th") || []);
        let s = 0;
        const i = this.dt.data.headings.map((t, i) => {
            if (this.settings[i]?.hidden) return 0;
            const n = e[s].offsetWidth;
            return s += 1, n;
          }),
          n = i.reduce((t, e) => t + e, 0);
        this._state.widths = i.map(t => t / n * 100);
      } else {
        t.renderHeader = !0, this.dt._renderTable(t);
        const e = Array.from(this.dt.dom.querySelector("thead, tfoot")?.firstElementChild?.querySelectorAll("th") || []);
        let s = 0;
        const i = this.dt.data.headings.map((t, i) => {
            if (this.settings[i]?.hidden) return 0;
            const n = e[s].offsetWidth;
            return s += 1, n;
          }),
          n = i.reduce((t, e) => t + e, 0);
        this._state.widths = i.map(t => t / n * 100);
      }
      this.dt._renderTable();
    }
  }
}
const st = {
    sortable: !0,
    locale: "en",
    numeric: !0,
    caseFirst: "false",
    searchable: !0,
    sensitivity: "base",
    ignorePunctuation: !0,
    destroyable: !0,
    searchItemSeparator: "",
    searchQuerySeparator: " ",
    searchAnd: !1,
    searchMethod: !1,
    data: {},
    type: "html",
    format: "YYYY-MM-DD",
    columns: [],
    paging: !0,
    perPage: 10,
    perPageSelect: [5, 10, 15, 20, 25],
    nextPrev: !0,
    firstLast: !1,
    prevText: "‹",
    nextText: "›",
    firstText: "«",
    lastText: "»",
    ellipsisText: "…",
    truncatePager: !0,
    pagerDelta: 2,
    scrollY: "",
    fixedColumns: !0,
    fixedHeight: !1,
    footer: !1,
    header: !0,
    hiddenHeader: !1,
    caption: void 0,
    rowNavigation: !1,
    tabIndex: !1,
    pagerRender: !1,
    rowRender: !1,
    tableRender: !1,
    diffDomOptions: {
      valueDiffing: !1
    },
    labels: {
      placeholder: "Search...",
      searchTitle: "Search within table",
      perPage: "entries per page",
      pageTitle: "Page {page}",
      noRows: "No entries found",
      noResults: "No results match your search query",
      info: "Showing {start} to {end} of {rows} entries"
    },
    template: (t, e) => `<div class='${t.classes.top}'>\n    ${t.paging && t.perPageSelect ? `<div class='${t.classes.dropdown}'>\n            <label>\n                <select class='${t.classes.selector}' name="per-page"></select> ${t.labels.perPage}\n            </label>\n        </div>` : ""}\n    ${t.searchable ? `<div class='${t.classes.search}'>\n            <input class='${t.classes.input}' placeholder='${t.labels.placeholder}' type='search' name="search" title='${t.labels.searchTitle}'${e.id ? ` aria-controls="${e.id}"` : ""}>\n        </div>` : ""}\n</div>\n<div class='${t.classes.container}'${t.scrollY.length ? ` style='height: ${t.scrollY}; overflow-Y: auto;'` : ""}></div>\n<div class='${t.classes.bottom}'>\n    ${t.paging ? `<div class='${t.classes.info}'></div>` : ""}\n    <nav class='${t.classes.pagination}'></nav>\n</div>`,
    classes: {
      active: "datatable-active",
      ascending: "datatable-ascending",
      bottom: "datatable-bottom",
      container: "datatable-container",
      cursor: "datatable-cursor",
      descending: "datatable-descending",
      disabled: "datatable-disabled",
      dropdown: "datatable-dropdown",
      ellipsis: "datatable-ellipsis",
      filter: "datatable-filter",
      filterActive: "datatable-filter-active",
      empty: "datatable-empty",
      headercontainer: "datatable-headercontainer",
      hidden: "datatable-hidden",
      info: "datatable-info",
      input: "datatable-input",
      loading: "datatable-loading",
      pagination: "datatable-pagination",
      paginationList: "datatable-pagination-list",
      paginationListItem: "datatable-pagination-list-item",
      paginationListItemLink: "datatable-pagination-list-item-link",
      search: "datatable-search",
      selector: "datatable-selector",
      sorter: "datatable-sorter",
      table: "datatable-table",
      top: "datatable-top",
      wrapper: "datatable-wrapper"
    }
  },
  it = (t, e, s, i = {}) => ({
    nodeName: "LI",
    attributes: {
      class: i.active && !i.hidden ? `${s.classes.paginationListItem} ${s.classes.active}` : i.hidden ? `${s.classes.paginationListItem} ${s.classes.hidden} ${s.classes.disabled}` : s.classes.paginationListItem
    },
    childNodes: [{
      nodeName: "BUTTON",
      attributes: {
        "data-page": String(t),
        class: s.classes.paginationListItemLink,
        "aria-label": s.labels.pageTitle.replace("{page}", String(t))
      },
      childNodes: [{
        nodeName: "#text",
        data: e
      }]
    }]
  }),
  nt = (t, e, s, i, n) => {
    let a = [];
    if (n.firstLast && a.push(it(1, n.firstText, n)), n.nextPrev) {
      const e = t ? 1 : s - 1;
      a.push(it(e, n.prevText, n, {
        hidden: t
      }));
    }
    let o = [...Array(i).keys()].map(t => it(t + 1, String(t + 1), n, {
      active: t === s - 1
    }));
    if (n.truncatePager && (o = ((t, e, s, i) => {
      const n = i.pagerDelta,
        a = i.classes,
        o = i.ellipsisText,
        r = 2 * n;
      let l = e - n,
        d = e + n;
      e < 4 - n + r ? d = 3 + r : e > s - (3 - n + r) && (l = s - (2 + r));
      const c = [];
      for (let e = 1; e <= s; e++) if (1 == e || e == s || e >= l && e <= d) {
        const s = t[e - 1];
        c.push(s);
      }
      let h;
      const u = [];
      return c.forEach(e => {
        const s = parseInt(e.childNodes[0].attributes["data-page"], 10);
        if (h) {
          const e = parseInt(h.childNodes[0].attributes["data-page"], 10);
          if (s - e == 2) u.push(t[e]);else if (s - e != 1) {
            const t = {
              nodeName: "LI",
              attributes: {
                class: `${a.paginationListItem} ${a.ellipsis} ${a.disabled}`
              },
              childNodes: [{
                nodeName: "BUTTON",
                attributes: {
                  class: a.paginationListItemLink
                },
                childNodes: [{
                  nodeName: "#text",
                  data: o
                }]
              }]
            };
            u.push(t);
          }
        }
        u.push(e), h = e;
      }), u;
    })(o, s, i, n)), a = a.concat(o), n.nextPrev) {
      const t = e ? i : s + 1;
      a.push(it(t, n.nextText, n, {
        hidden: e
      }));
    }
    n.firstLast && a.push(it(i, n.lastText, n));
    return {
      nodeName: "UL",
      attributes: {
        class: n.classes.paginationList
      },
      childNodes: o.length > 1 ? a : []
    };
  };
class at {
  columns;
  containerDOM;
  _currentPage;
  data;
  _dd;
  dom;
  _events;
  hasHeadings;
  hasRows;
  headerDOM;
  _initialHTML;
  initialized;
  _label;
  lastPage;
  _listeners;
  onFirstPage;
  onLastPage;
  options;
  _pagerDOMs;
  _virtualPagerDOM;
  pages;
  _rect;
  rows;
  _searchData;
  _searchQueries;
  _tableAttributes;
  _tableFooters;
  _tableCaptions;
  totalPages;
  _virtualDOM;
  _virtualHeaderDOM;
  wrapperDOM;
  constructor(t, e = {}) {
    const s = "string" == typeof t ? document.querySelector(t) : t;
    s instanceof HTMLTableElement ? this.dom = s : (this.dom = document.createElement("table"), s.appendChild(this.dom));
    const i = {
        ...st.diffDomOptions,
        ...e.diffDomOptions
      },
      n = {
        ...st.labels,
        ...e.labels
      },
      a = {
        ...st.classes,
        ...e.classes
      };
    this.options = {
      ...st,
      ...e,
      diffDomOptions: i,
      labels: n,
      classes: a
    }, this._initialHTML = this.options.destroyable ? s.outerHTML : "", this.options.tabIndex ? this.dom.tabIndex = this.options.tabIndex : this.options.rowNavigation && -1 === this.dom.tabIndex && (this.dom.tabIndex = 0), this._listeners = {
      onResize: () => this._onResize()
    }, this._dd = new q(this.options.diffDomOptions || {}), this.initialized = !1, this._events = {}, this._currentPage = 0, this.onFirstPage = !0, this.hasHeadings = !1, this.hasRows = !1, this._searchQueries = [], this.init();
  }
  init() {
    if (this.initialized || d(this.dom, this.options.classes.table)) return !1;
    this._virtualDOM = T(this.dom, this.options.diffDomOptions || {}), this._tableAttributes = {
      ...this._virtualDOM.attributes
    }, this._tableFooters = this._virtualDOM.childNodes?.filter(t => "TFOOT" === t.nodeName) ?? [], this._tableCaptions = this._virtualDOM.childNodes?.filter(t => "CAPTION" === t.nodeName) ?? [], void 0 !== this.options.caption && this._tableCaptions.push({
      nodeName: "CAPTION",
      childNodes: [{
        nodeName: "#text",
        data: this.options.caption
      }]
    }), this.rows = new tt(this), this.columns = new et(this), this.data = K(this.options.data, this.dom, this.columns.settings, this.options.type, this.options.format), this._render(), setTimeout(() => {
      this.emit("datatable.init"), this.initialized = !0;
    }, 10);
  }
  _render() {
    this.wrapperDOM = s("div", {
      class: `${this.options.classes.wrapper} ${this.options.classes.loading}`
    }), this.wrapperDOM.innerHTML = this.options.template(this.options, this.dom);
    const t = l(this.options.classes.selector),
      e = this.wrapperDOM.querySelector(`select${t}`);
    e && this.options.paging && this.options.perPageSelect ? this.options.perPageSelect.forEach(t => {
      const [s, i] = Array.isArray(t) ? [t[0], t[1]] : [String(t), t],
        n = i === this.options.perPage,
        a = new Option(s, String(i), n, n);
      e.appendChild(a);
    }) : e && e.parentElement.removeChild(e);
    const i = l(this.options.classes.container);
    this.containerDOM = this.wrapperDOM.querySelector(i), this._pagerDOMs = [];
    const n = l(this.options.classes.pagination);
    Array.from(this.wrapperDOM.querySelectorAll(n)).forEach(t => {
      t instanceof HTMLElement && (t.innerHTML = `<ul class="${this.options.classes.paginationList}"></ul>`, this._pagerDOMs.push(t.firstElementChild));
    }), this._virtualPagerDOM = {
      nodeName: "UL",
      attributes: {
        class: this.options.classes.paginationList
      }
    };
    const a = l(this.options.classes.info);
    this._label = this.wrapperDOM.querySelector(a), this.dom.parentElement.replaceChild(this.wrapperDOM, this.dom), this.containerDOM.appendChild(this.dom), this._rect = this.dom.getBoundingClientRect(), this._fixHeight(), this.options.header || this.wrapperDOM.classList.add("no-header"), this.options.footer || this.wrapperDOM.classList.add("no-footer"), this.options.sortable && this.wrapperDOM.classList.add("sortable"), this.options.searchable && this.wrapperDOM.classList.add("searchable"), this.options.fixedHeight && this.wrapperDOM.classList.add("fixed-height"), this.options.fixedColumns && this.wrapperDOM.classList.add("fixed-columns"), this._bindEvents(), this.columns._state.sort && this.columns.sort(this.columns._state.sort.column, this.columns._state.sort.dir, !0), this.update(!0);
  }
  _renderTable(t = {}) {
    let e;
    e = (this.options.paging || this._searchQueries.length || this.columns._state.filters.length) && this._currentPage && this.pages.length && !t.noPaging ? this.pages[this._currentPage - 1] : this.data.data.map((t, e) => ({
      row: t,
      index: e
    }));
    let s = B(this._tableAttributes, this.data.headings, e, this.columns.settings, this.columns._state, this.rows.cursor, this.options, t, this._tableFooters, this._tableCaptions);
    if (this.options.tableRender) {
      const t = this.options.tableRender(this.data, s, "main");
      t && (s = t);
    }
    const i = this._dd.diff(this._virtualDOM, s);
    this._dd.apply(this.dom, i), this._virtualDOM = s;
  }
  _renderPage(t = !1) {
    this.hasRows && this.totalPages ? (this._currentPage > this.totalPages && (this._currentPage = 1), this._renderTable(), this.onFirstPage = 1 === this._currentPage, this.onLastPage = this._currentPage === this.lastPage) : this.setMessage(this.options.labels.noRows);
    let e,
      s = 0,
      i = 0,
      n = 0;
    if (this.totalPages && (s = this._currentPage - 1, i = s * this.options.perPage, n = i + this.pages[s].length, i += 1, e = this._searchQueries.length ? this._searchData.length : this.data.data.length), this._label && this.options.labels.info.length) {
      const t = this.options.labels.info.replace("{start}", String(i)).replace("{end}", String(n)).replace("{page}", String(this._currentPage)).replace("{pages}", String(this.totalPages)).replace("{rows}", String(e));
      this._label.innerHTML = e ? t : "";
    }
    if (1 == this._currentPage && this._fixHeight(), this.options.rowNavigation && this._currentPage && (!this.rows.cursor || !this.pages[this._currentPage - 1].find(t => t.index === this.rows.cursor))) {
      const e = this.pages[this._currentPage - 1];
      e.length && (t ? this.rows.setCursor(e[e.length - 1].index) : this.rows.setCursor(e[0].index));
    }
  }
  _renderPagers() {
    if (!this.options.paging) return;
    let t = nt(this.onFirstPage, this.onLastPage, this._currentPage, this.totalPages, this.options);
    if (this.options.pagerRender) {
      const e = this.options.pagerRender([this.onFirstPage, this.onLastPage, this._currentPage, this.totalPages], t);
      e && (t = e);
    }
    const e = this._dd.diff(this._virtualPagerDOM, t);
    this._pagerDOMs.forEach(t => {
      this._dd.apply(t, e);
    }), this._virtualPagerDOM = t;
  }
  _renderSeparateHeader() {
    const t = this.dom.parentElement;
    this.headerDOM || (this.headerDOM = document.createElement("div"), this._virtualHeaderDOM = {
      nodeName: "DIV"
    }), t.parentElement.insertBefore(this.headerDOM, t);
    let e = {
      nodeName: "TABLE",
      attributes: this._tableAttributes,
      childNodes: [{
        nodeName: "THEAD",
        childNodes: [F(this.data.headings, this.columns.settings, this.columns._state, this.options, {
          unhideHeader: !0
        })]
      }]
    };
    if (e.attributes.class = c(e.attributes.class, this.options.classes.table), this.options.tableRender) {
      const t = this.options.tableRender(this.data, e, "header");
      t && (e = t);
    }
    const s = {
        nodeName: "DIV",
        attributes: {
          class: this.options.classes.headercontainer
        },
        childNodes: [e]
      },
      i = this._dd.diff(this._virtualHeaderDOM, s);
    this._dd.apply(this.headerDOM, i), this._virtualHeaderDOM = s;
    const n = this.headerDOM.firstElementChild.clientWidth - this.dom.clientWidth;
    if (n) {
      const t = structuredClone(this._virtualHeaderDOM);
      t.attributes.style = `padding-right: ${n}px;`;
      const e = this._dd.diff(this._virtualHeaderDOM, t);
      this._dd.apply(this.headerDOM, e), this._virtualHeaderDOM = t;
    }
    t.scrollHeight > t.clientHeight && (t.style.overflowY = "scroll");
  }
  _bindEvents() {
    if (this.options.perPageSelect) {
      const t = l(this.options.classes.selector),
        e = this.wrapperDOM.querySelector(t);
      e && e instanceof HTMLSelectElement && e.addEventListener("change", () => {
        this.emit("datatable.perpage:before", this.options.perPage), this.options.perPage = parseInt(e.value, 10), this.update(), this._fixHeight(), this.emit("datatable.perpage", this.options.perPage);
      }, !1);
    }
    this.options.searchable && this.wrapperDOM.addEventListener("input", t => {
      const e = l(this.options.classes.input),
        s = t.target;
      if (!(s instanceof HTMLInputElement && s.matches(e))) return;
      t.preventDefault();
      const i = [];
      if (Array.from(this.wrapperDOM.querySelectorAll(e)).filter(t => t.value.length).forEach(t => {
        const e = t.dataset.and || this.options.searchAnd,
          s = t.dataset.querySeparator || this.options.searchQuerySeparator ? t.value.split(this.options.searchQuerySeparator) : [t.value];
        e ? s.forEach(e => {
          t.dataset.columns ? i.push({
            terms: [e],
            columns: JSON.parse(t.dataset.columns)
          }) : i.push({
            terms: [e],
            columns: void 0
          });
        }) : t.dataset.columns ? i.push({
          terms: s,
          columns: JSON.parse(t.dataset.columns)
        }) : i.push({
          terms: s,
          columns: void 0
        });
      }), 1 === i.length && 1 === i[0].terms.length) {
        const t = i[0];
        this.search(t.terms[0], t.columns);
      } else this.multiSearch(i);
    }), this.wrapperDOM.addEventListener("click", t => {
      const e = t.target.closest("a, button");
      if (e) if (e.hasAttribute("data-page")) this.page(parseInt(e.getAttribute("data-page"), 10)), t.preventDefault();else if (d(e, this.options.classes.sorter)) {
        const s = Array.from(e.parentElement.parentElement.children).indexOf(e.parentElement),
          i = o(s, this.columns.settings);
        this.columns.sort(i), t.preventDefault();
      } else if (d(e, this.options.classes.filter)) {
        const s = Array.from(e.parentElement.parentElement.children).indexOf(e.parentElement),
          i = o(s, this.columns.settings);
        this.columns.filter(i), t.preventDefault();
      }
    }, !1), this.options.rowNavigation ? (this.dom.addEventListener("keydown", t => {
      if ("ArrowUp" === t.key) {
        let e;
        t.preventDefault(), t.stopPropagation(), this.pages[this._currentPage - 1].find(t => t.index === this.rows.cursor || (e = t, !1)), e ? this.rows.setCursor(e.index) : this.onFirstPage || this.page(this._currentPage - 1, !0);
      } else if ("ArrowDown" === t.key) {
        let e;
        t.preventDefault(), t.stopPropagation();
        const s = this.pages[this._currentPage - 1].find(t => !!e || (t.index === this.rows.cursor && (e = !0), !1));
        s ? this.rows.setCursor(s.index) : this.onLastPage || this.page(this._currentPage + 1);
      } else ["Enter", " "].includes(t.key) && this.emit("datatable.selectrow", this.rows.cursor, t);
    }), this.dom.addEventListener("mousedown", t => {
      const e = t.target;
      if (e instanceof Element && this.dom.matches(":focus")) {
        const s = Array.from(this.dom.querySelectorAll("tbody > tr")).find(t => t.contains(e));
        s && s instanceof HTMLElement && this.emit("datatable.selectrow", parseInt(s.dataset.index, 10), t);
      }
    })) : this.dom.addEventListener("mousedown", t => {
      const e = t.target;
      if (!(e instanceof Element)) return;
      const s = Array.from(this.dom.querySelectorAll("tbody > tr")).find(t => t.contains(e));
      s && s instanceof HTMLElement && this.emit("datatable.selectrow", parseInt(s.dataset.index, 10), t);
    }), window.addEventListener("resize", this._listeners.onResize);
  }
  _onResize = h(() => {
    this._rect = this.containerDOM.getBoundingClientRect(), this._rect.width && this.update(!0);
  }, 250);
  destroy() {
    if (this.options.destroyable) {
      if (this.wrapperDOM) {
        const t = this.wrapperDOM.parentElement;
        if (t) {
          const e = s("div");
          e.innerHTML = this._initialHTML;
          const i = e.firstElementChild;
          t.replaceChild(i, this.wrapperDOM), this.dom = i;
        } else this.options.classes.table?.split(" ").forEach(t => this.wrapperDOM.classList.remove(t));
      }
      window.removeEventListener("resize", this._listeners.onResize), this.initialized = !1;
    }
  }
  update(t = !1) {
    this.emit("datatable.update:before"), t && (this.columns._measureWidths(), this.hasRows = Boolean(this.data.data.length), this.hasHeadings = Boolean(this.data.headings.length)), this.options.classes.empty?.split(" ").forEach(t => this.wrapperDOM.classList.remove(t)), this._paginate(), this._renderPage(), this._renderPagers(), this.options.scrollY.length && this._renderSeparateHeader(), this.emit("datatable.update");
  }
  _paginate() {
    let t = this.data.data.map((t, e) => ({
      row: t,
      index: e
    }));
    return this._searchQueries.length && (t = [], this._searchData.forEach(e => t.push({
      index: e,
      row: this.data.data[e]
    }))), this.columns._state.filters.length && this.columns._state.filters.forEach((e, s) => {
      e && (t = t.filter(t => {
        const i = t.row.cells[s];
        return "function" == typeof e ? e(i.data) : n(i) === e;
      }));
    }), this.options.paging && this.options.perPage > 0 ? this.pages = t.map((e, s) => s % this.options.perPage == 0 ? t.slice(s, s + this.options.perPage) : null).filter(t => t) : this.pages = [t], this.totalPages = this.lastPage = this.pages.length, this._currentPage || (this._currentPage = 1), this.totalPages;
  }
  _fixHeight() {
    this.options.fixedHeight && (this.containerDOM.style.height = null, this._rect = this.containerDOM.getBoundingClientRect(), this.containerDOM.style.height = `${this._rect.height}px`);
  }
  search(t, e = void 0, s = "search") {
    if (this.emit("datatable.search:before", t, this._searchData), !t.length) return this._currentPage = 1, this._searchQueries = [], this._searchData = [], this.update(), this.emit("datatable.search", "", []), this.wrapperDOM.classList.remove("search-results"), !1;
    this.multiSearch([{
      terms: [t],
      columns: e || void 0
    }], s), this.emit("datatable.search", t, this._searchData);
  }
  multiSearch(t, e = "search") {
    if (!this.hasRows) return !1;
    this._currentPage = 1, this._searchData = [];
    let s = t.map(t => ({
      columns: t.columns,
      terms: t.terms.map(t => t.trim()).filter(t => t),
      source: e
    })).filter(t => t.terms.length);
    if (this.emit("datatable.multisearch:before", s, this._searchData), e.length && (s = s.concat(this._searchQueries.filter(t => t.source !== e))), this._searchQueries = s, !s.length) return this.update(), this.emit("datatable.multisearch", s, this._searchData), this.wrapperDOM.classList.remove("search-results"), !1;
    const i = s.map(t => this.columns.settings.map((e, s) => {
      if (e.hidden || !e.searchable || t.columns && !t.columns.includes(s)) return !1;
      let i = t.terms;
      const n = e.sensitivity || this.options.sensitivity;
      ["base", "accent"].includes(n) && (i = i.map(t => t.toLowerCase())), ["base", "case"].includes(n) && (i = i.map(t => t.normalize("NFD").replace(/\p{Diacritic}/gu, "")));
      return (e.ignorePunctuation ?? this.options.ignorePunctuation) && (i = i.map(t => t.replace(/[.,/#!$%^&*;:{}=-_`~()]/g, ""))), i;
    }));
    this.data.data.forEach((t, e) => {
      const a = t.cells.map((t, e) => {
        const s = this.columns.settings[e];
        if (s.searchMethod || this.options.searchMethod) return t;
        let i = n(t).trim();
        if (i.length) {
          const t = s.sensitivity || this.options.sensitivity;
          ["base", "accent"].includes(t) && (i = i.toLowerCase()), ["base", "case"].includes(t) && (i = i.normalize("NFD").replace(/\p{Diacritic}/gu, ""));
          (s.ignorePunctuation ?? this.options.ignorePunctuation) && (i = i.replace(/[.,/#!$%^&*;:{}=-_`~()]/g, ""));
        }
        const a = s.searchItemSeparator || this.options.searchItemSeparator;
        return a ? i.split(a) : [i];
      });
      i.every((e, i) => e.find((e, n) => {
        if (!e) return !1;
        const o = this.columns.settings[n].searchMethod || this.options.searchMethod;
        return o ? o(e, a[n], t, n, s[i].source) : e.find(t => a[n].find(e => e.includes(t)));
      })) && this._searchData.push(e);
    }), this.wrapperDOM.classList.add("search-results"), this._searchData.length ? this.update() : (this.wrapperDOM.classList.remove("search-results"), this.setMessage(this.options.labels.noResults)), this.emit("datatable.multisearch", s, this._searchData);
  }
  page(t, e = !1) {
    return this.emit("datatable.page:before", t), t !== this._currentPage && (isNaN(t) || (this._currentPage = t), !(t > this.pages.length || t < 0) && (this._renderPage(e), this._renderPagers(), void this.emit("datatable.page", t)));
  }
  insert(e) {
    let s = [];
    if (Array.isArray(e)) {
      const t = this.data.headings.map(t => t.data ? String(t.data) : t.text);
      e.forEach((e, i) => {
        const n = [];
        Object.entries(e).forEach(([e, s]) => {
          const a = t.indexOf(e);
          a > -1 ? n[a] = Z(s, this.columns.settings[a]) : this.hasHeadings || this.hasRows || 0 !== i || (n[t.length] = Z(s, this.columns.settings[t.length]), t.push(e), this.data.headings.push(G(e)));
        }), s.push({
          cells: n
        });
      });
    } else t(e) && (!e.headings || this.hasHeadings || this.hasRows ? e.data && Array.isArray(e.data) && (s = e.data.map(t => {
      let e, s;
      return Array.isArray(t) ? (e = {}, s = t) : (e = t.attributes, s = t.cells), {
        attributes: e,
        cells: s.map((t, e) => Z(t, this.columns.settings[e]))
      };
    })) : this.data = K(e, void 0, this.columns.settings, this.options.type, this.options.format));
    s.length && s.forEach(t => this.data.data.push(t)), this.hasHeadings = Boolean(this.data.headings.length), this.columns._state.sort && this.columns.sort(this.columns._state.sort.column, this.columns._state.sort.dir, !0), this.update(!0);
  }
  refresh() {
    if (this.emit("datatable.refresh:before"), this.options.searchable) {
      const t = l(this.options.classes.input);
      Array.from(this.wrapperDOM.querySelectorAll(t)).forEach(t => t.value = ""), this._searchQueries = [];
    }
    this._currentPage = 1, this.onFirstPage = !0, this.update(!0), this.emit("datatable.refresh");
  }
  print() {
    const t = s("table");
    let e = B(this._tableAttributes, this.data.headings, this.data.data.map((t, e) => ({
      row: t,
      index: e
    })), this.columns.settings, this.columns._state, !1, this.options, {
      noColumnWidths: !0,
      unhideHeader: !0
    }, this._tableFooters, this._tableCaptions);
    if (this.options.tableRender) {
      const t = this.options.tableRender(this.data, e, "print");
      t && (e = t);
    }
    const i = this._dd.diff({
      nodeName: "TABLE"
    }, e);
    this._dd.apply(t, i);
    const n = window.open();
    n.document.body.appendChild(t), n.print();
  }
  setMessage(t) {
    const e = this.data.headings.filter((t, e) => !this.columns.settings[e]?.hidden).length || 1;
    this.options.classes.empty?.split(" ").forEach(t => this.wrapperDOM.classList.add(t)), this._label && (this._label.innerHTML = ""), this.totalPages = 0, this._renderPagers();
    let s = {
      nodeName: "TABLE",
      attributes: this._tableAttributes,
      childNodes: [{
        nodeName: "THEAD",
        childNodes: [F(this.data.headings, this.columns.settings, this.columns._state, this.options, {})]
      }, {
        nodeName: "TBODY",
        childNodes: [{
          nodeName: "TR",
          childNodes: [{
            nodeName: "TD",
            attributes: {
              class: this.options.classes.empty,
              colspan: String(e)
            },
            childNodes: [{
              nodeName: "#text",
              data: t
            }]
          }]
        }]
      }]
    };
    if (this._tableFooters.forEach(t => s.childNodes.push(t)), this._tableCaptions.forEach(t => s.childNodes.push(t)), s.attributes.class = c(s.attributes.class, this.options.classes.table), this.options.tableRender) {
      const t = this.options.tableRender(this.data, s, "message");
      t && (s = t);
    }
    const i = this._dd.diff(this._virtualDOM, s);
    this._dd.apply(this.dom, i), this._virtualDOM = s;
  }
  on(t, e) {
    this._events[t] = this._events[t] || [], this._events[t].push(e);
  }
  off(t, e) {
    t in this._events != !1 && this._events[t].splice(this._events[t].indexOf(e), 1);
  }
  emit(t, ...e) {
    if (t in this._events != !1) for (let s = 0; s < this._events[t].length; s++) this._events[t][s](...e);
  }
}
const ot = function (e) {
    let s;
    if (!t(e)) return !1;
    const i = {
      lineDelimiter: "\n",
      columnDelimiter: ",",
      removeDoubleQuotes: !1,
      ...e
    };
    if (i.data.length) {
      s = {
        data: []
      };
      const t = i.data.split(i.lineDelimiter);
      if (t.length && (i.headings && (s.headings = t[0].split(i.columnDelimiter), i.removeDoubleQuotes && (s.headings = s.headings.map(t => t.trim().replace(/(^"|"$)/g, ""))), t.shift()), t.forEach((t, e) => {
        s.data[e] = [];
        const n = t.split(i.columnDelimiter);
        n.length && n.forEach(t => {
          i.removeDoubleQuotes && (t = t.trim().replace(/(^"|"$)/g, "")), s.data[e].push(t);
        });
      })), s) return s;
    }
    return !1;
  },
  rt = function (s) {
    let i;
    if (!t(s)) return !1;
    const n = {
      data: "",
      ...s
    };
    if (n.data.length || t(n.data)) {
      const t = !!e(n.data) && JSON.parse(n.data);
      if (t ? (i = {
        headings: [],
        data: []
      }, t.forEach((t, e) => {
        i.data[e] = [], Object.entries(t).forEach(([t, s]) => {
          i.headings.includes(t) || i.headings.push(t), i.data[e].push(s);
        });
      })) : console.warn("That's not valid JSON!"), i) return i;
    }
    return !1;
  },
  lt = function (e, s = {}) {
    if (!e.hasHeadings && !e.hasRows) return !1;
    if (!t(s)) return !1;
    const i = {
        download: !0,
        skipColumn: [],
        lineDelimiter: "\n",
        columnDelimiter: ",",
        ...s
      },
      a = t => !i.skipColumn.includes(t) && !e.columns.settings[t]?.hidden,
      o = e.data.headings.filter((t, e) => a(e)).map(t => t.text ?? t.data);
    let r;
    if (i.selection) {
      if (Array.isArray(i.selection)) {
        r = [];
        for (let t = 0; t < i.selection.length; t++) r = r.concat(e.pages[i.selection[t] - 1].map(t => t.row));
      } else r = e.pages[i.selection - 1].map(t => t.row);
    } else r = e.data.data;
    let l = [];
    if (l[0] = o, l = l.concat(r.map(t => t.cells.filter((t, e) => a(e)).map(t => n(t)))), l.length) {
      let t = "";
      if (l.forEach(e => {
        e.forEach(e => {
          "string" == typeof e && (e = (e = (e = (e = (e = e.trim()).replace(/\s{2,}/g, " ")).replace(/\n/g, "  ")).replace(/"/g, '""')).replace(/#/g, "%23")).includes(",") && (e = `"${e}"`), t += e + i.columnDelimiter;
        }), t = t.trim().substring(0, t.length - 1), t += i.lineDelimiter;
      }), t = t.trim().substring(0, t.length - 1), i.download) {
        const e = document.createElement("a");
        e.href = encodeURI(`data:text/csv;charset=utf-8,${t}`), e.download = `${i.filename || "datatable_export"}.csv`, document.body.appendChild(e), e.click(), document.body.removeChild(e);
      }
      return t;
    }
    return !1;
  },
  dt = function (e, s = {}) {
    if (!e.hasHeadings && !e.hasRows) return !1;
    if (!t(s)) return !1;
    const i = {
        download: !0,
        skipColumn: [],
        replacer: null,
        space: 4,
        ...s
      },
      a = t => !i.skipColumn.includes(t) && !e.columns.settings[t]?.hidden;
    let o;
    if (i.selection) {
      if (Array.isArray(i.selection)) {
        o = [];
        for (let t = 0; t < i.selection.length; t++) o = o.concat(e.pages[i.selection[t] - 1].map(t => t.row));
      } else o = e.pages[i.selection - 1].map(t => t.row);
    } else o = e.data.data;
    const r = o.map(t => t.cells.filter((t, e) => a(e)).map(t => n(t))),
      l = e.data.headings.filter((t, e) => a(e)).map(t => t.text ?? String(t.data));
    if (r.length) {
      const t = [];
      r.forEach((e, s) => {
        t[s] = t[s] || {}, e.forEach((e, i) => {
          t[s][l[i]] = e;
        });
      });
      const e = JSON.stringify(t, i.replacer, i.space);
      if (i.download) {
        const t = new Blob([e], {
            type: "data:application/json;charset=utf-8"
          }),
          s = URL.createObjectURL(t),
          n = document.createElement("a");
        n.href = s, n.download = `${i.filename || "datatable_export"}.json`, document.body.appendChild(n), n.click(), document.body.removeChild(n), URL.revokeObjectURL(s);
      }
      return e;
    }
    return !1;
  },
  ct = function (e, s = {}) {
    if (!e.hasHeadings && !e.hasRows) return !1;
    if (!t(s)) return !1;
    const i = {
        download: !0,
        skipColumn: [],
        tableName: "myTable",
        ...s
      },
      a = t => !i.skipColumn.includes(t) && !e.columns.settings[t]?.hidden;
    let o = [];
    if (i.selection) {
      if (Array.isArray(i.selection)) for (let t = 0; t < i.selection.length; t++) o = o.concat(e.pages[i.selection[t] - 1].map(t => t.row));else o = e.pages[i.selection - 1].map(t => t.row);
    } else o = e.data.data;
    const r = o.map(t => t.cells.filter((t, e) => a(e)).map(t => n(t))),
      l = e.data.headings.filter((t, e) => a(e)).map(t => t.text ?? String(t.data));
    if (r.length) {
      let t = `INSERT INTO \`${i.tableName}\` (`;
      if (l.forEach(e => {
        t += `\`${e}\`,`;
      }), t = t.trim().substring(0, t.length - 1), t += ") VALUES ", r.forEach(e => {
        t += "(", e.forEach(e => {
          t += "string" == typeof e ? `"${e}",` : `${e},`;
        }), t = t.trim().substring(0, t.length - 1), t += "),";
      }), t = t.trim().substring(0, t.length - 1), t += ";", i.download && (t = `data:application/sql;charset=utf-8,${t}`), i.download) {
        const e = document.createElement("a");
        e.href = encodeURI(t), e.download = `${i.filename || "datatable_export"}.sql`, document.body.appendChild(e), e.click(), document.body.removeChild(e);
      }
      return t;
    }
    return !1;
  },
  ht = function (e, s = {}) {
    if (!e.hasHeadings && !e.hasRows) return !1;
    if (!t(s)) return !1;
    const i = {
        download: !0,
        skipColumn: [],
        lineDelimiter: "\n",
        columnDelimiter: ",",
        ...s
      },
      a = t => !i.skipColumn.includes(t) && !e.columns.settings[t]?.hidden,
      o = e.data.headings.filter((t, e) => a(e)).map(t => t.text ?? t.data);
    let r;
    if (i.selection) {
      if (Array.isArray(i.selection)) {
        r = [];
        for (let t = 0; t < i.selection.length; t++) r = r.concat(e.pages[i.selection[t] - 1].map(t => t.row));
      } else r = e.pages[i.selection - 1].map(t => t.row);
    } else r = e.data.data;
    let l = [];
    if (l[0] = o, l = l.concat(r.map(t => t.cells.filter((t, e) => a(e)).map(t => n(t)))), l.length) {
      let t = "";
      if (l.forEach(e => {
        e.forEach(e => {
          "string" == typeof e && (e = (e = (e = (e = (e = e.trim()).replace(/\s{2,}/g, " ")).replace(/\n/g, "  ")).replace(/"/g, '""')).replace(/#/g, "%23")).includes(",") && (e = `"${e}"`), t += e + i.columnDelimiter;
        }), t = t.trim().substring(0, t.length - 1), t += i.lineDelimiter;
      }), t = t.trim().substring(0, t.length - 1), i.download && (t = `data:text/csv;charset=utf-8,${t}`), i.download) {
        const e = document.createElement("a");
        e.href = encodeURI(t), e.download = `${i.filename || "datatable_export"}.txt`, document.body.appendChild(e), e.click(), document.body.removeChild(e);
      }
      return t;
    }
    return !1;
  },
  ut = {
    classes: {
      row: "datatable-editor-row",
      form: "datatable-editor-form",
      item: "datatable-editor-item",
      menu: "datatable-editor-menu",
      save: "datatable-editor-save",
      block: "datatable-editor-block",
      cancel: "datatable-editor-cancel",
      close: "datatable-editor-close",
      inner: "datatable-editor-inner",
      input: "datatable-editor-input",
      label: "datatable-editor-label",
      modal: "datatable-editor-modal",
      action: "datatable-editor-action",
      header: "datatable-editor-header",
      wrapper: "datatable-editor-wrapper",
      editable: "datatable-editor-editable",
      container: "datatable-editor-container",
      separator: "datatable-editor-separator"
    },
    labels: {
      closeX: "x",
      editCell: "Edit Cell",
      editRow: "Edit Row",
      removeRow: "Remove Row",
      reallyRemove: "Are you sure?",
      reallyCancel: "Do you really want to cancel?",
      save: "Save",
      cancel: "Cancel"
    },
    cancelModal: t => confirm(t.options.labels.reallyCancel),
    inline: !0,
    hiddenColumns: !1,
    contextMenu: !0,
    clickEvent: "dblclick",
    excludeColumns: [],
    menuItems: [{
      text: t => t.options.labels.editCell,
      action: (t, e) => {
        if (!(t.event.target instanceof Element)) return;
        const s = t.event.target.closest("td");
        return t.editCell(s);
      }
    }, {
      text: t => t.options.labels.editRow,
      action: (t, e) => {
        if (!(t.event.target instanceof Element)) return;
        const s = t.event.target.closest("tr");
        return t.editRow(s);
      }
    }, {
      separator: !0
    }, {
      text: t => t.options.labels.removeRow,
      action: (t, e) => {
        if (t.event.target instanceof Element && confirm(t.options.labels.reallyRemove)) {
          const e = t.event.target.closest("tr");
          t.removeRow(e);
        }
      }
    }]
  };
class pt {
  menuOpen;
  containerDOM;
  data;
  disabled;
  dt;
  editing;
  editingCell;
  editingRow;
  event;
  events;
  initialized;
  limits;
  menuDOM;
  modalDOM;
  options;
  originalRowRender;
  rect;
  wrapperDOM;
  constructor(t, e = {}) {
    this.dt = t, this.options = {
      ...ut,
      ...e
    };
  }
  init() {
    this.initialized || (this.options.classes.editable?.split(" ").forEach(t => this.dt.wrapperDOM.classList.add(t)), this.options.inline && (this.originalRowRender = this.dt.options.rowRender, this.dt.options.rowRender = (t, e, s) => {
      let i = this.rowRender(t, e, s);
      return this.originalRowRender && (i = this.originalRowRender(t, i, s)), i;
    }), this.options.contextMenu && (this.containerDOM = s("div", {
      id: this.options.classes.container
    }), this.wrapperDOM = s("div", {
      class: this.options.classes.wrapper
    }), this.menuDOM = s("ul", {
      class: this.options.classes.menu
    }), this.options.menuItems && this.options.menuItems.length && this.options.menuItems.forEach(t => {
      const e = s("li", {
        class: t.separator ? this.options.classes.separator : this.options.classes.item
      });
      if (!t.separator) {
        const i = s("a", {
          class: this.options.classes.action,
          href: t.url || "#",
          html: "function" == typeof t.text ? t.text(this) : t.text
        });
        e.appendChild(i), t.action && "function" == typeof t.action && i.addEventListener("click", e => {
          e.preventDefault(), t.action(this, e);
        });
      }
      this.menuDOM.appendChild(e);
    }), this.wrapperDOM.appendChild(this.menuDOM), this.containerDOM.appendChild(this.wrapperDOM), this.updateMenu()), this.data = {}, this.menuOpen = !1, this.editing = !1, this.editingRow = !1, this.editingCell = !1, this.bindEvents(), setTimeout(() => {
      this.initialized = !0, this.dt.emit("editable.init");
    }, 10));
  }
  bindEvents() {
    this.events = {
      keydown: this.keydown.bind(this),
      click: this.click.bind(this)
    }, this.dt.dom.addEventListener(this.options.clickEvent, this.events.click), document.addEventListener("keydown", this.events.keydown), this.options.contextMenu && (this.events.context = this.context.bind(this), this.events.updateMenu = this.updateMenu.bind(this), this.events.dismissMenu = this.dismissMenu.bind(this), this.events.reset = h(() => this.events.updateMenu(), 50), this.dt.dom.addEventListener("contextmenu", this.events.context), document.addEventListener("click", this.events.dismissMenu), window.addEventListener("resize", this.events.reset), window.addEventListener("scroll", this.events.reset));
  }
  context(t) {
    const e = t.target;
    if (!(e instanceof Element)) return;
    this.event = t;
    const s = e.closest("tbody td");
    if (!this.disabled && s) {
      t.preventDefault();
      let e = t.pageX,
        s = t.pageY;
      e > this.limits.x && (e -= this.rect.width), s > this.limits.y && (s -= this.rect.height), this.wrapperDOM.style.top = `${s}px`, this.wrapperDOM.style.left = `${e}px`, this.openMenu(), this.updateMenu();
    }
  }
  click(t) {
    const e = t.target;
    if (e instanceof Element) if (this.editing && this.data && this.editingCell) {
      const t = l(this.options.classes.input),
        e = this.modalDOM ? this.modalDOM.querySelector(`input${t}[type=text]`) : this.dt.wrapperDOM.querySelector(`input${t}[type=text]`);
      this.saveCell(e.value);
    } else if (!this.editing) {
      const s = e.closest("tbody td");
      s && (this.editCell(s), t.preventDefault());
    }
  }
  keydown(t) {
    const e = l(this.options.classes.input);
    if (this.modalDOM) {
      if ("Escape" === t.key) this.options.cancelModal(this) && this.closeModal();else if ("Enter" === t.key) if (this.editingCell) {
        const t = this.modalDOM.querySelector(`input${e}[type=text]`);
        this.saveCell(t.value);
      } else {
        const t = Array.from(this.modalDOM.querySelectorAll(`input${e}[type=text]`)).map(t => t.value.trim());
        this.saveRow(t, this.data.row);
      }
    } else if (this.editing && this.data) if ("Enter" === t.key) {
      if (this.editingCell) {
        const t = this.dt.wrapperDOM.querySelector(`input${e}[type=text]`);
        this.saveCell(t.value);
      } else if (this.editingRow) {
        const t = Array.from(this.dt.wrapperDOM.querySelectorAll(`input${e}[type=text]`)).map(t => t.value.trim());
        this.saveRow(t, this.data.row);
      }
    } else "Escape" === t.key && (this.editingCell ? this.saveCell(this.data.content) : this.editingRow && this.saveRow(null, this.data.row));
  }
  editCell(t) {
    const e = o(t.cellIndex, this.dt.columns.settings);
    if (this.options.excludeColumns.includes(e)) return void this.closeMenu();
    const s = parseInt(t.parentElement.dataset.index, 10),
      i = this.dt.data.data[s].cells[e];
    this.data = {
      cell: i,
      rowIndex: s,
      columnIndex: e,
      content: n(i)
    }, this.editing = !0, this.editingCell = !0, this.options.inline ? this.dt.update() : this.editCellModal(), this.closeMenu();
  }
  editCellModal() {
    const t = this.data.cell,
      e = this.data.columnIndex,
      i = this.dt.data.headings[e].text || String(this.dt.data.headings[e].data),
      o = [`<div class='${this.options.classes.inner}'>`, `<div class='${this.options.classes.header}'>`, `<h4>${this.options.labels.editCell}</h4>`, `<button class='${this.options.classes.close}' type='button' data-editor-cancel>${this.options.labels.closeX}</button>`, " </div>", `<div class='${this.options.classes.block}'>`, `<form class='${this.options.classes.form}'>`, `<div class='${this.options.classes.row}'>`, `<label class='${this.options.classes.label}'>${a(i)}</label>`, `<input class='${this.options.classes.input}' value='${a(n(t))}' type='text'>`, "</div>", `<div class='${this.options.classes.row}'>`, `<button class='${this.options.classes.cancel}' type='button' data-editor-cancel>${this.options.labels.cancel}</button>`, `<button class='${this.options.classes.save}' type='button' data-editor-save>${this.options.labels.save}</button>`, "</div>", "</form>", "</div>", "</div>"].join(""),
      r = s("div", {
        class: this.options.classes.modal,
        html: o
      });
    this.modalDOM = r, this.openModal();
    const d = l(this.options.classes.input),
      c = r.querySelector(`input${d}[type=text]`);
    c.focus(), c.selectionStart = c.selectionEnd = c.value.length, r.addEventListener("click", t => {
      const e = t.target;
      e instanceof Element && (e.hasAttribute("data-editor-cancel") ? (t.preventDefault(), this.options.cancelModal(this) && this.closeModal()) : e.hasAttribute("data-editor-save") && (t.preventDefault(), this.saveCell(c.value)));
    });
  }
  saveCell(t) {
    const e = this.data.content,
      s = this.dt.columns.settings[this.data.columnIndex].type || this.dt.options.type,
      i = t.trim();
    let n;
    if ("number" === s) n = {
      data: parseFloat(i)
    };else if ("boolean" === s) n = ["", "false", "0"].includes(i) ? {
      data: !1,
      text: "false",
      order: 0
    } : {
      data: !0,
      text: "true",
      order: 1
    };else if ("html" === s) n = {
      data: [{
        nodeName: "#text",
        data: t
      }],
      text: t,
      order: t
    };else if ("string" === s) n = {
      data: t
    };else if ("date" === s) {
      const e = this.dt.columns.settings[this.data.columnIndex].format || this.dt.options.format;
      n = {
        data: t,
        order: X(String(t), e)
      };
    } else n = {
      data: t
    };
    this.dt.data.data[this.data.rowIndex].cells[this.data.columnIndex] = n, this.closeModal();
    const a = this.data.rowIndex,
      o = this.data.columnIndex;
    this.data = {}, this.dt.update(!0), this.editing = !1, this.editingCell = !1, this.dt.emit("editable.save.cell", t, e, a, o);
  }
  editRow(t) {
    if (!t || "TR" !== t.nodeName || this.editing) return;
    const e = parseInt(t.dataset.index, 10),
      s = this.dt.data.data[e];
    this.data = {
      row: s.cells,
      rowIndex: e
    }, this.editing = !0, this.editingRow = !0, this.options.inline ? this.dt.update() : this.editRowModal(), this.closeMenu();
  }
  editRowModal() {
    const t = this.data.row,
      e = [`<div class='${this.options.classes.inner}'>`, `<div class='${this.options.classes.header}'>`, `<h4>${this.options.labels.editRow}</h4>`, `<button class='${this.options.classes.close}' type='button' data-editor-cancel>${this.options.labels.closeX}</button>`, " </div>", `<div class='${this.options.classes.block}'>`, `<form class='${this.options.classes.form}'>`, `<div class='${this.options.classes.row}'>`, `<button class='${this.options.classes.cancel}' type='button' data-editor-cancel>${this.options.labels.cancel}</button>`, `<button class='${this.options.classes.save}' type='button' data-editor-save>${this.options.labels.save}</button>`, "</div>", "</form>", "</div>", "</div>"].join(""),
      i = s("div", {
        class: this.options.classes.modal,
        html: e
      }),
      o = i.firstElementChild;
    if (!o) return;
    const r = o.lastElementChild?.firstElementChild;
    if (!r) return;
    t.forEach((t, e) => {
      const i = this.dt.columns.settings[e];
      if ((!i.hidden || i.hidden && this.options.hiddenColumns) && !this.options.excludeColumns.includes(e)) {
        const i = this.dt.data.headings[e].text || String(this.dt.data.headings[e].data);
        r.insertBefore(s("div", {
          class: this.options.classes.row,
          html: [`<div class='${this.options.classes.row}'>`, `<label class='${this.options.classes.label}'>${a(i)}</label>`, `<input class='${this.options.classes.input}' value='${a(n(t))}' type='text'>`, "</div>"].join("")
        }), r.lastElementChild);
      }
    }), this.modalDOM = i, this.openModal();
    const d = l(this.options.classes.input),
      c = Array.from(r.querySelectorAll(`input${d}[type=text]`));
    i.addEventListener("click", t => {
      const e = t.target;
      if (e instanceof Element) if (e.hasAttribute("data-editor-cancel")) this.options.cancelModal(this) && this.closeModal();else if (e.hasAttribute("data-editor-save")) {
        const t = c.map(t => t.value.trim());
        this.saveRow(t, this.data.row);
      }
    });
  }
  saveRow(t, e) {
    const s = e.map(t => n(t)),
      i = this.dt.data.data[this.data.rowIndex];
    if (t) {
      let s = 0;
      i.cells = e.map((e, i) => {
        if (this.options.excludeColumns.includes(i) || this.dt.columns.settings[i].hidden) return e;
        const n = this.dt.columns.settings[i].type || this.dt.options.type,
          a = t[s++];
        let o;
        if ("number" === n) o = {
          data: parseFloat(a)
        };else if ("boolean" === n) o = ["", "false", "0"].includes(a) ? {
          data: !1,
          text: "false",
          order: 0
        } : {
          data: !0,
          text: "true",
          order: 1
        };else if ("html" === n) o = {
          data: [{
            nodeName: "#text",
            data: a
          }],
          text: a,
          order: a
        };else if ("string" === n) o = {
          data: a
        };else if ("date" === n) {
          const t = this.dt.columns.settings[i].format || this.dt.options.format;
          o = {
            data: a,
            order: X(String(a), t)
          };
        } else o = {
          data: a
        };
        return o;
      });
    }
    const a = i.cells.map(t => n(t));
    this.data = {}, this.dt.update(!0), this.closeModal(), this.editing = !1, this.dt.emit("editable.save.row", a, s, e);
  }
  openModal() {
    this.modalDOM && document.body.appendChild(this.modalDOM);
  }
  closeModal() {
    this.editing && this.modalDOM && (document.body.removeChild(this.modalDOM), this.modalDOM = this.editing = this.editingRow = this.editingCell = !1);
  }
  removeRow(t) {
    if (!t || "TR" !== t.nodeName || this.editing) return;
    const e = parseInt(t.dataset.index, 10);
    this.dt.rows.remove(e), this.closeMenu();
  }
  updateMenu() {
    const t = window.scrollX || window.pageXOffset,
      e = window.scrollY || window.pageYOffset;
    this.rect = this.wrapperDOM.getBoundingClientRect(), this.limits = {
      x: window.innerWidth + t - this.rect.width,
      y: window.innerHeight + e - this.rect.height
    };
  }
  dismissMenu(t) {
    const e = t.target;
    if (!(e instanceof Element) || this.wrapperDOM.contains(e)) return;
    let s = !0;
    if (this.editing) {
      const t = l(this.options.classes.input);
      s = !e.matches(`input${t}[type=text]`);
    }
    s && this.closeMenu();
  }
  openMenu() {
    if (this.editing && this.data && this.editingCell) {
      const t = l(this.options.classes.input),
        e = this.modalDOM ? this.modalDOM.querySelector(`input${t}[type=text]`) : this.dt.wrapperDOM.querySelector(`input${t}[type=text]`);
      this.saveCell(e.value);
    }
    document.body.appendChild(this.containerDOM), this.menuOpen = !0, this.dt.emit("editable.context.open");
  }
  closeMenu() {
    this.menuOpen && (this.menuOpen = !1, document.body.removeChild(this.containerDOM), this.dt.emit("editable.context.close"));
  }
  destroy() {
    this.dt.dom.removeEventListener(this.options.clickEvent, this.events.click), this.dt.dom.removeEventListener("contextmenu", this.events.context), document.removeEventListener("click", this.events.dismissMenu), document.removeEventListener("keydown", this.events.keydown), window.removeEventListener("resize", this.events.reset), window.removeEventListener("scroll", this.events.reset), document.body.contains(this.containerDOM) && document.body.removeChild(this.containerDOM), this.options.inline && (this.dt.options.rowRender = this.originalRowRender), this.initialized = !1;
  }
  rowRender(t, e, s) {
    if (!this.data || this.data.rowIndex !== s) return e;
    if (this.editingCell) {
      e.childNodes[function (t, e) {
        let s = t,
          i = 0;
        for (; i < t;) e[i].hidden && (s -= 1), i++;
        return s;
      }(this.data.columnIndex, this.dt.columns.settings)].childNodes = [{
        nodeName: "INPUT",
        attributes: {
          type: "text",
          value: this.data.content,
          class: this.options.classes.input
        }
      }];
    } else e.childNodes.forEach((s, i) => {
      const n = o(i, this.dt.columns.settings),
        r = t[n];
      if (!this.options.excludeColumns.includes(n)) {
        e.childNodes[i].childNodes = [{
          nodeName: "INPUT",
          attributes: {
            type: "text",
            value: a(r.text || String(r.data) || ""),
            class: this.options.classes.input
          }
        }];
      }
    });
    return e;
  }
}
const ft = function (t, e = {}) {
    const s = new pt(t, e);
    return t.initialized ? s.init() : t.on("datatable.init", () => s.init()), s;
  },
  mt = {
    classes: {
      button: "datatable-column-filter-button",
      menu: "datatable-column-filter-menu",
      container: "datatable-column-filter-container",
      wrapper: "datatable-column-filter-wrapper"
    },
    labels: {
      button: "Filter columns within the table"
    },
    hiddenColumns: []
  };
class gt {
  addedButtonDOM;
  menuOpen;
  buttonDOM;
  dt;
  events;
  initialized;
  options;
  menuDOM;
  containerDOM;
  wrapperDOM;
  limits;
  rect;
  event;
  constructor(t, e = {}) {
    this.dt = t, this.options = {
      ...mt,
      ...e
    };
  }
  init() {
    if (this.initialized) return;
    const t = l(this.options.classes.button);
    let e = this.dt.wrapperDOM.querySelector(t);
    if (!e) {
      e = s("button", {
        class: this.options.classes.button,
        html: "▦"
      });
      const t = l(this.dt.options.classes.search),
        i = this.dt.wrapperDOM.querySelector(t);
      i ? i.appendChild(e) : this.dt.wrapperDOM.appendChild(e), this.addedButtonDOM = !0;
    }
    this.buttonDOM = e, this.containerDOM = s("div", {
      id: this.options.classes.container
    }), this.wrapperDOM = s("div", {
      class: this.options.classes.wrapper
    }), this.menuDOM = s("ul", {
      class: this.options.classes.menu,
      html: this.dt.data.headings.map((t, e) => {
        const s = this.dt.columns.settings[e];
        return this.options.hiddenColumns.includes(e) ? "" : `<li data-column="${e}">\n                        <input type="checkbox" value="${t.text || t.data}" ${s.hidden ? "" : "checked=''"}>\n                        <label>\n                            ${t.text || t.data}\n                        </label>\n                    </li>`;
      }).join("")
    }), this.wrapperDOM.appendChild(this.menuDOM), this.containerDOM.appendChild(this.wrapperDOM), this._measureSpace(), this._bind(), this.initialized = !0;
  }
  dismiss() {
    this.addedButtonDOM && this.buttonDOM.parentElement && this.buttonDOM.parentElement.removeChild(this.buttonDOM), document.removeEventListener("click", this.events.click);
  }
  _bind() {
    this.events = {
      click: this._click.bind(this)
    }, document.addEventListener("click", this.events.click);
  }
  _openMenu() {
    document.body.appendChild(this.containerDOM), this._measureSpace(), this.menuOpen = !0, this.dt.emit("columnFilter.menu.open");
  }
  _closeMenu() {
    this.menuOpen && (this.menuOpen = !1, document.body.removeChild(this.containerDOM), this.dt.emit("columnFilter.menu.close"));
  }
  _measureSpace() {
    const t = window.scrollX || window.pageXOffset,
      e = window.scrollY || window.pageYOffset;
    this.rect = this.wrapperDOM.getBoundingClientRect(), this.limits = {
      x: window.innerWidth + t - this.rect.width,
      y: window.innerHeight + e - this.rect.height
    };
  }
  _click(t) {
    const e = t.target;
    if (e instanceof Element) if (this.event = t, this.buttonDOM.contains(e)) {
      if (t.preventDefault(), this.menuOpen) return void this._closeMenu();
      this._openMenu();
      let e = t.pageX,
        s = t.pageY;
      e > this.limits.x && (e -= this.rect.width), s > this.limits.y && (s -= this.rect.height), this.wrapperDOM.style.top = `${s}px`, this.wrapperDOM.style.left = `${e}px`;
    } else if (this.menuDOM.contains(e)) {
      const t = l(this.options.classes.menu),
        s = e.closest(`${t} > li`);
      if (!s) return;
      const i = s.querySelector("input[type=checkbox]");
      i.contains(e) || (i.checked = !i.checked);
      const n = Number(s.dataset.column);
      i.checked ? this.dt.columns.show([n]) : this.dt.columns.hide([n]);
    } else this.menuOpen && this._closeMenu();
  }
}
const bt = function (t, e = {}) {
  const s = new gt(t, e);
  return t.initialized ? s.init() : t.on("datatable.init", () => s.init()), s;
};


/***/ }),

/***/ "./src/js/addon/TimePicker.js":
/*!************************************!*\
  !*** ./src/js/addon/TimePicker.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TimePicker)
/* harmony export */ });
/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @popperjs/core */ "./node_modules/@popperjs/core/lib/popper.js");
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../function */ "./src/js/function/index.js");


function TimePicker(selector, opt) {
  let options = {
    format: opt.format ? opt.format : 24,
    interval: opt.interval ? opt.interval : 30,
    start: opt.start ? opt.start : '00:00',
    end: opt.end ? opt.end : '23:59',
    placement: opt.placement ? opt.placement : 'bottom-start',
    class: {
      dropdown: 'nk-timepicker-dropdown',
      dropdownItem: 'nk-timepicker-time'
    }
  };
  let timeInterval = options.interval;
  let timeFormat = options.format;
  let timeStart = options.start;
  let timeEnd = options.end;
  let totalTime = (0,_function__WEBPACK_IMPORTED_MODULE_0__.toMin)(timeEnd) - (0,_function__WEBPACK_IMPORTED_MODULE_0__.toMin)(timeStart);
  let timeSlot = Math.floor(totalTime / timeInterval);
  let items = [];
  let startTime = (0,_function__WEBPACK_IMPORTED_MODULE_0__.toMin)(timeStart);
  for (let i = 0; i < timeSlot + 1; i++) {
    let currentTime = startTime;
    let timeString = function () {
      if (timeFormat == 12) {
        return (0,_function__WEBPACK_IMPORTED_MODULE_0__.toTwelve)((0,_function__WEBPACK_IMPORTED_MODULE_0__.toTime)(currentTime));
      } else {
        return (0,_function__WEBPACK_IMPORTED_MODULE_0__.toTime)(currentTime);
      }
    };
    items.push(`<li><button class="relative w-full px-5 py-1.5 flex items-center rounded-[inherit] text-xs leading-5 font-normal text-base-600 hover:text-primary-600 hover:bg-base-50 transition-all duration-[400ms] ${options.class.dropdownItem}" data-picker-text="${timeString()}" type="button">
            ${timeString()}
        </button></li>`);
    startTime = currentTime + timeInterval;
  }
  let itemsMarkups = items.join('');
  selector.classList.add('peer');
  selector.addEventListener("click", function (e) {
    e.preventDefault();
    selector.classList.contains("show") ? selector.classList.remove("show") : selector.classList.add("show");
    (0,_popperjs_core__WEBPACK_IMPORTED_MODULE_1__.createPopper)(selector, selector.nextElementSibling, {
      placement: options.placement
    });
    selector.nextElementSibling.style.display = 'block';
  });
  document.addEventListener("mouseup", function (e) {
    e.preventDefault();
    if (selector !== e.target) {
      selector.classList.remove("show");
      selector.nextElementSibling.style.display = 'none';
    }
  });
  let id = selector.id ? selector.id : (0,_function__WEBPACK_IMPORTED_MODULE_0__.randomId)(8);
  if (!selector.id) {
    (0,_function__WEBPACK_IMPORTED_MODULE_0__.attr)(selector, 'id', id);
  }
  let dropdownTemplate = `
    <ul class="nk-timepicker-dropdown absolute min-w-[180px] border border-gray-300 dark:border-gray-900 bg-white dark:bg-gray-950 rounded-md shadow-md z-[1000] ${options.class.dropdown}" data-picker-id="${id}" style="max-height:320px;overflow:auto;display:none;">
        ${itemsMarkups}
    </ul>
    `;
  selector.insertAdjacentHTML('afterend', dropdownTemplate);
  let timeSelector = document.querySelectorAll(`.${options.class.dropdownItem}`);
  timeSelector.forEach(item => {
    item.addEventListener("click", function (e) {
      e.preventDefault();
      let itemtext = item.dataset.pickerText;
      let input = document.getElementById(item.closest(`.${options.class.dropdown}`).dataset.pickerId);
      input.value = itemtext;
      //set active slot
      let allItems = item.closest(`.${options.class.dropdown}`).querySelectorAll(`.${options.class.dropdownItem}`);
      allItems.forEach(otherItem => {
        otherItem.classList.remove('active');
      });
      item.classList.add('active');
      selector.classList.remove("show");
    });
  });
}

/***/ }),

/***/ "./src/js/addon/index.js":
/*!*******************************!*\
  !*** ./src/js/addon/index.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TimePicker: () => (/* reexport safe */ _TimePicker__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _TimePicker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TimePicker */ "./src/js/addon/TimePicker.js");



/***/ }),

/***/ "./src/js/component/Accordion.js":
/*!***************************************!*\
  !*** ./src/js/component/Accordion.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Accordion)
/* harmony export */ });
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../function */ "./src/js/function/index.js");

function Accordion(el) {
  const elm = document.querySelectorAll('.accordion-toggle');
  elm.forEach(function (item) {
    let parent = item.parentElement,
      accordion_body = item.nextElementSibling,
      accordion_root = parent.parentElement,
      accordion_items = accordion_root.children,
      speed = 400;

    //on load
    parent.classList.contains("active") ? accordion_body.style.display = 'block' : accordion_body.style.display = 'none';
    item.addEventListener("click", function (e) {
      e.preventDefault();
      Array.from(accordion_items).forEach(item => {
        if (item !== parent && !accordion_root.classList.contains('manual-close')) {
          (0,_function__WEBPACK_IMPORTED_MODULE_0__.slideUp)(item.querySelector('.accordion-body'), speed);
          item.classList.remove("active");
        }
      });
      if (!parent.classList.contains("active")) {
        parent.classList.add("active");
        (0,_function__WEBPACK_IMPORTED_MODULE_0__.slideDown)(accordion_body, speed);
      } else {
        (0,_function__WEBPACK_IMPORTED_MODULE_0__.slideUp)(accordion_body, speed);
        parent.classList.remove("active");
      }
    });
  });
}

/***/ }),

/***/ "./src/js/component/Clipboard.js":
/*!***************************************!*\
  !*** ./src/js/component/Clipboard.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Clipboard)
/* harmony export */ });
/* harmony import */ var clipboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! clipboard */ "./node_modules/clipboard/dist/clipboard.js");
/* harmony import */ var clipboard__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(clipboard__WEBPACK_IMPORTED_MODULE_0__);

function Clipboard(selector) {
  let clipboardTrigger = document.querySelectorAll(selector);
  clipboardTrigger.forEach(item => {
    //init clipboard
    let clipboard = new (clipboard__WEBPACK_IMPORTED_MODULE_0___default())(item);
    //set markup
    let initMarkup = item.innerHTML;
    let successMarkup = item.dataset.markupSuccess;
    //on-sucess
    clipboard.on("success", function (e) {
      let target = e.trigger;
      target.classList.add('success');
      target.innerHTML = successMarkup;
      setTimeout(function () {
        target.innerHTML = initMarkup;
        target.classList.remove('success');
      }, 1000);
    });
  });
}

/***/ }),

/***/ "./src/js/component/CurrentLink.js":
/*!*****************************************!*\
  !*** ./src/js/component/CurrentLink.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CurrentLink)
/* harmony export */ });
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../function */ "./src/js/function/index.js");

function CurrentLink(selector, parent, submenu, base, active) {
  let elm = document.querySelectorAll(selector);
  let currentURL = document.location.href,
    removeHash = currentURL.substring(0, currentURL.indexOf("#") == -1 ? currentURL.length : currentURL.indexOf("#")),
    removeQuery = removeHash.substring(0, removeHash.indexOf("?") == -1 ? removeHash.length : removeHash.indexOf("?")),
    fileName = removeQuery;
  elm.forEach(function (item) {
    var selfLink = item.getAttribute('href').split('../').slice(-1);
    if (fileName.match(selfLink)) {
      let parents = (0,_function__WEBPACK_IMPORTED_MODULE_0__.getParents)(item, `.${base}`, parent);
      parents.forEach(parentElemets => {
        parentElemets.classList.add(...active);
        let subItem = parentElemets.querySelector(`.${submenu}`);
        subItem !== null && (subItem.style.display = "block");
        parentElemets.scrollIntoView({
          behavior: "smooth",
          block: "start",
          inline: "nearest"
        });
      });
    } else {
      item.parentElement.classList.remove(...active);
    }
  });
}

/***/ }),

/***/ "./src/js/component/DataTable.js":
/*!***************************************!*\
  !*** ./src/js/component/DataTable.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DataTableElement)
/* harmony export */ });
/* harmony import */ var simple_datatables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! simple-datatables */ "./node_modules/simple-datatables/dist/module.js");

function DataTableElement(selector) {
  let elm = document.querySelectorAll(selector);
  if (elm != 'undefined' && elm != null) {
    elm.forEach(item => {
      let showPerPage = item.dataset.showPerPage ? parseInt(item.dataset.showPerPage) : 10;
      let dataTables = new simple_datatables__WEBPACK_IMPORTED_MODULE_0__.DataTable(item, {
        labels: {
          placeholder: "Type in to Search",
          searchTitle: "Search within table",
          pageTitle: "Page {page}",
          perPage: "Show",
          noRows: "No entries found",
          info: "{start} - {end} of {rows}",
          noResults: "No results match your search query"
        },
        perPage: showPerPage,
        prevText: `Prev`,
        nextText: `Next`,
        firstText: `First`,
        lastText: `Last`,
        template: (options, dom) => `<div class='${options.classes.top} flex items-center justify-between gap-x-3 !px-0 !pt-0 !pb-4 after:hidden'>
                ${options.searchable ? `<div class='${options.classes.search}'>
                        <input class='${options.classes.input} block w-full box-border text-sm leading-4.5 px-4 py-1.5 h-9 text-slate-700 dark:text-white placeholder-slate-300 bg-white dark:bg-gray-950 border border-gray-200 dark:border-gray-800 outline-none focus:border-primary-500 focus:dark:border-primary-600 focus:outline-offset-0 focus:outline-primary-200 focus:dark:outline-primary-950  disabled:bg-slate-50 disabled:dark:bg-slate-950 disabled:cursor-not-allowed rounded transition-all' placeholder='${options.labels.placeholder}' type='search' title='${options.labels.searchTitle}'${dom.id ? ` aria-controls="${dom.id}"` : ""}>
                    </div>` : ""}
                ${options.paging && options.perPageSelect ? `<div class='${options.classes.dropdown}'>
                        <label class='inline-flex items-center gap-2'>
                          <span class='hidden sm:block'>${options.labels.perPage}</span><select class='${options.classes.selector} block w-full text-sm leading-4.5 !pe-10 !ps-3 py-1.5 h-9 min-w-[4.5rem] text-slate-700 dark:text-white placeholder-slate-300 bg-white dark:bg-gray-950 border border-gray-200 dark:border-gray-800 focus:border-primary-500 outline-none focus:outline-offset-0 focus:outline-primary-200 focus:dark:outline-primary-950 disabled:bg-slate-50 disabled:dark:bg-slate-950 disabled:cursor-not-allowed rounded transition-all bg-[right_0.5rem_center] rtl:bg-[left_0.5rem_center]'></select> 
                        </label>
                    </div>` : ""}
              </div>
              <div class='${options.classes.container} overflow-auto border !border-gray-200 dark:!border-gray-800 [&_tbody_tr:last-child_td]:border-b-0 [&_thead_tr_th]:border-b-gray-200 [&_thead_tr_th]:dark:border-b-gray-800 [&_td]:border-b [&_td]:border-b-gray-200 [&_td]:dark:border-b-gray-800 [&_th]:p-2 [&_thead_th_button]:leading-4 [&_thead_th_button]:whitespace-nowrap [&_thead_th]:!py-1 [&_.datatable-sorter]:pe-6 [&_.datatable-sorter]:after:-top-0.5 [&_.datatable-sorter]:before:bottom-px [&_td]:p-2 [&_th:first-child]:!ps-5 [&_th:last-child]:pe-5 [&_td:first-child]:ps-5 [& _td:last-child]:pe-5 rounded'${options.scrollY.length ? ` style='height: ${options.scrollY}; overflow-Y: auto;'` : ""}></div>
              <div class='${options.classes.bottom} !px-0 !pb-0 !pt-4 flex items-center justify-between after:hidden'>
                <nav class='${options.classes.pagination}'></nav>
                  ${options.paging ? `<div class='${options.classes.info} text-xs text-slate-600'></div>` : ""}
            </div>`
      });

      //scrolled rsponsive
      let dataContainer = item.dataset.nkContainer ? item.dataset.nkContainer : '',
        containerClass = dataContainer.split(' ');
      dataContainer && dataTables.container.classList.add(...containerClass);
    });
  }
}

/***/ }),

/***/ "./src/js/component/DatePicker.js":
/*!****************************************!*\
  !*** ./src/js/component/DatePicker.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DatePickerElement)
/* harmony export */ });
/* harmony import */ var vanillajs_datepicker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vanillajs-datepicker */ "./node_modules/vanillajs-datepicker/js/main.js");

function DatePickerElement(selector, opt) {
  let elm = document.querySelectorAll(selector);
  if (elm.length > 0) {
    elm.forEach(item => {
      let autohide = item.dataset.autoHide ? JSON.parse(item.dataset.autoHide) : true;
      let clearBtn = item.dataset.clearBtn ? JSON.parse(item.dataset.clearBtn) : false;
      let format = item.dataset.format ? item.dataset.format : 'mm/dd/yyyy';
      let maxView = item.dataset.maxView ? parseInt(item.dataset.maxView) : 3;
      let pickLevel = item.dataset.pickLevel ? parseInt(item.dataset.pickLevel) : 0;
      let startView = item.dataset.startView ? parseInt(item.dataset.startView) : 0;
      let title = item.dataset.title ? item.dataset.title : '';
      let todayBtn = item.dataset.todayBtn ? JSON.parse(item.dataset.todayBtn) : false;
      let todayBtnMode = item.dataset.todayBtnMode ? parseInt(item.dataset.todayBtnMode) : 0;
      let weekStart = item.dataset.weekStart ? parseInt(item.dataset.weekStart) : 0;
      let rangePicker = item.dataset.range ? true : false;
      let def = {
          autohide: autohide,
          clearBtn: clearBtn,
          format: format,
          maxView: maxView,
          pickLevel: pickLevel,
          startView: startView,
          title: title,
          todayBtn: todayBtn,
          todayBtnMode: todayBtnMode,
          weekStart: weekStart
        },
        attr = opt ? opt : def;
      const datepicker = rangePicker ? new vanillajs_datepicker__WEBPACK_IMPORTED_MODULE_0__.DateRangePicker(item, attr) : new vanillajs_datepicker__WEBPACK_IMPORTED_MODULE_0__.Datepicker(item, attr);
    });
  }
}

/***/ }),

/***/ "./src/js/component/Dropdown.js":
/*!**************************************!*\
  !*** ./src/js/component/Dropdown.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Dropdown)
/* harmony export */ });
/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @popperjs/core */ "./node_modules/@popperjs/core/lib/popper.js");
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../function */ "./src/js/function/index.js");


function Dropdown(el) {
  const elm = document.querySelectorAll('.dropdown-toggle');
  elm.forEach(function (item) {
    item.addEventListener("click", function (e) {
      e.preventDefault();
      const offset = item.dataset.offset ? [parseInt(item.dataset.offset.split(',')[0]), parseInt(item.dataset.offset.split(',')[1])] : [0, 0];
      const rtlOffset = item.dataset.rtlOffset ? [parseInt(item.dataset.rtlOffset.split(',')[0]), parseInt(item.dataset.rtlOffset.split(',')[1])] : offset;
      let placement = item.dataset.placement ? item.dataset.placement : 'bottom-start';
      let rtlPlacement = item.dataset.rtlPlacement ? item.dataset.rtlPlacement : 'bottom-end';
      var getNextSibling = function (elem, selector) {
        var sibling = elem.nextElementSibling;
        while (sibling) {
          if (sibling.matches(selector)) return sibling;
          sibling = sibling.nextElementSibling;
        }
      };
      (0,_popperjs_core__WEBPACK_IMPORTED_MODULE_1__.createPopper)(item, getNextSibling(item, '.dropdown-menu'), {
        placement: (0,_function__WEBPACK_IMPORTED_MODULE_0__.isRTL)() ? rtlPlacement : placement,
        // strategy: 'fixed',
        modifiers: [{
          name: 'offset',
          options: {
            offset: (0,_function__WEBPACK_IMPORTED_MODULE_0__.isRTL)() ? rtlOffset : offset
          }
        }, {
          name: 'preventOverflow',
          options: {
            padding: 8,
            altAxis: true,
            boundary: '#pagecontent'
          }
        }]
      });
      item.classList.contains("show") ? item.classList.remove("show") : item.classList.add("show");
    });
    document.addEventListener("mouseup", function (e) {
      e.preventDefault();
      if (item !== e.target && (0,_function__WEBPACK_IMPORTED_MODULE_0__.getParents)(e.target, undefined, 'clickable').length <= 0 && !e.target.classList.contains('clickable')) {
        item.classList.remove("show");
      }
    });
  });
}

/***/ }),

/***/ "./src/js/component/Dropzone.js":
/*!**************************************!*\
  !*** ./src/js/component/Dropzone.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ UploadZone)
/* harmony export */ });
/* harmony import */ var dropzone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dropzone */ "./node_modules/dropzone/dist/dropzone.js");
/* harmony import */ var dropzone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dropzone__WEBPACK_IMPORTED_MODULE_0__);

dropzone__WEBPACK_IMPORTED_MODULE_0__.Dropzone.autoDiscover = false;
function UploadZone(selector) {
  let elm = document.querySelectorAll(selector);
  if (elm != 'undefined' && elm != null) {
    elm.forEach(item => {
      let itemId = item.id;
      let maxFiles = item.dataset.maxFiles ? parseInt(item.dataset.maxFiles) : null;
      let maxFilesize = item.dataset.maxFilesize ? parseInt(item.dataset.maxFilesize) : 256;
      let acceptedFiles = item.dataset.acceptedFiles ? item.dataset.acceptedFiles : null;

      //add styling Class 
      item.classList.add('dropzone');
      let myDropzone = new dropzone__WEBPACK_IMPORTED_MODULE_0__.Dropzone(`#${itemId}`, {
        url: "image",
        maxFilesize: maxFilesize,
        maxFiles: maxFiles,
        acceptedFiles: acceptedFiles
      });
    });
  }
}
;

/***/ }),

/***/ "./src/js/component/FileInput.js":
/*!***************************************!*\
  !*** ./src/js/component/FileInput.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FileInput)
/* harmony export */ });
function FileInput(selector) {
  const elm = document.querySelectorAll(selector);
  elm.forEach(item => {
    let old = item.nextElementSibling.textContent,
      allFile = [];
    item.addEventListener("change", function (e) {
      for (var i = 0; i < item.files.length; i++) {
        allFile[i] = item.files[i].name;
      }
      old = allFile ? allFile.join(', ') : old;
      item.nextElementSibling.innerHTML = old;
    });
  });
}
;

/***/ }),

/***/ "./src/js/component/FormValidate.js":
/*!******************************************!*\
  !*** ./src/js/component/FormValidate.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FormValidate)
/* harmony export */ });
/* harmony import */ var pristinejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pristinejs */ "./node_modules/pristinejs/dist/pristine.js");
/* harmony import */ var pristinejs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pristinejs__WEBPACK_IMPORTED_MODULE_0__);
// pristinejs

function FormValidate(selector) {
  let elm = document.querySelectorAll(selector);
  if (elm != 'undefined' && elm != null) {
    elm.forEach(item => {
      let itemId = item.id;
      var form = document.getElementById(itemId);
      var pristine = new (pristinejs__WEBPACK_IMPORTED_MODULE_0___default())(form, {
        classTo: 'form-group',
        errorClass: 'is-invalid',
        successClass: 'is-valid',
        errorTextParent: 'form-wrap',
        errorTextTag: 'div',
        errorTextClass: 'form-error'
      });
      function onchange(newselector) {
        let newelm = document.querySelectorAll(newselector);
        newelm.forEach(newitem => {
          newitem.addEventListener('change', function () {
            if (form.classList.contains('validated')) {
              var valid = pristine.validate();
            }
          });
        });
      }
      onchange('.js-select');
      form.addEventListener('submit', function (e) {
        e.preventDefault();
        var valid = pristine.validate();
        form.classList.add('validated');
      });
    });
  }
}

/***/ }),

/***/ "./src/js/component/Menu.js":
/*!**********************************!*\
  !*** ./src/js/component/Menu.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../function */ "./src/js/function/index.js");

let Menu = {};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Menu = {
  load: function (elm, subparent) {
    let parent = elm.parentElement;
    if (!parent.classList.contains(subparent)) {
      parent.classList.add(subparent);
    }
  },
  toggle: function (elm, active) {
    let parent = elm.parentElement;
    let nextelm = elm.nextElementSibling;
    let speed = nextelm.children.length > 5 ? 400 + nextelm.children.length * 10 : 400;
    if (!parent.classList.contains(active)) {
      parent.classList.add(active);
      (0,_function__WEBPACK_IMPORTED_MODULE_0__.slideDown)(nextelm, speed);
    } else {
      parent.classList.remove(active);
      (0,_function__WEBPACK_IMPORTED_MODULE_0__.slideUp)(nextelm, speed);
    }
  },
  closeSiblings: function (elm, active, subparent, submenu) {
    let parent = elm.parentElement;
    let siblings = parent.parentElement.children;
    Array.from(siblings).forEach(item => {
      if (item !== parent) {
        item.classList.remove(active);
        if (item.classList.contains(subparent)) {
          let subitem = item.querySelectorAll(`.${submenu}`);
          subitem.forEach(child => {
            child.parentElement.classList.remove(active);
            (0,_function__WEBPACK_IMPORTED_MODULE_0__.slideUp)(child, 400);
          });
        }
      }
    });
  }
});

/***/ }),

/***/ "./src/js/component/Modal.js":
/*!***********************************!*\
  !*** ./src/js/component/Modal.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Modal)
/* harmony export */ });
function Modal(el) {
  const elm = document.querySelectorAll('.modal-toggle');
  elm.forEach(function (item) {
    let dialog = document.querySelector(item.dataset.target),
      close = dialog?.querySelectorAll('.modal-close'),
      getAll = document.querySelectorAll('.modal');
    item.addEventListener("click", function (e) {
      dialog.classList.add('show');
      document.body.classList.add('overflow-hidden');
      getAll.forEach(function (getItem) {
        getItem !== dialog && getItem.classList.remove('show');
      });
    });
    close?.forEach(function (item) {
      item.addEventListener("click", function (e) {
        e.preventDefault();
        dialog.classList.remove('show');
        document.body.classList.remove('overflow-hidden');
      });
    });
  });
}

/***/ }),

/***/ "./src/js/component/NumberSpinner.js":
/*!*******************************************!*\
  !*** ./src/js/component/NumberSpinner.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ NumberSpinner)
/* harmony export */ });
function NumberSpinner(elm, opt) {
  var plus = document.querySelectorAll("[data-number='plus']");
  var minus = document.querySelectorAll("[data-number='minus']");
  var number_spinner = document.querySelectorAll(".number-spinner");
  plus.forEach(function (item, index, arr) {
    var parent = plus[index].parentNode;
    plus[index].addEventListener("click", function () {
      var child = plus[index].parentNode.children;
      child.forEach(function (item, index, arr) {
        if (child[index].classList.contains("number-spinner")) {
          var value = !child[index].value == "" ? parseInt(child[index].value) : 0;
          var step = !child[index].step == "" ? parseInt(child[index].step) : 1;
          var max = !child[index].max == "" ? parseInt(child[index].max) : Infinity;
          if (max + 1 > value + step) {
            child[index].value = value + step;
          } else {
            child[index].value = value;
          }
        }
      });
    });
  });
  minus.forEach(function (item, index, arr) {
    var parent = minus[index].parentNode;
    minus[index].addEventListener("click", function () {
      var child = minus[index].parentNode.children;
      child.forEach(function (item, index, arr) {
        if (child[index].classList.contains("number-spinner")) {
          var value = !child[index].value == "" ? parseInt(child[index].value) : 0;
          var step = !child[index].step == "" ? parseInt(child[index].step) : 1;
          var min = !child[index].min == "" ? parseInt(child[index].min) : 0;
          if (min - 1 < value - step) {
            child[index].value = value - step;
          } else {
            child[index].value = value;
          }
        }
      });
    });
  });
}

/***/ }),

/***/ "./src/js/component/Popover.js":
/*!*************************************!*\
  !*** ./src/js/component/Popover.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Popover)
/* harmony export */ });
/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @popperjs/core */ "./node_modules/@popperjs/core/lib/popper.js");
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../function */ "./src/js/function/index.js");


function Popover(el) {
  const elm = document.querySelectorAll('.popover-toggle');
  const class_top = `[&[data-popper-placement^='top']_.popover-arrow]:h-2 [&[data-popper-placement^='top']_.popover-arrow]:w-4 [&[data-popper-placement^='top']_.popover-arrow]:-bottom-2 [&[data-popper-placement^='top']_.popover-arrow]:left-1/2 [&[data-popper-placement^='top']_.popover-arrow]:-translate-x-1/2 [&[data-popper-placement^='top']_.popover-arrow]:before:border-t-gray-300 [&[data-popper-placement^='top']_.popover-arrow]:before:dark:border-t-gray-900 [&[data-popper-placement^='top']_.popover-arrow]:before:border-t-8 [&[data-popper-placement^='top']_.popover-arrow]:before:border-r-8 [&[data-popper-placement^='top']_.popover-arrow]:before:border-b-0 [&[data-popper-placement^='top']_.popover-arrow]:before:border-l-8 [&[data-popper-placement^='top']_.popover-arrow]:after:bottom-px [&[data-popper-placement^='top']_.popover-arrow]:after:left-0 [&[data-popper-placement^='top']_.popover-arrow]:after:border-t-white [&[data-popper-placement^='top']_.popover-arrow]:after:dark:border-t-gray-950 [&[data-popper-placement^='top']_.popover-arrow]:after:border-t-8 [&[data-popper-placement^='top']_.popover-arrow]:after:border-r-8 [&[data-popper-placement^='top']_.popover-arrow]:after:border-b-0 [&[data-popper-placement^='top']_.popover-arrow]:after:border-l-8`,
    class_right = `[&[data-popper-placement^='right']_.popover-arrow]:h-4 [&[data-popper-placement^='right']_.popover-arrow]:w-2 [&[data-popper-placement^='right']_.popover-arrow]:-left-2 [&[data-popper-placement^='right']_.popover-arrow]:top-1/2 [&[data-popper-placement^='right']_.popover-arrow]:-translate-y-1/2 [&[data-popper-placement^='right']_.popover-arrow]:before:border-r-gray-300 [&[data-popper-placement^='right']_.popover-arrow]:before:dark:border-r-gray-900 [&[data-popper-placement^='right']_.popover-arrow]:before:border-t-8 [&[data-popper-placement^='right']_.popover-arrow]:before:border-r-8 [&[data-popper-placement^='right']_.popover-arrow]:before:border-b-8 [&[data-popper-placement^='right']_.popover-arrow]:before:border-l-0 [&[data-popper-placement^='right']_.popover-arrow]:after:left-px [&[data-popper-placement^='right']_.popover-arrow]:after:top-0 [&[data-popper-placement^='right']_.popover-arrow]:after:border-r-white [&[data-popper-placement^='right']_.popover-arrow]:after:dark:border-r-gray-950 [&[data-popper-placement^='right']_.popover-arrow]:after:border-t-8 [&[data-popper-placement^='right']_.popover-arrow]:after:border-r-8 [&[data-popper-placement^='right']_.popover-arrow]:after:border-b-8 [&[data-popper-placement^='right']_.popover-arrow]:after:border-l-0`,
    class_bottom = `[&[data-popper-placement^='bottom']_.popover-arrow]:h-2 [&[data-popper-placement^='bottom']_.popover-arrow]:w-4 [&[data-popper-placement^='bottom']_.popover-arrow]:-top-2 [&[data-popper-placement^='bottom']_.popover-arrow]:left-1/2 [&[data-popper-placement^='bottom']_.popover-arrow]:-translate-x-1/2 [&[data-popper-placement^='bottom']_.popover-arrow]:before:border-b-gray-300 [&[data-popper-placement^='bottom']_.popover-arrow]:before:dark:border-b-gray-900 [&[data-popper-placement^='bottom']_.popover-arrow]:before:border-t-0 [&[data-popper-placement^='bottom']_.popover-arrow]:before:border-r-8 [&[data-popper-placement^='bottom']_.popover-arrow]:before:border-b-8 [&[data-popper-placement^='bottom']_.popover-arrow]:before:border-l-8 [&[data-popper-placement^='bottom']_.popover-arrow]:after:top-px [&[data-popper-placement^='bottom']_.popover-arrow]:after:left-0 [&[data-popper-placement^='bottom']_.popover-arrow]:after:border-b-white [&[data-popper-placement^='bottom']_.popover-arrow]:after:dark:border-b-gray-950 [&[data-popper-placement^='bottom']_.popover-arrow]:after:border-t-0 [&[data-popper-placement^='bottom']_.popover-arrow]:after:border-r-8 [&[data-popper-placement^='bottom']_.popover-arrow]:after:border-b-8 [&[data-popper-placement^='bottom']_.popover-arrow]:after:border-l-8`,
    class_left = `[&[data-popper-placement^='left']_.popover-arrow]:h-4 [&[data-popper-placement^='left']_.popover-arrow]:w-2 [&[data-popper-placement^='left']_.popover-arrow]:-right-2 [&[data-popper-placement^='left']_.popover-arrow]:top-1/2 [&[data-popper-placement^='left']_.popover-arrow]:-translate-y-1/2 [&[data-popper-placement^='left']_.popover-arrow]:before:border-l-gray-300 [&[data-popper-placement^='left']_.popover-arrow]:before:dark:border-l-gray-900 [&[data-popper-placement^='left']_.popover-arrow]:before:border-t-8 [&[data-popper-placement^='left']_.popover-arrow]:before:border-r-0 [&[data-popper-placement^='left']_.popover-arrow]:before:border-b-8 [&[data-popper-placement^='left']_.popover-arrow]:before:border-l-8 [&[data-popper-placement^='left']_.popover-arrow]:after:right-px [&[data-popper-placement^='left']_.popover-arrow]:after:top-0 [&[data-popper-placement^='left']_.popover-arrow]:after:border-l-white [&[data-popper-placement^='left']_.popover-arrow]:after:dark:border-l-gray-950 [&[data-popper-placement^='left']_.popover-arrow]:after:border-t-8 [&[data-popper-placement^='left']_.popover-arrow]:after:border-r-0 [&[data-popper-placement^='left']_.popover-arrow]:after:border-b-8 [&[data-popper-placement^='left']_.popover-arrow]:after:border-l-8`;
  elm.forEach(function (item) {
    const id = "id" + Math.random().toString(16).slice(2);
    item.setAttribute("data-target", id);
    const title = item.dataset.title ? item.dataset.title : false;
    const content = item.dataset.content ? item.dataset.content : 'placeholder';
    const markup = `<div tabindex="0" id="${id}" class="popover-content absolute w-screen max-w-[276px] border border-gray-300 dark:border-gray-900 bg-white dark:bg-gray-950 rounded-md shadow-md z-[1070] hidden [&.show]:block ${class_top} ${class_right} ${class_bottom} ${class_left}">
            <div class="popover-arrow absolute before:block before:h-0 before:w-0 before:border-transparent after:absolute after:block after:h-0 after:w-0 after:border-transparent"></div>
            ${title ? `<h3 class="px-3 py-2 border-b border-gray-300 dark:border-gray-900 bg-gray-100 dark:bg-gray-900 text-base leading-5 font-bold font-heading text-slate-700 dark:text-white rounded-t-[inherit]">${title}</h3>` : ''}
            <div class="px-3 py-2 text-sm leading-6">${content}</div>
        </div>`;
    document.body.insertAdjacentHTML('beforeend', markup);
    item.addEventListener("click", function (e) {
      e.preventDefault();
      const offset = item.dataset.offset ? item.dataset.offset : [0, 10];
      const placement = item.dataset.placement ? item.dataset.placement : 'right';
      const rtlPlacement = item.dataset.rtlPlacement ? item.dataset.rtlPlacement : placement;
      const popover = document.getElementById(item.dataset.target);
      popover.classList.contains("show") ? popover.classList.remove("show") : popover.classList.add("show");
      (0,_popperjs_core__WEBPACK_IMPORTED_MODULE_1__.createPopper)(item, popover, {
        placement: (0,_function__WEBPACK_IMPORTED_MODULE_0__.isRTL)() ? rtlPlacement : placement,
        modifiers: [{
          name: 'offset',
          options: {
            offset: offset
          }
        }, {
          name: 'flip',
          options: {
            fallbackPlacements: ['top', 'bottom']
          }
        }]
      });
    });
  });
}

/***/ }),

/***/ "./src/js/component/Progress.js":
/*!**************************************!*\
  !*** ./src/js/component/Progress.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Progress)
/* harmony export */ });
function Progress(selector) {
  let progressBar = document.querySelectorAll(selector);
  progressBar.forEach(item => {
    let amount = item.dataset.progress;
    item.style.width = amount;
  });
}

/***/ }),

/***/ "./src/js/component/Range.js":
/*!***********************************!*\
  !*** ./src/js/component/Range.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Range)
/* harmony export */ });
/* harmony import */ var nouislider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nouislider */ "./node_modules/nouislider/dist/nouislider.mjs");
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function */ "./src/js/function/index.js");


function Range(selector, opt) {
  let elm = document.querySelectorAll(selector);
  if (elm != 'undefined' && elm != null) {
    elm.forEach(item => {
      let itemId = item.id;
      let start = item.dataset.start;
      start = /\s/g.test(start) ? start.split(' ') : start;
      start = start ? start : 0;
      let connect = item.dataset.connect;
      connect = /\s/g.test(connect) ? connect.split(' ') : connect;
      connect = typeof connect == 'undefined' ? 'lower' : connect;
      connect = connect == 'true' || connect == 'false' ? JSON.parse(connect) : connect;
      let min = item.dataset.min ? parseInt(item.dataset.min) : 0;
      let max = item.dataset.max ? parseInt(item.dataset.max) : 100;
      let minDistance = item.dataset.minDistance ? parseInt(item.dataset.minDistance) : null;
      let maxDistance = item.dataset.maxDistance ? parseInt(item.dataset.maxDistance) : null;
      let step = item.dataset.step ? parseInt(item.dataset.step) : 1;
      let orientation = item.dataset.orientation ? item.dataset.orientation : 'horizontal';
      let tooltip = item.dataset.tooltip ? JSON.parse(item.dataset.tooltip) : false;
      var def = {
          start: start,
          connect: connect,
          direction: (0,_function__WEBPACK_IMPORTED_MODULE_1__.isRTL)() ? "rtl" : "ltr",
          range: {
            'min': min,
            'max': max
          },
          margin: minDistance,
          limit: maxDistance,
          step: step,
          orientation: orientation,
          tooltips: tooltip
        },
        attr = opt ? (0,_function__WEBPACK_IMPORTED_MODULE_1__.extendObject)(def, opt) : def;
      nouislider__WEBPACK_IMPORTED_MODULE_0__["default"].create(item, attr);
    });
  }
}

/***/ }),

/***/ "./src/js/component/Select.js":
/*!************************************!*\
  !*** ./src/js/component/Select.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Select)
/* harmony export */ });
/* harmony import */ var choices_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! choices.js */ "./node_modules/choices.js/public/assets/scripts/choices.mjs");

function Select(selector, options) {
  let elm = document.querySelectorAll(selector);
  if (elm.length > 0) {
    elm.forEach(item => {
      let search = item.dataset.search ? JSON.parse(item.dataset.search) : false;
      let sort = item.dataset.sort ? JSON.parse(item.dataset.sort) : false;
      let cross = item.dataset.cross ? JSON.parse(item.dataset.cross) : true;
      let placeholderValue = item.dataset.placeholder ? item.dataset.placeholder : null;
      const choices = new choices_js__WEBPACK_IMPORTED_MODULE_0__["default"](item, {
        silent: true,
        allowHTML: false,
        searchEnabled: search,
        placeholder: true,
        placeholderValue: placeholderValue,
        searchPlaceholderValue: '',
        shouldSort: sort,
        removeItemButton: cross,
        itemSelectText: '',
        noResultsText: 'No results'
      });
    });
  }
}

/***/ }),

/***/ "./src/js/component/Settings.js":
/*!**************************************!*\
  !*** ./src/js/component/Settings.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Settings)
/* harmony export */ });
let theme = [];
let date = new Date().toLocaleDateString();
function Settings(defaultTheme) {
  if (localStorage.getItem("dashwind-html-demo1")) {
    let localData = JSON.parse(localStorage.getItem("dashwind-html-demo1"));
    if (localData.date !== date) {
      theme = defaultTheme;
    } else {
      theme = theme;
    }
  } else {
    localStorage.setItem("dashwind-html-demo1", JSON.stringify({
      ...defaultTheme,
      date: date
    }));
  }
  function onPageLoad() {
    let themeData = JSON.parse(localStorage.getItem("dashwind-html-demo1"));
    if (themeData.skin === 'dark') {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
    if (themeData.direction === 'rtl') {
      document.body.setAttribute('dir', 'rtl');
    } else {
      document.body.setAttribute('dir', 'ltr');
    }
  }
  onPageLoad();
  const themeToggle = document.querySelectorAll('.theme-toggle');
  const directionToggle = document.querySelectorAll('.direction-toggle');

  // mode toggle
  themeToggle.forEach(item => {
    item.addEventListener('click', function (e) {
      e.preventDefault();
      let themeData = JSON.parse(localStorage.getItem("dashwind-html-demo1"));
      if (themeData.skin !== 'dark') {
        localStorage.setItem("dashwind-html-demo1", JSON.stringify({
          ...themeData,
          skin: 'dark',
          date: date
        }));
        document.documentElement.classList.add('dark');
      } else {
        localStorage.setItem("dashwind-html-demo1", JSON.stringify({
          ...themeData,
          skin: 'light',
          date: date
        }));
        document.documentElement.classList.remove('dark');
      }
    });
  });
  // direction toggle
  directionToggle.forEach(item => {
    item.addEventListener('click', function (e) {
      e.preventDefault();
      let themeData = JSON.parse(localStorage.getItem("dashwind-html-demo1"));
      if (themeData.direction !== 'rtl') {
        localStorage.setItem("dashwind-html-demo1", JSON.stringify({
          ...themeData,
          direction: 'rtl',
          date: date
        }));
        document.body.setAttribute('dir', 'rtl');
      } else {
        localStorage.setItem("dashwind-html-demo1", JSON.stringify({
          ...themeData,
          direction: 'ltr',
          date: date
        }));
        document.body.setAttribute('dir', 'ltr');
      }
    });
  });
}

/***/ }),

/***/ "./src/js/component/Sidebar.js":
/*!*************************************!*\
  !*** ./src/js/component/Sidebar.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../function */ "./src/js/function/index.js");

let Sidebar = {};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Sidebar = {
  compact: function () {
    let toggle = document.querySelectorAll('.sidebar-compact-toggle');
    let parent = document.querySelector('.nk-sidebar');
    let body = parent && parent.querySelector('.nk-sidebar-body');
    toggle && toggle.forEach(item => {
      item.addEventListener("click", function (e) {
        e.preventDefault();
        item.classList.toggle('compact-active');
        parent.classList.toggle('is-compact');
        !parent.classList.contains('is-compact') && parent.classList.remove('has-hover');
      });
    });
    body && body.addEventListener('mouseenter', function (e) {
      parent.classList.contains('is-compact') && parent.classList.add('has-hover');
    });
    body && body.addEventListener('mouseleave', function (e) {
      parent.classList.contains('is-compact') && parent.classList.remove('has-hover');
    });
  },
  toggle: function () {
    let toggle = document.querySelectorAll('.sidebar-toggle');
    let parent = document.querySelector('.nk-sidebar');
    toggle.forEach(item => {
      item.addEventListener("click", function (e) {
        e.preventDefault();
        item.classList.toggle('active');
        parent && parent.classList.toggle('sidebar-visible');
        document.body.classList.toggle('overflow-hidden');
      });
    });
  },
  page_resize: function () {
    let toggle = document.querySelectorAll('.sidebar-toggle');
    let parent = document.querySelector('.nk-sidebar');
    if (_function__WEBPACK_IMPORTED_MODULE_0__.config.win.width > _function__WEBPACK_IMPORTED_MODULE_0__.config.break.xl) {
      toggle.forEach(item => {
        item.classList.remove('active');
      });
      parent && parent.classList.remove('sidebar-visible');
      document.body.classList.remove('overflow-hidden');
    }
  }
});

/***/ }),

/***/ "./src/js/component/Slider.js":
/*!************************************!*\
  !*** ./src/js/component/Slider.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Slider)
/* harmony export */ });
/* harmony import */ var swiper_bundle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swiper/bundle */ "./node_modules/swiper/swiper-bundle.mjs");
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function */ "./src/js/function/index.js");


function Slider(selector) {
  let elm = document.querySelectorAll(selector);
  if (elm != 'undefined' && elm != null) {
    elm.forEach(item => {
      let _breakpoints = item.dataset.breakpoints ? JSON.parse(item.dataset.breakpoints) : null;
      let _autoplay = item.dataset.autoplay ? JSON.parse(item.dataset.autoplay) : false;
      let _loop = item.dataset.loop ? JSON.parse(item.dataset.loop) : false;
      let _centeredSlides = item.dataset.centeredslides ? JSON.parse(item.dataset.centeredslides) : false;
      let _speed = item.dataset.speed ? parseInt(item.dataset.speed) : 1000;
      let _effect = item.dataset.effect ? item.dataset.effect : '';
      let _parent = item.dataset.parent ? item.dataset.parent : false;
      var swiper = new swiper_bundle__WEBPACK_IMPORTED_MODULE_0__["default"](item, {
        // Optional parameters
        centeredSlides: _centeredSlides,
        loop: _loop,
        speed: _speed,
        autoplay: _autoplay,
        effect: _effect,
        // If we need pagination
        pagination: {
          el: ".swiper-pagination",
          type: 'bullets',
          clickable: true
        },
        // Navigation arrows
        navigation: {
          nextEl: '.swiper-button-next',
          prevEl: '.swiper-button-prev',
          clickable: true
        },
        breakpoints: _breakpoints
        // thumbs: {
        //   swiper: swiper,
        // },
      });
      if (_parent) {
        let item = document.querySelector(_parent);
        let _breakpoints = item.dataset.breakpoints ? JSON.parse(item.dataset.breakpoints) : null;
        let _autoplay = item.dataset.autoplay ? JSON.parse(item.dataset.autoplay) : false;
        let _loop = item.dataset.loop ? JSON.parse(item.dataset.loop) : false;
        let _centeredSlides = item.dataset.centeredslides ? JSON.parse(item.dataset.centeredslides) : false;
        let _speed = item.dataset.speed ? parseInt(item.dataset.speed) : 1000;
        let _effect = item.dataset.effect ? item.dataset.effect : '';
        var swiper_parent = new swiper_bundle__WEBPACK_IMPORTED_MODULE_0__["default"](item, {
          // Optional parameters
          centeredSlides: _centeredSlides,
          loop: _loop,
          speed: _speed,
          autoplay: _autoplay,
          effect: _effect,
          // If we need pagination
          pagination: {
            el: ".swiper-pagination",
            type: 'bullets',
            clickable: true
          },
          // Navigation arrows
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
            clickable: true
          },
          breakpoints: _breakpoints,
          thumbs: {
            swiper: swiper
          }
        });
      }
    });
  }
}

/***/ }),

/***/ "./src/js/component/StickyNav.js":
/*!***************************************!*\
  !*** ./src/js/component/StickyNav.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ StickyNav)
/* harmony export */ });
function StickyNav(selector) {
  let elem = document.querySelectorAll(selector);
  if (elem.length > 0) {
    elem.forEach(item => {
      let _item_offset = item.offsetTop;
      console.log(_item_offset);
      window.addEventListener("scroll", function () {
        if (window.scrollY > _item_offset) {
          item.classList.add('has-fixed');
        } else {
          item.classList.remove('has-fixed');
        }
      });
    });
  }
}
;

/***/ }),

/***/ "./src/js/component/Tab.js":
/*!*********************************!*\
  !*** ./src/js/component/Tab.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Tab)
/* harmony export */ });
function Tab(el) {
  const elm = document.querySelectorAll('.tab-toggle');
  elm.forEach(function (item) {
    let panel = document.querySelector(item.dataset.target),
      panel_root = panel.parentElement,
      panel_items = panel_root.children;
    item.addEventListener("click", function (e) {
      e.preventDefault();
      // tab toggle active
      let toggles = item.closest('.tab-nav').querySelectorAll('.tab-toggle');
      Array.from(toggles).forEach(item => {
        item.classList.remove('active');
      });
      item.classList.add('active');

      //tab panel active
      Array.from(panel_items).forEach(item => {
        item.classList.remove('active');
      });
      panel.classList.add('active');
    });
  });
}

/***/ }),

/***/ "./src/js/component/Tags.js":
/*!**********************************!*\
  !*** ./src/js/component/Tags.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Tags)
/* harmony export */ });
/* harmony import */ var _yaireo_tagify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @yaireo/tagify */ "./node_modules/@yaireo/tagify/dist/tagify.esm.js");

function Tags(selector) {
  let elm = document.querySelectorAll(selector);
  if (elm.length > 0) {
    elm.forEach(item => {
      let tagify = new _yaireo_tagify__WEBPACK_IMPORTED_MODULE_0__["default"](item);
    });
  }
}
;

/***/ }),

/***/ "./src/js/component/TimePicker.js":
/*!****************************************!*\
  !*** ./src/js/component/TimePicker.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TimePickerElement)
/* harmony export */ });
/* harmony import */ var _addon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../addon */ "./src/js/addon/index.js");
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function */ "./src/js/function/index.js");


function TimePickerElement(selector, opt) {
  let elm = document.querySelectorAll(selector);
  if (elm.length > 0) {
    elm.forEach(item => {
      let format = item.dataset.format ? parseInt(item.dataset.format) : 12;
      let interval = item.dataset.interval ? parseInt(item.dataset.interval) : 30;
      let startTime = item.dataset.startTime ? item.dataset.startTime : '12:00';
      let endTime = item.dataset.endTime ? item.dataset.endTime : '23:00';
      let placement = item.dataset.placement ? item.dataset.placement : 'bottom-start';
      let def = {
          format: format,
          interval: interval,
          start: startTime,
          placement: placement
        },
        attr = opt ? (0,_function__WEBPACK_IMPORTED_MODULE_1__.extendObject)(def, opt) : def;
      (0,_addon__WEBPACK_IMPORTED_MODULE_0__.TimePicker)(item, attr);
    });
  }
}

/***/ }),

/***/ "./src/js/component/ToggleClass.js":
/*!*****************************************!*\
  !*** ./src/js/component/ToggleClass.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ToggleClass)
/* harmony export */ });
function ToggleClass(el) {
  const elm = document.querySelectorAll('.class-toggle');
  elm.forEach(function (item) {
    let target = document.querySelector(item.dataset.target);
    let activeclass = item.dataset.activeClass ? item.dataset.activeClass : 'active';
    let bodyScroll = item.dataset.bodyScroll === "off" ? true : false;
    item.addEventListener("click", function (e) {
      let items = document.querySelectorAll(`[data-target="${item.dataset.target}"]`);
      items.forEach(function (single) {
        single.classList.contains(activeclass) ? single.classList.remove(activeclass) : single.classList.add(activeclass);
      });
      target.classList.contains(activeclass) ? target.classList.remove(activeclass) : target.classList.add(activeclass);
      bodyScroll && document.body.classList.toggle('overflow-hidden');
    });
  });
}

/***/ }),

/***/ "./src/js/component/TogglePassword.js":
/*!********************************************!*\
  !*** ./src/js/component/TogglePassword.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TogglePassword)
/* harmony export */ });
function TogglePassword(selector) {
  let elem = document.querySelectorAll(selector);
  if (elem.length > 0) {
    elem.forEach(item => {
      item.addEventListener("click", function (e) {
        e.preventDefault();
        let target = document.querySelector(item.getAttribute("href"));
        if (target.type == "password") {
          target.type = "text";
          item.classList.add("is-shown");
        } else {
          target.type = "password";
          item.classList.remove("is-shown");
        }
      });
    });
  }
}
;

/***/ }),

/***/ "./src/js/component/Tooltip.js":
/*!*************************************!*\
  !*** ./src/js/component/Tooltip.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Tooltip)
/* harmony export */ });
/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @popperjs/core */ "./node_modules/@popperjs/core/lib/popper.js");
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../function */ "./src/js/function/index.js");


function Tooltip(el) {
  const elm = document.querySelectorAll('.tooltip-toggle');
  const class_top = `[&[data-popper-placement^='top']]:after:top-full [&[data-popper-placement^='top']]:after:left-1/2 [&[data-popper-placement^='top']]:after:-translate-x-1/2 [&[data-popper-placement^='top']]:after:border-t-gray-800 [&[data-popper-placement^='top']]:after:border-t-6 [&[data-popper-placement^='top']]:after:border-r-6 [&[data-popper-placement^='top']]:after:border-b-0 [&[data-popper-placement^='top']]:after:border-l-6`,
    class_right = `[&[data-popper-placement^='right']]:after:right-full [&[data-popper-placement^='right']]:after:top-1/2 [&[data-popper-placement^='right']]:after:-translate-y-1/2 [&[data-popper-placement^='right']]:after:border-r-gray-800 [&[data-popper-placement^='right']]:after:border-t-6 [&[data-popper-placement^='right']]:after:border-r-6 [&[data-popper-placement^='right']]:after:border-b-6 [&[data-popper-placement^='right']]:after:border-l-0`,
    class_bottom = `[&[data-popper-placement^='bottom']]:after:bottom-full [&[data-popper-placement^='bottom']]:after:left-1/2 [&[data-popper-placement^='bottom']]:after:-translate-x-1/2 [&[data-popper-placement^='bottom']]:after:border-b-gray-800 [&[data-popper-placement^='bottom']]:after:border-t-0 [&[data-popper-placement^='bottom']]:after:border-r-6 [&[data-popper-placement^='bottom']]:after:border-b-6 [&[data-popper-placement^='bottom']]:after:border-l-6`,
    class_left = `[&[data-popper-placement^='left']]:after:left-full [&[data-popper-placement^='left']]:after:top-1/2 [&[data-popper-placement^='left']]:after:-translate-y-1/2 [&[data-popper-placement^='left']]:after:border-l-gray-800 [&[data-popper-placement^='left']]:after:border-t-6 [&[data-popper-placement^='left']]:after:border-r-0 [&[data-popper-placement^='left']]:after:border-b-6 [&[data-popper-placement^='left']]:after:border-l-6`;
  elm.forEach(function (item) {
    const id = "id" + Math.random().toString(16).slice(2);
    item.setAttribute("data-target", id);
    const title = item.dataset.title ? item.dataset.title : false;
    const markup = `<div tabindex="0" id="${id}" class="text-white bg-gray-800 text-xs px-3 py-1.5 rounded-sm z-[10000] max-w-[200px] w-max bock break-words font-normal after:absolute after:block after:h-0 after:w-0 after:border-transparent after:z-[10000] [&[data-popper-reference-hidden]]:opacity-0 ${class_top} ${class_right} ${class_bottom} ${class_left}" >
        ${title}
        </div>`;
    item.addEventListener("mouseenter", function (e) {
      e.preventDefault();
      const offset = item.dataset.offset ? item.dataset.offset : [0, 10];
      const placement = item.dataset.placement ? item.dataset.placement : 'right';
      const rtlPlacement = item.dataset.rtlPlacement ? item.dataset.rtlPlacement : placement;
      document.body.insertAdjacentHTML('beforeend', markup);
      const tooltip = document.getElementById(item.dataset.target);
      (0,_popperjs_core__WEBPACK_IMPORTED_MODULE_1__.createPopper)(item, tooltip, {
        placement: (0,_function__WEBPACK_IMPORTED_MODULE_0__.isRTL)() ? rtlPlacement : placement,
        modifiers: [{
          name: 'offset',
          options: {
            offset: offset
          }
        }, {
          name: 'flip',
          options: {
            fallbackPlacements: ['top', 'bottom']
          }
        }]
      });
    });
    item.addEventListener("mouseleave", function (e) {
      e.preventDefault();
      const tooltip = document.getElementById(item.dataset.target);
      tooltip.remove();
    });
  });
}

/***/ }),

/***/ "./src/js/component/WorldMap.js":
/*!**************************************!*\
  !*** ./src/js/component/WorldMap.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WorldMap)
/* harmony export */ });
/* harmony import */ var jsvectormap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsvectormap */ "./node_modules/jsvectormap/dist/jsvectormap.esm.js");
/* harmony import */ var jsvectormap_dist_maps_world_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jsvectormap/dist/maps/world.js */ "./node_modules/jsvectormap/dist/maps/world.js");
/* harmony import */ var jsvectormap_dist_maps_world_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jsvectormap_dist_maps_world_js__WEBPACK_IMPORTED_MODULE_1__);


function WorldMap(selector, data) {
  let elm = document.querySelectorAll(selector);
  elm.forEach(item => {
    const map = new jsvectormap__WEBPACK_IMPORTED_MODULE_0__["default"]({
      selector: `#${item.id}`,
      map: 'world',
      showTooltip: true,
      zoomButtons: false,
      zoomOnScroll: false,
      visualizeData: data
    });
  });
}

/***/ }),

/***/ "./src/js/component/index.js":
/*!***********************************!*\
  !*** ./src/js/component/index.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Accordion: () => (/* reexport safe */ _Accordion__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   Clipboard: () => (/* reexport safe */ _Clipboard__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   CurrentLink: () => (/* reexport safe */ _CurrentLink__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   DataTable: () => (/* reexport safe */ _DataTable__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   DatePicker: () => (/* reexport safe */ _DatePicker__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   Dropdown: () => (/* reexport safe */ _Dropdown__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   Dropzone: () => (/* reexport safe */ _Dropzone__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   FileInput: () => (/* reexport safe */ _FileInput__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   FormValidate: () => (/* reexport safe */ _FormValidate__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   Menu: () => (/* reexport safe */ _Menu__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   Modal: () => (/* reexport safe */ _Modal__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   NumberSpinner: () => (/* reexport safe */ _NumberSpinner__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   Popover: () => (/* reexport safe */ _Popover__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   Progress: () => (/* reexport safe */ _Progress__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   Range: () => (/* reexport safe */ _Range__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   Select: () => (/* reexport safe */ _Select__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   Settings: () => (/* reexport safe */ _Settings__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   Sidebar: () => (/* reexport safe */ _Sidebar__WEBPACK_IMPORTED_MODULE_17__["default"]),
/* harmony export */   Slider: () => (/* reexport safe */ _Slider__WEBPACK_IMPORTED_MODULE_18__["default"]),
/* harmony export */   StickyNav: () => (/* reexport safe */ _StickyNav__WEBPACK_IMPORTED_MODULE_19__["default"]),
/* harmony export */   Tab: () => (/* reexport safe */ _Tab__WEBPACK_IMPORTED_MODULE_20__["default"]),
/* harmony export */   Tags: () => (/* reexport safe */ _Tags__WEBPACK_IMPORTED_MODULE_21__["default"]),
/* harmony export */   TimePicker: () => (/* reexport safe */ _TimePicker__WEBPACK_IMPORTED_MODULE_22__["default"]),
/* harmony export */   ToggleClass: () => (/* reexport safe */ _ToggleClass__WEBPACK_IMPORTED_MODULE_23__["default"]),
/* harmony export */   TogglePassword: () => (/* reexport safe */ _TogglePassword__WEBPACK_IMPORTED_MODULE_24__["default"]),
/* harmony export */   Tooltip: () => (/* reexport safe */ _Tooltip__WEBPACK_IMPORTED_MODULE_25__["default"]),
/* harmony export */   WorldMap: () => (/* reexport safe */ _WorldMap__WEBPACK_IMPORTED_MODULE_26__["default"])
/* harmony export */ });
/* harmony import */ var _Accordion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Accordion */ "./src/js/component/Accordion.js");
/* harmony import */ var _Clipboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Clipboard */ "./src/js/component/Clipboard.js");
/* harmony import */ var _CurrentLink__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CurrentLink */ "./src/js/component/CurrentLink.js");
/* harmony import */ var _DataTable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DataTable */ "./src/js/component/DataTable.js");
/* harmony import */ var _DatePicker__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DatePicker */ "./src/js/component/DatePicker.js");
/* harmony import */ var _Dropdown__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Dropdown */ "./src/js/component/Dropdown.js");
/* harmony import */ var _Dropzone__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Dropzone */ "./src/js/component/Dropzone.js");
/* harmony import */ var _FileInput__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./FileInput */ "./src/js/component/FileInput.js");
/* harmony import */ var _FormValidate__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./FormValidate */ "./src/js/component/FormValidate.js");
/* harmony import */ var _Menu__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Menu */ "./src/js/component/Menu.js");
/* harmony import */ var _Modal__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Modal */ "./src/js/component/Modal.js");
/* harmony import */ var _NumberSpinner__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./NumberSpinner */ "./src/js/component/NumberSpinner.js");
/* harmony import */ var _Popover__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Popover */ "./src/js/component/Popover.js");
/* harmony import */ var _Progress__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Progress */ "./src/js/component/Progress.js");
/* harmony import */ var _Range__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Range */ "./src/js/component/Range.js");
/* harmony import */ var _Select__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Select */ "./src/js/component/Select.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./Settings */ "./src/js/component/Settings.js");
/* harmony import */ var _Sidebar__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./Sidebar */ "./src/js/component/Sidebar.js");
/* harmony import */ var _Slider__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./Slider */ "./src/js/component/Slider.js");
/* harmony import */ var _StickyNav__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./StickyNav */ "./src/js/component/StickyNav.js");
/* harmony import */ var _Tab__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./Tab */ "./src/js/component/Tab.js");
/* harmony import */ var _Tags__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./Tags */ "./src/js/component/Tags.js");
/* harmony import */ var _TimePicker__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./TimePicker */ "./src/js/component/TimePicker.js");
/* harmony import */ var _ToggleClass__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./ToggleClass */ "./src/js/component/ToggleClass.js");
/* harmony import */ var _TogglePassword__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./TogglePassword */ "./src/js/component/TogglePassword.js");
/* harmony import */ var _Tooltip__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./Tooltip */ "./src/js/component/Tooltip.js");
/* harmony import */ var _WorldMap__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./WorldMap */ "./src/js/component/WorldMap.js");





























/***/ }),

/***/ "./src/js/function/asMobile.js":
/*!*************************************!*\
  !*** ./src/js/function/asMobile.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ asMobile)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./src/js/function/index.js");

function asMobile() {
  let value = _index_js__WEBPACK_IMPORTED_MODULE_0__.config.win.width < _index_js__WEBPACK_IMPORTED_MODULE_0__.config.break.md ? true : false;
  return value;
}

/***/ }),

/***/ "./src/js/function/attr.js":
/*!*********************************!*\
  !*** ./src/js/function/attr.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ attr)
/* harmony export */ });
function attr(selector, property, value) {
  const att = document.createAttribute(property);
  att.value = value;
  selector.setAttributeNode(att);
}

/***/ }),

/***/ "./src/js/function/currentMonth.js":
/*!*****************************************!*\
  !*** ./src/js/function/currentMonth.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ currentMonth)
/* harmony export */ });
function currentMonth() {
  let today = new Date();
  let mm = String(today.getMonth() + 1).padStart(2, '0');
  let yyyy = today.getFullYear();
  return yyyy + '-' + mm;
}

/***/ }),

/***/ "./src/js/function/extendObject.js":
/*!*****************************************!*\
  !*** ./src/js/function/extendObject.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ extendObject)
/* harmony export */ });
function extendObject(obj, ext) {
  Object.keys(ext).forEach(function (key) {
    obj[key] = ext[key];
  });
  return obj;
}

/***/ }),

/***/ "./src/js/function/getParents.js":
/*!***************************************!*\
  !*** ./src/js/function/getParents.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getParents)
/* harmony export */ });
function getParents(el, selector, filter) {
  // If no selector defined will bubble up all the way to *document*
  let parentSelector = selector === undefined ? document : document.querySelector(selector);
  var parents = [];
  var pNode = el.parentNode;
  while (pNode !== parentSelector) {
    var element = pNode;
    if (filter === undefined) {
      parents.push(element); // Push that parentSelector you wanted to stop at
    } else {
      element.classList.contains(filter) && parents.push(element);
    }
    pNode = element.parentNode;
  }
  return parents;
}

/***/ }),

/***/ "./src/js/function/hexRGB.js":
/*!***********************************!*\
  !*** ./src/js/function/hexRGB.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ hexRGB)
/* harmony export */ });
function hexRGB(hex, op) {
  let color, colorRGB;
  var opc = op ? op : 1;
  if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
    color = hex.substring(1).split('');
    if (color.length === 3) {
      color = [color[0], color[0], color[1], color[1], color[2], color[2]];
    }
    color = '0x' + color.join('');
    colorRGB = [color >> 16 & 255, color >> 8 & 255, color & 255].join(',');
    return opc >= 1 ? 'rgba(' + colorRGB + ')' : 'rgba(' + colorRGB + ',' + opc + ')';
  }
  throw new Error('bad hex');
}

/***/ }),

/***/ "./src/js/function/index.js":
/*!**********************************!*\
  !*** ./src/js/function/index.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   asMobile: () => (/* reexport safe */ _asMobile_js__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   attr: () => (/* reexport safe */ _attr_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   config: () => (/* binding */ config),
/* harmony export */   currentMonth: () => (/* reexport safe */ _currentMonth_js__WEBPACK_IMPORTED_MODULE_18__["default"]),
/* harmony export */   docReady: () => (/* binding */ docReady),
/* harmony export */   extendObject: () => (/* reexport safe */ _extendObject_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   getParents: () => (/* reexport safe */ _getParents_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   hexRGB: () => (/* reexport safe */ _hexRGB_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   isDark: () => (/* reexport safe */ _isDark_js__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   isMobile: () => (/* reexport safe */ _isMobile_js__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   isRTL: () => (/* reexport safe */ _isRTL_js__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   isTouch: () => (/* reexport safe */ _isTouch_js__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   onResize: () => (/* binding */ onResize),
/* harmony export */   randomId: () => (/* reexport safe */ _randomId_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   slideDown: () => (/* reexport safe */ _slideDown_js__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   slideToggle: () => (/* reexport safe */ _slideToggle_js__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   slideUp: () => (/* reexport safe */ _slideUp_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   toMin: () => (/* reexport safe */ _toMin_js__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   toTime: () => (/* reexport safe */ _toTime_js__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   toTwelve: () => (/* reexport safe */ _toTwelve_js__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   today: () => (/* reexport safe */ _today_js__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   winLoad: () => (/* binding */ winLoad),
/* harmony export */   yesterday: () => (/* reexport safe */ _yesterday_js__WEBPACK_IMPORTED_MODULE_17__["default"])
/* harmony export */ });
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attr.js */ "./src/js/function/attr.js");
/* harmony import */ var _extendObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extendObject.js */ "./src/js/function/extendObject.js");
/* harmony import */ var _getParents_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getParents.js */ "./src/js/function/getParents.js");
/* harmony import */ var _hexRGB_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hexRGB.js */ "./src/js/function/hexRGB.js");
/* harmony import */ var _randomId_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./randomId.js */ "./src/js/function/randomId.js");
/* harmony import */ var _slideDown_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./slideDown.js */ "./src/js/function/slideDown.js");
/* harmony import */ var _slideUp_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./slideUp.js */ "./src/js/function/slideUp.js");
/* harmony import */ var _slideToggle_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./slideToggle.js */ "./src/js/function/slideToggle.js");
/* harmony import */ var _toMin_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./toMin.js */ "./src/js/function/toMin.js");
/* harmony import */ var _toTime_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./toTime.js */ "./src/js/function/toTime.js");
/* harmony import */ var _toTwelve_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./toTwelve.js */ "./src/js/function/toTwelve.js");
/* harmony import */ var _isDark_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./isDark.js */ "./src/js/function/isDark.js");
/* harmony import */ var _isRTL_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./isRTL.js */ "./src/js/function/isRTL.js");
/* harmony import */ var _isTouch_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./isTouch.js */ "./src/js/function/isTouch.js");
/* harmony import */ var _isMobile_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./isMobile.js */ "./src/js/function/isMobile.js");
/* harmony import */ var _asMobile_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./asMobile.js */ "./src/js/function/asMobile.js");
/* harmony import */ var _today_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./today.js */ "./src/js/function/today.js");
/* harmony import */ var _yesterday_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./yesterday.js */ "./src/js/function/yesterday.js");
/* harmony import */ var _currentMonth_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./currentMonth.js */ "./src/js/function/currentMonth.js");
/*!
  * NioApp v1.0.0 (https://softnio.com/)
  * Developed by Softnio Team.
  * Copyright by Softnio.
*/




















const config = {
  app: {
    name: "NioApp",
    version: "1.0.0",
    author: "Softnio"
  },
  package: {
    name: "DashWind Tailwind",
    version: "1.0"
  },
  break: {
    sm: 640,
    md: 768,
    lg: 1024,
    xl: 1280,
    xl2: 1536,
    any: Infinity
  },
  win: {
    height: window.innerHeight,
    width: window.innerWidth
  },
  monthList: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  theme: {
    sidebar: "dark",
    //other value can be passed "light"
    header: "light",
    //other value can be passed "dark"
    skin: "light",
    //other value can be passed "dark"
    direction: 'ltr'
  }
};
function docReady(callback) {
  document.addEventListener('DOMContentLoaded', callback, false);
}
function winLoad(callback) {
  window.addEventListener('load', callback, false);
}
function onResize(callback, selector) {
  selector = typeof selector === typeof undefined ? window : selector;
  selector.addEventListener('resize', callback);
}


/***/ }),

/***/ "./src/js/function/isDark.js":
/*!***********************************!*\
  !*** ./src/js/function/isDark.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isDark)
/* harmony export */ });
function isDark() {
  let value = document.querySelector('body').classList.contains('dark') ? true : false;
  return value;
}

/***/ }),

/***/ "./src/js/function/isMobile.js":
/*!*************************************!*\
  !*** ./src/js/function/isMobile.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isMobile)
/* harmony export */ });
function isMobile() {
  let value = navigator.userAgent.match(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Windows Phone|/i) ? true : false;
  return value;
}

/***/ }),

/***/ "./src/js/function/isRTL.js":
/*!**********************************!*\
  !*** ./src/js/function/isRTL.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isRTL)
/* harmony export */ });
function isRTL() {
  let value = document.querySelector('body').classList.contains('rtl') || document.querySelector('body').getAttribute('dir') === 'rtl' ? true : false;
  return value;
}

/***/ }),

/***/ "./src/js/function/isTouch.js":
/*!************************************!*\
  !*** ./src/js/function/isTouch.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isTouch)
/* harmony export */ });
function isTouch() {
  let value = "ontouchstart" in document.documentElement ? true : false;
  return value;
}

/***/ }),

/***/ "./src/js/function/randomId.js":
/*!*************************************!*\
  !*** ./src/js/function/randomId.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ randomId)
/* harmony export */ });
function randomId(length) {
  var result = '';
  var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  var charactersLength = characters.length;
  for (var i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
}

/***/ }),

/***/ "./src/js/function/slideDown.js":
/*!**************************************!*\
  !*** ./src/js/function/slideDown.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ slideDown)
/* harmony export */ });
/* eslint-disable no-unused-expressions */
function slideDown(target, duration = 500) {
  target.style.removeProperty('display');
  let display = window.getComputedStyle(target).display;
  if (display === 'none') display = 'block';
  target.style.display = display;
  let height = target.offsetHeight;
  target.style.overflow = 'hidden';
  target.style.height = 0;
  target.style.paddingTop = 0;
  target.style.paddingBottom = 0;
  target.style.marginTop = 0;
  target.style.marginBottom = 0;
  target.offsetHeight;
  target.style.boxSizing = 'border-box';
  target.style.transitionProperty = "height, margin, padding";
  target.style.transitionDuration = duration + 'ms';
  target.style.height = height + 'px';
  target.style.removeProperty('padding-top');
  target.style.removeProperty('padding-bottom');
  target.style.removeProperty('margin-top');
  target.style.removeProperty('margin-bottom');
  window.setTimeout(() => {
    target.style.removeProperty('height');
    target.style.removeProperty('overflow');
    target.style.removeProperty('transition-duration');
    target.style.removeProperty('transition-property');
  }, duration);
}

/***/ }),

/***/ "./src/js/function/slideToggle.js":
/*!****************************************!*\
  !*** ./src/js/function/slideToggle.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ slideToggle)
/* harmony export */ });
/* harmony import */ var _slideUp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./slideUp */ "./src/js/function/slideUp.js");
/* harmony import */ var _slideDown__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./slideDown */ "./src/js/function/slideDown.js");


function slideToggle(target, duration = 500) {
  if (window.getComputedStyle(target).display === 'none') {
    return (0,_slideUp__WEBPACK_IMPORTED_MODULE_0__["default"])(target, duration);
  } else {
    return (0,_slideDown__WEBPACK_IMPORTED_MODULE_1__["default"])(target, duration);
  }
}
;

/***/ }),

/***/ "./src/js/function/slideUp.js":
/*!************************************!*\
  !*** ./src/js/function/slideUp.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ slideUp)
/* harmony export */ });
/* eslint-disable no-unused-expressions */
function slideUp(target, duration = 500) {
  target.style.transitionProperty = 'height, margin, padding';
  target.style.transitionDuration = duration + 'ms';
  target.style.boxSizing = 'border-box';
  target.style.height = target.offsetHeight + 'px';
  target.offsetHeight;
  target.style.overflow = 'hidden';
  target.style.height = 0;
  target.style.paddingTop = 0;
  target.style.paddingBottom = 0;
  target.style.marginTop = 0;
  target.style.marginBottom = 0;
  window.setTimeout(() => {
    target.style.display = 'none';
    target.style.removeProperty('height');
    target.style.removeProperty('padding-top');
    target.style.removeProperty('padding-bottom');
    target.style.removeProperty('margin-top');
    target.style.removeProperty('margin-bottom');
    target.style.removeProperty('overflow');
    target.style.removeProperty('transition-duration');
    target.style.removeProperty('transition-property');
  }, duration);
}

/***/ }),

/***/ "./src/js/function/toMin.js":
/*!**********************************!*\
  !*** ./src/js/function/toMin.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toMin)
/* harmony export */ });
function toMin(input) {
  let value = input.split(':');
  let hour = parseInt(value[0]);
  let min = value[1] !== undefined ? parseInt(value[1]) : 0;
  let time = hour * 60 + min;
  return time;
}

/***/ }),

/***/ "./src/js/function/toTime.js":
/*!***********************************!*\
  !*** ./src/js/function/toTime.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toTime)
/* harmony export */ });
function toTime(totalMinutes) {
  const minutes = totalMinutes % 60;
  const hours = Math.floor(totalMinutes / 60);
  return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
}

/***/ }),

/***/ "./src/js/function/toTwelve.js":
/*!*************************************!*\
  !*** ./src/js/function/toTwelve.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toTwelve)
/* harmony export */ });
function toTwelve(time) {
  time = time.toString().match(/^([01]\d|2[0-3])(:)([0-5]\d)(:[0-5]\d)?$/) || [time];
  if (time.length > 1) {
    time = time.slice(1);
    time.pop();
    time[5] = +time[0] < 12 ? ' AM' : ' PM'; // Set AM/PM
    time[0] = +time[0] % 12 || 12;
  }
  time = time.join('');
  return time;
}

/***/ }),

/***/ "./src/js/function/today.js":
/*!**********************************!*\
  !*** ./src/js/function/today.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ today)
/* harmony export */ });
function today() {
  let today = new Date();
  let dd = String(today.getDate()).padStart(2, '0');
  let mm = String(today.getMonth() + 1).padStart(2, '0');
  let yyyy = today.getFullYear();
  return yyyy + '-' + mm + '-' + dd;
}

/***/ }),

/***/ "./src/js/function/yesterday.js":
/*!**************************************!*\
  !*** ./src/js/function/yesterday.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ yesterday)
/* harmony export */ });
function yesterday() {
  let today = new Date();
  let yesterday = new Date(today);
  yesterday.setDate(today.getDate() - 1);
  let y_dd = String(yesterday.getDate()).padStart(2, '0');
  let y_mm = String(yesterday.getMonth() + 1).padStart(2, '0');
  let y_yyyy = yesterday.getFullYear();
  return y_yyyy + '-' + y_mm + '-' + y_dd;
}

/***/ }),

/***/ "./src/css/app.css":
/*!*************************!*\
  !*** ./src/css/app.css ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/lodash-es/_Symbol.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/_Symbol.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");


/** Built-in value references. */
var Symbol = _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].Symbol;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Symbol);

/***/ }),

/***/ "./node_modules/lodash-es/_baseGetTag.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_baseGetTag.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Symbol.js */ "./node_modules/lodash-es/_Symbol.js");
/* harmony import */ var _getRawTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getRawTag.js */ "./node_modules/lodash-es/_getRawTag.js");
/* harmony import */ var _objectToString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_objectToString.js */ "./node_modules/lodash-es/_objectToString.js");




/** `Object#toString` result references. */
var nullTag = '[object Null]',
  undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? (0,_getRawTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) : (0,_objectToString_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseGetTag);

/***/ }),

/***/ "./node_modules/lodash-es/_baseTrim.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_baseTrim.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _trimmedEndIndex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_trimmedEndIndex.js */ "./node_modules/lodash-es/_trimmedEndIndex.js");


/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string ? string.slice(0, (0,_trimmedEndIndex_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string) + 1).replace(reTrimStart, '') : string;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseTrim);

/***/ }),

/***/ "./node_modules/lodash-es/_freeGlobal.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_freeGlobal.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (freeGlobal);

/***/ }),

/***/ "./node_modules/lodash-es/_getRawTag.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_getRawTag.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Symbol.js */ "./node_modules/lodash-es/_Symbol.js");


/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
    tag = value[symToStringTag];
  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getRawTag);

/***/ }),

/***/ "./node_modules/lodash-es/_objectToString.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_objectToString.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (objectToString);

/***/ }),

/***/ "./node_modules/lodash-es/_root.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/_root.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_freeGlobal.js */ "./node_modules/lodash-es/_freeGlobal.js");


/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__["default"] || freeSelf || Function('return this')();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (root);

/***/ }),

/***/ "./node_modules/lodash-es/_trimmedEndIndex.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_trimmedEndIndex.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (trimmedEndIndex);

/***/ }),

/***/ "./node_modules/lodash-es/debounce.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/debounce.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");
/* harmony import */ var _now_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./now.js */ "./node_modules/lodash-es/now.js");
/* harmony import */ var _toNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toNumber.js */ "./node_modules/lodash-es/toNumber.js");




/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
  nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
    lastThis,
    maxWait,
    result,
    timerId,
    lastCallTime,
    lastInvokeTime = 0,
    leading = false,
    maxing = false,
    trailing = true;
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = (0,_toNumber_js__WEBPACK_IMPORTED_MODULE_0__["default"])(wait) || 0;
  if ((0,_isObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax((0,_toNumber_js__WEBPACK_IMPORTED_MODULE_0__["default"])(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs,
      thisArg = lastThis;
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
      timeSinceLastInvoke = time - lastInvokeTime,
      timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
      timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = (0,_now_js__WEBPACK_IMPORTED_MODULE_2__["default"])();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }
  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }
  function flush() {
    return timerId === undefined ? result : trailingEdge((0,_now_js__WEBPACK_IMPORTED_MODULE_2__["default"])());
  }
  function debounced() {
    var time = (0,_now_js__WEBPACK_IMPORTED_MODULE_2__["default"])(),
      isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (debounce);

/***/ }),

/***/ "./node_modules/lodash-es/isObject.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isObject.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isObject);

/***/ }),

/***/ "./node_modules/lodash-es/isObjectLike.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/isObjectLike.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isObjectLike);

/***/ }),

/***/ "./node_modules/lodash-es/isSymbol.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isSymbol.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js");
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js");



/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' || (0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) == symbolTag;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isSymbol);

/***/ }),

/***/ "./node_modules/lodash-es/now.js":
/*!***************************************!*\
  !*** ./node_modules/lodash-es/now.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");


/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function () {
  return _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].Date.now();
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (now);

/***/ }),

/***/ "./node_modules/lodash-es/throttle.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/throttle.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _debounce_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./debounce.js */ "./node_modules/lodash-es/debounce.js");
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");



/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
    trailing = true;
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if ((0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return (0,_debounce_js__WEBPACK_IMPORTED_MODULE_1__["default"])(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (throttle);

/***/ }),

/***/ "./node_modules/lodash-es/toNumber.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/toNumber.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseTrim_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseTrim.js */ "./node_modules/lodash-es/_baseTrim.js");
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isSymbol.js */ "./node_modules/lodash-es/isSymbol.js");




/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if ((0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
    return NAN;
  }
  if ((0,_isObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = (0,_isObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(other) ? other + '' : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = (0,_baseTrim_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toNumber);

/***/ }),

/***/ "./node_modules/vanillajs-datepicker/js/DateRangePicker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vanillajs-datepicker/js/DateRangePicker.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DateRangePicker)
/* harmony export */ });
/* harmony import */ var _lib_event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/event.js */ "./node_modules/vanillajs-datepicker/js/lib/event.js");
/* harmony import */ var _lib_date_format_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/date-format.js */ "./node_modules/vanillajs-datepicker/js/lib/date-format.js");
/* harmony import */ var _Datepicker_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Datepicker.js */ "./node_modules/vanillajs-datepicker/js/Datepicker.js");




// filter out the config options inapproprite to pass to Datepicker
function filterOptions(options) {
  const newOpts = Object.assign({}, options);
  delete newOpts.inputs;
  delete newOpts.allowOneSidedRange;
  delete newOpts.maxNumberOfDates; // to ensure each datepicker handles a single date

  return newOpts;
}
function setupDatepicker(rangepicker, changeDateListener, el, options) {
  (0,_lib_event_js__WEBPACK_IMPORTED_MODULE_0__.registerListeners)(rangepicker, [[el, 'changeDate', changeDateListener]]);
  new _Datepicker_js__WEBPACK_IMPORTED_MODULE_2__["default"](el, options, rangepicker);
}
function onChangeDate(rangepicker, ev) {
  // to prevent both datepickers trigger the other side's update each other
  if (rangepicker._updating) {
    return;
  }
  rangepicker._updating = true;
  const target = ev.target;
  if (target.datepicker === undefined) {
    return;
  }
  const datepickers = rangepicker.datepickers;
  const [datepicker0, datepicker1] = datepickers;
  const setDateOptions = {
    render: false
  };
  const changedSide = rangepicker.inputs.indexOf(target);
  const otherSide = changedSide === 0 ? 1 : 0;
  const changedDate = datepickers[changedSide].dates[0];
  const otherDate = datepickers[otherSide].dates[0];
  if (changedDate !== undefined && otherDate !== undefined) {
    // if the start of the range > the end, swap them
    if (changedSide === 0 && changedDate > otherDate) {
      datepicker0.setDate(otherDate, setDateOptions);
      datepicker1.setDate(changedDate, setDateOptions);
    } else if (changedSide === 1 && changedDate < otherDate) {
      datepicker0.setDate(changedDate, setDateOptions);
      datepicker1.setDate(otherDate, setDateOptions);
    }
  } else if (!rangepicker.allowOneSidedRange) {
    // to prevent the range from becoming one-sided, copy changed side's
    // selection (no matter if it's empty) to the other side
    if (changedDate !== undefined || otherDate !== undefined) {
      setDateOptions.clear = true;
      datepickers[otherSide].setDate(datepickers[changedSide].dates, setDateOptions);
    }
  }
  datepickers.forEach(datepicker => {
    datepicker.picker.update().render();
  });
  delete rangepicker._updating;
}

/**
 * Class representing a date range picker
 */
class DateRangePicker {
  /**
   * Create a date range picker
   * @param  {Element} element - element to bind a date range picker
   * @param  {Object} [options] - config options
   */
  constructor(element, options = {}) {
    let inputs = Array.isArray(options.inputs) ? options.inputs : Array.from(element.querySelectorAll('input'));
    if (inputs.length < 2) {
      return;
    }
    element.rangepicker = this;
    this.element = element;
    this.inputs = inputs = inputs.slice(0, 2);
    Object.freeze(inputs);
    this.allowOneSidedRange = !!options.allowOneSidedRange;
    const changeDateListener = onChangeDate.bind(null, this);
    const cleanOptions = filterOptions(options);
    // in order for initial date setup to work right when pcicLvel > 0,
    // let Datepicker constructor add the instance to the rangepicker
    const datepickers = this.datepickers = [];
    inputs.forEach(input => {
      setupDatepicker(this, changeDateListener, input, cleanOptions);
    });
    Object.freeze(datepickers);
    Object.defineProperty(this, 'dates', {
      get() {
        return datepickers.map(datepicker => datepicker.dates[0]);
      }
    });
    // normalize the range if inital dates are given
    if (datepickers[0].dates.length > 0) {
      onChangeDate(this, {
        target: inputs[0]
      });
    } else if (datepickers[1].dates.length > 0) {
      onChangeDate(this, {
        target: inputs[1]
      });
    }
  }

  /**
   * Set new values to the config options
   * @param {Object} options - config options to update
   */
  setOptions(options) {
    this.allowOneSidedRange = !!options.allowOneSidedRange;
    const cleanOptions = filterOptions(options);
    this.datepickers.forEach(datepicker => {
      datepicker.setOptions(cleanOptions);
    });
  }

  /**
   * Destroy the DateRangePicker instance
   * @return {DateRangePicker} - the instance destroyed
   */
  destroy() {
    this.datepickers.forEach(datepicker => {
      datepicker.destroy();
    });
    (0,_lib_event_js__WEBPACK_IMPORTED_MODULE_0__.unregisterListeners)(this);
    delete this.element.rangepicker;
  }

  /**
   * Get the start and end dates of the date range
   *
   * The method returns Date objects by default. If format string is passed,
   * it returns date strings formatted in given format.
   * The result array always contains 2 items (start date/end date) and
   * undefined is used for unselected side. (e.g. If none is selected,
   * the result will be [undefined, undefined]. If only the end date is set
   * when allowOneSidedRange config option is true, [undefined, endDate] will
   * be returned.)
   *
   * @param  {String} [format] - Format string to stringify the dates
   * @return {Array} - Start and end dates
   */
  getDates(format = undefined) {
    const callback = format ? date => (0,_lib_date_format_js__WEBPACK_IMPORTED_MODULE_1__.formatDate)(date, format, this.datepickers[0].config.locale) : date => new Date(date);
    return this.dates.map(date => date === undefined ? date : callback(date));
  }

  /**
   * Set the start and end dates of the date range
   *
   * The method calls datepicker.setDate() internally using each of the
   * arguments in start→end order.
   *
   * When a clear: true option object is passed instead of a date, the method
   * clears the date.
   *
   * If an invalid date, the same date as the current one or an option object
   * without clear: true is passed, the method considers that argument as an
   * "ineffective" argument because calling datepicker.setDate() with those
   * values makes no changes to the date selection.
   *
   * When the allowOneSidedRange config option is false, passing {clear: true}
   * to clear the range works only when it is done to the last effective
   * argument (in other words, passed to rangeEnd or to rangeStart along with
   * ineffective rangeEnd). This is because when the date range is changed,
   * it gets normalized based on the last change at the end of the changing
   * process.
   *
   * @param {Date|Number|String|Object} rangeStart - Start date of the range
   * or {clear: true} to clear the date
   * @param {Date|Number|String|Object} rangeEnd - End date of the range
   * or {clear: true} to clear the date
   */
  setDates(rangeStart, rangeEnd) {
    const {
      datepickers: [datepicker0, datepicker1],
      inputs: [input0, input1],
      dates: [origDate0, origDate1]
    } = this;

    // If range normalization runs on every change, we can't set a new range
    // that starts after the end of the current range correctly because the
    // normalization process swaps start↔︎end right after setting the new start
    // date. To prevent this, the normalization process needs to run once after
    // both of the new dates are set.
    this._updating = true;
    datepicker0.setDate(rangeStart);
    datepicker1.setDate(rangeEnd);
    delete this._updating;
    if (datepicker1.dates[0] !== origDate1) {
      onChangeDate(this, {
        target: input1
      });
    } else if (datepicker0.dates[0] !== origDate0) {
      onChangeDate(this, {
        target: input0
      });
    }
  }
}

/***/ }),

/***/ "./node_modules/vanillajs-datepicker/js/Datepicker.js":
/*!************************************************************!*\
  !*** ./node_modules/vanillajs-datepicker/js/Datepicker.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Datepicker)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/utils.js */ "./node_modules/vanillajs-datepicker/js/lib/utils.js");
/* harmony import */ var _lib_date_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/date.js */ "./node_modules/vanillajs-datepicker/js/lib/date.js");
/* harmony import */ var _lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/date-format.js */ "./node_modules/vanillajs-datepicker/js/lib/date-format.js");
/* harmony import */ var _lib_dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/dom.js */ "./node_modules/vanillajs-datepicker/js/lib/dom.js");
/* harmony import */ var _lib_event_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/event.js */ "./node_modules/vanillajs-datepicker/js/lib/event.js");
/* harmony import */ var _i18n_base_locales_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./i18n/base-locales.js */ "./node_modules/vanillajs-datepicker/js/i18n/base-locales.js");
/* harmony import */ var _options_defaultOptions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./options/defaultOptions.js */ "./node_modules/vanillajs-datepicker/js/options/defaultOptions.js");
/* harmony import */ var _options_processOptions_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./options/processOptions.js */ "./node_modules/vanillajs-datepicker/js/options/processOptions.js");
/* harmony import */ var _options_shortcutKeys_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./options/shortcutKeys.js */ "./node_modules/vanillajs-datepicker/js/options/shortcutKeys.js");
/* harmony import */ var _picker_Picker_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./picker/Picker.js */ "./node_modules/vanillajs-datepicker/js/picker/Picker.js");
/* harmony import */ var _events_functions_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./events/functions.js */ "./node_modules/vanillajs-datepicker/js/events/functions.js");
/* harmony import */ var _events_elementListeners_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./events/elementListeners.js */ "./node_modules/vanillajs-datepicker/js/events/elementListeners.js");
/* harmony import */ var _events_otherListeners_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./events/otherListeners.js */ "./node_modules/vanillajs-datepicker/js/events/otherListeners.js");













function stringifyDates(dates, config) {
  return dates.map(dt => (0,_lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__.formatDate)(dt, config.format, config.locale)).join(config.dateDelimiter);
}

// parse input dates and create an array of time values for selection
// returns undefined if there are no valid dates in inputDates
// when origDates (current selection) is passed, the function works to mix
// the input dates into the current selection
function processInputDates(datepicker, inputDates, clear = false) {
  if (inputDates.length === 0) {
    // empty input is considered valid unless origiDates is passed
    return clear ? [] : undefined;
  }
  const {
    config,
    dates: origDates,
    rangeSideIndex
  } = datepicker;
  const {
    pickLevel,
    maxNumberOfDates
  } = config;
  let newDates = inputDates.reduce((dates, dt) => {
    let date = (0,_lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__.parseDate)(dt, config.format, config.locale);
    if (date === undefined) {
      return dates;
    }
    // adjust to 1st of the month/Jan 1st of the year
    // or to the last day of the monh/Dec 31st of the year if the datepicker
    // is the range-end picker of a rangepicker
    date = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.regularizeDate)(date, pickLevel, rangeSideIndex);
    if ((0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.isInRange)(date, config.minDate, config.maxDate) && !dates.includes(date) && !config.checkDisabled(date, pickLevel) && (pickLevel > 0 || !config.daysOfWeekDisabled.includes(new Date(date).getDay()))) {
      dates.push(date);
    }
    return dates;
  }, []);
  if (newDates.length === 0) {
    return;
  }
  if (config.multidate && !clear) {
    // get the synmetric difference between origDates and newDates
    newDates = newDates.reduce((dates, date) => {
      if (!origDates.includes(date)) {
        dates.push(date);
      }
      return dates;
    }, origDates.filter(date => !newDates.includes(date)));
  }
  // do length check always because user can input multiple dates regardless of the mode
  return maxNumberOfDates && newDates.length > maxNumberOfDates ? newDates.slice(maxNumberOfDates * -1) : newDates;
}

// refresh the UI elements
// modes: 1: input only, 2, picker only, 3 both
function refreshUI(datepicker, mode = 3, quickRender = true, viewDate = undefined) {
  const {
    config,
    picker,
    inputField
  } = datepicker;
  if (mode & 2) {
    const newView = picker.active ? config.pickLevel : config.startView;
    picker.update(viewDate).changeView(newView).render(quickRender);
  }
  if (mode & 1 && inputField) {
    inputField.value = stringifyDates(datepicker.dates, config);
  }
}
function setDate(datepicker, inputDates, options) {
  const config = datepicker.config;
  let {
    clear,
    render,
    autohide,
    revert,
    forceRefresh,
    viewDate
  } = options;
  if (render === undefined) {
    render = true;
  }
  if (!render) {
    autohide = forceRefresh = false;
  } else if (autohide === undefined) {
    autohide = config.autohide;
  }
  viewDate = (0,_lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__.parseDate)(viewDate, config.format, config.locale);
  const newDates = processInputDates(datepicker, inputDates, clear);
  if (!newDates && !revert) {
    return;
  }
  if (newDates && newDates.toString() !== datepicker.dates.toString()) {
    datepicker.dates = newDates;
    refreshUI(datepicker, render ? 3 : 1, true, viewDate);
    (0,_events_functions_js__WEBPACK_IMPORTED_MODULE_10__.triggerDatepickerEvent)(datepicker, 'changeDate');
  } else {
    refreshUI(datepicker, forceRefresh ? 3 : 1, true, viewDate);
  }
  if (autohide) {
    datepicker.hide();
  }
}
function getOutputConverter(datepicker, format) {
  return format ? date => (0,_lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__.formatDate)(date, format, datepicker.config.locale) : date => new Date(date);
}

/**
 * Class representing a date picker
 */
class Datepicker {
  /**
   * Create a date picker
   * @param  {Element} element - element to bind a date picker
   * @param  {Object} [options] - config options
   * @param  {DateRangePicker} [rangepicker] - DateRangePicker instance the
   * date picker belongs to. Use this only when creating date picker as a part
   * of date range picker
   */
  constructor(element, options = {}, rangepicker = undefined) {
    element.datepicker = this;
    this.element = element;
    this.dates = [];

    // initialize config
    const config = this.config = Object.assign({
      buttonClass: options.buttonClass && String(options.buttonClass) || 'button',
      container: null,
      defaultViewDate: (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.today)(),
      maxDate: undefined,
      minDate: undefined
    }, (0,_options_processOptions_js__WEBPACK_IMPORTED_MODULE_7__["default"])(_options_defaultOptions_js__WEBPACK_IMPORTED_MODULE_6__["default"], this));

    // configure by type
    let inputField;
    if (element.tagName === 'INPUT') {
      inputField = this.inputField = element;
      inputField.classList.add('datepicker-input');
      if (options.container) {
        // omit string type check because it doesn't guarantee to avoid errors
        // (invalid selector string causes abend with sytax error)
        config.container = options.container instanceof HTMLElement ? options.container : document.querySelector(options.container);
      }
    } else {
      config.container = element;
    }
    if (rangepicker) {
      // check validiry
      const index = rangepicker.inputs.indexOf(inputField);
      const datepickers = rangepicker.datepickers;
      if (index < 0 || index > 1 || !Array.isArray(datepickers)) {
        throw Error('Invalid rangepicker object.');
      }
      // attach itaelf to the rangepicker here so that processInputDates() can
      // determine if this is the range-end picker of the rangepicker while
      // setting inital values when pickLevel > 0
      datepickers[index] = this;
      this.rangepicker = rangepicker;
      this.rangeSideIndex = index;
    }

    // set up config
    this._options = options;
    Object.assign(config, (0,_options_processOptions_js__WEBPACK_IMPORTED_MODULE_7__["default"])(options, this));
    config.shortcutKeys = (0,_options_shortcutKeys_js__WEBPACK_IMPORTED_MODULE_8__["default"])(options.shortcutKeys || {});

    // process initial value
    const initialDates = (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.stringToArray)(element.value || element.dataset.date, config.dateDelimiter);
    delete element.dataset.date;
    const inputDateValues = processInputDates(this, initialDates);
    if (inputDateValues && inputDateValues.length > 0) {
      this.dates = inputDateValues;
    }
    if (inputField) {
      inputField.value = stringifyDates(this.dates, config);
    }

    // set up picekr element
    const picker = this.picker = new _picker_Picker_js__WEBPACK_IMPORTED_MODULE_9__["default"](this);
    const keydownListener = [element, 'keydown', _events_elementListeners_js__WEBPACK_IMPORTED_MODULE_11__.onKeydown.bind(null, this)];
    if (inputField) {
      (0,_lib_event_js__WEBPACK_IMPORTED_MODULE_4__.registerListeners)(this, [keydownListener, [inputField, 'focus', _events_elementListeners_js__WEBPACK_IMPORTED_MODULE_11__.onFocus.bind(null, this)], [inputField, 'mousedown', _events_elementListeners_js__WEBPACK_IMPORTED_MODULE_11__.onMousedown.bind(null, this)], [inputField, 'click', _events_elementListeners_js__WEBPACK_IMPORTED_MODULE_11__.onClickInput.bind(null, this)], [inputField, 'paste', _events_elementListeners_js__WEBPACK_IMPORTED_MODULE_11__.onPaste.bind(null, this)],
      // To detect a click on outside, just listening to mousedown is enough,
      // no need to listen to touchstart.
      // Actually, listening to touchstart can be a problem because, while
      // mousedown is fired only on tapping but not on swiping/pinching,
      // touchstart is fired on swiping/pinching as well.
      // (issue #95)
      [document, 'mousedown', _events_otherListeners_js__WEBPACK_IMPORTED_MODULE_12__.onClickOutside.bind(null, this)], [window, 'resize', picker.place.bind(picker)]]);
    } else {
      (0,_lib_event_js__WEBPACK_IMPORTED_MODULE_4__.registerListeners)(this, [keydownListener]);
      this.show();
    }
  }

  /**
   * Format Date object or time value in given format and language
   * @param  {Date|Number} date - date or time value to format
   * @param  {String|Object} format - format string or object that contains
   * toDisplay() custom formatter, whose signature is
   * - args:
   *   - date: {Date} - Date instance of the date passed to the method
   *   - format: {Object} - the format object passed to the method
   *   - locale: {Object} - locale for the language specified by `lang`
   * - return:
   *     {String} formatted date
   * @param  {String} [lang=en] - language code for the locale to use
   * @return {String} formatted date
   */
  static formatDate(date, format, lang) {
    return (0,_lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__.formatDate)(date, format, lang && _i18n_base_locales_js__WEBPACK_IMPORTED_MODULE_5__["default"][lang] || _i18n_base_locales_js__WEBPACK_IMPORTED_MODULE_5__["default"].en);
  }

  /**
   * Parse date string
   * @param  {String|Date|Number} dateStr - date string, Date object or time
   * value to parse
   * @param  {String|Object} format - format string or object that contains
   * toValue() custom parser, whose signature is
   * - args:
   *   - dateStr: {String|Date|Number} - the dateStr passed to the method
   *   - format: {Object} - the format object passed to the method
   *   - locale: {Object} - locale for the language specified by `lang`
   * - return:
   *     {Date|Number} parsed date or its time value
   * @param  {String} [lang=en] - language code for the locale to use
   * @return {Number} time value of parsed date
   */
  static parseDate(dateStr, format, lang) {
    return (0,_lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__.parseDate)(dateStr, format, lang && _i18n_base_locales_js__WEBPACK_IMPORTED_MODULE_5__["default"][lang] || _i18n_base_locales_js__WEBPACK_IMPORTED_MODULE_5__["default"].en);
  }

  /**
   * @type {Object} - Installed locales in `[languageCode]: localeObject` format
   * en`:_English (US)_ is pre-installed.
   */
  static get locales() {
    return _i18n_base_locales_js__WEBPACK_IMPORTED_MODULE_5__["default"];
  }

  /**
   * @type {Boolean} - Whether the picker element is shown. `true` whne shown
   */
  get active() {
    return !!(this.picker && this.picker.active);
  }

  /**
   * @type {HTMLDivElement} - DOM object of picker element
   */
  get pickerElement() {
    return this.picker ? this.picker.element : undefined;
  }

  /**
   * Set new values to the config options
   * @param {Object} options - config options to update
   */
  setOptions(options) {
    const newOptions = (0,_options_processOptions_js__WEBPACK_IMPORTED_MODULE_7__["default"])(options, this);
    Object.assign(this._options, options);
    Object.assign(this.config, newOptions);
    this.picker.setOptions(newOptions);
    refreshUI(this, 3);
  }

  /**
   * Show the picker element
   */
  show() {
    if (this.inputField) {
      const {
        config,
        inputField
      } = this;
      if (inputField.disabled || inputField.readOnly && !config.enableOnReadonly) {
        return;
      }
      if (!(0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_3__.isActiveElement)(inputField) && !config.disableTouchKeyboard) {
        this._showing = true;
        inputField.focus();
        delete this._showing;
      }
    }
    this.picker.show();
  }

  /**
   * Hide the picker element
   * Not available on inline picker
   */
  hide() {
    if (!this.inputField) {
      return;
    }
    this.picker.hide();
    this.picker.update().changeView(this.config.startView).render();
  }

  /**
   * Toggle the display of the picker element
   * Not available on inline picker
   *
   * Unlike hide(), the picker does not return to the start view when hiding.
   */
  toggle() {
    if (!this.picker.active) {
      this.show();
    } else if (this.inputField) {
      this.picker.hide();
    }
  }

  /**
   * Destroy the Datepicker instance
   * @return {Detepicker} - the instance destroyed
   */
  destroy() {
    this.hide();
    (0,_lib_event_js__WEBPACK_IMPORTED_MODULE_4__.unregisterListeners)(this);
    this.picker.detach();
    const element = this.element;
    element.classList.remove('datepicker-input');
    delete element.datepicker;
    return this;
  }

  /**
   * Get the selected date(s)
   *
   * The method returns a Date object of selected date by default, and returns
   * an array of selected dates in multidate mode. If format string is passed,
   * it returns date string(s) formatted in given format.
   *
   * @param  {String} [format] - format string to stringify the date(s)
   * @return {Date|String|Date[]|String[]} - selected date(s), or if none is
   * selected, empty array in multidate mode and undefined in sigledate mode
   */
  getDate(format = undefined) {
    const callback = getOutputConverter(this, format);
    if (this.config.multidate) {
      return this.dates.map(callback);
    }
    if (this.dates.length > 0) {
      return callback(this.dates[0]);
    }
  }

  /**
   * Set selected date(s)
   *
   * In multidate mode, you can pass multiple dates as a series of arguments
   * or an array. (Since each date is parsed individually, the type of the
   * dates doesn't have to be the same.)
   * The given dates are used to toggle the select status of each date. The
   * number of selected dates is kept from exceeding the length set to
   * maxNumberOfDates.
   *
   * With clear: true option, the method can be used to clear the selection
   * and to replace the selection instead of toggling in multidate mode.
   * If the option is passed with no date arguments or an empty dates array,
   * it works as "clear" (clear the selection then set nothing), and if the
   * option is passed with new dates to select, it works as "replace" (clear
   * the selection then set the given dates)
   *
   * When render: false option is used, the method omits re-rendering the
   * picker element. In this case, you need to call refresh() method later in
   * order for the picker element to reflect the changes. The input field is
   * refreshed always regardless of this option.
   *
   * When invalid (unparsable, repeated, disabled or out-of-range) dates are
   * passed, the method ignores them and applies only valid ones. In the case
   * that all the given dates are invalid, which is distinguished from passing
   * no dates, the method considers it as an error and leaves the selection
   * untouched. (The input field also remains untouched unless revert: true
   * option is used.)
   * Replacing the selection with the same date(s) also causes a similar
   * situation. In both cases, the method does not refresh the picker element
   * unless forceRefresh: true option is used.
   *
   * If viewDate option is used, the method changes the focused date to the
   * specified date instead of the last item of the selection.
   *
   * @param {...(Date|Number|String)|Array} [dates] - Date strings, Date
   * objects, time values or mix of those for new selection
   * @param {Object} [options] - function options
   * - clear: {boolean} - Whether to clear the existing selection
   *     defualt: false
   * - render: {boolean} - Whether to re-render the picker element
   *     default: true
   * - autohide: {boolean} - Whether to hide the picker element after re-render
   *     Ignored when used with render: false
   *     default: config.autohide
   * - revert: {boolean} - Whether to refresh the input field when all the
   *     passed dates are invalid
   *     default: false
   * - forceRefresh: {boolean} - Whether to refresh the picker element when
   *     passed dates don't change the existing selection
   *     default: false
   * - viewDate: {Date|Number|String} - Date to be focused after setiing date(s)
   *     default: The last item of the resulting selection, or defaultViewDate
   *     config option if none is selected
   */
  setDate(...args) {
    const dates = [...args];
    const opts = {};
    const lastArg = (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.lastItemOf)(args);
    if (lastArg && typeof lastArg === 'object' && !Array.isArray(lastArg) && !(lastArg instanceof Date)) {
      Object.assign(opts, dates.pop());
    }
    const inputDates = Array.isArray(dates[0]) ? dates[0] : dates;
    setDate(this, inputDates, opts);
  }

  /**
   * Update the selected date(s) with input field's value
   * Not available on inline picker
   *
   * The input field will be refreshed with properly formatted date string.
   *
   * In the case that all the entered dates are invalid (unparsable, repeated,
   * disabled or out-of-range), which is distinguished from empty input field,
   * the method leaves the input field untouched as well as the selection by
   * default. If revert: true option is used in this case, the input field is
   * refreshed with the existing selection.
   * The method also doesn't refresh the picker element in this case and when
   * the entered dates are the same as the existing selection. If
   * forceRefresh: true option is used, the picker element is refreshed in
   * these cases too.
   *
   * @param  {Object} [options] - function options
   * - autohide: {boolean} - whether to hide the picker element after refresh
   *     default: false
   * - revert: {boolean} - Whether to refresh the input field when all the
   *     passed dates are invalid
   *     default: false
   * - forceRefresh: {boolean} - Whether to refresh the picer element when
   *     input field's value doesn't change the existing selection
   *     default: false
   */
  update(options = undefined) {
    if (!this.inputField) {
      return;
    }
    const opts = Object.assign(options || {}, {
      clear: true,
      render: true,
      viewDate: undefined
    });
    const inputDates = (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.stringToArray)(this.inputField.value, this.config.dateDelimiter);
    setDate(this, inputDates, opts);
  }

  /**
   * Get the focused date
   *
   * The method returns a Date object of focused date by default. If format
   * string is passed, it returns date string formatted in given format.
   *
   * @param  {String} [format] - format string to stringify the date
   * @return {Date|String} - focused date (viewDate)
   */
  getFocusedDate(format = undefined) {
    return getOutputConverter(this, format)(this.picker.viewDate);
  }

  /**
   * Set focused date
   *
   * By default, the method updates the focus on the view shown at the time,
   * or the one set to the startView config option if the picker is hidden.
   * When resetView: true is passed, the view displayed is changed to the
   * pickLevel config option's if the picker is shown.
   *
   * @param {Date|Number|String} viewDate - date string, Date object, time
   * values of the date to focus
   * @param {Boolean} [resetView] - whether to change the view to pickLevel
   * config option's when the picker is shown. Ignored when the picker is
   * hidden
   */
  setFocusedDate(viewDate, resetView = false) {
    const {
      config,
      picker,
      active,
      rangeSideIndex
    } = this;
    const pickLevel = config.pickLevel;
    const newViewDate = (0,_lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__.parseDate)(viewDate, config.format, config.locale);
    if (newViewDate === undefined) {
      return;
    }
    picker.changeFocus((0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.regularizeDate)(newViewDate, pickLevel, rangeSideIndex));
    if (active && resetView) {
      picker.changeView(pickLevel);
    }
    picker.render();
  }

  /**
   * Refresh the picker element and the associated input field
   * @param {String} [target] - target item when refreshing one item only
   * 'picker' or 'input'
   * @param {Boolean} [forceRender] - whether to re-render the picker element
   * regardless of its state instead of optimized refresh
   */
  refresh(target = undefined, forceRender = false) {
    if (target && typeof target !== 'string') {
      forceRender = target;
      target = undefined;
    }
    let mode;
    if (target === 'picker') {
      mode = 2;
    } else if (target === 'input') {
      mode = 1;
    } else {
      mode = 3;
    }
    refreshUI(this, mode, !forceRender);
  }

  /**
   * Enter edit mode
   * Not available on inline picker or when the picker element is hidden
   */
  enterEditMode() {
    const inputField = this.inputField;
    if (!inputField || inputField.readOnly || !this.picker.active || this.editMode) {
      return;
    }
    this.editMode = true;
    inputField.classList.add('in-edit');
  }

  /**
   * Exit from edit mode
   * Not available on inline picker
   * @param  {Object} [options] - function options
   * - update: {boolean} - whether to call update() after exiting
   *     If false, input field is revert to the existing selection
   *     default: false
   */
  exitEditMode(options = undefined) {
    if (!this.inputField || !this.editMode) {
      return;
    }
    const opts = Object.assign({
      update: false
    }, options);
    delete this.editMode;
    this.inputField.classList.remove('in-edit');
    if (opts.update) {
      this.update(opts);
    }
  }
}

/***/ }),

/***/ "./node_modules/vanillajs-datepicker/js/events/elementListeners.js":
/*!*************************************************************************!*\
  !*** ./node_modules/vanillajs-datepicker/js/events/elementListeners.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onClickInput: () => (/* binding */ onClickInput),
/* harmony export */   onFocus: () => (/* binding */ onFocus),
/* harmony export */   onKeydown: () => (/* binding */ onKeydown),
/* harmony export */   onMousedown: () => (/* binding */ onMousedown),
/* harmony export */   onPaste: () => (/* binding */ onPaste)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/utils.js */ "./node_modules/vanillajs-datepicker/js/lib/utils.js");
/* harmony import */ var _lib_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/dom.js */ "./node_modules/vanillajs-datepicker/js/lib/dom.js");
/* harmony import */ var _lib_date_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/date.js */ "./node_modules/vanillajs-datepicker/js/lib/date.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./functions.js */ "./node_modules/vanillajs-datepicker/js/events/functions.js");





// Find the closest date that doesn't meet the condition for unavailable date
// Returns undefined if no available date is found
// addFn: function to calculate the next date
//   - args: time value, amount
// increase: amount to pass to addFn
// testFn: function to test the unavailability of the date
//   - args: time value; return: true if unavailable
function findNextAvailableOne(date, addFn, increase, testFn, min, max) {
  if (!(0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.isInRange)(date, min, max)) {
    return;
  }
  if (testFn(date)) {
    const newDate = addFn(date, increase);
    return findNextAvailableOne(newDate, addFn, increase, testFn, min, max);
  }
  return date;
}

// direction: -1 (left/up), 1 (right/down)
// vertical: true for up/down, false for left/right
function moveByArrowKey(datepicker, direction, vertical) {
  const picker = datepicker.picker;
  const currentView = picker.currentView;
  const step = currentView.step || 1;
  let viewDate = picker.viewDate;
  let addFn;
  switch (currentView.id) {
    case 0:
      viewDate = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_2__.addDays)(viewDate, vertical ? direction * 7 : direction);
      addFn = _lib_date_js__WEBPACK_IMPORTED_MODULE_2__.addDays;
      break;
    case 1:
      viewDate = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_2__.addMonths)(viewDate, vertical ? direction * 4 : direction);
      addFn = _lib_date_js__WEBPACK_IMPORTED_MODULE_2__.addMonths;
      break;
    default:
      viewDate = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_2__.addYears)(viewDate, direction * (vertical ? 4 : 1) * step);
      addFn = _lib_date_js__WEBPACK_IMPORTED_MODULE_2__.addYears;
  }
  viewDate = findNextAvailableOne(viewDate, addFn, direction < 0 ? -step : step, date => currentView.disabled.includes(date), currentView.minDate, currentView.maxDate);
  if (viewDate !== undefined) {
    picker.changeFocus(viewDate).render();
  }
}
function onKeydown(datepicker, ev) {
  const {
    config,
    picker,
    editMode
  } = datepicker;
  const active = picker.active;
  const {
    key,
    altKey,
    shiftKey
  } = ev;
  const ctrlOrMetaKey = ev.ctrlKey || ev.metaKey;
  const cancelEvent = () => {
    ev.preventDefault();
    ev.stopPropagation();
  };

  // tab/enter keys should not be taken by shortcut keys
  if (key === 'Tab') {
    (0,_functions_js__WEBPACK_IMPORTED_MODULE_3__.unfocus)(datepicker);
    return;
  }
  if (key === 'Enter') {
    if (!active) {
      datepicker.update();
    } else if (editMode) {
      datepicker.exitEditMode({
        update: true,
        autohide: config.autohide
      });
    } else {
      const currentView = picker.currentView;
      if (currentView.isMinView) {
        datepicker.setDate(picker.viewDate);
      } else {
        picker.changeView(currentView.id - 1).render();
        cancelEvent();
      }
    }
    return;
  }
  const shortcutKeys = config.shortcutKeys;
  const keyInfo = {
    key,
    ctrlOrMetaKey,
    altKey,
    shiftKey
  };
  const shortcut = Object.keys(shortcutKeys).find(item => {
    const keyDef = shortcutKeys[item];
    return !Object.keys(keyDef).find(prop => keyDef[prop] !== keyInfo[prop]);
  });
  if (shortcut) {
    let action;
    if (shortcut === 'toggle') {
      action = shortcut;
    } else if (editMode) {
      if (shortcut === 'exitEditMode') {
        action = shortcut;
      }
    } else if (active) {
      if (shortcut === 'hide') {
        action = shortcut;
      } else if (shortcut === 'prevButton') {
        action = [_functions_js__WEBPACK_IMPORTED_MODULE_3__.goToPrevOrNext, [datepicker, -1]];
      } else if (shortcut === 'nextButton') {
        action = [_functions_js__WEBPACK_IMPORTED_MODULE_3__.goToPrevOrNext, [datepicker, 1]];
      } else if (shortcut === 'viewSwitch') {
        action = [_functions_js__WEBPACK_IMPORTED_MODULE_3__.switchView, [datepicker]];
      } else if (config.clearButton && shortcut === 'clearButton') {
        action = [_functions_js__WEBPACK_IMPORTED_MODULE_3__.clearSelection, [datepicker]];
      } else if (config.todayButton && shortcut === 'todayButton') {
        action = [_functions_js__WEBPACK_IMPORTED_MODULE_3__.goToOrSelectToday, [datepicker]];
      }
    } else if (shortcut === 'show') {
      action = shortcut;
    }
    if (action) {
      if (Array.isArray(action)) {
        action[0].apply(null, action[1]);
      } else {
        datepicker[action]();
      }
      cancelEvent();
      return;
    }
  }

  // perform as a regular <input> when picker in hidden or in edit mode
  if (!active || editMode) {
    return;
  }
  const handleArrowKeyPress = (direction, vertical) => {
    if (shiftKey || ctrlOrMetaKey || altKey) {
      datepicker.enterEditMode();
    } else {
      moveByArrowKey(datepicker, direction, vertical);
      ev.preventDefault();
    }
  };
  if (key === 'ArrowLeft') {
    handleArrowKeyPress(-1, false);
  } else if (key === 'ArrowRight') {
    handleArrowKeyPress(1, false);
  } else if (key === 'ArrowUp') {
    handleArrowKeyPress(-1, true);
  } else if (key === 'ArrowDown') {
    handleArrowKeyPress(1, true);
  } else if (key === 'Backspace' || key === 'Delete'
  // When autofill is performed, Chromium-based browsers trigger fake
  // keydown/keyup events that don't have the `key` property (on Edge,
  // keyup only) in addition to the input event. Therefore, we need to
  // check the existence of `key`'s value before checking the length.
  // (issue #144)
  || key && key.length === 1 && !ctrlOrMetaKey) {
    datepicker.enterEditMode();
  }
}
function onFocus(datepicker) {
  if (datepicker.config.showOnFocus && !datepicker._showing) {
    datepicker.show();
  }
}

// for the prevention for entering edit mode while getting focus on click
function onMousedown(datepicker, ev) {
  const el = ev.target;
  if (datepicker.picker.active || datepicker.config.showOnClick) {
    el._active = (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_1__.isActiveElement)(el);
    el._clicking = setTimeout(() => {
      delete el._active;
      delete el._clicking;
    }, 2000);
  }
}
function onClickInput(datepicker, ev) {
  const el = ev.target;
  if (!el._clicking) {
    return;
  }
  clearTimeout(el._clicking);
  delete el._clicking;
  if (el._active) {
    datepicker.enterEditMode();
  }
  delete el._active;
  if (datepicker.config.showOnClick) {
    datepicker.show();
  }
}
function onPaste(datepicker, ev) {
  if (ev.clipboardData.types.includes('text/plain')) {
    datepicker.enterEditMode();
  }
}

/***/ }),

/***/ "./node_modules/vanillajs-datepicker/js/events/functions.js":
/*!******************************************************************!*\
  !*** ./node_modules/vanillajs-datepicker/js/events/functions.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clearSelection: () => (/* binding */ clearSelection),
/* harmony export */   goToOrSelectToday: () => (/* binding */ goToOrSelectToday),
/* harmony export */   goToPrevOrNext: () => (/* binding */ goToPrevOrNext),
/* harmony export */   switchView: () => (/* binding */ switchView),
/* harmony export */   triggerDatepickerEvent: () => (/* binding */ triggerDatepickerEvent),
/* harmony export */   unfocus: () => (/* binding */ unfocus)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/utils.js */ "./node_modules/vanillajs-datepicker/js/lib/utils.js");
/* harmony import */ var _lib_date_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/date.js */ "./node_modules/vanillajs-datepicker/js/lib/date.js");
/* harmony import */ var _lib_dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/dom.js */ "./node_modules/vanillajs-datepicker/js/lib/dom.js");



function triggerDatepickerEvent(datepicker, type) {
  const options = {
    bubbles: true,
    cancelable: true,
    detail: {
      date: datepicker.getDate(),
      viewDate: new Date(datepicker.picker.viewDate),
      viewId: datepicker.picker.currentView.id,
      datepicker
    }
  };
  datepicker.element.dispatchEvent(new CustomEvent(type, options));
}

// direction: -1 (to previous), 1 (to next)
function goToPrevOrNext(datepicker, direction) {
  const {
    config,
    picker
  } = datepicker;
  const {
    currentView,
    viewDate
  } = picker;
  let newViewDate;
  switch (currentView.id) {
    case 0:
      newViewDate = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.addMonths)(viewDate, direction);
      break;
    case 1:
      newViewDate = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.addYears)(viewDate, direction);
      break;
    default:
      newViewDate = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.addYears)(viewDate, direction * currentView.navStep);
  }
  newViewDate = (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.limitToRange)(newViewDate, config.minDate, config.maxDate);
  picker.changeFocus(newViewDate).render();
}
function switchView(datepicker) {
  const viewId = datepicker.picker.currentView.id;
  if (viewId === datepicker.config.maxView) {
    return;
  }
  datepicker.picker.changeView(viewId + 1).render();
}
function clearSelection(datepicker) {
  datepicker.setDate({
    clear: true
  });
}
function goToOrSelectToday(datepicker) {
  const currentDate = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.today)();
  if (datepicker.config.todayButtonMode === 1) {
    datepicker.setDate(currentDate, {
      forceRefresh: true,
      viewDate: currentDate
    });
  } else {
    datepicker.setFocusedDate(currentDate, true);
  }
}
function unfocus(datepicker) {
  const onBlur = () => {
    if (datepicker.config.updateOnBlur) {
      datepicker.update({
        revert: true
      });
    } else {
      datepicker.refresh('input');
    }
    datepicker.hide();
  };
  const element = datepicker.element;
  if ((0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.isActiveElement)(element)) {
    element.addEventListener('blur', onBlur, {
      once: true
    });
  } else {
    onBlur();
  }
}

/***/ }),

/***/ "./node_modules/vanillajs-datepicker/js/events/otherListeners.js":
/*!***********************************************************************!*\
  !*** ./node_modules/vanillajs-datepicker/js/events/otherListeners.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onClickOutside: () => (/* binding */ onClickOutside)
/* harmony export */ });
/* harmony import */ var _lib_dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/dom.js */ "./node_modules/vanillajs-datepicker/js/lib/dom.js");
/* harmony import */ var _lib_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/event.js */ "./node_modules/vanillajs-datepicker/js/lib/event.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./functions.js */ "./node_modules/vanillajs-datepicker/js/events/functions.js");




// for the `document` to delegate the events from outside the picker/input field
function onClickOutside(datepicker, ev) {
  const {
    element,
    picker
  } = datepicker;
  // check both picker's and input's activeness to make updateOnBlur work in
  // the cases where...
  // - picker is hidden by ESC key press → input stays focused
  // - input is unfocused by closing mobile keyboard → piker is kept shown
  if (!picker.active && !(0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_0__.isActiveElement)(element)) {
    return;
  }
  const pickerElem = picker.element;
  if ((0,_lib_event_js__WEBPACK_IMPORTED_MODULE_1__.findElementInEventPath)(ev, el => el === element || el === pickerElem)) {
    return;
  }
  (0,_functions_js__WEBPACK_IMPORTED_MODULE_2__.unfocus)(datepicker);
}

/***/ }),

/***/ "./node_modules/vanillajs-datepicker/js/events/pickerListeners.js":
/*!************************************************************************!*\
  !*** ./node_modules/vanillajs-datepicker/js/events/pickerListeners.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onClickNextButton: () => (/* binding */ onClickNextButton),
/* harmony export */   onClickPrevButton: () => (/* binding */ onClickPrevButton),
/* harmony export */   onClickView: () => (/* binding */ onClickView),
/* harmony export */   onClickViewSwitch: () => (/* binding */ onClickViewSwitch),
/* harmony export */   onMousedownPicker: () => (/* binding */ onMousedownPicker)
/* harmony export */ });
/* harmony import */ var _lib_date_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/date.js */ "./node_modules/vanillajs-datepicker/js/lib/date.js");
/* harmony import */ var _lib_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/event.js */ "./node_modules/vanillajs-datepicker/js/lib/event.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./functions.js */ "./node_modules/vanillajs-datepicker/js/events/functions.js");



function goToSelectedMonthOrYear(datepicker, selection) {
  const picker = datepicker.picker;
  const viewDate = new Date(picker.viewDate);
  const viewId = picker.currentView.id;
  const newDate = viewId === 1 ? (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_0__.addMonths)(viewDate, selection - viewDate.getMonth()) : (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_0__.addYears)(viewDate, selection - viewDate.getFullYear());
  picker.changeFocus(newDate).changeView(viewId - 1).render();
}
function onClickViewSwitch(datepicker) {
  (0,_functions_js__WEBPACK_IMPORTED_MODULE_2__.switchView)(datepicker);
}
function onClickPrevButton(datepicker) {
  (0,_functions_js__WEBPACK_IMPORTED_MODULE_2__.goToPrevOrNext)(datepicker, -1);
}
function onClickNextButton(datepicker) {
  (0,_functions_js__WEBPACK_IMPORTED_MODULE_2__.goToPrevOrNext)(datepicker, 1);
}

// For the picker's main block to delegete the events from `datepicker-cell`s
function onClickView(datepicker, ev) {
  const target = (0,_lib_event_js__WEBPACK_IMPORTED_MODULE_1__.findElementInEventPath)(ev, '.datepicker-cell');
  if (!target || target.classList.contains('disabled')) {
    return;
  }
  const {
    id,
    isMinView
  } = datepicker.picker.currentView;
  const data = target.dataset;
  if (isMinView) {
    datepicker.setDate(Number(data.date));
  } else if (id === 1) {
    goToSelectedMonthOrYear(datepicker, Number(data.month));
  } else {
    goToSelectedMonthOrYear(datepicker, Number(data.year));
  }
}
function onMousedownPicker(ev) {
  ev.preventDefault();
}

/***/ }),

/***/ "./node_modules/vanillajs-datepicker/js/i18n/base-locales.js":
/*!*******************************************************************!*\
  !*** ./node_modules/vanillajs-datepicker/js/i18n/base-locales.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// default locales
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  en: {
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    today: "Today",
    clear: "Clear",
    titleFormat: "MM y"
  }
});

/***/ }),

/***/ "./node_modules/vanillajs-datepicker/js/lib/date-format.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vanillajs-datepicker/js/lib/date-format.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   formatDate: () => (/* binding */ formatDate),
/* harmony export */   parseDate: () => (/* binding */ parseDate),
/* harmony export */   reFormatTokens: () => (/* binding */ reFormatTokens),
/* harmony export */   reNonDateParts: () => (/* binding */ reNonDateParts)
/* harmony export */ });
/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./date.js */ "./node_modules/vanillajs-datepicker/js/lib/date.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/vanillajs-datepicker/js/lib/utils.js");



// pattern for format parts
const reFormatTokens = /dd?|DD?|mm?|MM?|yy?(?:yy)?/;
// pattern for non date parts
const reNonDateParts = /[\s!-/:-@[-`{-~年月日]+/;
// cache for persed formats
let knownFormats = {};
// parse funtions for date parts
const parseFns = {
  y(date, year) {
    return new Date(date).setFullYear(parseInt(year, 10));
  },
  m(date, month, locale) {
    const newDate = new Date(date);
    let monthIndex = parseInt(month, 10) - 1;
    if (isNaN(monthIndex)) {
      if (!month) {
        return NaN;
      }
      const monthName = month.toLowerCase();
      const compareNames = name => name.toLowerCase().startsWith(monthName);
      // compare with both short and full names because some locales have periods
      // in the short names (not equal to the first X letters of the full names)
      monthIndex = locale.monthsShort.findIndex(compareNames);
      if (monthIndex < 0) {
        monthIndex = locale.months.findIndex(compareNames);
      }
      if (monthIndex < 0) {
        return NaN;
      }
    }
    newDate.setMonth(monthIndex);
    return newDate.getMonth() !== normalizeMonth(monthIndex) ? newDate.setDate(0) : newDate.getTime();
  },
  d(date, day) {
    return new Date(date).setDate(parseInt(day, 10));
  }
};
// format functions for date parts
const formatFns = {
  d(date) {
    return date.getDate();
  },
  dd(date) {
    return padZero(date.getDate(), 2);
  },
  D(date, locale) {
    return locale.daysShort[date.getDay()];
  },
  DD(date, locale) {
    return locale.days[date.getDay()];
  },
  m(date) {
    return date.getMonth() + 1;
  },
  mm(date) {
    return padZero(date.getMonth() + 1, 2);
  },
  M(date, locale) {
    return locale.monthsShort[date.getMonth()];
  },
  MM(date, locale) {
    return locale.months[date.getMonth()];
  },
  y(date) {
    return date.getFullYear();
  },
  yy(date) {
    return padZero(date.getFullYear(), 2).slice(-2);
  },
  yyyy(date) {
    return padZero(date.getFullYear(), 4);
  }
};

// get month index in normal range (0 - 11) from any number
function normalizeMonth(monthIndex) {
  return monthIndex > -1 ? monthIndex % 12 : normalizeMonth(monthIndex + 12);
}
function padZero(num, length) {
  return num.toString().padStart(length, '0');
}
function parseFormatString(format) {
  if (typeof format !== 'string') {
    throw new Error("Invalid date format.");
  }
  if (format in knownFormats) {
    return knownFormats[format];
  }

  // sprit the format string into parts and seprators
  const separators = format.split(reFormatTokens);
  const parts = format.match(new RegExp(reFormatTokens, 'g'));
  if (separators.length === 0 || !parts) {
    throw new Error("Invalid date format.");
  }

  // collect format functions used in the format
  const partFormatters = parts.map(token => formatFns[token]);

  // collect parse function keys used in the format
  // iterate over parseFns' keys in order to keep the order of the keys.
  const partParserKeys = Object.keys(parseFns).reduce((keys, key) => {
    const token = parts.find(part => part[0] !== 'D' && part[0].toLowerCase() === key);
    if (token) {
      keys.push(key);
    }
    return keys;
  }, []);
  return knownFormats[format] = {
    parser(dateStr, locale) {
      const dateParts = dateStr.split(reNonDateParts).reduce((dtParts, part, index) => {
        if (part.length > 0 && parts[index]) {
          const token = parts[index][0];
          if (token === 'M') {
            dtParts.m = part;
          } else if (token !== 'D') {
            dtParts[token] = part;
          }
        }
        return dtParts;
      }, {});

      // iterate over partParserkeys so that the parsing is made in the oder
      // of year, month and day to prevent the day parser from correcting last
      // day of month wrongly
      return partParserKeys.reduce((origDate, key) => {
        const newDate = parseFns[key](origDate, dateParts[key], locale);
        // ingnore the part failed to parse
        return isNaN(newDate) ? origDate : newDate;
      }, (0,_date_js__WEBPACK_IMPORTED_MODULE_0__.today)());
    },
    formatter(date, locale) {
      let dateStr = partFormatters.reduce((str, fn, index) => {
        return str += `${separators[index]}${fn(date, locale)}`;
      }, '');
      // separators' length is always parts' length + 1,
      return dateStr += (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.lastItemOf)(separators);
    }
  };
}
function parseDate(dateStr, format, locale) {
  if (dateStr instanceof Date || typeof dateStr === 'number') {
    const date = (0,_date_js__WEBPACK_IMPORTED_MODULE_0__.stripTime)(dateStr);
    return isNaN(date) ? undefined : date;
  }
  if (!dateStr) {
    return undefined;
  }
  if (dateStr === 'today') {
    return (0,_date_js__WEBPACK_IMPORTED_MODULE_0__.today)();
  }
  if (format && format.toValue) {
    const date = format.toValue(dateStr, format, locale);
    return isNaN(date) ? undefined : (0,_date_js__WEBPACK_IMPORTED_MODULE_0__.stripTime)(date);
  }
  return parseFormatString(format).parser(dateStr, locale);
}
function formatDate(date, format, locale) {
  if (isNaN(date) || !date && date !== 0) {
    return '';
  }
  const dateObj = typeof date === 'number' ? new Date(date) : date;
  if (format.toDisplay) {
    return format.toDisplay(dateObj, format, locale);
  }
  return parseFormatString(format).formatter(dateObj, locale);
}

/***/ }),

/***/ "./node_modules/vanillajs-datepicker/js/lib/date.js":
/*!**********************************************************!*\
  !*** ./node_modules/vanillajs-datepicker/js/lib/date.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addDays: () => (/* binding */ addDays),
/* harmony export */   addMonths: () => (/* binding */ addMonths),
/* harmony export */   addWeeks: () => (/* binding */ addWeeks),
/* harmony export */   addYears: () => (/* binding */ addYears),
/* harmony export */   dateValue: () => (/* binding */ dateValue),
/* harmony export */   dayOfTheWeekOf: () => (/* binding */ dayOfTheWeekOf),
/* harmony export */   getIsoWeek: () => (/* binding */ getIsoWeek),
/* harmony export */   getMidEasternWeek: () => (/* binding */ getMidEasternWeek),
/* harmony export */   getWesternTradWeek: () => (/* binding */ getWesternTradWeek),
/* harmony export */   regularizeDate: () => (/* binding */ regularizeDate),
/* harmony export */   startOfYearPeriod: () => (/* binding */ startOfYearPeriod),
/* harmony export */   stripTime: () => (/* binding */ stripTime),
/* harmony export */   today: () => (/* binding */ today)
/* harmony export */ });
function stripTime(timeValue) {
  return new Date(timeValue).setHours(0, 0, 0, 0);
}
function today() {
  return new Date().setHours(0, 0, 0, 0);
}

// Get the time value of the start of given date or year, month and day
function dateValue(...args) {
  switch (args.length) {
    case 0:
      return today();
    case 1:
      return stripTime(args[0]);
  }

  // use setFullYear() to keep 2-digit year from being mapped to 1900-1999
  const newDate = new Date(0);
  newDate.setFullYear(...args);
  return newDate.setHours(0, 0, 0, 0);
}
function addDays(date, amount) {
  const newDate = new Date(date);
  return newDate.setDate(newDate.getDate() + amount);
}
function addWeeks(date, amount) {
  return addDays(date, amount * 7);
}
function addMonths(date, amount) {
  // If the day of the date is not in the new month, the last day of the new
  // month will be returned. e.g. Jan 31 + 1 month → Feb 28 (not Mar 03)
  const newDate = new Date(date);
  const monthsToSet = newDate.getMonth() + amount;
  let expectedMonth = monthsToSet % 12;
  if (expectedMonth < 0) {
    expectedMonth += 12;
  }
  const time = newDate.setMonth(monthsToSet);
  return newDate.getMonth() !== expectedMonth ? newDate.setDate(0) : time;
}
function addYears(date, amount) {
  // If the date is Feb 29 and the new year is not a leap year, Feb 28 of the
  // new year will be returned.
  const newDate = new Date(date);
  const expectedMonth = newDate.getMonth();
  const time = newDate.setFullYear(newDate.getFullYear() + amount);
  return expectedMonth === 1 && newDate.getMonth() === 2 ? newDate.setDate(0) : time;
}

// Calculate the distance bettwen 2 days of the week
function dayDiff(day, from) {
  return (day - from + 7) % 7;
}

// Get the date of the specified day of the week of given base date
function dayOfTheWeekOf(baseDate, dayOfWeek, weekStart = 0) {
  const baseDay = new Date(baseDate).getDay();
  return addDays(baseDate, dayDiff(dayOfWeek, weekStart) - dayDiff(baseDay, weekStart));
}
function calcWeekNum(dayOfTheWeek, sameDayOfFirstWeek) {
  return Math.round((dayOfTheWeek - sameDayOfFirstWeek) / 604800000) + 1;
}

// Get the ISO week number of a date
function getIsoWeek(date) {
  // - Start of ISO week is Monday
  // - Use Thursday for culculation because the first Thursday of ISO week is
  //   always in January
  const thuOfTheWeek = dayOfTheWeekOf(date, 4, 1);
  // - Week 1 in ISO week is the week including Jan 04
  // - Use the Thu of given date's week (instead of given date itself) to
  //   calculate week 1 of the year so that Jan 01 - 03 won't be miscalculated
  //   as week 0 when Jan 04 is Mon - Wed
  const firstThu = dayOfTheWeekOf(new Date(thuOfTheWeek).setMonth(0, 4), 4, 1);
  // return Math.round((thuOfTheWeek - firstThu) / 604800000) + 1;
  return calcWeekNum(thuOfTheWeek, firstThu);
}

// Calculate week number in traditional week number system
// @see https://en.wikipedia.org/wiki/Week#Other_week_numbering_systems
function calcTraditionalWeekNumber(date, weekStart) {
  // - Week 1 of traditional week is the week including the Jan 01
  // - Use Jan 01 of given date's year to calculate the start of week 1
  const startOfFirstWeek = dayOfTheWeekOf(new Date(date).setMonth(0, 1), weekStart, weekStart);
  const startOfTheWeek = dayOfTheWeekOf(date, weekStart, weekStart);
  const weekNum = calcWeekNum(startOfTheWeek, startOfFirstWeek);
  if (weekNum < 53) {
    return weekNum;
  }
  // If the 53rd week includes Jan 01, it's actually next year's week 1
  const weekOneOfNextYear = dayOfTheWeekOf(new Date(date).setDate(32), weekStart, weekStart);
  return startOfTheWeek === weekOneOfNextYear ? 1 : weekNum;
}

// Get the Western traditional week number of a date
function getWesternTradWeek(date) {
  // Start of Western traditionl week is Sunday
  return calcTraditionalWeekNumber(date, 0);
}

// Get the Middle Eastern week number of a date
function getMidEasternWeek(date) {
  // Start of Middle Eastern week is Saturday
  return calcTraditionalWeekNumber(date, 6);
}

// Get the start year of the period of years that includes given date
// years: length of the year period
function startOfYearPeriod(date, years) {
  /* @see https://en.wikipedia.org/wiki/Year_zero#ISO_8601 */
  const year = new Date(date).getFullYear();
  return Math.floor(year / years) * years;
}

// Convert date to the first/last date of the month/year of the date
function regularizeDate(date, timeSpan, useLastDate) {
  if (timeSpan !== 1 && timeSpan !== 2) {
    return date;
  }
  const newDate = new Date(date);
  if (timeSpan === 1) {
    useLastDate ? newDate.setMonth(newDate.getMonth() + 1, 0) : newDate.setDate(1);
  } else {
    useLastDate ? newDate.setFullYear(newDate.getFullYear() + 1, 0, 0) : newDate.setMonth(0, 1);
  }
  return newDate.setHours(0, 0, 0, 0);
}

/***/ }),

/***/ "./node_modules/vanillajs-datepicker/js/lib/dom.js":
/*!*********************************************************!*\
  !*** ./node_modules/vanillajs-datepicker/js/lib/dom.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   emptyChildNodes: () => (/* binding */ emptyChildNodes),
/* harmony export */   getParent: () => (/* binding */ getParent),
/* harmony export */   hideElement: () => (/* binding */ hideElement),
/* harmony export */   isActiveElement: () => (/* binding */ isActiveElement),
/* harmony export */   isVisible: () => (/* binding */ isVisible),
/* harmony export */   parseHTML: () => (/* binding */ parseHTML),
/* harmony export */   replaceChildNodes: () => (/* binding */ replaceChildNodes),
/* harmony export */   showElement: () => (/* binding */ showElement)
/* harmony export */ });
const range = document.createRange();
function parseHTML(html) {
  return range.createContextualFragment(html);
}
function getParent(el) {
  return el.parentElement || (el.parentNode instanceof ShadowRoot ? el.parentNode.host : undefined);
}
function isActiveElement(el) {
  return el.getRootNode().activeElement === el;
}

// equivalent to jQuery's :visble
function isVisible(el) {
  return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
}
function hideElement(el) {
  if (el.style.display === 'none') {
    return;
  }
  // back up the existing display setting in data-style-display
  if (el.style.display) {
    el.dataset.styleDisplay = el.style.display;
  }
  el.style.display = 'none';
}
function showElement(el) {
  if (el.style.display !== 'none') {
    return;
  }
  if (el.dataset.styleDisplay) {
    // restore backed-up dispay property
    el.style.display = el.dataset.styleDisplay;
    delete el.dataset.styleDisplay;
  } else {
    el.style.display = '';
  }
}
function emptyChildNodes(el) {
  if (el.firstChild) {
    el.removeChild(el.firstChild);
    emptyChildNodes(el);
  }
}
function replaceChildNodes(el, newChildNodes) {
  emptyChildNodes(el);
  if (newChildNodes instanceof DocumentFragment) {
    el.appendChild(newChildNodes);
  } else if (typeof newChildNodes === 'string') {
    el.appendChild(parseHTML(newChildNodes));
  } else if (typeof newChildNodes.forEach === 'function') {
    newChildNodes.forEach(node => {
      el.appendChild(node);
    });
  }
}

/***/ }),

/***/ "./node_modules/vanillajs-datepicker/js/lib/event.js":
/*!***********************************************************!*\
  !*** ./node_modules/vanillajs-datepicker/js/lib/event.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   findElementInEventPath: () => (/* binding */ findElementInEventPath),
/* harmony export */   registerListeners: () => (/* binding */ registerListeners),
/* harmony export */   unregisterListeners: () => (/* binding */ unregisterListeners)
/* harmony export */ });
const listenerRegistry = new WeakMap();
const {
  addEventListener,
  removeEventListener
} = EventTarget.prototype;

// Register event listeners to a key object
// listeners: array of listener definitions;
//   - each definition must be a flat array of event target and the arguments
//     used to call addEventListener() on the target
function registerListeners(keyObj, listeners) {
  let registered = listenerRegistry.get(keyObj);
  if (!registered) {
    registered = [];
    listenerRegistry.set(keyObj, registered);
  }
  listeners.forEach(listener => {
    addEventListener.call(...listener);
    registered.push(listener);
  });
}
function unregisterListeners(keyObj) {
  let listeners = listenerRegistry.get(keyObj);
  if (!listeners) {
    return;
  }
  listeners.forEach(listener => {
    removeEventListener.call(...listener);
  });
  listenerRegistry.delete(keyObj);
}

// Event.composedPath() polyfill for Edge
// based on https://gist.github.com/kleinfreund/e9787d73776c0e3750dcfcdc89f100ec
if (!Event.prototype.composedPath) {
  const getComposedPath = (node, path = []) => {
    path.push(node);
    let parent;
    if (node.parentNode) {
      parent = node.parentNode;
    } else if (node.host) {
      // ShadowRoot
      parent = node.host;
    } else if (node.defaultView) {
      // Document
      parent = node.defaultView;
    }
    return parent ? getComposedPath(parent, path) : path;
  };
  Event.prototype.composedPath = function () {
    return getComposedPath(this.target);
  };
}
function findFromPath(path, criteria, currentTarget) {
  const [node, ...rest] = path;
  if (criteria(node)) {
    return node;
  }
  if (node === currentTarget || node.tagName === 'HTML' || rest.length === 0) {
    // stop when reaching currentTarget or <html>
    return;
  }
  return findFromPath(rest, criteria, currentTarget);
}

// Search for the actual target of a delegated event
function findElementInEventPath(ev, selector) {
  const criteria = typeof selector === 'function' ? selector : el => el instanceof Element && el.matches(selector);
  return findFromPath(ev.composedPath(), criteria, ev.currentTarget);
}

/***/ }),

/***/ "./node_modules/vanillajs-datepicker/js/lib/utils.js":
/*!***********************************************************!*\
  !*** ./node_modules/vanillajs-datepicker/js/lib/utils.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createTagRepeat: () => (/* binding */ createTagRepeat),
/* harmony export */   isInRange: () => (/* binding */ isInRange),
/* harmony export */   lastItemOf: () => (/* binding */ lastItemOf),
/* harmony export */   limitToRange: () => (/* binding */ limitToRange),
/* harmony export */   optimizeTemplateHTML: () => (/* binding */ optimizeTemplateHTML),
/* harmony export */   pushUnique: () => (/* binding */ pushUnique),
/* harmony export */   stringToArray: () => (/* binding */ stringToArray)
/* harmony export */ });
function lastItemOf(arr) {
  return arr[arr.length - 1];
}

// push only the items not included in the array
function pushUnique(arr, ...items) {
  items.forEach(item => {
    if (arr.includes(item)) {
      return;
    }
    arr.push(item);
  });
  return arr;
}
function stringToArray(str, separator) {
  // convert empty string to an empty array
  return str ? str.split(separator) : [];
}
function isInRange(testVal, min, max) {
  const minOK = min === undefined || testVal >= min;
  const maxOK = max === undefined || testVal <= max;
  return minOK && maxOK;
}
function limitToRange(val, min, max) {
  if (val < min) {
    return min;
  }
  if (val > max) {
    return max;
  }
  return val;
}
function createTagRepeat(tagName, repeat, attributes = {}, index = 0, html = '') {
  const openTagSrc = Object.keys(attributes).reduce((src, attr) => {
    let val = attributes[attr];
    if (typeof val === 'function') {
      val = val(index);
    }
    return `${src} ${attr}="${val}"`;
  }, tagName);
  html += `<${openTagSrc}></${tagName}>`;
  const next = index + 1;
  return next < repeat ? createTagRepeat(tagName, repeat, attributes, next, html) : html;
}

// Remove the spacing surrounding tags for HTML parser not to create text nodes
// before/after elements
function optimizeTemplateHTML(html) {
  return html.replace(/>\s+/g, '>').replace(/\s+</, '<');
}

/***/ }),

/***/ "./node_modules/vanillajs-datepicker/js/main.js":
/*!******************************************************!*\
  !*** ./node_modules/vanillajs-datepicker/js/main.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DateRangePicker: () => (/* reexport safe */ _DateRangePicker_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   Datepicker: () => (/* reexport safe */ _Datepicker_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _Datepicker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Datepicker.js */ "./node_modules/vanillajs-datepicker/js/Datepicker.js");
/* harmony import */ var _DateRangePicker_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DateRangePicker.js */ "./node_modules/vanillajs-datepicker/js/DateRangePicker.js");



/***/ }),

/***/ "./node_modules/vanillajs-datepicker/js/options/defaultOptions.js":
/*!************************************************************************!*\
  !*** ./node_modules/vanillajs-datepicker/js/options/defaultOptions.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// config options updatable by setOptions() and their default values
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  autohide: false,
  beforeShowDay: null,
  beforeShowDecade: null,
  beforeShowMonth: null,
  beforeShowYear: null,
  clearButton: false,
  dateDelimiter: ',',
  datesDisabled: [],
  daysOfWeekDisabled: [],
  daysOfWeekHighlighted: [],
  defaultViewDate: undefined,
  // placeholder, defaults to today() by the program
  disableTouchKeyboard: false,
  enableOnReadonly: true,
  format: 'mm/dd/yyyy',
  language: 'en',
  maxDate: null,
  maxNumberOfDates: 1,
  maxView: 3,
  minDate: null,
  nextArrow: '»',
  orientation: 'auto',
  pickLevel: 0,
  prevArrow: '«',
  showDaysOfWeek: true,
  showOnClick: true,
  showOnFocus: true,
  startView: 0,
  title: '',
  todayButton: false,
  todayButtonMode: 0,
  todayHighlight: false,
  updateOnBlur: true,
  weekNumbers: 0,
  weekStart: 0
});

/***/ }),

/***/ "./node_modules/vanillajs-datepicker/js/options/processOptions.js":
/*!************************************************************************!*\
  !*** ./node_modules/vanillajs-datepicker/js/options/processOptions.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ processOptions)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/utils.js */ "./node_modules/vanillajs-datepicker/js/lib/utils.js");
/* harmony import */ var _lib_date_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/date.js */ "./node_modules/vanillajs-datepicker/js/lib/date.js");
/* harmony import */ var _lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/date-format.js */ "./node_modules/vanillajs-datepicker/js/lib/date-format.js");
/* harmony import */ var _lib_dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/dom.js */ "./node_modules/vanillajs-datepicker/js/lib/dom.js");
/* harmony import */ var _defaultOptions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./defaultOptions.js */ "./node_modules/vanillajs-datepicker/js/options/defaultOptions.js");





const {
  language: defaultLang,
  format: defaultFormat,
  weekStart: defaultWeekStart
} = _defaultOptions_js__WEBPACK_IMPORTED_MODULE_4__["default"];

// Reducer function to filter out invalid day-of-week from the input
function sanitizeDOW(dow, day) {
  return dow.length < 6 && day >= 0 && day < 7 ? (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.pushUnique)(dow, day) : dow;
}
function determineGetWeekMethod(numberingMode, weekStart) {
  const methodId = numberingMode === 4 ? weekStart === 6 ? 3 : !weekStart + 1 : numberingMode;
  switch (methodId) {
    case 1:
      return _lib_date_js__WEBPACK_IMPORTED_MODULE_1__.getIsoWeek;
    case 2:
      return _lib_date_js__WEBPACK_IMPORTED_MODULE_1__.getWesternTradWeek;
    case 3:
      return _lib_date_js__WEBPACK_IMPORTED_MODULE_1__.getMidEasternWeek;
  }
}
function updateWeekStart(newValue, config, weekNumbers) {
  config.weekStart = newValue;
  config.weekEnd = (newValue + 6) % 7;
  if (weekNumbers === 4) {
    config.getWeekNumber = determineGetWeekMethod(4, newValue);
  }
  return newValue;
}

// validate input date. if invalid, fallback to the original value
function validateDate(value, format, locale, origValue) {
  const date = (0,_lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__.parseDate)(value, format, locale);
  return date !== undefined ? date : origValue;
}

// Validate viewId. if invalid, fallback to the original value
function validateViewId(value, origValue, max = 3) {
  const viewId = parseInt(value, 10);
  return viewId >= 0 && viewId <= max ? viewId : origValue;
}
function replaceOptions(options, from, to, convert = undefined) {
  if (from in options) {
    if (!(to in options)) {
      options[to] = convert ? convert(options[from]) : options[from];
    }
    delete options[from];
  }
}

// Create Datepicker configuration to set
function processOptions(options, datepicker) {
  const inOpts = Object.assign({}, options);
  const config = {};
  const locales = datepicker.constructor.locales;
  const rangeEnd = !!datepicker.rangeSideIndex;
  let {
    datesDisabled,
    format,
    language,
    locale,
    maxDate,
    maxView,
    minDate,
    pickLevel,
    startView,
    weekNumbers,
    weekStart
  } = datepicker.config || {};

  // for backword compatibility
  replaceOptions(inOpts, 'calendarWeeks', 'weekNumbers', val => val ? 1 : 0);
  replaceOptions(inOpts, 'clearBtn', 'clearButton');
  replaceOptions(inOpts, 'todayBtn', 'todayButton');
  replaceOptions(inOpts, 'todayBtnMode', 'todayButtonMode');
  if (inOpts.language) {
    let lang;
    if (inOpts.language !== language) {
      if (locales[inOpts.language]) {
        lang = inOpts.language;
      } else {
        // Check if langauge + region tag can fallback to the one without
        // region (e.g. fr-CA → fr)
        lang = inOpts.language.split('-')[0];
        if (!locales[lang]) {
          lang = false;
        }
      }
    }
    delete inOpts.language;
    if (lang) {
      language = config.language = lang;

      // update locale as well when updating language
      const origLocale = locale || locales[defaultLang];
      // use default language's properties for the fallback
      locale = Object.assign({
        format: defaultFormat,
        weekStart: defaultWeekStart
      }, locales[defaultLang]);
      if (language !== defaultLang) {
        Object.assign(locale, locales[language]);
      }
      config.locale = locale;
      // if format and/or weekStart are the same as old locale's defaults,
      // update them to new locale's defaults
      if (format === origLocale.format) {
        format = config.format = locale.format;
      }
      if (weekStart === origLocale.weekStart) {
        weekStart = updateWeekStart(locale.weekStart, config, weekNumbers);
      }
    }
  }
  if (inOpts.format) {
    const hasToDisplay = typeof inOpts.format.toDisplay === 'function';
    const hasToValue = typeof inOpts.format.toValue === 'function';
    const validFormatString = _lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__.reFormatTokens.test(inOpts.format);
    if (hasToDisplay && hasToValue || validFormatString) {
      format = config.format = inOpts.format;
    }
    delete inOpts.format;
  }

  //*** pick level ***//
  let newPickLevel = pickLevel;
  if ('pickLevel' in inOpts) {
    newPickLevel = validateViewId(inOpts.pickLevel, pickLevel, 2);
    delete inOpts.pickLevel;
  }
  if (newPickLevel !== pickLevel) {
    if (newPickLevel > pickLevel) {
      // complement current minDate/madDate so that the existing range will be
      // expanded to fit the new level later
      if (!('minDate' in inOpts)) {
        inOpts.minDate = minDate;
      }
      if (!('maxDate' in inOpts)) {
        inOpts.maxDate = maxDate;
      }
    }
    // complement datesDisabled so that it will be reset later
    if (datesDisabled && !inOpts.datesDisabled) {
      inOpts.datesDisabled = [];
    }
    pickLevel = config.pickLevel = newPickLevel;
  }

  //*** dates ***//
  // while min and maxDate for "no limit" in the options are better to be null
  // (especially when updating), the ones in the config have to be undefined
  // because null is treated as 0 (= unix epoch) when comparing with time value
  let minDt = minDate;
  let maxDt = maxDate;
  if ('minDate' in inOpts) {
    const defaultMinDt = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.dateValue)(0, 0, 1);
    minDt = inOpts.minDate === null ? defaultMinDt // set 0000-01-01 to prevent negative values for year
    : validateDate(inOpts.minDate, format, locale, minDt);
    if (minDt !== defaultMinDt) {
      minDt = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.regularizeDate)(minDt, pickLevel, false);
    }
    delete inOpts.minDate;
  }
  if ('maxDate' in inOpts) {
    maxDt = inOpts.maxDate === null ? undefined : validateDate(inOpts.maxDate, format, locale, maxDt);
    if (maxDt !== undefined) {
      maxDt = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.regularizeDate)(maxDt, pickLevel, true);
    }
    delete inOpts.maxDate;
  }
  if (maxDt < minDt) {
    minDate = config.minDate = maxDt;
    maxDate = config.maxDate = minDt;
  } else {
    if (minDate !== minDt) {
      minDate = config.minDate = minDt;
    }
    if (maxDate !== maxDt) {
      maxDate = config.maxDate = maxDt;
    }
  }
  if (inOpts.datesDisabled) {
    const dtsDisabled = inOpts.datesDisabled;
    if (typeof dtsDisabled === 'function') {
      config.datesDisabled = null;
      config.checkDisabled = (timeValue, viewId) => dtsDisabled(new Date(timeValue), viewId, rangeEnd);
    } else {
      const disabled = config.datesDisabled = dtsDisabled.reduce((dates, dt) => {
        const date = (0,_lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__.parseDate)(dt, format, locale);
        return date !== undefined ? (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.pushUnique)(dates, (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.regularizeDate)(date, pickLevel, rangeEnd)) : dates;
      }, []);
      config.checkDisabled = timeValue => disabled.includes(timeValue);
    }
    delete inOpts.datesDisabled;
  }
  if ('defaultViewDate' in inOpts) {
    const viewDate = (0,_lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__.parseDate)(inOpts.defaultViewDate, format, locale);
    if (viewDate !== undefined) {
      config.defaultViewDate = viewDate;
    }
    delete inOpts.defaultViewDate;
  }

  //*** days of week ***//
  if ('weekStart' in inOpts) {
    const wkStart = Number(inOpts.weekStart) % 7;
    if (!isNaN(wkStart)) {
      weekStart = updateWeekStart(wkStart, config, weekNumbers);
    }
    delete inOpts.weekStart;
  }
  if (inOpts.daysOfWeekDisabled) {
    config.daysOfWeekDisabled = inOpts.daysOfWeekDisabled.reduce(sanitizeDOW, []);
    delete inOpts.daysOfWeekDisabled;
  }
  if (inOpts.daysOfWeekHighlighted) {
    config.daysOfWeekHighlighted = inOpts.daysOfWeekHighlighted.reduce(sanitizeDOW, []);
    delete inOpts.daysOfWeekHighlighted;
  }

  //*** week numbers ***//
  if ('weekNumbers' in inOpts) {
    let method = inOpts.weekNumbers;
    if (method) {
      const getWeekNumber = typeof method === 'function' ? (timeValue, startOfWeek) => method(new Date(timeValue), startOfWeek) : determineGetWeekMethod(method = parseInt(method, 10), weekStart);
      if (getWeekNumber) {
        weekNumbers = config.weekNumbers = method;
        config.getWeekNumber = getWeekNumber;
      }
    } else {
      weekNumbers = config.weekNumbers = 0;
      config.getWeekNumber = null;
    }
    delete inOpts.weekNumbers;
  }

  //*** multi date ***//
  if ('maxNumberOfDates' in inOpts) {
    const maxNumberOfDates = parseInt(inOpts.maxNumberOfDates, 10);
    if (maxNumberOfDates >= 0) {
      config.maxNumberOfDates = maxNumberOfDates;
      config.multidate = maxNumberOfDates !== 1;
    }
    delete inOpts.maxNumberOfDates;
  }
  if (inOpts.dateDelimiter) {
    config.dateDelimiter = String(inOpts.dateDelimiter);
    delete inOpts.dateDelimiter;
  }

  //*** view ***//
  let newMaxView = maxView;
  if ('maxView' in inOpts) {
    newMaxView = validateViewId(inOpts.maxView, maxView);
    delete inOpts.maxView;
  }
  // ensure max view >= pick level
  newMaxView = pickLevel > newMaxView ? pickLevel : newMaxView;
  if (newMaxView !== maxView) {
    maxView = config.maxView = newMaxView;
  }
  let newStartView = startView;
  if ('startView' in inOpts) {
    newStartView = validateViewId(inOpts.startView, newStartView);
    delete inOpts.startView;
  }
  // ensure pick level <= start view <= max view
  if (newStartView < pickLevel) {
    newStartView = pickLevel;
  } else if (newStartView > maxView) {
    newStartView = maxView;
  }
  if (newStartView !== startView) {
    config.startView = newStartView;
  }

  //*** template ***//
  if (inOpts.prevArrow) {
    const prevArrow = (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_3__.parseHTML)(inOpts.prevArrow);
    if (prevArrow.childNodes.length > 0) {
      config.prevArrow = prevArrow.childNodes;
    }
    delete inOpts.prevArrow;
  }
  if (inOpts.nextArrow) {
    const nextArrow = (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_3__.parseHTML)(inOpts.nextArrow);
    if (nextArrow.childNodes.length > 0) {
      config.nextArrow = nextArrow.childNodes;
    }
    delete inOpts.nextArrow;
  }

  //*** misc ***//
  if ('disableTouchKeyboard' in inOpts) {
    config.disableTouchKeyboard = 'ontouchstart' in document && !!inOpts.disableTouchKeyboard;
    delete inOpts.disableTouchKeyboard;
  }
  if (inOpts.orientation) {
    const orientation = inOpts.orientation.toLowerCase().split(/\s+/g);
    config.orientation = {
      x: orientation.find(x => x === 'left' || x === 'right') || 'auto',
      y: orientation.find(y => y === 'top' || y === 'bottom') || 'auto'
    };
    delete inOpts.orientation;
  }
  if ('todayButtonMode' in inOpts) {
    switch (inOpts.todayButtonMode) {
      case 0:
      case 1:
        config.todayButtonMode = inOpts.todayButtonMode;
    }
    delete inOpts.todayButtonMode;
  }

  //*** copy the rest ***//
  Object.entries(inOpts).forEach(([key, value]) => {
    if (value !== undefined && key in _defaultOptions_js__WEBPACK_IMPORTED_MODULE_4__["default"]) {
      config[key] = value;
    }
  });
  return config;
}

/***/ }),

/***/ "./node_modules/vanillajs-datepicker/js/options/shortcutKeys.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vanillajs-datepicker/js/options/shortcutKeys.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createShortcutKeyConfig)
/* harmony export */ });
const defaultShortcutKeys = {
  show: {
    key: 'ArrowDown'
  },
  hide: null,
  toggle: {
    key: 'Escape'
  },
  prevButton: {
    key: 'ArrowLeft',
    ctrlOrMetaKey: true
  },
  nextButton: {
    key: 'ArrowRight',
    ctrlOrMetaKey: true
  },
  viewSwitch: {
    key: 'ArrowUp',
    ctrlOrMetaKey: true
  },
  clearButton: {
    key: 'Backspace',
    ctrlOrMetaKey: true
  },
  todayButton: {
    key: '.',
    ctrlOrMetaKey: true
  },
  exitEditMode: {
    key: 'ArrowDown',
    ctrlOrMetaKey: true
  }
};
function createShortcutKeyConfig(options) {
  return Object.keys(defaultShortcutKeys).reduce((keyDefs, shortcut) => {
    const keyDef = options[shortcut] === undefined ? defaultShortcutKeys[shortcut] : options[shortcut];
    const key = keyDef && keyDef.key;
    if (!key || typeof key !== 'string') {
      return keyDefs;
    }
    const normalizedDef = {
      key,
      ctrlOrMetaKey: !!(keyDef.ctrlOrMetaKey || keyDef.ctrlKey || keyDef.metaKey)
    };
    if (key.length > 1) {
      normalizedDef.altKey = !!keyDef.altKey;
      normalizedDef.shiftKey = !!keyDef.shiftKey;
    }
    keyDefs[shortcut] = normalizedDef;
    return keyDefs;
  }, {});
}

/***/ }),

/***/ "./node_modules/vanillajs-datepicker/js/picker/Picker.js":
/*!***************************************************************!*\
  !*** ./node_modules/vanillajs-datepicker/js/picker/Picker.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Picker)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/utils.js */ "./node_modules/vanillajs-datepicker/js/lib/utils.js");
/* harmony import */ var _lib_date_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/date.js */ "./node_modules/vanillajs-datepicker/js/lib/date.js");
/* harmony import */ var _lib_dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/dom.js */ "./node_modules/vanillajs-datepicker/js/lib/dom.js");
/* harmony import */ var _lib_event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/event.js */ "./node_modules/vanillajs-datepicker/js/lib/event.js");
/* harmony import */ var _templates_pickerTemplate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./templates/pickerTemplate.js */ "./node_modules/vanillajs-datepicker/js/picker/templates/pickerTemplate.js");
/* harmony import */ var _views_DaysView_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./views/DaysView.js */ "./node_modules/vanillajs-datepicker/js/picker/views/DaysView.js");
/* harmony import */ var _views_MonthsView_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./views/MonthsView.js */ "./node_modules/vanillajs-datepicker/js/picker/views/MonthsView.js");
/* harmony import */ var _views_YearsView_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./views/YearsView.js */ "./node_modules/vanillajs-datepicker/js/picker/views/YearsView.js");
/* harmony import */ var _events_functions_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../events/functions.js */ "./node_modules/vanillajs-datepicker/js/events/functions.js");
/* harmony import */ var _events_pickerListeners_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../events/pickerListeners.js */ "./node_modules/vanillajs-datepicker/js/events/pickerListeners.js");










const orientClasses = ['left', 'top', 'right', 'bottom'].reduce((obj, key) => {
  obj[key] = `datepicker-orient-${key}`;
  return obj;
}, {});
const toPx = num => num ? `${num}px` : num;
function processPickerOptions(picker, options) {
  if ('title' in options) {
    if (options.title) {
      picker.controls.title.textContent = options.title;
      (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.showElement)(picker.controls.title);
    } else {
      picker.controls.title.textContent = '';
      (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.hideElement)(picker.controls.title);
    }
  }
  if (options.prevArrow) {
    const prevButton = picker.controls.prevButton;
    (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.emptyChildNodes)(prevButton);
    options.prevArrow.forEach(node => {
      prevButton.appendChild(node.cloneNode(true));
    });
  }
  if (options.nextArrow) {
    const nextButton = picker.controls.nextButton;
    (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.emptyChildNodes)(nextButton);
    options.nextArrow.forEach(node => {
      nextButton.appendChild(node.cloneNode(true));
    });
  }
  if (options.locale) {
    picker.controls.todayButton.textContent = options.locale.today;
    picker.controls.clearButton.textContent = options.locale.clear;
  }
  if ('todayButton' in options) {
    if (options.todayButton) {
      (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.showElement)(picker.controls.todayButton);
    } else {
      (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.hideElement)(picker.controls.todayButton);
    }
  }
  if ('minDate' in options || 'maxDate' in options) {
    const {
      minDate,
      maxDate
    } = picker.datepicker.config;
    picker.controls.todayButton.disabled = !(0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.isInRange)((0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.today)(), minDate, maxDate);
  }
  if ('clearButton' in options) {
    if (options.clearButton) {
      (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.showElement)(picker.controls.clearButton);
    } else {
      (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.hideElement)(picker.controls.clearButton);
    }
  }
}

// Compute view date to reset, which will be...
// - the last item of the selected dates or defaultViewDate if no selection
// - limitted to minDate or maxDate if it exceeds the range
function computeResetViewDate(datepicker) {
  const {
    dates,
    config,
    rangeSideIndex
  } = datepicker;
  const viewDate = dates.length > 0 ? (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.lastItemOf)(dates) : (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.regularizeDate)(config.defaultViewDate, config.pickLevel, rangeSideIndex);
  return (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.limitToRange)(viewDate, config.minDate, config.maxDate);
}

// Change current view's view date
function setViewDate(picker, newDate) {
  if (!('_oldViewDate' in picker) && newDate !== picker.viewDate) {
    picker._oldViewDate = picker.viewDate;
  }
  picker.viewDate = newDate;

  // return whether the new date is in different period on time from the one
  // displayed in the current view
  // when true, the view needs to be re-rendered on the next UI refresh.
  const {
    id,
    year,
    first,
    last
  } = picker.currentView;
  const viewYear = new Date(newDate).getFullYear();
  switch (id) {
    case 0:
      return newDate < first || newDate > last;
    case 1:
      return viewYear !== year;
    default:
      return viewYear < first || viewYear > last;
  }
}
function getTextDirection(el) {
  return window.getComputedStyle(el).direction;
}

// find the closet scrollable ancestor elemnt under the body
function findScrollParents(el) {
  const parent = (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.getParent)(el);
  if (parent === document.body || !parent) {
    return;
  }

  // checking overflow only is enough because computed overflow cannot be
  // visible or a combination of visible and other when either axis is set
  // to other than visible.
  // (Setting one axis to other than 'visible' while the other is 'visible'
  // results in the other axis turning to 'auto')
  return window.getComputedStyle(parent).overflow !== 'visible' ? parent : findScrollParents(parent);
}

// Class representing the picker UI
class Picker {
  constructor(datepicker) {
    const {
      config,
      inputField
    } = this.datepicker = datepicker;
    const template = _templates_pickerTemplate_js__WEBPACK_IMPORTED_MODULE_4__["default"].replace(/%buttonClass%/g, config.buttonClass);
    const element = this.element = (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.parseHTML)(template).firstChild;
    const [header, main, footer] = element.firstChild.children;
    const title = header.firstElementChild;
    const [prevButton, viewSwitch, nextButton] = header.lastElementChild.children;
    const [todayButton, clearButton] = footer.firstChild.children;
    const controls = {
      title,
      prevButton,
      viewSwitch,
      nextButton,
      todayButton,
      clearButton
    };
    this.main = main;
    this.controls = controls;
    const elementClass = inputField ? 'dropdown' : 'inline';
    element.classList.add(`datepicker-${elementClass}`);
    processPickerOptions(this, config);
    this.viewDate = computeResetViewDate(datepicker);

    // set up event listeners
    (0,_lib_event_js__WEBPACK_IMPORTED_MODULE_3__.registerListeners)(datepicker, [[element, 'mousedown', _events_pickerListeners_js__WEBPACK_IMPORTED_MODULE_9__.onMousedownPicker], [main, 'click', _events_pickerListeners_js__WEBPACK_IMPORTED_MODULE_9__.onClickView.bind(null, datepicker)], [controls.viewSwitch, 'click', _events_pickerListeners_js__WEBPACK_IMPORTED_MODULE_9__.onClickViewSwitch.bind(null, datepicker)], [controls.prevButton, 'click', _events_pickerListeners_js__WEBPACK_IMPORTED_MODULE_9__.onClickPrevButton.bind(null, datepicker)], [controls.nextButton, 'click', _events_pickerListeners_js__WEBPACK_IMPORTED_MODULE_9__.onClickNextButton.bind(null, datepicker)], [controls.todayButton, 'click', _events_functions_js__WEBPACK_IMPORTED_MODULE_8__.goToOrSelectToday.bind(null, datepicker)], [controls.clearButton, 'click', _events_functions_js__WEBPACK_IMPORTED_MODULE_8__.clearSelection.bind(null, datepicker)]]);

    // set up views
    this.views = [new _views_DaysView_js__WEBPACK_IMPORTED_MODULE_5__["default"](this), new _views_MonthsView_js__WEBPACK_IMPORTED_MODULE_6__["default"](this), new _views_YearsView_js__WEBPACK_IMPORTED_MODULE_7__["default"](this, {
      id: 2,
      name: 'years',
      cellClass: 'year',
      step: 1
    }), new _views_YearsView_js__WEBPACK_IMPORTED_MODULE_7__["default"](this, {
      id: 3,
      name: 'decades',
      cellClass: 'decade',
      step: 10
    })];
    this.currentView = this.views[config.startView];
    this.currentView.render();
    this.main.appendChild(this.currentView.element);
    if (config.container) {
      config.container.appendChild(this.element);
    } else {
      inputField.after(this.element);
    }
  }
  setOptions(options) {
    processPickerOptions(this, options);
    this.views.forEach(view => {
      view.init(options, false);
    });
    this.currentView.render();
  }
  detach() {
    this.element.remove();
  }
  show() {
    if (this.active) {
      return;
    }
    const {
      datepicker,
      element
    } = this;
    const inputField = datepicker.inputField;
    if (inputField) {
      // ensure picker's direction matches input's
      const inputDirection = getTextDirection(inputField);
      if (inputDirection !== getTextDirection((0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.getParent)(element))) {
        element.dir = inputDirection;
      } else if (element.dir) {
        element.removeAttribute('dir');
      }

      // Determine the picker's position first to prevent `orientation: 'auto'`
      // from being miscalculated to 'bottom' after the picker temporarily
      // shown below the input field expands the document height if the field
      // is at the bottom edge of the document
      this.place();
      element.classList.add('active');
      if (datepicker.config.disableTouchKeyboard) {
        inputField.blur();
      }
    } else {
      element.classList.add('active');
    }
    this.active = true;
    (0,_events_functions_js__WEBPACK_IMPORTED_MODULE_8__.triggerDatepickerEvent)(datepicker, 'show');
  }
  hide() {
    if (!this.active) {
      return;
    }
    this.datepicker.exitEditMode();
    this.element.classList.remove('active');
    this.active = false;
    (0,_events_functions_js__WEBPACK_IMPORTED_MODULE_8__.triggerDatepickerEvent)(this.datepicker, 'hide');
  }
  place() {
    const {
      classList,
      style
    } = this.element;
    // temporarily display the picker to get its size and offset parent
    style.display = 'block';
    const {
      width: calendarWidth,
      height: calendarHeight
    } = this.element.getBoundingClientRect();
    const offsetParent = this.element.offsetParent;
    // turn the picker back to hidden so that the position is determined with
    // the state before it is shown.
    style.display = '';
    const {
      config,
      inputField
    } = this.datepicker;
    const {
      left: inputLeft,
      top: inputTop,
      right: inputRight,
      bottom: inputBottom,
      width: inputWidth,
      height: inputHeight
    } = inputField.getBoundingClientRect();
    let {
      x: orientX,
      y: orientY
    } = config.orientation;
    let left = inputLeft;
    let top = inputTop;

    // caliculate offsetLeft/Top of inputField
    if (offsetParent === document.body || !offsetParent) {
      left += window.scrollX;
      top += window.scrollY;
    } else {
      const offsetParentRect = offsetParent.getBoundingClientRect();
      left -= offsetParentRect.left - offsetParent.scrollLeft;
      top -= offsetParentRect.top - offsetParent.scrollTop;
    }

    // caliculate the boundaries of the visible area that contains inputField
    const scrollParent = findScrollParents(inputField);
    let scrollAreaLeft = 0;
    let scrollAreaTop = 0;
    let {
      clientWidth: scrollAreaRight,
      clientHeight: scrollAreaBottom
    } = document.documentElement;
    if (scrollParent) {
      const scrollParentRect = scrollParent.getBoundingClientRect();
      if (scrollParentRect.top > 0) {
        scrollAreaTop = scrollParentRect.top;
      }
      if (scrollParentRect.left > 0) {
        scrollAreaLeft = scrollParentRect.left;
      }
      if (scrollParentRect.right < scrollAreaRight) {
        scrollAreaRight = scrollParentRect.right;
      }
      if (scrollParentRect.bottom < scrollAreaBottom) {
        scrollAreaBottom = scrollParentRect.bottom;
      }
    }

    // determine the horizontal orientation and left position
    let adjustment = 0;
    if (orientX === 'auto') {
      if (inputLeft < scrollAreaLeft) {
        orientX = 'left';
        adjustment = scrollAreaLeft - inputLeft;
      } else if (inputLeft + calendarWidth > scrollAreaRight) {
        orientX = 'right';
        if (scrollAreaRight < inputRight) {
          adjustment = scrollAreaRight - inputRight;
        }
      } else if (getTextDirection(inputField) === 'rtl') {
        orientX = inputRight - calendarWidth < scrollAreaLeft ? 'left' : 'right';
      } else {
        orientX = 'left';
      }
    }
    if (orientX === 'right') {
      left += inputWidth - calendarWidth;
    }
    left += adjustment;

    // determine the vertical orientation and top position
    if (orientY === 'auto') {
      if (inputTop - calendarHeight > scrollAreaTop) {
        orientY = inputBottom + calendarHeight > scrollAreaBottom ? 'top' : 'bottom';
      } else {
        orientY = 'bottom';
      }
    }
    if (orientY === 'top') {
      top -= calendarHeight;
    } else {
      top += inputHeight;
    }
    classList.remove(...Object.values(orientClasses));
    classList.add(orientClasses[orientX], orientClasses[orientY]);
    style.left = toPx(left);
    style.top = toPx(top);
  }
  setViewSwitchLabel(labelText) {
    this.controls.viewSwitch.textContent = labelText;
  }
  setPrevButtonDisabled(disabled) {
    this.controls.prevButton.disabled = disabled;
  }
  setNextButtonDisabled(disabled) {
    this.controls.nextButton.disabled = disabled;
  }
  changeView(viewId) {
    const currentView = this.currentView;
    if (viewId !== currentView.id) {
      if (!this._oldView) {
        this._oldView = currentView;
      }
      this.currentView = this.views[viewId];
      this._renderMethod = 'render';
    }
    return this;
  }

  // Change the focused date (view date)
  changeFocus(newViewDate) {
    this._renderMethod = setViewDate(this, newViewDate) ? 'render' : 'refreshFocus';
    this.views.forEach(view => {
      view.updateFocus();
    });
    return this;
  }

  // Apply the change of the selected dates
  update(viewDate = undefined) {
    const newViewDate = viewDate === undefined ? computeResetViewDate(this.datepicker) : viewDate;
    this._renderMethod = setViewDate(this, newViewDate) ? 'render' : 'refresh';
    this.views.forEach(view => {
      view.updateFocus();
      view.updateSelection();
    });
    return this;
  }

  // Refresh the picker UI
  render(quickRender = true) {
    const {
      currentView,
      datepicker,
      _oldView: oldView
    } = this;
    const oldViewDate = new Date(this._oldViewDate);
    const renderMethod = quickRender && this._renderMethod || 'render';
    delete this._oldView;
    delete this._oldViewDate;
    delete this._renderMethod;
    currentView[renderMethod]();
    if (oldView) {
      this.main.replaceChild(currentView.element, oldView.element);
      (0,_events_functions_js__WEBPACK_IMPORTED_MODULE_8__.triggerDatepickerEvent)(datepicker, 'changeView');
    }
    if (!isNaN(oldViewDate)) {
      const newViewDate = new Date(this.viewDate);
      if (newViewDate.getFullYear() !== oldViewDate.getFullYear()) {
        (0,_events_functions_js__WEBPACK_IMPORTED_MODULE_8__.triggerDatepickerEvent)(datepicker, 'changeYear');
      }
      if (newViewDate.getMonth() !== oldViewDate.getMonth()) {
        (0,_events_functions_js__WEBPACK_IMPORTED_MODULE_8__.triggerDatepickerEvent)(datepicker, 'changeMonth');
      }
    }
  }
}

/***/ }),

/***/ "./node_modules/vanillajs-datepicker/js/picker/templates/daysTemplate.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/vanillajs-datepicker/js/picker/templates/daysTemplate.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/utils.js */ "./node_modules/vanillajs-datepicker/js/lib/utils.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.optimizeTemplateHTML)(`<div class="days">
  <div class="days-of-week">${(0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.createTagRepeat)('span', 7, {
  class: 'dow'
})}</div>
  <div class="datepicker-grid">${(0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.createTagRepeat)('span', 42)}</div>
</div>`));

/***/ }),

/***/ "./node_modules/vanillajs-datepicker/js/picker/templates/pickerTemplate.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/vanillajs-datepicker/js/picker/templates/pickerTemplate.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/utils.js */ "./node_modules/vanillajs-datepicker/js/lib/utils.js");

const getButtons = buttonList => buttonList.map(classes => `<button type="button" class="%buttonClass% ${classes}" tabindex="-1"></button>`).join('');
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.optimizeTemplateHTML)(`<div class="datepicker">
  <div class="datepicker-picker">
    <div class="datepicker-header">
      <div class="datepicker-title"></div>
      <div class="datepicker-controls">
        ${getButtons(['prev-button prev-btn', 'view-switch', 'next-button next-btn'])}
      </div>
    </div>
    <div class="datepicker-main"></div>
    <div class="datepicker-footer">
      <div class="datepicker-controls">
        ${getButtons(['today-button today-btn', 'clear-button clear-btn'])}
      </div>
    </div>
  </div>
</div>`));

/***/ }),

/***/ "./node_modules/vanillajs-datepicker/js/picker/templates/weekNumbersTemplate.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/vanillajs-datepicker/js/picker/templates/weekNumbersTemplate.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/utils.js */ "./node_modules/vanillajs-datepicker/js/lib/utils.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.optimizeTemplateHTML)(`<div class="week-numbers calendar-weeks">
  <div class="days-of-week"><span class="dow"></span></div>
  <div class="weeks">${(0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.createTagRepeat)('span', 6, {
  class: 'week'
})}</div>
</div>`));

/***/ }),

/***/ "./node_modules/vanillajs-datepicker/js/picker/views/DaysView.js":
/*!***********************************************************************!*\
  !*** ./node_modules/vanillajs-datepicker/js/picker/views/DaysView.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DaysView)
/* harmony export */ });
/* harmony import */ var _lib_date_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/date.js */ "./node_modules/vanillajs-datepicker/js/lib/date.js");
/* harmony import */ var _lib_date_format_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/date-format.js */ "./node_modules/vanillajs-datepicker/js/lib/date-format.js");
/* harmony import */ var _lib_dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/dom.js */ "./node_modules/vanillajs-datepicker/js/lib/dom.js");
/* harmony import */ var _templates_daysTemplate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../templates/daysTemplate.js */ "./node_modules/vanillajs-datepicker/js/picker/templates/daysTemplate.js");
/* harmony import */ var _templates_weekNumbersTemplate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../templates/weekNumbersTemplate.js */ "./node_modules/vanillajs-datepicker/js/picker/templates/weekNumbersTemplate.js");
/* harmony import */ var _View_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./View.js */ "./node_modules/vanillajs-datepicker/js/picker/views/View.js");






class DaysView extends _View_js__WEBPACK_IMPORTED_MODULE_5__["default"] {
  constructor(picker) {
    super(picker, {
      id: 0,
      name: 'days',
      cellClass: 'day'
    });
  }
  init(options, onConstruction = true) {
    if (onConstruction) {
      const inner = (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.parseHTML)(_templates_daysTemplate_js__WEBPACK_IMPORTED_MODULE_3__["default"]).firstChild;
      this.dow = inner.firstChild;
      this.grid = inner.lastChild;
      this.element.appendChild(inner);
    }
    super.init(options);
  }
  setOptions(options) {
    let updateDOW;
    if ('minDate' in options) {
      this.minDate = options.minDate;
    }
    if ('maxDate' in options) {
      this.maxDate = options.maxDate;
    }
    if (options.checkDisabled) {
      this.checkDisabled = options.checkDisabled;
    }
    if (options.daysOfWeekDisabled) {
      this.daysOfWeekDisabled = options.daysOfWeekDisabled;
      updateDOW = true;
    }
    if (options.daysOfWeekHighlighted) {
      this.daysOfWeekHighlighted = options.daysOfWeekHighlighted;
    }
    if ('todayHighlight' in options) {
      this.todayHighlight = options.todayHighlight;
    }
    if ('weekStart' in options) {
      this.weekStart = options.weekStart;
      this.weekEnd = options.weekEnd;
      updateDOW = true;
    }
    if (options.locale) {
      const locale = this.locale = options.locale;
      this.dayNames = locale.daysMin;
      this.switchLabelFormat = locale.titleFormat;
      updateDOW = true;
    }
    if ('beforeShowDay' in options) {
      this.beforeShow = typeof options.beforeShowDay === 'function' ? options.beforeShowDay : undefined;
    }
    if ('weekNumbers' in options) {
      if (options.weekNumbers && !this.weekNumbers) {
        const weeksElem = (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.parseHTML)(_templates_weekNumbersTemplate_js__WEBPACK_IMPORTED_MODULE_4__["default"]).firstChild;
        this.weekNumbers = {
          element: weeksElem,
          dow: weeksElem.firstChild,
          weeks: weeksElem.lastChild
        };
        this.element.insertBefore(weeksElem, this.element.firstChild);
      } else if (this.weekNumbers && !options.weekNumbers) {
        this.element.removeChild(this.weekNumbers.element);
        this.weekNumbers = null;
      }
    }
    if ('getWeekNumber' in options) {
      this.getWeekNumber = options.getWeekNumber;
    }
    if ('showDaysOfWeek' in options) {
      if (options.showDaysOfWeek) {
        (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.showElement)(this.dow);
        if (this.weekNumbers) {
          (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.showElement)(this.weekNumbers.dow);
        }
      } else {
        (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.hideElement)(this.dow);
        if (this.weekNumbers) {
          (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.hideElement)(this.weekNumbers.dow);
        }
      }
    }

    // update days-of-week when locale, daysOfweekDisabled or weekStart is changed
    if (updateDOW) {
      Array.from(this.dow.children).forEach((el, index) => {
        const dow = (this.weekStart + index) % 7;
        el.textContent = this.dayNames[dow];
        el.className = this.daysOfWeekDisabled.includes(dow) ? 'dow disabled' : 'dow';
      });
    }
  }

  // Apply update on the focused date to view's settings
  updateFocus() {
    const viewDate = new Date(this.picker.viewDate);
    const viewYear = viewDate.getFullYear();
    const viewMonth = viewDate.getMonth();
    const firstOfMonth = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_0__.dateValue)(viewYear, viewMonth, 1);
    const start = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_0__.dayOfTheWeekOf)(firstOfMonth, this.weekStart, this.weekStart);
    this.first = firstOfMonth;
    this.last = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_0__.dateValue)(viewYear, viewMonth + 1, 0);
    this.start = start;
    this.focused = this.picker.viewDate;
  }

  // Apply update on the selected dates to view's settings
  updateSelection() {
    const {
      dates,
      rangepicker
    } = this.picker.datepicker;
    this.selected = dates;
    if (rangepicker) {
      this.range = rangepicker.dates;
    }
  }

  // Update the entire view UI
  render() {
    // update today marker on ever render
    this.today = this.todayHighlight ? (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_0__.today)() : undefined;
    this.prepareForRender((0,_lib_date_format_js__WEBPACK_IMPORTED_MODULE_1__.formatDate)(this.focused, this.switchLabelFormat, this.locale), this.first <= this.minDate, this.last >= this.maxDate);
    if (this.weekNumbers) {
      const weekStart = this.weekStart;
      const startOfWeek = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_0__.dayOfTheWeekOf)(this.first, weekStart, weekStart);
      Array.from(this.weekNumbers.weeks.children).forEach((el, index) => {
        const dateOfWeekStart = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_0__.addWeeks)(startOfWeek, index);
        el.textContent = this.getWeekNumber(dateOfWeekStart, weekStart);
        if (index > 3) {
          el.classList[dateOfWeekStart > this.last ? 'add' : 'remove']('next');
        }
      });
    }
    Array.from(this.grid.children).forEach((el, index) => {
      const current = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_0__.addDays)(this.start, index);
      const dateObj = new Date(current);
      const day = dateObj.getDay();
      const extraClasses = [];
      if (this.today === current) {
        extraClasses.push('today');
      }
      if (this.daysOfWeekHighlighted.includes(day)) {
        extraClasses.push('highlighted');
      }
      this.renderCell(el, dateObj.getDate(), current, current, this, current < this.minDate || current > this.maxDate || this.daysOfWeekDisabled.includes(day), extraClasses);
    });
  }

  // Update the view UI by applying the changes of selected and focused items
  refresh() {
    const range = this.range || [];
    Array.from(this.grid.children).forEach(el => {
      this.refreshCell(el, Number(el.dataset.date), this.selected, range);
    });
  }

  // Update the view UI by applying the change of focused item
  refreshFocus() {
    this.changeFocusedCell(Math.round((this.focused - this.start) / 86400000));
  }
}

/***/ }),

/***/ "./node_modules/vanillajs-datepicker/js/picker/views/MonthsView.js":
/*!*************************************************************************!*\
  !*** ./node_modules/vanillajs-datepicker/js/picker/views/MonthsView.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MonthsView)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/utils.js */ "./node_modules/vanillajs-datepicker/js/lib/utils.js");
/* harmony import */ var _lib_date_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/date.js */ "./node_modules/vanillajs-datepicker/js/lib/date.js");
/* harmony import */ var _lib_dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/dom.js */ "./node_modules/vanillajs-datepicker/js/lib/dom.js");
/* harmony import */ var _View_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./View.js */ "./node_modules/vanillajs-datepicker/js/picker/views/View.js");




function computeMonthRange(range, thisYear) {
  if (!range || !range[0] || !range[1]) {
    return;
  }
  const [[startY, startM], [endY, endM]] = range;
  if (startY > thisYear || endY < thisYear) {
    return;
  }
  return [startY === thisYear ? startM : -1, endY === thisYear ? endM : 12];
}
class MonthsView extends _View_js__WEBPACK_IMPORTED_MODULE_3__["default"] {
  constructor(picker) {
    super(picker, {
      id: 1,
      name: 'months',
      cellClass: 'month'
    });
  }
  init(options, onConstruction = true) {
    if (onConstruction) {
      this.grid = this.element;
      this.element.classList.add('months', 'datepicker-grid');
      this.grid.appendChild((0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.parseHTML)((0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.createTagRepeat)('span', 12, {
        'data-month': ix => ix
      })));
      this.first = 0;
      this.last = 11;
    }
    super.init(options);
  }
  setOptions(options) {
    if (options.locale) {
      this.monthNames = options.locale.monthsShort;
    }
    if ('minDate' in options) {
      if (options.minDate === undefined) {
        this.minYear = this.minMonth = this.minDate = undefined;
      } else {
        const minDateObj = new Date(options.minDate);
        this.minYear = minDateObj.getFullYear();
        this.minMonth = minDateObj.getMonth();
        this.minDate = minDateObj.setDate(1);
      }
    }
    if ('maxDate' in options) {
      if (options.maxDate === undefined) {
        this.maxYear = this.maxMonth = this.maxDate = undefined;
      } else {
        const maxDateObj = new Date(options.maxDate);
        this.maxYear = maxDateObj.getFullYear();
        this.maxMonth = maxDateObj.getMonth();
        this.maxDate = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.dateValue)(this.maxYear, this.maxMonth + 1, 0);
      }
    }
    if (options.checkDisabled) {
      this.checkDisabled = this.isMinView || options.datesDisabled === null ? options.checkDisabled : () => false;
    }
    if ('beforeShowMonth' in options) {
      this.beforeShow = typeof options.beforeShowMonth === 'function' ? options.beforeShowMonth : undefined;
    }
  }

  // Update view's settings to reflect the viewDate set on the picker
  updateFocus() {
    const viewDate = new Date(this.picker.viewDate);
    this.year = viewDate.getFullYear();
    this.focused = viewDate.getMonth();
  }

  // Update view's settings to reflect the selected dates
  updateSelection() {
    const {
      dates,
      rangepicker
    } = this.picker.datepicker;
    this.selected = dates.reduce((selected, timeValue) => {
      const date = new Date(timeValue);
      const year = date.getFullYear();
      const month = date.getMonth();
      if (selected[year] === undefined) {
        selected[year] = [month];
      } else {
        (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.pushUnique)(selected[year], month);
      }
      return selected;
    }, {});
    if (rangepicker && rangepicker.dates) {
      this.range = rangepicker.dates.map(timeValue => {
        const date = new Date(timeValue);
        return isNaN(date) ? undefined : [date.getFullYear(), date.getMonth()];
      });
    }
  }

  // Update the entire view UI
  render() {
    this.prepareForRender(this.year, this.year <= this.minYear, this.year >= this.maxYear);
    const selected = this.selected[this.year] || [];
    const yrOutOfRange = this.year < this.minYear || this.year > this.maxYear;
    const isMinYear = this.year === this.minYear;
    const isMaxYear = this.year === this.maxYear;
    const range = computeMonthRange(this.range, this.year);
    Array.from(this.grid.children).forEach((el, index) => {
      const date = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.regularizeDate)(new Date(this.year, index, 1), 1, this.isRangeEnd);
      this.renderCell(el, this.monthNames[index], index, date, {
        selected,
        range
      }, yrOutOfRange || isMinYear && index < this.minMonth || isMaxYear && index > this.maxMonth);
    });
  }

  // Update the view UI by applying the changes of selected and focused items
  refresh() {
    const selected = this.selected[this.year] || [];
    const range = computeMonthRange(this.range, this.year) || [];
    Array.from(this.grid.children).forEach((el, index) => {
      this.refreshCell(el, index, selected, range);
    });
  }

  // Update the view UI by applying the change of focused item
  refreshFocus() {
    this.changeFocusedCell(this.focused);
  }
}

/***/ }),

/***/ "./node_modules/vanillajs-datepicker/js/picker/views/View.js":
/*!*******************************************************************!*\
  !*** ./node_modules/vanillajs-datepicker/js/picker/views/View.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ View)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/utils.js */ "./node_modules/vanillajs-datepicker/js/lib/utils.js");
/* harmony import */ var _lib_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/dom.js */ "./node_modules/vanillajs-datepicker/js/lib/dom.js");



// Base class of the view classes
class View {
  constructor(picker, config) {
    Object.assign(this, config, {
      picker,
      element: (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_1__.parseHTML)(`<div class="datepicker-view"></div>`).firstChild,
      selected: [],
      isRangeEnd: !!picker.datepicker.rangeSideIndex
    });
    this.init(this.picker.datepicker.config);
  }
  init(options) {
    if ('pickLevel' in options) {
      this.isMinView = this.id === options.pickLevel;
    }
    this.setOptions(options);
    this.updateFocus();
    this.updateSelection();
  }
  prepareForRender(switchLabel, prevButtonDisabled, nextButtonDisabled) {
    // refresh disabled years on every render in order to clear the ones added
    // by beforeShow hook at previous render
    this.disabled = [];
    const picker = this.picker;
    picker.setViewSwitchLabel(switchLabel);
    picker.setPrevButtonDisabled(prevButtonDisabled);
    picker.setNextButtonDisabled(nextButtonDisabled);
  }
  setDisabled(date, classList) {
    classList.add('disabled');
    (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.pushUnique)(this.disabled, date);
  }

  // Execute beforeShow() callback and apply the result to the element
  // args:
  performBeforeHook(el, timeValue) {
    let result = this.beforeShow(new Date(timeValue));
    switch (typeof result) {
      case 'boolean':
        result = {
          enabled: result
        };
        break;
      case 'string':
        result = {
          classes: result
        };
    }
    if (result) {
      const classList = el.classList;
      if (result.enabled === false) {
        this.setDisabled(timeValue, classList);
      }
      if (result.classes) {
        const extraClasses = result.classes.split(/\s+/);
        classList.add(...extraClasses);
        if (extraClasses.includes('disabled')) {
          this.setDisabled(timeValue, classList);
        }
      }
      if (result.content) {
        (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_1__.replaceChildNodes)(el, result.content);
      }
    }
  }
  renderCell(el, content, cellVal, date, {
    selected,
    range
  }, outOfScope, extraClasses = []) {
    el.textContent = content;
    if (this.isMinView) {
      el.dataset.date = date;
    }
    const classList = el.classList;
    el.className = `datepicker-cell ${this.cellClass}`;
    if (cellVal < this.first) {
      classList.add('prev');
    } else if (cellVal > this.last) {
      classList.add('next');
    }
    classList.add(...extraClasses);
    if (outOfScope || this.checkDisabled(date, this.id)) {
      this.setDisabled(date, classList);
    }
    if (range) {
      const [rangeStart, rangeEnd] = range;
      if (cellVal > rangeStart && cellVal < rangeEnd) {
        classList.add('range');
      }
      if (cellVal === rangeStart) {
        classList.add('range-start');
      }
      if (cellVal === rangeEnd) {
        classList.add('range-end');
      }
    }
    if (selected.includes(cellVal)) {
      classList.add('selected');
    }
    if (cellVal === this.focused) {
      classList.add('focused');
    }
    if (this.beforeShow) {
      this.performBeforeHook(el, date);
    }
  }
  refreshCell(el, cellVal, selected, [rangeStart, rangeEnd]) {
    const classList = el.classList;
    classList.remove('range', 'range-start', 'range-end', 'selected', 'focused');
    if (cellVal > rangeStart && cellVal < rangeEnd) {
      classList.add('range');
    }
    if (cellVal === rangeStart) {
      classList.add('range-start');
    }
    if (cellVal === rangeEnd) {
      classList.add('range-end');
    }
    if (selected.includes(cellVal)) {
      classList.add('selected');
    }
    if (cellVal === this.focused) {
      classList.add('focused');
    }
  }
  changeFocusedCell(cellIndex) {
    this.grid.querySelectorAll('.focused').forEach(el => {
      el.classList.remove('focused');
    });
    this.grid.children[cellIndex].classList.add('focused');
  }
}

/***/ }),

/***/ "./node_modules/vanillajs-datepicker/js/picker/views/YearsView.js":
/*!************************************************************************!*\
  !*** ./node_modules/vanillajs-datepicker/js/picker/views/YearsView.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ YearsView)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/utils.js */ "./node_modules/vanillajs-datepicker/js/lib/utils.js");
/* harmony import */ var _lib_date_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/date.js */ "./node_modules/vanillajs-datepicker/js/lib/date.js");
/* harmony import */ var _lib_dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/dom.js */ "./node_modules/vanillajs-datepicker/js/lib/dom.js");
/* harmony import */ var _View_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./View.js */ "./node_modules/vanillajs-datepicker/js/picker/views/View.js");




function toTitleCase(word) {
  return [...word].reduce((str, ch, ix) => str += ix ? ch : ch.toUpperCase(), '');
}

// Class representing the years and decades view elements
class YearsView extends _View_js__WEBPACK_IMPORTED_MODULE_3__["default"] {
  constructor(picker, config) {
    super(picker, config);
  }
  init(options, onConstruction = true) {
    if (onConstruction) {
      this.navStep = this.step * 10;
      this.beforeShowOption = `beforeShow${toTitleCase(this.cellClass)}`;
      this.grid = this.element;
      this.element.classList.add(this.name, 'datepicker-grid');
      this.grid.appendChild((0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.parseHTML)((0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.createTagRepeat)('span', 12)));
    }
    super.init(options);
  }
  setOptions(options) {
    if ('minDate' in options) {
      if (options.minDate === undefined) {
        this.minYear = this.minDate = undefined;
      } else {
        this.minYear = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.startOfYearPeriod)(options.minDate, this.step);
        this.minDate = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.dateValue)(this.minYear, 0, 1);
      }
    }
    if ('maxDate' in options) {
      if (options.maxDate === undefined) {
        this.maxYear = this.maxDate = undefined;
      } else {
        this.maxYear = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.startOfYearPeriod)(options.maxDate, this.step);
        this.maxDate = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.dateValue)(this.maxYear, 11, 31);
      }
    }
    if (options.checkDisabled) {
      this.checkDisabled = this.isMinView || options.datesDisabled === null ? options.checkDisabled : () => false;
    }
    if (this.beforeShowOption in options) {
      const beforeShow = options[this.beforeShowOption];
      this.beforeShow = typeof beforeShow === 'function' ? beforeShow : undefined;
    }
  }

  // Update view's settings to reflect the viewDate set on the picker
  updateFocus() {
    const viewDate = new Date(this.picker.viewDate);
    const first = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.startOfYearPeriod)(viewDate, this.navStep);
    const last = first + 9 * this.step;
    this.first = first;
    this.last = last;
    this.start = first - this.step;
    this.focused = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.startOfYearPeriod)(viewDate, this.step);
  }

  // Update view's settings to reflect the selected dates
  updateSelection() {
    const {
      dates,
      rangepicker
    } = this.picker.datepicker;
    this.selected = dates.reduce((years, timeValue) => {
      return (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.pushUnique)(years, (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.startOfYearPeriod)(timeValue, this.step));
    }, []);
    if (rangepicker && rangepicker.dates) {
      this.range = rangepicker.dates.map(timeValue => {
        if (timeValue !== undefined) {
          return (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.startOfYearPeriod)(timeValue, this.step);
        }
      });
    }
  }

  // Update the entire view UI
  render() {
    this.prepareForRender(`${this.first}-${this.last}`, this.first <= this.minYear, this.last >= this.maxYear);
    Array.from(this.grid.children).forEach((el, index) => {
      const current = this.start + index * this.step;
      const date = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.regularizeDate)(new Date(current, 0, 1), 2, this.isRangeEnd);
      el.dataset.year = current;
      this.renderCell(el, current, current, date, this, current < this.minYear || current > this.maxYear);
    });
  }

  // Update the view UI by applying the changes of selected and focused items
  refresh() {
    const range = this.range || [];
    Array.from(this.grid.children).forEach(el => {
      this.refreshCell(el, Number(el.textContent), this.selected, range);
    });
  }

  // Update the view UI by applying the change of focused item
  refreshFocus() {
    this.changeFocusedCell(Math.round((this.focused - this.start) / this.step));
  }
}

/***/ }),

/***/ "./node_modules/choices.js/public/assets/scripts/choices.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/choices.js/public/assets/scripts/choices.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Choices)
/* harmony export */ });
/*! choices.js v11.0.2 | © 2024 Josh Johnson | https://github.com/jshjohnson/Choices#readme */

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var ActionType = {
    ADD_CHOICE: 'ADD_CHOICE',
    REMOVE_CHOICE: 'REMOVE_CHOICE',
    FILTER_CHOICES: 'FILTER_CHOICES',
    ACTIVATE_CHOICES: 'ACTIVATE_CHOICES',
    CLEAR_CHOICES: 'CLEAR_CHOICES',
    ADD_GROUP: 'ADD_GROUP',
    ADD_ITEM: 'ADD_ITEM',
    REMOVE_ITEM: 'REMOVE_ITEM',
    HIGHLIGHT_ITEM: 'HIGHLIGHT_ITEM',
};

var EventType = {
    showDropdown: 'showDropdown',
    hideDropdown: 'hideDropdown',
    change: 'change',
    choice: 'choice',
    search: 'search',
    addItem: 'addItem',
    removeItem: 'removeItem',
    highlightItem: 'highlightItem',
    highlightChoice: 'highlightChoice',
    unhighlightItem: 'unhighlightItem',
};

var ObjectsInConfig = ['fuseOptions', 'classNames'];

var PassedElementTypes = {
    Text: 'text',
    SelectOne: 'select-one',
    SelectMultiple: 'select-multiple',
};

var addChoice = function (choice) { return ({
    type: ActionType.ADD_CHOICE,
    choice: choice,
}); };
var removeChoice = function (choice) { return ({
    type: ActionType.REMOVE_CHOICE,
    choice: choice,
}); };
var filterChoices = function (results) { return ({
    type: ActionType.FILTER_CHOICES,
    results: results,
}); };
var activateChoices = function (active) {
    return ({
        type: ActionType.ACTIVATE_CHOICES,
        active: active,
    });
};

var addGroup = function (group) { return ({
    type: ActionType.ADD_GROUP,
    group: group,
}); };

var addItem = function (item) { return ({
    type: ActionType.ADD_ITEM,
    item: item,
}); };
var removeItem$1 = function (item) { return ({
    type: ActionType.REMOVE_ITEM,
    item: item,
}); };
var highlightItem = function (item, highlighted) { return ({
    type: ActionType.HIGHLIGHT_ITEM,
    item: item,
    highlighted: highlighted,
}); };

var getRandomNumber = function (min, max) { return Math.floor(Math.random() * (max - min) + min); };
var generateChars = function (length) {
    return Array.from({ length: length }, function () { return getRandomNumber(0, 36).toString(36); }).join('');
};
var generateId = function (element, prefix) {
    var id = element.id || (element.name && "".concat(element.name, "-").concat(generateChars(2))) || generateChars(4);
    id = id.replace(/(:|\.|\[|\]|,)/g, '');
    id = "".concat(prefix, "-").concat(id);
    return id;
};
var getAdjacentEl = function (startEl, selector, direction) {
    if (direction === void 0) { direction = 1; }
    var prop = "".concat(direction > 0 ? 'next' : 'previous', "ElementSibling");
    var sibling = startEl[prop];
    while (sibling) {
        if (sibling.matches(selector)) {
            return sibling;
        }
        sibling = sibling[prop];
    }
    return null;
};
var isScrolledIntoView = function (element, parent, direction) {
    if (direction === void 0) { direction = 1; }
    var isVisible;
    if (direction > 0) {
        // In view from bottom
        isVisible = parent.scrollTop + parent.offsetHeight >= element.offsetTop + element.offsetHeight;
    }
    else {
        // In view from top
        isVisible = element.offsetTop >= parent.scrollTop;
    }
    return isVisible;
};
var sanitise = function (value) {
    if (typeof value !== 'string') {
        if (value === null || value === undefined) {
            return '';
        }
        if (typeof value === 'object') {
            if ('raw' in value) {
                return sanitise(value.raw);
            }
            if ('trusted' in value) {
                return value.trusted;
            }
        }
        return value;
    }
    return value
        .replace(/&/g, '&amp;')
        .replace(/>/g, '&gt;')
        .replace(/</g, '&lt;')
        .replace(/'/g, '&#039;')
        .replace(/"/g, '&quot;');
};
var strToEl = (function () {
    var tmpEl = document.createElement('div');
    return function (str) {
        tmpEl.innerHTML = str.trim();
        var firstChild = tmpEl.children[0];
        while (tmpEl.firstChild) {
            tmpEl.removeChild(tmpEl.firstChild);
        }
        return firstChild;
    };
})();
var resolveNoticeFunction = function (fn, value) {
    return typeof fn === 'function' ? fn(sanitise(value), value) : fn;
};
var resolveStringFunction = function (fn) {
    return typeof fn === 'function' ? fn() : fn;
};
var unwrapStringForRaw = function (s) {
    if (typeof s === 'string') {
        return s;
    }
    if (typeof s === 'object') {
        if ('trusted' in s) {
            return s.trusted;
        }
        if ('raw' in s) {
            return s.raw;
        }
    }
    return '';
};
var unwrapStringForEscaped = function (s) {
    if (typeof s === 'string') {
        return s;
    }
    if (typeof s === 'object') {
        if ('escaped' in s) {
            return s.escaped;
        }
        if ('trusted' in s) {
            return s.trusted;
        }
    }
    return '';
};
var escapeForTemplate = function (allowHTML, s) {
    return allowHTML ? unwrapStringForEscaped(s) : sanitise(s);
};
var setElementHtml = function (el, allowHtml, html) {
    el.innerHTML = escapeForTemplate(allowHtml, html);
};
var sortByAlpha = function (_a, _b) {
    var value = _a.value, _c = _a.label, label = _c === void 0 ? value : _c;
    var value2 = _b.value, _d = _b.label, label2 = _d === void 0 ? value2 : _d;
    return unwrapStringForRaw(label).localeCompare(unwrapStringForRaw(label2), [], {
        sensitivity: 'base',
        ignorePunctuation: true,
        numeric: true,
    });
};
var sortByRank = function (a, b) {
    return a.rank - b.rank;
};
var dispatchEvent = function (element, type, customArgs) {
    if (customArgs === void 0) { customArgs = null; }
    var event = new CustomEvent(type, {
        detail: customArgs,
        bubbles: true,
        cancelable: true,
    });
    return element.dispatchEvent(event);
};
/**
 * Returns an array of keys present on the first but missing on the second object
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
var diff = function (a, b) {
    var aKeys = Object.keys(a).sort();
    var bKeys = Object.keys(b).sort();
    return aKeys.filter(function (i) { return bKeys.indexOf(i) < 0; });
};
var getClassNames = function (ClassNames) {
    return Array.isArray(ClassNames) ? ClassNames : [ClassNames];
};
var getClassNamesSelector = function (option) {
    if (option && Array.isArray(option)) {
        return option
            .map(function (item) {
            return ".".concat(item);
        })
            .join('');
    }
    return ".".concat(option);
};
var addClassesToElement = function (element, className) {
    var _a;
    (_a = element.classList).add.apply(_a, getClassNames(className));
};
var removeClassesFromElement = function (element, className) {
    var _a;
    (_a = element.classList).remove.apply(_a, getClassNames(className));
};
var parseCustomProperties = function (customProperties) {
    if (typeof customProperties !== 'undefined') {
        try {
            return JSON.parse(customProperties);
        }
        catch (e) {
            return customProperties;
        }
    }
    return {};
};
var updateClassList = function (item, add, remove) {
    var itemEl = item.itemEl;
    if (itemEl) {
        removeClassesFromElement(itemEl, remove);
        addClassesToElement(itemEl, add);
    }
};

var Dropdown = /** @class */ (function () {
    function Dropdown(_a) {
        var element = _a.element, type = _a.type, classNames = _a.classNames;
        this.element = element;
        this.classNames = classNames;
        this.type = type;
        this.isActive = false;
    }
    /**
     * Show dropdown to user by adding active state class
     */
    Dropdown.prototype.show = function () {
        addClassesToElement(this.element, this.classNames.activeState);
        this.element.setAttribute('aria-expanded', 'true');
        this.isActive = true;
        return this;
    };
    /**
     * Hide dropdown from user
     */
    Dropdown.prototype.hide = function () {
        removeClassesFromElement(this.element, this.classNames.activeState);
        this.element.setAttribute('aria-expanded', 'false');
        this.isActive = false;
        return this;
    };
    return Dropdown;
}());

var Container = /** @class */ (function () {
    function Container(_a) {
        var element = _a.element, type = _a.type, classNames = _a.classNames, position = _a.position;
        this.element = element;
        this.classNames = classNames;
        this.type = type;
        this.position = position;
        this.isOpen = false;
        this.isFlipped = false;
        this.isDisabled = false;
        this.isLoading = false;
    }
    /**
     * Determine whether container should be flipped based on passed
     * dropdown position
     */
    Container.prototype.shouldFlip = function (dropdownPos, dropdownHeight) {
        // If flip is enabled and the dropdown bottom position is
        // greater than the window height flip the dropdown.
        var shouldFlip = false;
        if (this.position === 'auto') {
            shouldFlip =
                this.element.getBoundingClientRect().top - dropdownHeight >= 0 &&
                    !window.matchMedia("(min-height: ".concat(dropdownPos + 1, "px)")).matches;
        }
        else if (this.position === 'top') {
            shouldFlip = true;
        }
        return shouldFlip;
    };
    Container.prototype.setActiveDescendant = function (activeDescendantID) {
        this.element.setAttribute('aria-activedescendant', activeDescendantID);
    };
    Container.prototype.removeActiveDescendant = function () {
        this.element.removeAttribute('aria-activedescendant');
    };
    Container.prototype.open = function (dropdownPos, dropdownHeight) {
        addClassesToElement(this.element, this.classNames.openState);
        this.element.setAttribute('aria-expanded', 'true');
        this.isOpen = true;
        if (this.shouldFlip(dropdownPos, dropdownHeight)) {
            addClassesToElement(this.element, this.classNames.flippedState);
            this.isFlipped = true;
        }
    };
    Container.prototype.close = function () {
        removeClassesFromElement(this.element, this.classNames.openState);
        this.element.setAttribute('aria-expanded', 'false');
        this.removeActiveDescendant();
        this.isOpen = false;
        // A dropdown flips if it does not have space within the page
        if (this.isFlipped) {
            removeClassesFromElement(this.element, this.classNames.flippedState);
            this.isFlipped = false;
        }
    };
    Container.prototype.addFocusState = function () {
        addClassesToElement(this.element, this.classNames.focusState);
    };
    Container.prototype.removeFocusState = function () {
        removeClassesFromElement(this.element, this.classNames.focusState);
    };
    Container.prototype.enable = function () {
        removeClassesFromElement(this.element, this.classNames.disabledState);
        this.element.removeAttribute('aria-disabled');
        if (this.type === PassedElementTypes.SelectOne) {
            this.element.setAttribute('tabindex', '0');
        }
        this.isDisabled = false;
    };
    Container.prototype.disable = function () {
        addClassesToElement(this.element, this.classNames.disabledState);
        this.element.setAttribute('aria-disabled', 'true');
        if (this.type === PassedElementTypes.SelectOne) {
            this.element.setAttribute('tabindex', '-1');
        }
        this.isDisabled = true;
    };
    Container.prototype.wrap = function (element) {
        var el = this.element;
        var parentNode = element.parentNode;
        if (parentNode) {
            if (element.nextSibling) {
                parentNode.insertBefore(el, element.nextSibling);
            }
            else {
                parentNode.appendChild(el);
            }
        }
        el.appendChild(element);
    };
    Container.prototype.unwrap = function (element) {
        var el = this.element;
        var parentNode = el.parentNode;
        if (parentNode) {
            // Move passed element outside this element
            parentNode.insertBefore(element, el);
            // Remove this element
            parentNode.removeChild(el);
        }
    };
    Container.prototype.addLoadingState = function () {
        addClassesToElement(this.element, this.classNames.loadingState);
        this.element.setAttribute('aria-busy', 'true');
        this.isLoading = true;
    };
    Container.prototype.removeLoadingState = function () {
        removeClassesFromElement(this.element, this.classNames.loadingState);
        this.element.removeAttribute('aria-busy');
        this.isLoading = false;
    };
    return Container;
}());

var Input = /** @class */ (function () {
    function Input(_a) {
        var element = _a.element, type = _a.type, classNames = _a.classNames, preventPaste = _a.preventPaste;
        this.element = element;
        this.type = type;
        this.classNames = classNames;
        this.preventPaste = preventPaste;
        this.isFocussed = this.element.isEqualNode(document.activeElement);
        this.isDisabled = element.disabled;
        this._onPaste = this._onPaste.bind(this);
        this._onInput = this._onInput.bind(this);
        this._onFocus = this._onFocus.bind(this);
        this._onBlur = this._onBlur.bind(this);
    }
    Object.defineProperty(Input.prototype, "placeholder", {
        set: function (placeholder) {
            this.element.placeholder = placeholder;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Input.prototype, "value", {
        get: function () {
            return this.element.value;
        },
        set: function (value) {
            this.element.value = value;
        },
        enumerable: false,
        configurable: true
    });
    Input.prototype.addEventListeners = function () {
        var el = this.element;
        el.addEventListener('paste', this._onPaste);
        el.addEventListener('input', this._onInput, {
            passive: true,
        });
        el.addEventListener('focus', this._onFocus, {
            passive: true,
        });
        el.addEventListener('blur', this._onBlur, {
            passive: true,
        });
    };
    Input.prototype.removeEventListeners = function () {
        var el = this.element;
        el.removeEventListener('input', this._onInput);
        el.removeEventListener('paste', this._onPaste);
        el.removeEventListener('focus', this._onFocus);
        el.removeEventListener('blur', this._onBlur);
    };
    Input.prototype.enable = function () {
        var el = this.element;
        el.removeAttribute('disabled');
        this.isDisabled = false;
    };
    Input.prototype.disable = function () {
        var el = this.element;
        el.setAttribute('disabled', '');
        this.isDisabled = true;
    };
    Input.prototype.focus = function () {
        if (!this.isFocussed) {
            this.element.focus();
        }
    };
    Input.prototype.blur = function () {
        if (this.isFocussed) {
            this.element.blur();
        }
    };
    Input.prototype.clear = function (setWidth) {
        if (setWidth === void 0) { setWidth = true; }
        this.element.value = '';
        if (setWidth) {
            this.setWidth();
        }
        return this;
    };
    /**
     * Set the correct input width based on placeholder
     * value or input value
     */
    Input.prototype.setWidth = function () {
        // Resize input to contents or placeholder
        var element = this.element;
        element.style.minWidth = "".concat(element.placeholder.length + 1, "ch");
        element.style.width = "".concat(element.value.length + 1, "ch");
    };
    Input.prototype.setActiveDescendant = function (activeDescendantID) {
        this.element.setAttribute('aria-activedescendant', activeDescendantID);
    };
    Input.prototype.removeActiveDescendant = function () {
        this.element.removeAttribute('aria-activedescendant');
    };
    Input.prototype._onInput = function () {
        if (this.type !== PassedElementTypes.SelectOne) {
            this.setWidth();
        }
    };
    Input.prototype._onPaste = function (event) {
        if (this.preventPaste) {
            event.preventDefault();
        }
    };
    Input.prototype._onFocus = function () {
        this.isFocussed = true;
    };
    Input.prototype._onBlur = function () {
        this.isFocussed = false;
    };
    return Input;
}());

var SCROLLING_SPEED = 4;

var List = /** @class */ (function () {
    function List(_a) {
        var element = _a.element;
        this.element = element;
        this.scrollPos = this.element.scrollTop;
        this.height = this.element.offsetHeight;
    }
    List.prototype.prepend = function (node) {
        var child = this.element.firstElementChild;
        if (child) {
            this.element.insertBefore(node, child);
        }
        else {
            this.element.append(node);
        }
    };
    List.prototype.scrollToTop = function () {
        this.element.scrollTop = 0;
    };
    List.prototype.scrollToChildElement = function (element, direction) {
        var _this = this;
        if (!element) {
            return;
        }
        var listHeight = this.element.offsetHeight;
        // Scroll position of dropdown
        var listScrollPosition = this.element.scrollTop + listHeight;
        var elementHeight = element.offsetHeight;
        // Distance from bottom of element to top of parent
        var elementPos = element.offsetTop + elementHeight;
        // Difference between the element and scroll position
        var destination = direction > 0 ? this.element.scrollTop + elementPos - listScrollPosition : element.offsetTop;
        requestAnimationFrame(function () {
            _this._animateScroll(destination, direction);
        });
    };
    List.prototype._scrollDown = function (scrollPos, strength, destination) {
        var easing = (destination - scrollPos) / strength;
        var distance = easing > 1 ? easing : 1;
        this.element.scrollTop = scrollPos + distance;
    };
    List.prototype._scrollUp = function (scrollPos, strength, destination) {
        var easing = (scrollPos - destination) / strength;
        var distance = easing > 1 ? easing : 1;
        this.element.scrollTop = scrollPos - distance;
    };
    List.prototype._animateScroll = function (destination, direction) {
        var _this = this;
        var strength = SCROLLING_SPEED;
        var choiceListScrollTop = this.element.scrollTop;
        var continueAnimation = false;
        if (direction > 0) {
            this._scrollDown(choiceListScrollTop, strength, destination);
            if (choiceListScrollTop < destination) {
                continueAnimation = true;
            }
        }
        else {
            this._scrollUp(choiceListScrollTop, strength, destination);
            if (choiceListScrollTop > destination) {
                continueAnimation = true;
            }
        }
        if (continueAnimation) {
            requestAnimationFrame(function () {
                _this._animateScroll(destination, direction);
            });
        }
    };
    return List;
}());

var WrappedElement = /** @class */ (function () {
    function WrappedElement(_a) {
        var element = _a.element, classNames = _a.classNames;
        this.element = element;
        this.classNames = classNames;
        this.isDisabled = false;
    }
    Object.defineProperty(WrappedElement.prototype, "isActive", {
        get: function () {
            return this.element.dataset.choice === 'active';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WrappedElement.prototype, "dir", {
        get: function () {
            return this.element.dir;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WrappedElement.prototype, "value", {
        get: function () {
            return this.element.value;
        },
        set: function (value) {
            this.element.setAttribute('value', value);
            this.element.value = value;
        },
        enumerable: false,
        configurable: true
    });
    WrappedElement.prototype.conceal = function () {
        var el = this.element;
        // Hide passed input
        addClassesToElement(el, this.classNames.input);
        el.hidden = true;
        // Remove element from tab index
        el.tabIndex = -1;
        // Backup original styles if any
        var origStyle = el.getAttribute('style');
        if (origStyle) {
            el.setAttribute('data-choice-orig-style', origStyle);
        }
        el.setAttribute('data-choice', 'active');
    };
    WrappedElement.prototype.reveal = function () {
        var el = this.element;
        // Reinstate passed element
        removeClassesFromElement(el, this.classNames.input);
        el.hidden = false;
        el.removeAttribute('tabindex');
        // Recover original styles if any
        var origStyle = el.getAttribute('data-choice-orig-style');
        if (origStyle) {
            el.removeAttribute('data-choice-orig-style');
            el.setAttribute('style', origStyle);
        }
        else {
            el.removeAttribute('style');
        }
        el.removeAttribute('data-choice');
    };
    WrappedElement.prototype.enable = function () {
        this.element.removeAttribute('disabled');
        this.element.disabled = false;
        this.isDisabled = false;
    };
    WrappedElement.prototype.disable = function () {
        this.element.setAttribute('disabled', '');
        this.element.disabled = true;
        this.isDisabled = true;
    };
    WrappedElement.prototype.triggerEvent = function (eventType, data) {
        dispatchEvent(this.element, eventType, data || {});
    };
    return WrappedElement;
}());

var WrappedInput = /** @class */ (function (_super) {
    __extends(WrappedInput, _super);
    function WrappedInput() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return WrappedInput;
}(WrappedElement));

var coerceBool = function (arg, defaultValue) {
    if (defaultValue === void 0) { defaultValue = true; }
    return typeof arg === 'undefined' ? defaultValue : !!arg;
};
var stringToHtmlClass = function (input) {
    if (typeof input === 'string') {
        // eslint-disable-next-line no-param-reassign
        input = input.split(' ').filter(function (s) { return s.length; });
    }
    if (Array.isArray(input) && input.length) {
        return input;
    }
    return undefined;
};
var mapInputToChoice = function (value, allowGroup) {
    if (typeof value === 'string') {
        var result_1 = mapInputToChoice({
            value: value,
            label: value,
        }, false);
        return result_1;
    }
    var groupOrChoice = value;
    if ('choices' in groupOrChoice) {
        if (!allowGroup) {
            // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/optgroup
            throw new TypeError("optGroup is not allowed");
        }
        var group = groupOrChoice;
        var choices = group.choices.map(function (e) { return mapInputToChoice(e, false); });
        var result_2 = {
            id: 0, // actual ID will be assigned during _addGroup
            label: unwrapStringForRaw(group.label) || group.value,
            active: !!choices.length,
            disabled: !!group.disabled,
            choices: choices,
        };
        return result_2;
    }
    var choice = groupOrChoice;
    var result = {
        id: 0, // actual ID will be assigned during _addChoice
        group: null, // actual group will be assigned during _addGroup but before _addChoice
        score: 0, // used in search
        rank: 0, // used in search, stable sort order
        value: choice.value,
        label: choice.label || choice.value,
        active: coerceBool(choice.active),
        selected: coerceBool(choice.selected, false),
        disabled: coerceBool(choice.disabled, false),
        placeholder: coerceBool(choice.placeholder, false),
        highlighted: false,
        labelClass: stringToHtmlClass(choice.labelClass),
        labelDescription: choice.labelDescription,
        customProperties: choice.customProperties,
    };
    return result;
};

var isHtmlInputElement = function (e) { return e.tagName === 'INPUT'; };
var isHtmlSelectElement = function (e) { return e.tagName === 'SELECT'; };
var isHtmlOption = function (e) { return e.tagName === 'OPTION'; };
var isHtmlOptgroup = function (e) { return e.tagName === 'OPTGROUP'; };

var WrappedSelect = /** @class */ (function (_super) {
    __extends(WrappedSelect, _super);
    function WrappedSelect(_a) {
        var element = _a.element, classNames = _a.classNames, template = _a.template, extractPlaceholder = _a.extractPlaceholder;
        var _this = _super.call(this, { element: element, classNames: classNames }) || this;
        _this.template = template;
        _this.extractPlaceholder = extractPlaceholder;
        return _this;
    }
    Object.defineProperty(WrappedSelect.prototype, "placeholderOption", {
        get: function () {
            return (this.element.querySelector('option[value=""]') ||
                // Backward compatibility layer for the non-standard placeholder attribute supported in older versions.
                this.element.querySelector('option[placeholder]'));
        },
        enumerable: false,
        configurable: true
    });
    WrappedSelect.prototype.addOptions = function (choices) {
        var _this = this;
        var fragment = document.createDocumentFragment();
        choices.forEach(function (obj) {
            var choice = obj;
            if (choice.element) {
                return;
            }
            var option = _this.template(choice);
            fragment.appendChild(option);
            choice.element = option;
        });
        this.element.appendChild(fragment);
    };
    WrappedSelect.prototype.optionsAsChoices = function () {
        var _this = this;
        var choices = [];
        this.element.querySelectorAll(':scope > option, :scope > optgroup').forEach(function (e) {
            if (isHtmlOption(e)) {
                choices.push(_this._optionToChoice(e));
            }
            else if (isHtmlOptgroup(e)) {
                choices.push(_this._optgroupToChoice(e));
            }
            // todo: hr as empty optgroup, requires displaying empty opt-groups to be useful
        });
        return choices;
    };
    // eslint-disable-next-line class-methods-use-this
    WrappedSelect.prototype._optionToChoice = function (option) {
        // option.value returns the label if there is no value attribute, which can break legacy placeholder attribute support
        if (!option.hasAttribute('value') && option.hasAttribute('placeholder')) {
            option.setAttribute('value', '');
            option.value = '';
        }
        return {
            id: 0,
            group: null,
            score: 0,
            rank: 0,
            value: option.value,
            label: option.innerHTML,
            element: option,
            active: true,
            // this returns true if nothing is selected on initial load, which will break placeholder support
            selected: this.extractPlaceholder ? option.selected : option.hasAttribute('selected'),
            disabled: option.disabled,
            highlighted: false,
            placeholder: this.extractPlaceholder && (!option.value || option.hasAttribute('placeholder')),
            labelClass: typeof option.dataset.labelClass !== 'undefined' ? stringToHtmlClass(option.dataset.labelClass) : undefined,
            labelDescription: typeof option.dataset.labelDescription !== 'undefined' ? option.dataset.labelDescription : undefined,
            customProperties: parseCustomProperties(option.dataset.customProperties),
        };
    };
    WrappedSelect.prototype._optgroupToChoice = function (optgroup) {
        var _this = this;
        var options = optgroup.querySelectorAll('option');
        var choices = Array.from(options).map(function (option) { return _this._optionToChoice(option); });
        return {
            id: 0,
            label: optgroup.label || '',
            element: optgroup,
            active: !!choices.length,
            disabled: optgroup.disabled,
            choices: choices,
        };
    };
    return WrappedSelect;
}(WrappedElement));

var DEFAULT_CLASSNAMES = {
    containerOuter: ['choices'],
    containerInner: ['choices__inner'],
    input: ['choices__input'],
    inputCloned: ['choices__input--cloned'],
    list: ['choices__list'],
    listItems: ['choices__list--multiple'],
    listSingle: ['choices__list--single'],
    listDropdown: ['choices__list--dropdown'],
    item: ['choices__item'],
    itemSelectable: ['choices__item--selectable'],
    itemDisabled: ['choices__item--disabled'],
    itemChoice: ['choices__item--choice'],
    description: ['choices__description'],
    placeholder: ['choices__placeholder'],
    group: ['choices__group'],
    groupHeading: ['choices__heading'],
    button: ['choices__button'],
    activeState: ['is-active'],
    focusState: ['is-focused'],
    openState: ['is-open'],
    disabledState: ['is-disabled'],
    highlightedState: ['is-highlighted'],
    selectedState: ['is-selected'],
    flippedState: ['is-flipped'],
    loadingState: ['is-loading'],
    notice: ['choices__notice'],
    addChoice: ['choices__item--selectable', 'add-choice'],
    noResults: ['has-no-results'],
    noChoices: ['has-no-choices'],
};
var DEFAULT_CONFIG = {
    items: [],
    choices: [],
    silent: false,
    renderChoiceLimit: -1,
    maxItemCount: -1,
    closeDropdownOnSelect: 'auto',
    singleModeForMultiSelect: false,
    addChoices: false,
    addItems: true,
    addItemFilter: function (value) { return !!value && value !== ''; },
    removeItems: true,
    removeItemButton: false,
    removeItemButtonAlignLeft: false,
    editItems: false,
    allowHTML: false,
    allowHtmlUserInput: false,
    duplicateItemsAllowed: true,
    delimiter: ',',
    paste: true,
    searchEnabled: true,
    searchChoices: true,
    searchFloor: 1,
    searchResultLimit: 4,
    searchFields: ['label', 'value'],
    position: 'auto',
    resetScrollPosition: true,
    shouldSort: true,
    shouldSortItems: false,
    sorter: sortByAlpha,
    shadowRoot: null,
    placeholder: true,
    placeholderValue: null,
    searchPlaceholderValue: null,
    prependValue: null,
    appendValue: null,
    renderSelectedChoices: 'auto',
    loadingText: 'Loading...',
    noResultsText: 'No results found',
    noChoicesText: 'No choices to choose from',
    itemSelectText: 'Press to select',
    uniqueItemText: 'Only unique values can be added',
    customAddItemText: 'Only values matching specific conditions can be added',
    addItemText: function (value) { return "Press Enter to add <b>\"".concat(value, "\"</b>"); },
    removeItemIconText: function () { return "Remove item"; },
    removeItemLabelText: function (value) { return "Remove item: ".concat(value); },
    maxItemText: function (maxItemCount) { return "Only ".concat(maxItemCount, " values can be added"); },
    valueComparer: function (value1, value2) { return value1 === value2; },
    fuseOptions: {
        includeScore: true,
    },
    labelId: '',
    callbackOnInit: null,
    callbackOnCreateTemplates: null,
    classNames: DEFAULT_CLASSNAMES,
    appendGroupInSearch: false,
};

var removeItem = function (item) {
    var itemEl = item.itemEl;
    if (itemEl) {
        itemEl.remove();
        item.itemEl = undefined;
    }
};
function items(s, action, context) {
    var state = s;
    var update = true;
    switch (action.type) {
        case ActionType.ADD_ITEM: {
            action.item.selected = true;
            var el = action.item.element;
            if (el) {
                el.selected = true;
                el.setAttribute('selected', '');
            }
            state.push(action.item);
            break;
        }
        case ActionType.REMOVE_ITEM: {
            action.item.selected = false;
            var el = action.item.element;
            if (el) {
                el.selected = false;
                el.removeAttribute('selected');
                // For a select-one, if all options are deselected, the first item is selected. To set a black value, select.value needs to be set
                var select = el.parentElement;
                if (select && isHtmlSelectElement(select) && select.type === PassedElementTypes.SelectOne) {
                    select.value = '';
                }
            }
            // this is mixing concerns, but this is *so much faster*
            removeItem(action.item);
            state = state.filter(function (choice) { return choice.id !== action.item.id; });
            break;
        }
        case ActionType.REMOVE_CHOICE: {
            removeItem(action.choice);
            state = state.filter(function (item) { return item.id !== action.choice.id; });
            break;
        }
        case ActionType.HIGHLIGHT_ITEM: {
            var highlighted = action.highlighted;
            var item = state.find(function (obj) { return obj.id === action.item.id; });
            if (item && item.highlighted !== highlighted) {
                item.highlighted = highlighted;
                if (context) {
                    updateClassList(item, highlighted ? context.classNames.highlightedState : context.classNames.selectedState, highlighted ? context.classNames.selectedState : context.classNames.highlightedState);
                }
            }
            break;
        }
        default: {
            update = false;
            break;
        }
    }
    return { state: state, update: update };
}

function groups(s, action) {
    var state = s;
    var update = true;
    switch (action.type) {
        case ActionType.ADD_GROUP: {
            state.push(action.group);
            break;
        }
        case ActionType.CLEAR_CHOICES: {
            state = [];
            break;
        }
        default: {
            update = false;
            break;
        }
    }
    return { state: state, update: update };
}

/* eslint-disable */
function choices(s, action, context) {
    var state = s;
    var update = true;
    switch (action.type) {
        case ActionType.ADD_CHOICE: {
            state.push(action.choice);
            break;
        }
        case ActionType.REMOVE_CHOICE: {
            action.choice.choiceEl = undefined;
            if (action.choice.group) {
                action.choice.group.choices = action.choice.group.choices.filter(function (obj) { return obj.id !== action.choice.id; });
            }
            state = state.filter(function (obj) { return obj.id !== action.choice.id; });
            break;
        }
        case ActionType.ADD_ITEM:
        case ActionType.REMOVE_ITEM: {
            action.item.choiceEl = undefined;
            break;
        }
        case ActionType.FILTER_CHOICES: {
            // avoid O(n^2) algorithm complexity when searching/filtering choices
            var scoreLookup_1 = [];
            action.results.forEach(function (result) {
                scoreLookup_1[result.item.id] = result;
            });
            state.forEach(function (choice) {
                var result = scoreLookup_1[choice.id];
                if (result !== undefined) {
                    choice.score = result.score;
                    choice.rank = result.rank;
                    choice.active = true;
                }
                else {
                    choice.score = 0;
                    choice.rank = 0;
                    choice.active = false;
                }
                if (context && context.appendGroupInSearch) {
                    choice.choiceEl = undefined;
                }
            });
            break;
        }
        case ActionType.ACTIVATE_CHOICES: {
            state.forEach(function (choice) {
                choice.active = action.active;
                if (context && context.appendGroupInSearch) {
                    choice.choiceEl = undefined;
                }
            });
            break;
        }
        case ActionType.CLEAR_CHOICES: {
            state = [];
            break;
        }
        default: {
            update = false;
            break;
        }
    }
    return { state: state, update: update };
}

var reducers = {
    groups: groups,
    items: items,
    choices: choices,
};
var Store = /** @class */ (function () {
    function Store(context) {
        this._state = this.defaultState;
        this._listeners = [];
        this._txn = 0;
        this._context = context;
    }
    Object.defineProperty(Store.prototype, "defaultState", {
        // eslint-disable-next-line class-methods-use-this
        get: function () {
            return {
                groups: [],
                items: [],
                choices: [],
            };
        },
        enumerable: false,
        configurable: true
    });
    // eslint-disable-next-line class-methods-use-this
    Store.prototype.changeSet = function (init) {
        return {
            groups: init,
            items: init,
            choices: init,
        };
    };
    Store.prototype.reset = function () {
        this._state = this.defaultState;
        var changes = this.changeSet(true);
        if (this._txn) {
            this._changeSet = changes;
        }
        else {
            this._listeners.forEach(function (l) { return l(changes); });
        }
    };
    Store.prototype.subscribe = function (onChange) {
        this._listeners.push(onChange);
        return this;
    };
    Store.prototype.dispatch = function (action) {
        var _this = this;
        var state = this._state;
        var hasChanges = false;
        var changes = this._changeSet || this.changeSet(false);
        Object.keys(reducers).forEach(function (key) {
            var stateUpdate = reducers[key](state[key], action, _this._context);
            if (stateUpdate.update) {
                hasChanges = true;
                changes[key] = true;
                state[key] = stateUpdate.state;
            }
        });
        if (hasChanges) {
            if (this._txn) {
                this._changeSet = changes;
            }
            else {
                this._listeners.forEach(function (l) { return l(changes); });
            }
        }
    };
    Store.prototype.withTxn = function (func) {
        this._txn++;
        try {
            func();
        }
        finally {
            this._txn = Math.max(0, this._txn - 1);
            if (!this._txn) {
                var changeSet_1 = this._changeSet;
                if (changeSet_1) {
                    this._changeSet = undefined;
                    this._listeners.forEach(function (l) { return l(changeSet_1); });
                }
            }
        }
    };
    Object.defineProperty(Store.prototype, "state", {
        /**
         * Get store object
         */
        get: function () {
            return this._state;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "items", {
        /**
         * Get items from store
         */
        get: function () {
            return this.state.items;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "highlightedActiveItems", {
        /**
         * Get highlighted items from store
         */
        get: function () {
            return this.items.filter(function (item) { return !item.disabled && item.active && item.highlighted; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "choices", {
        /**
         * Get choices from store
         */
        get: function () {
            return this.state.choices;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "activeChoices", {
        /**
         * Get active choices from store
         */
        get: function () {
            return this.choices.filter(function (choice) { return choice.active; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "searchableChoices", {
        /**
         * Get choices that can be searched (excluding placeholders)
         */
        get: function () {
            return this.choices.filter(function (choice) { return !choice.disabled && !choice.placeholder; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "groups", {
        /**
         * Get groups from store
         */
        get: function () {
            return this.state.groups;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "activeGroups", {
        /**
         * Get active groups from store
         */
        get: function () {
            var _this = this;
            return this.state.groups.filter(function (group) {
                var isActive = group.active && !group.disabled;
                var hasActiveOptions = _this.state.choices.some(function (choice) { return choice.active && !choice.disabled; });
                return isActive && hasActiveOptions;
            }, []);
        },
        enumerable: false,
        configurable: true
    });
    Store.prototype.inTxn = function () {
        return this._txn > 0;
    };
    /**
     * Get single choice by it's ID
     */
    Store.prototype.getChoiceById = function (id) {
        return this.activeChoices.find(function (choice) { return choice.id === id; });
    };
    /**
     * Get group by group id
     */
    Store.prototype.getGroupById = function (id) {
        return this.groups.find(function (group) { return group.id === id; });
    };
    return Store;
}());

var NoticeTypes = {
    noChoices: 'no-choices',
    noResults: 'no-results',
    addChoice: 'add-choice',
    generic: '',
};

function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}

/**
 * Fuse.js v7.0.0 - Lightweight fuzzy-search (http://fusejs.io)
 *
 * Copyright (c) 2023 Kiro Risk (http://kiro.me)
 * All Rights Reserved. Apache Software License 2.0
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

function isArray(value) {
  return !Array.isArray ? getTag(value) === '[object Array]' : Array.isArray(value);
}

// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js
const INFINITY = 1 / 0;
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  let result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
function toString(value) {
  return value == null ? '' : baseToString(value);
}
function isString(value) {
  return typeof value === 'string';
}
function isNumber(value) {
  return typeof value === 'number';
}

// Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == '[object Boolean]';
}
function isObject(value) {
  return typeof value === 'object';
}

// Checks if `value` is object-like.
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== undefined && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}

// Gets the `toStringTag` of `value`.
// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js
function getTag(value) {
  return value == null ? value === undefined ? '[object Undefined]' : '[object Null]' : Object.prototype.toString.call(value);
}
const EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';
const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = key => `Invalid value for key ${key}`;
const PATTERN_LENGTH_TOO_LARGE = max => `Pattern length exceeds max of ${max}.`;
const MISSING_KEY_PROPERTY = name => `Missing ${name} property in key`;
const INVALID_KEY_WEIGHT_VALUE = key => `Property 'weight' in key '${key}' must be a positive integer`;
const hasOwn = Object.prototype.hasOwnProperty;
class KeyStore {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach(key => {
      let obj = createKey(key);
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });

    // Normalize weights so that their sum is equal to 1
    this._keys.forEach(key => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
}
function createKey(key) {
  let path = null;
  let id = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id = createKeyId(key);
  } else {
    if (!hasOwn.call(key, 'name')) {
      throw new Error(MISSING_KEY_PROPERTY('name'));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, 'weight')) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id = createKeyId(name);
    getFn = key.getFn;
  }
  return {
    path,
    id,
    weight,
    src,
    getFn
  };
}
function createKeyPath(key) {
  return isArray(key) ? key : key.split('.');
}
function createKeyId(key) {
  return isArray(key) ? key.join('.') : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj, path, index) => {
    if (!isDefined(obj)) {
      return;
    }
    if (!path[index]) {
      // If there's no path left, we've arrived at the object we care about.
      list.push(obj);
    } else {
      let key = path[index];
      const value = obj[key];
      if (!isDefined(value)) {
        return;
      }

      // If we're at the last value in the path, and if it's a string/number/bool,
      // add it to the list
      if (index === path.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        // Search each item in the array.
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path, index + 1);
        }
      } else if (path.length) {
        // An object. Recurse further.
        deepGet(value, path, index + 1);
      }
    }
  };

  // Backwards compatibility (since path used to be a string)
  deepGet(obj, isString(path) ? path.split('.') : path, 0);
  return arr ? list : list[0];
}
const MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
const BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
const FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
const AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, BasicOptions), MatchOptions), FuzzyOptions), AdvancedOptions);
const SPACE = /[^ ]+/g;

// Field-length norm: the shorter the field, the higher the weight.
// Set to 3 decimals to reduce index size.
function norm(weight = 1, mantissa = 3) {
  const cache = new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }

      // Default function is 1/sqrt(x), weight makes that variable
      const norm = 1 / Math.pow(numTokens, 0.5 * weight);

      // In place of `toFixed(mantissa)`, for faster computation
      const n = parseFloat(Math.round(norm * m) / m);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
}
class FuseIndex {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;

    // List is Array<String>
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      // List is Array<Object>
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);

    // Change ref index of every subsquent doc
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = {
      i: docIndex,
      $: {}
    };

    // Iterate over every key (i.e, path), and fetch the value at that key
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{
          nestedArrIndex: -1,
          value
        }];
        while (stack.length) {
          const {
            nestedArrIndex,
            value
          } = stack.pop();
          if (!isDefined(value)) {
            continue;
          }
          if (isString(value) && !isBlank(value)) {
            let subRecord = {
              v: value,
              i: nestedArrIndex,
              n: this.norm.get(value)
            };
            subRecords.push(subRecord);
          } else if (isArray(value)) {
            value.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
}
function createIndex(keys, docs, {
  getFn = Config.getFn,
  fieldNormWeight = Config.fieldNormWeight
} = {}) {
  const myIndex = new FuseIndex({
    getFn,
    fieldNormWeight
  });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, {
  getFn = Config.getFn,
  fieldNormWeight = Config.fieldNormWeight
} = {}) {
  const {
    keys,
    records
  } = data;
  const myIndex = new FuseIndex({
    getFn,
    fieldNormWeight
  });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    // Dodge divide by zero error.
    return proximity ? 1.0 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }

  // (i-1 - start) + 1 => i - start
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }
  return indices;
}

// Machine word size
const MAX_BITS = 32;
function search(text, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  // Set starting location at beginning text and initialize the alphabet.
  const textLen = text.length;
  // Handle the case when location > text.length
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  // Highest score beyond which we give up.
  let currentThreshold = threshold;
  // Is there a nearby exact match? (speedup)
  let bestLocation = expectedLocation;

  // Performance: only computer matches when the minMatchCharLength > 1
  // OR if `includeMatches` is true.
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  // A mask of the matches, used for building the indices
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;

  // Get all exact matches, here for speed up
  while ((index = text.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }

  // Reset the best location
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    // Scan for the best match; each iteration allows for one more error.
    // Run a binary search to determine how far from the match location we can stray
    // at this error level.
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }

    // Use the result from this iteration as the maximum for the next.
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;

    // Initialize the bit array
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish; j >= start; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text.charAt(currentLocation)];
      if (computeMatches) {
        // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)
        matchMask[currentLocation] = +!!charMatch;
      }

      // First pass: exact match
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;

      // Subsequent passes: fuzzy match
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });

        // This match will almost certainly be better than any existing match.
        // But check anyway.
        if (finalScore <= currentThreshold) {
          // Indeed it is
          currentThreshold = finalScore;
          bestLocation = currentLocation;

          // Already passed `loc`, downhill from here on in.
          if (bestLocation <= expectedLocation) {
            break;
          }

          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }

    // No hope for a (better) match at greater error levels.
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(0.001, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | 1 << len - i - 1;
  }
  return mask;
}
class BitapSearch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern, startIndex) => {
      this.chunks.push({
        pattern,
        alphabet: createPatternAlphabet(pattern),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text) {
    const {
      isCaseSensitive,
      includeMatches
    } = this.options;
    if (!isCaseSensitive) {
      text = text.toLowerCase();
    }

    // Exact match
    if (this.pattern === text) {
      let result = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result.indices = [[0, text.length - 1]];
      }
      return result;
    }

    // Otherwise, use Bitap algorithm
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({
      pattern,
      alphabet,
      startIndex
    }) => {
      const {
        isMatch,
        score,
        indices
      } = search(text, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
}
class BaseMatch {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search( /*text*/) {}
}
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}

// Token: 'file

class ExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'exact';
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text) {
    const isMatch = text === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}

// Token: !fire

class InverseExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'inverse-exact';
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text) {
    const index = text.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
}

// Token: ^file

class PrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'prefix-exact';
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text) {
    const isMatch = text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}

// Token: !^fire

class InversePrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'inverse-prefix-exact';
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text) {
    const isMatch = !text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
}

// Token: .file$

class SuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'suffix-exact';
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text) {
    const isMatch = text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text.length - this.pattern.length, text.length - 1]
    };
  }
}

// Token: !.file$

class InverseSuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'inverse-suffix-exact';
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text) {
    const isMatch = !text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
}
class FuzzyMatch extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return 'fuzzy';
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text) {
    return this._bitapSearch.searchIn(text);
  }
}

// Token: 'file

class IncludeMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'include';
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text) {
    let location = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;

    // Get all exact matches
    while ((index = text.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
}

// ❗Order is important. DO NOT CHANGE.
const searchers = [ExactMatch, IncludeMatch, PrefixExactMatch, InversePrefixExactMatch, InverseSuffixExactMatch, SuffixExactMatch, InverseExactMatch, FuzzyMatch];
const searchersLen = searchers.length;

// Regex to split by spaces, but keep anything in quotes together
const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
const OR_TOKEN = '|';

// Return a 2D array representation of the query, for simpler parsing.
// Example:
// "^core go$ | rb$ | py$ xy$" => [["^core", "go$"], ["rb$"], ["py$", "xy$"]]
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map(item => {
    let query = item.trim().split(SPACE_RE).filter(item => item && !!item.trim());
    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];

      // 1. Handle multiple query match (i.e, once that are quoted, like `"hello world"`)
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }

      // 2. Handle single query matches (i.e, once that are *not* quoted)
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
}

// These extended matchers can return an array of matches, as opposed
// to a singl match
const MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);

/**
 * Command-like searching
 * ======================
 *
 * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,
 * search in a given text.
 *
 * Search syntax:
 *
 * | Token       | Match type                 | Description                            |
 * | ----------- | -------------------------- | -------------------------------------- |
 * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |
 * | `=scheme`   | exact-match                | Items that are `scheme`                |
 * | `'python`   | include-match              | Items that include `python`            |
 * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |
 * | `^java`     | prefix-exact-match         | Items that start with `java`           |
 * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |
 * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |
 * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |
 *
 * A single pipe character acts as an OR operator. For example, the following
 * query matches entries that start with `core` and end with either`go`, `rb`,
 * or`py`.
 *
 * ```
 * ^core go$ | rb$ | py$
 * ```
 */
class ExtendedSearch {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const {
      includeMatches,
      isCaseSensitive
    } = this.options;
    text = isCaseSensitive ? text : text.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;

    // ORs
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers = query[i];

      // Reset indices
      allIndices.length = 0;
      numMatches = 0;

      // ANDs
      for (let j = 0, pLen = searchers.length; j < pLen; j += 1) {
        const searcher = searchers[j];
        const {
          isMatch,
          indices,
          score
        } = searcher.search(text);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }

      // OR condition, so if TRUE, return
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }

    // Nothing was matched
    return {
      isMatch: false,
      score: 1
    };
  }
}
const registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
const LogicalOperator = {
  AND: '$and',
  OR: '$or'
};
const KeyType = {
  PATH: '$path',
  PATTERN: '$val'
};
const isExpression = query => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
const isPath = query => !!query[KeyType.PATH];
const isLeaf = query => !isArray(query) && isObject(query) && !isExpression(query);
const convertToExplicit = query => ({
  [LogicalOperator.AND]: Object.keys(query).map(key => ({
    [key]: query[key]
  }))
});

// When `auto` is `true`, the parse function will infer and initialize and add
// the appropriate `Searcher` instance
function parse(query, options, {
  auto = true
} = {}) {
  const next = query => {
    let keys = Object.keys(query);
    const isQueryPath = isPath(query);
    if (!isQueryPath && keys.length > 1 && !isExpression(query)) {
      return next(convertToExplicit(query));
    }
    if (isLeaf(query)) {
      const key = isQueryPath ? query[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach(key => {
      const value = query[key];
      if (isArray(value)) {
        value.forEach(item => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}

// Practical scoring function
function computeScore(results, {
  ignoreFieldNorm = Config.ignoreFieldNorm
}) {
  results.forEach(result => {
    let totalScore = 1;
    result.matches.forEach(({
      key,
      norm,
      score
    }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm));
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach(match => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const {
      indices,
      value
    } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches) transformers.push(transformMatches);
  if (includeScore) transformers.push(transformScore);
  return results.map(result => {
    const {
      idx
    } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach(transformer => {
        transformer(result, data);
      });
    }
    return data;
  });
}
class Fuse {
  constructor(docs, options = {}, index) {
    this.options = _objectSpread2(_objectSpread2({}, Config), options);
    if (this.options.useExtendedSearch && !true) {}
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = ( /* doc, idx */) => false) {
    const results = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, {
    limit = -1
  } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, {
      ignoreFieldNorm
    });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const {
      records
    } = this._myIndex;
    const results = [];

    // Iterate over every string in the index
    records.forEach(({
      v: text,
      i: idx,
      n: norm
    }) => {
      if (!isDefined(text)) {
        return;
      }
      const {
        isMatch,
        score,
        indices
      } = searcher.searchIn(text);
      if (isMatch) {
        results.push({
          item: text,
          idx,
          matches: [{
            score,
            value: text,
            norm,
            indices
          }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const {
          keyId,
          searcher
        } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [{
            idx,
            item,
            matches
          }];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({
      $: item,
      i: idx
    }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          // Dedupe when adding
          if (!resultMap[idx]) {
            resultMap[idx] = {
              idx,
              item,
              matches: []
            };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({
            matches
          }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const {
      keys,
      records
    } = this._myIndex;
    const results = [];

    // List is Array<Object>
    records.forEach(({
      $: item,
      i: idx
    }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];

      // Iterate over every key (i.e, path), and fetch the value at that key
      keys.forEach((key, keyIndex) => {
        matches.push(...this._findMatches({
          key,
          value: item[keyIndex],
          searcher
        }));
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({
    key,
    value,
    searcher
  }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({
        v: text,
        i: idx,
        n: norm
      }) => {
        if (!isDefined(text)) {
          return;
        }
        const {
          isMatch,
          score,
          indices
        } = searcher.searchIn(text);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text,
            idx,
            norm,
            indices
          });
        }
      });
    } else {
      const {
        v: text,
        n: norm
      } = value;
      const {
        isMatch,
        score,
        indices
      } = searcher.searchIn(text);
      if (isMatch) {
        matches.push({
          score,
          key,
          value: text,
          norm,
          indices
        });
      }
    }
    return matches;
  }
}
Fuse.version = '7.0.0';
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}

var SearchByFuse = /** @class */ (function () {
    function SearchByFuse(config) {
        this._haystack = [];
        this._fuseOptions = __assign(__assign({}, config.fuseOptions), { keys: __spreadArray([], config.searchFields, true), includeMatches: true });
    }
    SearchByFuse.prototype.index = function (data) {
        this._haystack = data;
        if (this._fuse) {
            this._fuse.setCollection(data);
        }
    };
    SearchByFuse.prototype.reset = function () {
        this._haystack = [];
        this._fuse = undefined;
    };
    SearchByFuse.prototype.isEmptyIndex = function () {
        return !this._haystack.length;
    };
    SearchByFuse.prototype.search = function (needle) {
        if (!this._fuse) {
            {
                this._fuse = new Fuse(this._haystack, this._fuseOptions);
            }
        }
        var results = this._fuse.search(needle);
        return results.map(function (value, i) {
            return {
                item: value.item,
                score: value.score || 0,
                rank: i + 1, // If value.score is used for sorting, this can create non-stable sorts!
            };
        });
    };
    return SearchByFuse;
}());

function getSearcher(config) {
    {
        return new SearchByFuse(config);
    }
}

/**
 * Helpers to create HTML elements used by Choices
 * Can be overridden by providing `callbackOnCreateTemplates` option.
 * `Choices.defaults.templates` allows access to the default template methods from `callbackOnCreateTemplates`
 */
var isEmptyObject = function (obj) {
    // eslint-disable-next-line no-restricted-syntax
    for (var prop in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, prop)) {
            return false;
        }
    }
    return true;
};
var assignCustomProperties = function (el, choice, withCustomProperties) {
    var dataset = el.dataset;
    var customProperties = choice.customProperties, labelClass = choice.labelClass, labelDescription = choice.labelDescription;
    if (labelClass) {
        dataset.labelClass = getClassNames(labelClass).join(' ');
    }
    if (labelDescription) {
        dataset.labelDescription = labelDescription;
    }
    if (withCustomProperties && customProperties) {
        if (typeof customProperties === 'string') {
            dataset.customProperties = customProperties;
        }
        else if (typeof customProperties === 'object' && !isEmptyObject(customProperties)) {
            dataset.customProperties = JSON.stringify(customProperties);
        }
    }
};
var addAriaLabel = function (docRoot, id, element) {
    var label = id && docRoot.querySelector("label[for='".concat(id, "']"));
    var text = label && label.innerText;
    if (text) {
        element.setAttribute('aria-label', text);
    }
};
var templates = {
    containerOuter: function (_a, dir, isSelectElement, isSelectOneElement, searchEnabled, passedElementType, labelId) {
        var containerOuter = _a.classNames.containerOuter;
        var div = document.createElement('div');
        addClassesToElement(div, containerOuter);
        div.dataset.type = passedElementType;
        if (dir) {
            div.dir = dir;
        }
        if (isSelectOneElement) {
            div.tabIndex = 0;
        }
        if (isSelectElement) {
            div.setAttribute('role', searchEnabled ? 'combobox' : 'listbox');
            if (searchEnabled) {
                div.setAttribute('aria-autocomplete', 'list');
            }
            else if (!labelId) {
                addAriaLabel(this._docRoot, this.passedElement.element.id, div);
            }
            div.setAttribute('aria-haspopup', 'true');
            div.setAttribute('aria-expanded', 'false');
        }
        if (labelId) {
            div.setAttribute('aria-labelledby', labelId);
        }
        return div;
    },
    containerInner: function (_a) {
        var containerInner = _a.classNames.containerInner;
        var div = document.createElement('div');
        addClassesToElement(div, containerInner);
        return div;
    },
    itemList: function (_a, isSelectOneElement) {
        var searchEnabled = _a.searchEnabled, _b = _a.classNames, list = _b.list, listSingle = _b.listSingle, listItems = _b.listItems;
        var div = document.createElement('div');
        addClassesToElement(div, list);
        addClassesToElement(div, isSelectOneElement ? listSingle : listItems);
        if (this._isSelectElement && searchEnabled) {
            div.setAttribute('role', 'listbox');
        }
        return div;
    },
    placeholder: function (_a, value) {
        var allowHTML = _a.allowHTML, placeholder = _a.classNames.placeholder;
        var div = document.createElement('div');
        addClassesToElement(div, placeholder);
        setElementHtml(div, allowHTML, value);
        return div;
    },
    item: function (_a, choice, removeItemButton) {
        var allowHTML = _a.allowHTML, removeItemButtonAlignLeft = _a.removeItemButtonAlignLeft, removeItemIconText = _a.removeItemIconText, removeItemLabelText = _a.removeItemLabelText, _b = _a.classNames, item = _b.item, button = _b.button, highlightedState = _b.highlightedState, itemSelectable = _b.itemSelectable, placeholder = _b.placeholder;
        var rawValue = unwrapStringForRaw(choice.value);
        var div = document.createElement('div');
        addClassesToElement(div, item);
        if (choice.labelClass) {
            var spanLabel = document.createElement('span');
            setElementHtml(spanLabel, allowHTML, choice.label);
            addClassesToElement(spanLabel, choice.labelClass);
            div.appendChild(spanLabel);
        }
        else {
            setElementHtml(div, allowHTML, choice.label);
        }
        div.dataset.item = '';
        div.dataset.id = choice.id;
        div.dataset.value = rawValue;
        assignCustomProperties(div, choice, true);
        if (choice.disabled || this.containerOuter.isDisabled) {
            div.setAttribute('aria-disabled', 'true');
        }
        if (this._isSelectElement) {
            div.setAttribute('aria-selected', 'true');
            div.setAttribute('role', 'option');
        }
        if (choice.placeholder) {
            addClassesToElement(div, placeholder);
            div.dataset.placeholder = '';
        }
        addClassesToElement(div, choice.highlighted ? highlightedState : itemSelectable);
        if (removeItemButton) {
            if (choice.disabled) {
                removeClassesFromElement(div, itemSelectable);
            }
            div.dataset.deletable = '';
            var removeButton = document.createElement('button');
            removeButton.type = 'button';
            addClassesToElement(removeButton, button);
            setElementHtml(removeButton, true, resolveNoticeFunction(removeItemIconText, choice.value));
            var REMOVE_ITEM_LABEL = resolveNoticeFunction(removeItemLabelText, choice.value);
            if (REMOVE_ITEM_LABEL) {
                removeButton.setAttribute('aria-label', REMOVE_ITEM_LABEL);
            }
            removeButton.dataset.button = '';
            if (removeItemButtonAlignLeft) {
                div.insertAdjacentElement('afterbegin', removeButton);
            }
            else {
                div.appendChild(removeButton);
            }
        }
        return div;
    },
    choiceList: function (_a, isSelectOneElement) {
        var list = _a.classNames.list;
        var div = document.createElement('div');
        addClassesToElement(div, list);
        if (!isSelectOneElement) {
            div.setAttribute('aria-multiselectable', 'true');
        }
        div.setAttribute('role', 'listbox');
        return div;
    },
    choiceGroup: function (_a, _b) {
        var allowHTML = _a.allowHTML, _c = _a.classNames, group = _c.group, groupHeading = _c.groupHeading, itemDisabled = _c.itemDisabled;
        var id = _b.id, label = _b.label, disabled = _b.disabled;
        var rawLabel = unwrapStringForRaw(label);
        var div = document.createElement('div');
        addClassesToElement(div, group);
        if (disabled) {
            addClassesToElement(div, itemDisabled);
        }
        div.setAttribute('role', 'group');
        div.dataset.group = '';
        div.dataset.id = id;
        div.dataset.value = rawLabel;
        if (disabled) {
            div.setAttribute('aria-disabled', 'true');
        }
        var heading = document.createElement('div');
        addClassesToElement(heading, groupHeading);
        setElementHtml(heading, allowHTML, label || '');
        div.appendChild(heading);
        return div;
    },
    choice: function (_a, choice, selectText, groupName) {
        var allowHTML = _a.allowHTML, _b = _a.classNames, item = _b.item, itemChoice = _b.itemChoice, itemSelectable = _b.itemSelectable, selectedState = _b.selectedState, itemDisabled = _b.itemDisabled, description = _b.description, placeholder = _b.placeholder;
        // eslint-disable-next-line prefer-destructuring
        var label = choice.label;
        var rawValue = unwrapStringForRaw(choice.value);
        var div = document.createElement('div');
        div.id = choice.elementId;
        addClassesToElement(div, item);
        addClassesToElement(div, itemChoice);
        if (groupName && typeof label === 'string') {
            label = escapeForTemplate(allowHTML, label);
            label += " (".concat(groupName, ")");
            label = { trusted: label };
        }
        var describedBy = div;
        if (choice.labelClass) {
            var spanLabel = document.createElement('span');
            setElementHtml(spanLabel, allowHTML, label);
            addClassesToElement(spanLabel, choice.labelClass);
            describedBy = spanLabel;
            div.appendChild(spanLabel);
        }
        else {
            setElementHtml(div, allowHTML, label);
        }
        if (choice.labelDescription) {
            var descId = "".concat(choice.elementId, "-description");
            describedBy.setAttribute('aria-describedby', descId);
            var spanDesc = document.createElement('span');
            setElementHtml(spanDesc, allowHTML, choice.labelDescription);
            spanDesc.id = descId;
            addClassesToElement(spanDesc, description);
            div.appendChild(spanDesc);
        }
        if (choice.selected) {
            addClassesToElement(div, selectedState);
        }
        if (choice.placeholder) {
            addClassesToElement(div, placeholder);
        }
        div.setAttribute('role', choice.group ? 'treeitem' : 'option');
        div.dataset.choice = '';
        div.dataset.id = choice.id;
        div.dataset.value = rawValue;
        if (selectText) {
            div.dataset.selectText = selectText;
        }
        if (choice.group) {
            div.dataset.groupId = "".concat(choice.group.id);
        }
        assignCustomProperties(div, choice, false);
        if (choice.disabled) {
            addClassesToElement(div, itemDisabled);
            div.dataset.choiceDisabled = '';
            div.setAttribute('aria-disabled', 'true');
        }
        else {
            addClassesToElement(div, itemSelectable);
            div.dataset.choiceSelectable = '';
        }
        return div;
    },
    input: function (_a, placeholderValue) {
        var _b = _a.classNames, input = _b.input, inputCloned = _b.inputCloned, labelId = _a.labelId;
        var inp = document.createElement('input');
        inp.type = 'search';
        addClassesToElement(inp, input);
        addClassesToElement(inp, inputCloned);
        inp.autocomplete = 'off';
        inp.autocapitalize = 'off';
        inp.spellcheck = false;
        inp.setAttribute('role', 'textbox');
        inp.setAttribute('aria-autocomplete', 'list');
        if (placeholderValue) {
            inp.setAttribute('aria-label', placeholderValue);
        }
        else if (!labelId) {
            addAriaLabel(this._docRoot, this.passedElement.element.id, inp);
        }
        return inp;
    },
    dropdown: function (_a) {
        var _b = _a.classNames, list = _b.list, listDropdown = _b.listDropdown;
        var div = document.createElement('div');
        addClassesToElement(div, list);
        addClassesToElement(div, listDropdown);
        div.setAttribute('aria-expanded', 'false');
        return div;
    },
    notice: function (_a, innerHTML, type) {
        var _b = _a.classNames, item = _b.item, itemChoice = _b.itemChoice, addChoice = _b.addChoice, noResults = _b.noResults, noChoices = _b.noChoices, noticeItem = _b.notice;
        if (type === void 0) { type = NoticeTypes.generic; }
        var notice = document.createElement('div');
        setElementHtml(notice, true, innerHTML);
        addClassesToElement(notice, item);
        addClassesToElement(notice, itemChoice);
        addClassesToElement(notice, noticeItem);
        // eslint-disable-next-line default-case
        switch (type) {
            case NoticeTypes.addChoice:
                addClassesToElement(notice, addChoice);
                break;
            case NoticeTypes.noResults:
                addClassesToElement(notice, noResults);
                break;
            case NoticeTypes.noChoices:
                addClassesToElement(notice, noChoices);
                break;
        }
        if (type === NoticeTypes.addChoice) {
            notice.dataset.choiceSelectable = '';
            notice.dataset.choice = '';
        }
        return notice;
    },
    option: function (choice) {
        // HtmlOptionElement's label value does not support HTML, so the avoid double escaping unwrap the untrusted string.
        var labelValue = unwrapStringForRaw(choice.label);
        var opt = new Option(labelValue, choice.value, false, choice.selected);
        assignCustomProperties(opt, choice, true);
        opt.disabled = choice.disabled;
        if (choice.selected) {
            opt.setAttribute('selected', '');
        }
        return opt;
    },
};

/** @see {@link http://browserhacks.com/#hack-acea075d0ac6954f275a70023906050c} */
var IS_IE11 = '-ms-scroll-limit' in document.documentElement.style &&
    '-ms-ime-align' in document.documentElement.style;
var USER_DEFAULTS = {};
var parseDataSetId = function (element) {
    if (!element) {
        return undefined;
    }
    return element.dataset.id ? parseInt(element.dataset.id, 10) : undefined;
};
var selectableChoiceIdentifier = '[data-choice-selectable]';
/**
 * Choices
 * @author Josh Johnson<josh@joshuajohnson.co.uk>
 */
var Choices = /** @class */ (function () {
    function Choices(element, userConfig) {
        if (element === void 0) { element = '[data-choice]'; }
        if (userConfig === void 0) { userConfig = {}; }
        var _this = this;
        this.initialisedOK = undefined;
        this._hasNonChoicePlaceholder = false;
        this._lastAddedChoiceId = 0;
        this._lastAddedGroupId = 0;
        var defaults = Choices.defaults;
        this.config = __assign(__assign(__assign({}, defaults.allOptions), defaults.options), userConfig);
        ObjectsInConfig.forEach(function (key) {
            _this.config[key] = __assign(__assign(__assign({}, defaults.allOptions[key]), defaults.options[key]), userConfig[key]);
        });
        var config = this.config;
        if (!config.silent) {
            this._validateConfig();
        }
        var docRoot = config.shadowRoot || document.documentElement;
        this._docRoot = docRoot;
        var passedElement = typeof element === 'string' ? docRoot.querySelector(element) : element;
        if (!passedElement ||
            typeof passedElement !== 'object' ||
            !(isHtmlInputElement(passedElement) || isHtmlSelectElement(passedElement))) {
            if (!passedElement && typeof element === 'string') {
                throw TypeError("Selector ".concat(element, " failed to find an element"));
            }
            throw TypeError("Expected one of the following types text|select-one|select-multiple");
        }
        var elementType = passedElement.type;
        var isText = elementType === PassedElementTypes.Text;
        if (isText || config.maxItemCount !== 1) {
            config.singleModeForMultiSelect = false;
        }
        if (config.singleModeForMultiSelect) {
            elementType = PassedElementTypes.SelectMultiple;
        }
        var isSelectOne = elementType === PassedElementTypes.SelectOne;
        var isSelectMultiple = elementType === PassedElementTypes.SelectMultiple;
        var isSelect = isSelectOne || isSelectMultiple;
        this._elementType = elementType;
        this._isTextElement = isText;
        this._isSelectOneElement = isSelectOne;
        this._isSelectMultipleElement = isSelectMultiple;
        this._isSelectElement = isSelectOne || isSelectMultiple;
        this._canAddUserChoices = (isText && config.addItems) || (isSelect && config.addChoices);
        if (typeof config.renderSelectedChoices !== 'boolean') {
            config.renderSelectedChoices = config.renderSelectedChoices === 'always' || isSelectOne;
        }
        if (config.closeDropdownOnSelect === 'auto') {
            config.closeDropdownOnSelect = isText || isSelectOne || config.singleModeForMultiSelect;
        }
        else {
            config.closeDropdownOnSelect = coerceBool(config.closeDropdownOnSelect);
        }
        if (config.placeholder) {
            if (config.placeholderValue) {
                this._hasNonChoicePlaceholder = true;
            }
            else if (passedElement.dataset.placeholder) {
                this._hasNonChoicePlaceholder = true;
                config.placeholderValue = passedElement.dataset.placeholder;
            }
        }
        if (userConfig.addItemFilter && typeof userConfig.addItemFilter !== 'function') {
            var re = userConfig.addItemFilter instanceof RegExp ? userConfig.addItemFilter : new RegExp(userConfig.addItemFilter);
            config.addItemFilter = re.test.bind(re);
        }
        if (this._isTextElement) {
            this.passedElement = new WrappedInput({
                element: passedElement,
                classNames: config.classNames,
            });
        }
        else {
            var selectEl = passedElement;
            this.passedElement = new WrappedSelect({
                element: selectEl,
                classNames: config.classNames,
                template: function (data) { return _this._templates.option(data); },
                extractPlaceholder: config.placeholder && !this._hasNonChoicePlaceholder,
            });
        }
        this.initialised = false;
        this._store = new Store(config);
        this._currentValue = '';
        config.searchEnabled = (!isText && config.searchEnabled) || isSelectMultiple;
        this._canSearch = config.searchEnabled;
        this._isScrollingOnIe = false;
        this._highlightPosition = 0;
        this._wasTap = true;
        this._placeholderValue = this._generatePlaceholderValue();
        this._baseId = generateId(passedElement, 'choices-');
        /**
         * setting direction in cases where it's explicitly set on passedElement
         * or when calculated direction is different from the document
         */
        this._direction = passedElement.dir;
        if (!this._direction) {
            var elementDirection = window.getComputedStyle(passedElement).direction;
            var documentDirection = window.getComputedStyle(document.documentElement).direction;
            if (elementDirection !== documentDirection) {
                this._direction = elementDirection;
            }
        }
        this._idNames = {
            itemChoice: 'item-choice',
        };
        this._templates = defaults.templates;
        this._render = this._render.bind(this);
        this._onFocus = this._onFocus.bind(this);
        this._onBlur = this._onBlur.bind(this);
        this._onKeyUp = this._onKeyUp.bind(this);
        this._onKeyDown = this._onKeyDown.bind(this);
        this._onInput = this._onInput.bind(this);
        this._onClick = this._onClick.bind(this);
        this._onTouchMove = this._onTouchMove.bind(this);
        this._onTouchEnd = this._onTouchEnd.bind(this);
        this._onMouseDown = this._onMouseDown.bind(this);
        this._onMouseOver = this._onMouseOver.bind(this);
        this._onFormReset = this._onFormReset.bind(this);
        this._onSelectKey = this._onSelectKey.bind(this);
        this._onEnterKey = this._onEnterKey.bind(this);
        this._onEscapeKey = this._onEscapeKey.bind(this);
        this._onDirectionKey = this._onDirectionKey.bind(this);
        this._onDeleteKey = this._onDeleteKey.bind(this);
        // If element has already been initialised with Choices, fail silently
        if (this.passedElement.isActive) {
            if (!config.silent) {
                console.warn('Trying to initialise Choices on element already initialised', { element: element });
            }
            this.initialised = true;
            this.initialisedOK = false;
            return;
        }
        // Let's go
        this.init();
        // preserve the selected item list after setup for form reset
        this._initialItems = this._store.items.map(function (choice) { return choice.value; });
    }
    Object.defineProperty(Choices, "defaults", {
        get: function () {
            return Object.preventExtensions({
                get options() {
                    return USER_DEFAULTS;
                },
                get allOptions() {
                    return DEFAULT_CONFIG;
                },
                get templates() {
                    return templates;
                },
            });
        },
        enumerable: false,
        configurable: true
    });
    Choices.prototype.init = function () {
        if (this.initialised || this.initialisedOK !== undefined) {
            return;
        }
        this._searcher = getSearcher(this.config);
        this._loadChoices();
        this._createTemplates();
        this._createElements();
        this._createStructure();
        if ((this._isTextElement && !this.config.addItems) ||
            this.passedElement.element.hasAttribute('disabled') ||
            !!this.passedElement.element.closest('fieldset:disabled')) {
            this.disable();
        }
        else {
            this.enable();
            this._addEventListeners();
        }
        // should be triggered **after** disabled state to avoid additional re-draws
        this._initStore();
        this.initialised = true;
        this.initialisedOK = true;
        var callbackOnInit = this.config.callbackOnInit;
        // Run callback if it is a function
        if (typeof callbackOnInit === 'function') {
            callbackOnInit.call(this);
        }
    };
    Choices.prototype.destroy = function () {
        if (!this.initialised) {
            return;
        }
        this._removeEventListeners();
        this.passedElement.reveal();
        this.containerOuter.unwrap(this.passedElement.element);
        this._store._listeners = []; // prevents select/input value being wiped
        this.clearStore(false);
        this._stopSearch();
        this._templates = Choices.defaults.templates;
        this.initialised = false;
        this.initialisedOK = undefined;
    };
    Choices.prototype.enable = function () {
        if (this.passedElement.isDisabled) {
            this.passedElement.enable();
        }
        if (this.containerOuter.isDisabled) {
            this._addEventListeners();
            this.input.enable();
            this.containerOuter.enable();
        }
        return this;
    };
    Choices.prototype.disable = function () {
        if (!this.passedElement.isDisabled) {
            this.passedElement.disable();
        }
        if (!this.containerOuter.isDisabled) {
            this._removeEventListeners();
            this.input.disable();
            this.containerOuter.disable();
        }
        return this;
    };
    Choices.prototype.highlightItem = function (item, runEvent) {
        if (runEvent === void 0) { runEvent = true; }
        if (!item || !item.id) {
            return this;
        }
        var choice = this._store.items.find(function (c) { return c.id === item.id; });
        if (!choice || choice.highlighted) {
            return this;
        }
        this._store.dispatch(highlightItem(choice, true));
        if (runEvent) {
            this.passedElement.triggerEvent(EventType.highlightItem, this._getChoiceForOutput(choice));
        }
        return this;
    };
    Choices.prototype.unhighlightItem = function (item, runEvent) {
        if (runEvent === void 0) { runEvent = true; }
        if (!item || !item.id) {
            return this;
        }
        var choice = this._store.items.find(function (c) { return c.id === item.id; });
        if (!choice || !choice.highlighted) {
            return this;
        }
        this._store.dispatch(highlightItem(choice, false));
        if (runEvent) {
            this.passedElement.triggerEvent(EventType.unhighlightItem, this._getChoiceForOutput(choice));
        }
        return this;
    };
    Choices.prototype.highlightAll = function () {
        var _this = this;
        this._store.withTxn(function () {
            _this._store.items.forEach(function (item) {
                if (!item.highlighted) {
                    _this._store.dispatch(highlightItem(item, true));
                    _this.passedElement.triggerEvent(EventType.highlightItem, _this._getChoiceForOutput(item));
                }
            });
        });
        return this;
    };
    Choices.prototype.unhighlightAll = function () {
        var _this = this;
        this._store.withTxn(function () {
            _this._store.items.forEach(function (item) {
                if (item.highlighted) {
                    _this._store.dispatch(highlightItem(item, false));
                    _this.passedElement.triggerEvent(EventType.highlightItem, _this._getChoiceForOutput(item));
                }
            });
        });
        return this;
    };
    Choices.prototype.removeActiveItemsByValue = function (value) {
        var _this = this;
        this._store.withTxn(function () {
            _this._store.items.filter(function (item) { return item.value === value; }).forEach(function (item) { return _this._removeItem(item); });
        });
        return this;
    };
    Choices.prototype.removeActiveItems = function (excludedId) {
        var _this = this;
        this._store.withTxn(function () {
            _this._store.items.filter(function (_a) {
                var id = _a.id;
                return id !== excludedId;
            }).forEach(function (item) { return _this._removeItem(item); });
        });
        return this;
    };
    Choices.prototype.removeHighlightedItems = function (runEvent) {
        var _this = this;
        if (runEvent === void 0) { runEvent = false; }
        this._store.withTxn(function () {
            _this._store.highlightedActiveItems.forEach(function (item) {
                _this._removeItem(item);
                // If this action was performed by the user
                // trigger the event
                if (runEvent) {
                    _this._triggerChange(item.value);
                }
            });
        });
        return this;
    };
    Choices.prototype.showDropdown = function (preventInputFocus) {
        var _this = this;
        if (this.dropdown.isActive) {
            return this;
        }
        requestAnimationFrame(function () {
            _this.dropdown.show();
            var rect = _this.dropdown.element.getBoundingClientRect();
            _this.containerOuter.open(rect.bottom, rect.height);
            if (!preventInputFocus && _this._canSearch) {
                _this.input.focus();
            }
            _this.passedElement.triggerEvent(EventType.showDropdown);
        });
        return this;
    };
    Choices.prototype.hideDropdown = function (preventInputBlur) {
        var _this = this;
        if (!this.dropdown.isActive) {
            return this;
        }
        requestAnimationFrame(function () {
            _this.dropdown.hide();
            _this.containerOuter.close();
            if (!preventInputBlur && _this._canSearch) {
                _this.input.removeActiveDescendant();
                _this.input.blur();
            }
            _this.passedElement.triggerEvent(EventType.hideDropdown);
        });
        return this;
    };
    Choices.prototype.getValue = function (valueOnly) {
        var _this = this;
        var values = this._store.items.map(function (item) {
            return (valueOnly ? item.value : _this._getChoiceForOutput(item));
        });
        return this._isSelectOneElement || this.config.singleModeForMultiSelect ? values[0] : values;
    };
    Choices.prototype.setValue = function (items) {
        var _this = this;
        if (!this.initialisedOK) {
            this._warnChoicesInitFailed('setValue');
            return this;
        }
        this._store.withTxn(function () {
            items.forEach(function (value) {
                if (value) {
                    _this._addChoice(mapInputToChoice(value, false));
                }
            });
        });
        // @todo integrate with Store
        this._searcher.reset();
        return this;
    };
    Choices.prototype.setChoiceByValue = function (value) {
        var _this = this;
        if (!this.initialisedOK) {
            this._warnChoicesInitFailed('setChoiceByValue');
            return this;
        }
        if (this._isTextElement) {
            return this;
        }
        this._store.withTxn(function () {
            // If only one value has been passed, convert to array
            var choiceValue = Array.isArray(value) ? value : [value];
            // Loop through each value and
            choiceValue.forEach(function (val) { return _this._findAndSelectChoiceByValue(val); });
            _this.unhighlightAll();
        });
        // @todo integrate with Store
        this._searcher.reset();
        return this;
    };
    /**
     * Set choices of select input via an array of objects (or function that returns array of object or promise of it),
     * a value field name and a label field name.
     * This behaves the same as passing items via the choices option but can be called after initialising Choices.
     * This can also be used to add groups of choices (see example 2); Optionally pass a true `replaceChoices` value to remove any existing choices.
     * Optionally pass a `customProperties` object to add additional data to your choices (useful when searching/filtering etc).
     *
     * **Input types affected:** select-one, select-multiple
     *
     * @example
     * ```js
     * const example = new Choices(element);
     *
     * example.setChoices([
     *   {value: 'One', label: 'Label One', disabled: true},
     *   {value: 'Two', label: 'Label Two', selected: true},
     *   {value: 'Three', label: 'Label Three'},
     * ], 'value', 'label', false);
     * ```
     *
     * @example
     * ```js
     * const example = new Choices(element);
     *
     * example.setChoices(async () => {
     *   try {
     *      const items = await fetch('/items');
     *      return items.json()
     *   } catch(err) {
     *      console.error(err)
     *   }
     * });
     * ```
     *
     * @example
     * ```js
     * const example = new Choices(element);
     *
     * example.setChoices([{
     *   label: 'Group one',
     *   id: 1,
     *   disabled: false,
     *   choices: [
     *     {value: 'Child One', label: 'Child One', selected: true},
     *     {value: 'Child Two', label: 'Child Two',  disabled: true},
     *     {value: 'Child Three', label: 'Child Three'},
     *   ]
     * },
     * {
     *   label: 'Group two',
     *   id: 2,
     *   disabled: false,
     *   choices: [
     *     {value: 'Child Four', label: 'Child Four', disabled: true},
     *     {value: 'Child Five', label: 'Child Five'},
     *     {value: 'Child Six', label: 'Child Six', customProperties: {
     *       description: 'Custom description about child six',
     *       random: 'Another random custom property'
     *     }},
     *   ]
     * }], 'value', 'label', false);
     * ```
     */
    Choices.prototype.setChoices = function (choicesArrayOrFetcher, value, label, replaceChoices, clearSearchFlag) {
        var _this = this;
        if (choicesArrayOrFetcher === void 0) { choicesArrayOrFetcher = []; }
        if (value === void 0) { value = 'value'; }
        if (label === void 0) { label = 'label'; }
        if (replaceChoices === void 0) { replaceChoices = false; }
        if (clearSearchFlag === void 0) { clearSearchFlag = true; }
        if (!this.initialisedOK) {
            this._warnChoicesInitFailed('setChoices');
            return this;
        }
        if (!this._isSelectElement) {
            throw new TypeError("setChoices can't be used with INPUT based Choices");
        }
        if (typeof value !== 'string' || !value) {
            throw new TypeError("value parameter must be a name of 'value' field in passed objects");
        }
        // Clear choices if needed
        if (replaceChoices) {
            this.clearChoices();
        }
        if (typeof choicesArrayOrFetcher === 'function') {
            // it's a choices fetcher function
            var fetcher_1 = choicesArrayOrFetcher(this);
            if (typeof Promise === 'function' && fetcher_1 instanceof Promise) {
                // that's a promise
                // eslint-disable-next-line no-promise-executor-return
                return new Promise(function (resolve) { return requestAnimationFrame(resolve); })
                    .then(function () { return _this._handleLoadingState(true); })
                    .then(function () { return fetcher_1; })
                    .then(function (data) { return _this.setChoices(data, value, label, replaceChoices); })
                    .catch(function (err) {
                    if (!_this.config.silent) {
                        console.error(err);
                    }
                })
                    .then(function () { return _this._handleLoadingState(false); })
                    .then(function () { return _this; });
            }
            // function returned something else than promise, let's check if it's an array of choices
            if (!Array.isArray(fetcher_1)) {
                throw new TypeError(".setChoices first argument function must return either array of choices or Promise, got: ".concat(typeof fetcher_1));
            }
            // recursion with results, it's sync and choices were cleared already
            return this.setChoices(fetcher_1, value, label, false);
        }
        if (!Array.isArray(choicesArrayOrFetcher)) {
            throw new TypeError(".setChoices must be called either with array of choices with a function resulting into Promise of array of choices");
        }
        this.containerOuter.removeLoadingState();
        this._store.withTxn(function () {
            if (clearSearchFlag) {
                _this._isSearching = false;
            }
            var isDefaultValue = value === 'value';
            var isDefaultLabel = label === 'label';
            choicesArrayOrFetcher.forEach(function (groupOrChoice) {
                if ('choices' in groupOrChoice) {
                    var group = groupOrChoice;
                    if (!isDefaultLabel) {
                        group = __assign(__assign({}, group), { label: group[label] });
                    }
                    _this._addGroup(mapInputToChoice(group, true));
                }
                else {
                    var choice = groupOrChoice;
                    if (!isDefaultLabel || !isDefaultValue) {
                        choice = __assign(__assign({}, choice), { value: choice[value], label: choice[label] });
                    }
                    _this._addChoice(mapInputToChoice(choice, false));
                }
            });
            _this.unhighlightAll();
        });
        // @todo integrate with Store
        this._searcher.reset();
        return this;
    };
    Choices.prototype.refresh = function (withEvents, selectFirstOption, deselectAll) {
        var _this = this;
        if (withEvents === void 0) { withEvents = false; }
        if (selectFirstOption === void 0) { selectFirstOption = false; }
        if (deselectAll === void 0) { deselectAll = false; }
        if (!this._isSelectElement) {
            if (!this.config.silent) {
                console.warn('refresh method can only be used on choices backed by a <select> element');
            }
            return this;
        }
        this._store.withTxn(function () {
            var choicesFromOptions = _this.passedElement.optionsAsChoices();
            // Build the list of items which require preserving
            var existingItems = {};
            if (!deselectAll) {
                _this._store.items.forEach(function (choice) {
                    if (choice.id && choice.active && choice.selected && !choice.disabled) {
                        existingItems[choice.value] = true;
                    }
                });
            }
            _this.clearStore(false);
            var updateChoice = function (choice) {
                if (deselectAll) {
                    _this._store.dispatch(removeItem$1(choice));
                }
                else if (existingItems[choice.value]) {
                    choice.selected = true;
                }
            };
            choicesFromOptions.forEach(function (groupOrChoice) {
                if ('choices' in groupOrChoice) {
                    groupOrChoice.choices.forEach(updateChoice);
                    return;
                }
                updateChoice(groupOrChoice);
            });
            /* @todo only generate add events for the added options instead of all
            if (withEvents) {
              items.forEach((choice) => {
                if (existingItems[choice.value]) {
                  this.passedElement.triggerEvent(
                    EventType.removeItem,
                    this._getChoiceForEvent(choice),
                  );
                }
              });
            }
            */
            // load new choices & items
            _this._addPredefinedChoices(choicesFromOptions, selectFirstOption, withEvents);
            // re-do search if required
            if (_this._isSearching) {
                _this._searchChoices(_this.input.value);
            }
        });
        return this;
    };
    Choices.prototype.removeChoice = function (value) {
        var choice = this._store.choices.find(function (c) { return c.value === value; });
        if (!choice) {
            return this;
        }
        this._clearNotice();
        this._store.dispatch(removeChoice(choice));
        // @todo integrate with Store
        this._searcher.reset();
        if (choice.selected) {
            this.passedElement.triggerEvent(EventType.removeItem, this._getChoiceForOutput(choice));
        }
        return this;
    };
    Choices.prototype.clearChoices = function () {
        var _this = this;
        this._store.withTxn(function () {
            _this._store.choices.forEach(function (choice) {
                if (!choice.selected) {
                    _this._store.dispatch(removeChoice(choice));
                }
            });
        });
        // @todo integrate with Store
        this._searcher.reset();
        return this;
    };
    Choices.prototype.clearStore = function (clearOptions) {
        if (clearOptions === void 0) { clearOptions = true; }
        this._stopSearch();
        if (clearOptions) {
            this.passedElement.element.replaceChildren('');
        }
        this.itemList.element.replaceChildren('');
        this.choiceList.element.replaceChildren('');
        this._store.reset();
        this._lastAddedChoiceId = 0;
        this._lastAddedGroupId = 0;
        // @todo integrate with Store
        this._searcher.reset();
        return this;
    };
    Choices.prototype.clearInput = function () {
        var shouldSetInputWidth = !this._isSelectOneElement;
        this.input.clear(shouldSetInputWidth);
        this._stopSearch();
        return this;
    };
    Choices.prototype._validateConfig = function () {
        var config = this.config;
        var invalidConfigOptions = diff(config, DEFAULT_CONFIG);
        if (invalidConfigOptions.length) {
            console.warn('Unknown config option(s) passed', invalidConfigOptions.join(', '));
        }
        if (config.allowHTML && config.allowHtmlUserInput) {
            if (config.addItems) {
                console.warn('Warning: allowHTML/allowHtmlUserInput/addItems all being true is strongly not recommended and may lead to XSS attacks');
            }
            if (config.addChoices) {
                console.warn('Warning: allowHTML/allowHtmlUserInput/addChoices all being true is strongly not recommended and may lead to XSS attacks');
            }
        }
    };
    Choices.prototype._render = function (changes) {
        if (changes === void 0) { changes = { choices: true, groups: true, items: true }; }
        if (this._store.inTxn()) {
            return;
        }
        if (this._isSelectElement) {
            if (changes.choices || changes.groups) {
                this._renderChoices();
            }
        }
        if (changes.items) {
            this._renderItems();
        }
    };
    Choices.prototype._renderChoices = function () {
        var _this = this;
        if (!this._canAddItems()) {
            return; // block rendering choices if the input limit is reached.
        }
        var _a = this, config = _a.config, isSearching = _a._isSearching;
        var _b = this._store, activeGroups = _b.activeGroups, activeChoices = _b.activeChoices;
        var renderLimit = 0;
        if (isSearching && config.searchResultLimit > 0) {
            renderLimit = config.searchResultLimit;
        }
        else if (config.renderChoiceLimit > 0) {
            renderLimit = config.renderChoiceLimit;
        }
        if (this._isSelectElement) {
            var backingOptions = activeChoices.filter(function (choice) { return !choice.element; });
            if (backingOptions.length) {
                this.passedElement.addOptions(backingOptions);
            }
        }
        var fragment = document.createDocumentFragment();
        var renderableChoices = function (choices) {
            return choices.filter(function (choice) {
                return !choice.placeholder && (isSearching ? !!choice.rank : config.renderSelectedChoices || !choice.selected);
            });
        };
        var selectableChoices = false;
        var renderChoices = function (choices, withinGroup, groupLabel) {
            if (isSearching) {
                // sortByRank is used to ensure stable sorting, as scores are non-unique
                // this additionally ensures fuseOptions.sortFn is not ignored
                choices.sort(sortByRank);
            }
            else if (config.shouldSort) {
                choices.sort(config.sorter);
            }
            var choiceLimit = choices.length;
            choiceLimit = !withinGroup && renderLimit && choiceLimit > renderLimit ? renderLimit : choiceLimit;
            choiceLimit--;
            choices.every(function (choice, index) {
                // choiceEl being empty signals the contents has probably significantly changed
                var dropdownItem = choice.choiceEl || _this._templates.choice(config, choice, config.itemSelectText, groupLabel);
                choice.choiceEl = dropdownItem;
                fragment.appendChild(dropdownItem);
                if (!choice.disabled && (isSearching || !choice.selected)) {
                    selectableChoices = true;
                }
                return index < choiceLimit;
            });
        };
        if (activeChoices.length) {
            if (config.resetScrollPosition) {
                requestAnimationFrame(function () { return _this.choiceList.scrollToTop(); });
            }
            if (!this._hasNonChoicePlaceholder && !isSearching && this._isSelectOneElement) {
                // If we have a placeholder choice along with groups
                renderChoices(activeChoices.filter(function (choice) { return choice.placeholder && !choice.group; }), false, undefined);
            }
            // If we have grouped options
            if (activeGroups.length && !isSearching) {
                if (config.shouldSort) {
                    activeGroups.sort(config.sorter);
                }
                // render Choices without group first, regardless of sort, otherwise they won't be distinguishable
                // from the last group
                renderChoices(activeChoices.filter(function (choice) { return !choice.placeholder && !choice.group; }), false, undefined);
                activeGroups.forEach(function (group) {
                    var groupChoices = renderableChoices(group.choices);
                    if (groupChoices.length) {
                        if (group.label) {
                            var dropdownGroup = group.groupEl || _this._templates.choiceGroup(_this.config, group);
                            group.groupEl = dropdownGroup;
                            dropdownGroup.remove();
                            fragment.appendChild(dropdownGroup);
                        }
                        renderChoices(groupChoices, true, config.appendGroupInSearch && isSearching ? group.label : undefined);
                    }
                });
            }
            else {
                renderChoices(renderableChoices(activeChoices), false, undefined);
            }
        }
        if (!selectableChoices) {
            if (!this._notice) {
                this._notice = {
                    text: resolveStringFunction(isSearching ? config.noResultsText : config.noChoicesText),
                    type: isSearching ? NoticeTypes.noResults : NoticeTypes.noChoices,
                };
            }
            fragment.replaceChildren('');
        }
        this._renderNotice(fragment);
        this.choiceList.element.replaceChildren(fragment);
        if (selectableChoices) {
            this._highlightChoice();
        }
    };
    Choices.prototype._renderItems = function () {
        var _this = this;
        var items = this._store.items || [];
        var itemList = this.itemList.element;
        var config = this.config;
        var fragment = document.createDocumentFragment();
        var itemFromList = function (item) {
            return itemList.querySelector("[data-item][data-id=\"".concat(item.id, "\"]"));
        };
        var addItemToFragment = function (item) {
            var el = item.itemEl;
            if (el && el.parentElement) {
                return;
            }
            el = itemFromList(item) || _this._templates.item(config, item, config.removeItemButton);
            item.itemEl = el;
            fragment.appendChild(el);
        };
        // new items
        items.forEach(addItemToFragment);
        var addItems = !!fragment.childNodes.length;
        if (this._isSelectOneElement && this._hasNonChoicePlaceholder) {
            var existingItems = itemList.children.length;
            if (addItems || existingItems > 1) {
                var placeholder = itemList.querySelector(getClassNamesSelector(config.classNames.placeholder));
                if (placeholder) {
                    placeholder.remove();
                }
            }
            else if (!existingItems) {
                addItems = true;
                addItemToFragment(mapInputToChoice({
                    selected: true,
                    value: '',
                    label: config.placeholderValue || '',
                    placeholder: true,
                }, false));
            }
        }
        if (addItems) {
            itemList.append(fragment);
            if (config.shouldSortItems && !this._isSelectOneElement) {
                items.sort(config.sorter);
                // push sorting into the DOM
                items.forEach(function (item) {
                    var el = itemFromList(item);
                    if (el) {
                        el.remove();
                        fragment.append(el);
                    }
                });
                itemList.append(fragment);
            }
        }
        if (this._isTextElement) {
            // Update the value of the hidden input
            this.passedElement.value = items.map(function (_a) {
                var value = _a.value;
                return value;
            }).join(config.delimiter);
        }
    };
    Choices.prototype._displayNotice = function (text, type, openDropdown) {
        if (openDropdown === void 0) { openDropdown = true; }
        var oldNotice = this._notice;
        if (oldNotice &&
            ((oldNotice.type === type && oldNotice.text === text) ||
                (oldNotice.type === NoticeTypes.addChoice &&
                    (type === NoticeTypes.noResults || type === NoticeTypes.noChoices)))) {
            if (openDropdown) {
                this.showDropdown(true);
            }
            return;
        }
        this._clearNotice();
        this._notice = text
            ? {
                text: text,
                type: type,
            }
            : undefined;
        this._renderNotice();
        if (openDropdown && text) {
            this.showDropdown(true);
        }
    };
    Choices.prototype._clearNotice = function () {
        if (!this._notice) {
            return;
        }
        var noticeElement = this.choiceList.element.querySelector(getClassNamesSelector(this.config.classNames.notice));
        if (noticeElement) {
            noticeElement.remove();
        }
        this._notice = undefined;
    };
    Choices.prototype._renderNotice = function (fragment) {
        var noticeConf = this._notice;
        if (noticeConf) {
            var notice = this._templates.notice(this.config, noticeConf.text, noticeConf.type);
            if (fragment) {
                fragment.append(notice);
            }
            else {
                this.choiceList.prepend(notice);
            }
        }
    };
    // eslint-disable-next-line class-methods-use-this
    Choices.prototype._getChoiceForOutput = function (choice, keyCode) {
        return {
            id: choice.id,
            highlighted: choice.highlighted,
            labelClass: choice.labelClass,
            labelDescription: choice.labelDescription,
            customProperties: choice.customProperties,
            disabled: choice.disabled,
            active: choice.active,
            label: choice.label,
            placeholder: choice.placeholder,
            value: choice.value,
            groupValue: choice.group ? choice.group.label : undefined,
            element: choice.element,
            keyCode: keyCode,
        };
    };
    Choices.prototype._triggerChange = function (value) {
        if (value === undefined || value === null) {
            return;
        }
        this.passedElement.triggerEvent(EventType.change, {
            value: value,
        });
    };
    Choices.prototype._handleButtonAction = function (element) {
        var _this = this;
        var items = this._store.items;
        if (!items.length || !this.config.removeItems || !this.config.removeItemButton) {
            return;
        }
        var id = element && parseDataSetId(element.parentElement);
        var itemToRemove = id && items.find(function (item) { return item.id === id; });
        if (!itemToRemove) {
            return;
        }
        this._store.withTxn(function () {
            // Remove item associated with button
            _this._removeItem(itemToRemove);
            _this._triggerChange(itemToRemove.value);
            if (_this._isSelectOneElement && !_this._hasNonChoicePlaceholder) {
                var placeholderChoice = _this._store.choices
                    .reverse()
                    .find(function (choice) { return !choice.disabled && choice.placeholder; });
                if (placeholderChoice) {
                    _this._addItem(placeholderChoice);
                    _this.unhighlightAll();
                    if (placeholderChoice.value) {
                        _this._triggerChange(placeholderChoice.value);
                    }
                }
            }
        });
    };
    Choices.prototype._handleItemAction = function (element, hasShiftKey) {
        var _this = this;
        if (hasShiftKey === void 0) { hasShiftKey = false; }
        var items = this._store.items;
        if (!items.length || !this.config.removeItems || this._isSelectOneElement) {
            return;
        }
        var id = parseDataSetId(element);
        if (!id) {
            return;
        }
        // We only want to select one item with a click
        // so we deselect any items that aren't the target
        // unless shift is being pressed
        items.forEach(function (item) {
            if (item.id === id && !item.highlighted) {
                _this.highlightItem(item);
            }
            else if (!hasShiftKey && item.highlighted) {
                _this.unhighlightItem(item);
            }
        });
        // Focus input as without focus, a user cannot do anything with a
        // highlighted item
        this.input.focus();
    };
    Choices.prototype._handleChoiceAction = function (element) {
        var _this = this;
        // If we are clicking on an option
        var id = parseDataSetId(element);
        var choice = id && this._store.getChoiceById(id);
        if (!choice || choice.disabled) {
            return false;
        }
        var hasActiveDropdown = this.dropdown.isActive;
        if (!choice.selected) {
            if (!this._canAddItems()) {
                return true; // causes _onEnterKey to early out
            }
            this._store.withTxn(function () {
                _this._addItem(choice, true, true);
                _this.clearInput();
                _this.unhighlightAll();
            });
            this._triggerChange(choice.value);
        }
        // We want to close the dropdown if we are dealing with a single select box
        if (hasActiveDropdown && this.config.closeDropdownOnSelect) {
            this.hideDropdown(true);
            this.containerOuter.element.focus();
        }
        return true;
    };
    Choices.prototype._handleBackspace = function (items) {
        var config = this.config;
        if (!config.removeItems || !items.length) {
            return;
        }
        var lastItem = items[items.length - 1];
        var hasHighlightedItems = items.some(function (item) { return item.highlighted; });
        // If editing the last item is allowed and there are not other selected items,
        // we can edit the item value. Otherwise if we can remove items, remove all selected items
        if (config.editItems && !hasHighlightedItems && lastItem) {
            this.input.value = lastItem.value;
            this.input.setWidth();
            this._removeItem(lastItem);
            this._triggerChange(lastItem.value);
        }
        else {
            if (!hasHighlightedItems) {
                // Highlight last item if none already highlighted
                this.highlightItem(lastItem, false);
            }
            this.removeHighlightedItems(true);
        }
    };
    Choices.prototype._loadChoices = function () {
        var _a;
        var config = this.config;
        if (this._isTextElement) {
            // Assign preset items from passed object first
            this._presetChoices = config.items.map(function (e) { return mapInputToChoice(e, false); });
            // Add any values passed from attribute
            if (this.passedElement.value) {
                var elementItems = this.passedElement.value
                    .split(config.delimiter)
                    .map(function (e) { return mapInputToChoice(e, false); });
                this._presetChoices = this._presetChoices.concat(elementItems);
            }
            this._presetChoices.forEach(function (choice) {
                choice.selected = true;
            });
        }
        else if (this._isSelectElement) {
            // Assign preset choices from passed object
            this._presetChoices = config.choices.map(function (e) { return mapInputToChoice(e, true); });
            // Create array of choices from option elements
            var choicesFromOptions = this.passedElement.optionsAsChoices();
            if (choicesFromOptions) {
                (_a = this._presetChoices).push.apply(_a, choicesFromOptions);
            }
        }
    };
    Choices.prototype._handleLoadingState = function (setLoading) {
        if (setLoading === void 0) { setLoading = true; }
        var el = this.itemList.element;
        if (setLoading) {
            this.disable();
            this.containerOuter.addLoadingState();
            if (this._isSelectOneElement) {
                el.replaceChildren(this._templates.placeholder(this.config, this.config.loadingText));
            }
            else {
                this.input.placeholder = this.config.loadingText;
            }
        }
        else {
            this.enable();
            this.containerOuter.removeLoadingState();
            if (this._isSelectOneElement) {
                el.replaceChildren('');
                this._render();
            }
            else {
                this.input.placeholder = this._placeholderValue || '';
            }
        }
    };
    Choices.prototype._handleSearch = function (value) {
        if (!this.input.isFocussed) {
            return;
        }
        // Check that we have a value to search and the input was an alphanumeric character
        if (value !== null && typeof value !== 'undefined' && value.length >= this.config.searchFloor) {
            var resultCount = this.config.searchChoices ? this._searchChoices(value) : 0;
            if (resultCount !== null) {
                // Trigger search event
                this.passedElement.triggerEvent(EventType.search, {
                    value: value,
                    resultCount: resultCount,
                });
            }
        }
        else if (this._store.choices.some(function (option) { return !option.active; })) {
            this._stopSearch();
        }
    };
    Choices.prototype._canAddItems = function () {
        var config = this.config;
        var maxItemCount = config.maxItemCount, maxItemText = config.maxItemText;
        if (!config.singleModeForMultiSelect && maxItemCount > 0 && maxItemCount <= this._store.items.length) {
            this.choiceList.element.replaceChildren('');
            this._displayNotice(typeof maxItemText === 'function' ? maxItemText(maxItemCount) : maxItemText, NoticeTypes.addChoice);
            return false;
        }
        return true;
    };
    Choices.prototype._canCreateItem = function (value) {
        var config = this.config;
        var canAddItem = true;
        var notice = '';
        if (canAddItem && typeof config.addItemFilter === 'function' && !config.addItemFilter(value)) {
            canAddItem = false;
            notice = resolveNoticeFunction(config.customAddItemText, value);
        }
        if (canAddItem) {
            var foundChoice = this._store.choices.find(function (choice) { return config.valueComparer(choice.value, value); });
            if (this._isSelectElement) {
                // for exact matches, do not prompt to add it as a custom choice
                if (foundChoice) {
                    this._displayNotice('', NoticeTypes.addChoice);
                    return false;
                }
            }
            else if (this._isTextElement && !config.duplicateItemsAllowed) {
                if (foundChoice) {
                    canAddItem = false;
                    notice = resolveNoticeFunction(config.uniqueItemText, value);
                }
            }
        }
        if (canAddItem) {
            notice = resolveNoticeFunction(config.addItemText, value);
        }
        if (notice) {
            this._displayNotice(notice, NoticeTypes.addChoice);
        }
        return canAddItem;
    };
    Choices.prototype._searchChoices = function (value) {
        var newValue = value.trim().replace(/\s{2,}/, ' ');
        // signal input didn't change search
        if (!newValue.length || newValue === this._currentValue) {
            return null;
        }
        var searcher = this._searcher;
        if (searcher.isEmptyIndex()) {
            searcher.index(this._store.searchableChoices);
        }
        // If new value matches the desired length and is not the same as the current value with a space
        var results = searcher.search(newValue);
        this._currentValue = newValue;
        this._highlightPosition = 0;
        this._isSearching = true;
        var notice = this._notice;
        var noticeType = notice && notice.type;
        if (noticeType !== NoticeTypes.addChoice) {
            if (!results.length) {
                this._displayNotice(resolveStringFunction(this.config.noResultsText), NoticeTypes.noResults);
            }
            else {
                this._clearNotice();
            }
        }
        this._store.dispatch(filterChoices(results));
        return results.length;
    };
    Choices.prototype._stopSearch = function () {
        if (this._isSearching) {
            this._currentValue = '';
            this._isSearching = false;
            this._clearNotice();
            this._store.dispatch(activateChoices(true));
            this.passedElement.triggerEvent(EventType.search, {
                value: '',
                resultCount: 0,
            });
        }
    };
    Choices.prototype._addEventListeners = function () {
        var documentElement = this._docRoot;
        var outerElement = this.containerOuter.element;
        var inputElement = this.input.element;
        // capture events - can cancel event processing or propagation
        documentElement.addEventListener('touchend', this._onTouchEnd, true);
        outerElement.addEventListener('keydown', this._onKeyDown, true);
        outerElement.addEventListener('mousedown', this._onMouseDown, true);
        // passive events - doesn't call `preventDefault` or `stopPropagation`
        documentElement.addEventListener('click', this._onClick, { passive: true });
        documentElement.addEventListener('touchmove', this._onTouchMove, {
            passive: true,
        });
        this.dropdown.element.addEventListener('mouseover', this._onMouseOver, {
            passive: true,
        });
        if (this._isSelectOneElement) {
            outerElement.addEventListener('focus', this._onFocus, {
                passive: true,
            });
            outerElement.addEventListener('blur', this._onBlur, {
                passive: true,
            });
        }
        inputElement.addEventListener('keyup', this._onKeyUp, {
            passive: true,
        });
        inputElement.addEventListener('input', this._onInput, {
            passive: true,
        });
        inputElement.addEventListener('focus', this._onFocus, {
            passive: true,
        });
        inputElement.addEventListener('blur', this._onBlur, {
            passive: true,
        });
        if (inputElement.form) {
            inputElement.form.addEventListener('reset', this._onFormReset, {
                passive: true,
            });
        }
        this.input.addEventListeners();
    };
    Choices.prototype._removeEventListeners = function () {
        var documentElement = this._docRoot;
        var outerElement = this.containerOuter.element;
        var inputElement = this.input.element;
        documentElement.removeEventListener('touchend', this._onTouchEnd, true);
        outerElement.removeEventListener('keydown', this._onKeyDown, true);
        outerElement.removeEventListener('mousedown', this._onMouseDown, true);
        documentElement.removeEventListener('click', this._onClick);
        documentElement.removeEventListener('touchmove', this._onTouchMove);
        this.dropdown.element.removeEventListener('mouseover', this._onMouseOver);
        if (this._isSelectOneElement) {
            outerElement.removeEventListener('focus', this._onFocus);
            outerElement.removeEventListener('blur', this._onBlur);
        }
        inputElement.removeEventListener('keyup', this._onKeyUp);
        inputElement.removeEventListener('input', this._onInput);
        inputElement.removeEventListener('focus', this._onFocus);
        inputElement.removeEventListener('blur', this._onBlur);
        if (inputElement.form) {
            inputElement.form.removeEventListener('reset', this._onFormReset);
        }
        this.input.removeEventListeners();
    };
    Choices.prototype._onKeyDown = function (event) {
        var keyCode = event.keyCode;
        var hasActiveDropdown = this.dropdown.isActive;
        /*
        See:
        https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key
        https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values
        https://en.wikipedia.org/wiki/UTF-16#Code_points_from_U+010000_to_U+10FFFF - UTF-16 surrogate pairs
        https://stackoverflow.com/a/70866532 - "Unidentified" for mobile
        http://www.unicode.org/versions/Unicode5.2.0/ch16.pdf#G19635 - U+FFFF is reserved (Section 16.7)
    
        Logic: when a key event is sent, `event.key` represents its printable value _or_ one
        of a large list of special values indicating meta keys/functionality. In addition,
        key events for compose functionality contain a value of `Dead` when mid-composition.
    
        I can't quite verify it, but non-English IMEs may also be able to generate key codes
        for code points in the surrogate-pair range, which could potentially be seen as having
        key.length > 1. Since `Fn` is one of the special keys, we can't distinguish by that
        alone.
    
        Here, key.length === 1 means we know for sure the input was printable and not a special
        `key` value. When the length is greater than 1, it could be either a printable surrogate
        pair or a special `key` value. We can tell the difference by checking if the _character
        code_ value (not code point!) is in the "surrogate pair" range or not.
    
        We don't use .codePointAt because an invalid code point would return 65535, which wouldn't
        pass the >= 0x10000 check we would otherwise use.
    
        > ...The Unicode Standard sets aside 66 noncharacter code points. The last two code points
        > of each plane are noncharacters: U+FFFE and U+FFFF on the BMP...
        */
        var wasPrintableChar = event.key.length === 1 ||
            (event.key.length === 2 && event.key.charCodeAt(0) >= 0xd800) ||
            event.key === 'Unidentified';
        if (!this._isTextElement && !hasActiveDropdown) {
            this.showDropdown();
            if (!this.input.isFocussed && wasPrintableChar) {
                /*
                  We update the input value with the pressed key as
                  the input was not focussed at the time of key press
                  therefore does not have the value of the key.
                */
                this.input.value += event.key;
                // browsers interpret a space as pagedown
                if (event.key === ' ') {
                    event.preventDefault();
                }
            }
        }
        switch (keyCode) {
            case 65 /* KeyCodeMap.A_KEY */:
                return this._onSelectKey(event, this.itemList.element.hasChildNodes());
            case 13 /* KeyCodeMap.ENTER_KEY */:
                return this._onEnterKey(event, hasActiveDropdown);
            case 27 /* KeyCodeMap.ESC_KEY */:
                return this._onEscapeKey(event, hasActiveDropdown);
            case 38 /* KeyCodeMap.UP_KEY */:
            case 33 /* KeyCodeMap.PAGE_UP_KEY */:
            case 40 /* KeyCodeMap.DOWN_KEY */:
            case 34 /* KeyCodeMap.PAGE_DOWN_KEY */:
                return this._onDirectionKey(event, hasActiveDropdown);
            case 8 /* KeyCodeMap.DELETE_KEY */:
            case 46 /* KeyCodeMap.BACK_KEY */:
                return this._onDeleteKey(event, this._store.items, this.input.isFocussed);
        }
    };
    Choices.prototype._onKeyUp = function ( /* event: KeyboardEvent */) {
        this._canSearch = this.config.searchEnabled;
    };
    Choices.prototype._onInput = function ( /* event: InputEvent */) {
        var value = this.input.value;
        if (!value) {
            if (this._isTextElement) {
                this.hideDropdown(true);
            }
            else {
                this._stopSearch();
            }
            return;
        }
        if (!this._canAddItems()) {
            return;
        }
        if (this._canSearch) {
            // do the search even if the entered text can not be added
            this._handleSearch(value);
        }
        if (!this._canAddUserChoices) {
            return;
        }
        // determine if a notice needs to be displayed for why a search result can't be added
        this._canCreateItem(value);
        if (this._isSelectElement) {
            this._highlightPosition = 0; // reset to select the notice and/or exact match
            this._highlightChoice();
        }
    };
    Choices.prototype._onSelectKey = function (event, hasItems) {
        // If CTRL + A or CMD + A have been pressed and there are items to select
        if ((event.ctrlKey || event.metaKey) && hasItems) {
            this._canSearch = false;
            var shouldHightlightAll = this.config.removeItems && !this.input.value && this.input.element === document.activeElement;
            if (shouldHightlightAll) {
                this.highlightAll();
            }
        }
    };
    Choices.prototype._onEnterKey = function (event, hasActiveDropdown) {
        var _this = this;
        var value = this.input.value;
        var target = event.target;
        event.preventDefault();
        if (target && target.hasAttribute('data-button')) {
            this._handleButtonAction(target);
            return;
        }
        if (!hasActiveDropdown) {
            if (this._isSelectElement || this._notice) {
                this.showDropdown();
            }
            return;
        }
        var highlightedChoice = this.dropdown.element.querySelector(getClassNamesSelector(this.config.classNames.highlightedState));
        if (highlightedChoice && this._handleChoiceAction(highlightedChoice)) {
            return;
        }
        if (!target || !value) {
            this.hideDropdown(true);
            return;
        }
        if (!this._canAddItems()) {
            return;
        }
        var addedItem = false;
        this._store.withTxn(function () {
            addedItem = _this._findAndSelectChoiceByValue(value, true);
            if (!addedItem) {
                if (!_this._canAddUserChoices) {
                    return;
                }
                if (!_this._canCreateItem(value)) {
                    return;
                }
                var sanitisedValue = sanitise(value);
                var userValue = _this.config.allowHtmlUserInput || sanitisedValue === value ? value : { escaped: sanitisedValue, raw: value };
                _this._addChoice(mapInputToChoice({
                    value: userValue,
                    label: userValue,
                    selected: true,
                }, false), true, true);
                addedItem = true;
            }
            _this.clearInput();
            _this.unhighlightAll();
        });
        if (!addedItem) {
            return;
        }
        this._triggerChange(value);
        if (this.config.closeDropdownOnSelect) {
            this.hideDropdown(true);
        }
    };
    Choices.prototype._onEscapeKey = function (event, hasActiveDropdown) {
        if (hasActiveDropdown) {
            event.stopPropagation();
            this.hideDropdown(true);
            this.containerOuter.element.focus();
        }
    };
    Choices.prototype._onDirectionKey = function (event, hasActiveDropdown) {
        var keyCode = event.keyCode;
        // If up or down key is pressed, traverse through options
        if (hasActiveDropdown || this._isSelectOneElement) {
            this.showDropdown();
            this._canSearch = false;
            var directionInt = keyCode === 40 /* KeyCodeMap.DOWN_KEY */ || keyCode === 34 /* KeyCodeMap.PAGE_DOWN_KEY */ ? 1 : -1;
            var skipKey = event.metaKey || keyCode === 34 /* KeyCodeMap.PAGE_DOWN_KEY */ || keyCode === 33 /* KeyCodeMap.PAGE_UP_KEY */;
            var nextEl = void 0;
            if (skipKey) {
                if (directionInt > 0) {
                    nextEl = this.dropdown.element.querySelector("".concat(selectableChoiceIdentifier, ":last-of-type"));
                }
                else {
                    nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);
                }
            }
            else {
                var currentEl = this.dropdown.element.querySelector(getClassNamesSelector(this.config.classNames.highlightedState));
                if (currentEl) {
                    nextEl = getAdjacentEl(currentEl, selectableChoiceIdentifier, directionInt);
                }
                else {
                    nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);
                }
            }
            if (nextEl) {
                // We prevent default to stop the cursor moving
                // when pressing the arrow
                if (!isScrolledIntoView(nextEl, this.choiceList.element, directionInt)) {
                    this.choiceList.scrollToChildElement(nextEl, directionInt);
                }
                this._highlightChoice(nextEl);
            }
            // Prevent default to maintain cursor position whilst
            // traversing dropdown options
            event.preventDefault();
        }
    };
    Choices.prototype._onDeleteKey = function (event, items, hasFocusedInput) {
        // If backspace or delete key is pressed and the input has no value
        if (!this._isSelectOneElement && !event.target.value && hasFocusedInput) {
            this._handleBackspace(items);
            event.preventDefault();
        }
    };
    Choices.prototype._onTouchMove = function () {
        if (this._wasTap) {
            this._wasTap = false;
        }
    };
    Choices.prototype._onTouchEnd = function (event) {
        var target = (event || event.touches[0]).target;
        var touchWasWithinContainer = this._wasTap && this.containerOuter.element.contains(target);
        if (touchWasWithinContainer) {
            var containerWasExactTarget = target === this.containerOuter.element || target === this.containerInner.element;
            if (containerWasExactTarget) {
                if (this._isTextElement) {
                    this.input.focus();
                }
                else if (this._isSelectMultipleElement) {
                    this.showDropdown();
                }
            }
            // Prevents focus event firing
            event.stopPropagation();
        }
        this._wasTap = true;
    };
    /**
     * Handles mousedown event in capture mode for containetOuter.element
     */
    Choices.prototype._onMouseDown = function (event) {
        var target = event.target;
        if (!(target instanceof HTMLElement)) {
            return;
        }
        // If we have our mouse down on the scrollbar and are on IE11...
        if (IS_IE11 && this.choiceList.element.contains(target)) {
            // check if click was on a scrollbar area
            var firstChoice = this.choiceList.element.firstElementChild;
            this._isScrollingOnIe =
                this._direction === 'ltr' ? event.offsetX >= firstChoice.offsetWidth : event.offsetX < firstChoice.offsetLeft;
        }
        if (target === this.input.element) {
            return;
        }
        var item = target.closest('[data-button],[data-item],[data-choice]');
        if (item instanceof HTMLElement) {
            if ('button' in item.dataset) {
                this._handleButtonAction(item);
            }
            else if ('item' in item.dataset) {
                this._handleItemAction(item, event.shiftKey);
            }
            else if ('choice' in item.dataset) {
                this._handleChoiceAction(item);
            }
        }
        event.preventDefault();
    };
    /**
     * Handles mouseover event over this.dropdown
     * @param {MouseEvent} event
     */
    Choices.prototype._onMouseOver = function (_a) {
        var target = _a.target;
        if (target instanceof HTMLElement && 'choice' in target.dataset) {
            this._highlightChoice(target);
        }
    };
    Choices.prototype._onClick = function (_a) {
        var target = _a.target;
        var containerOuter = this.containerOuter;
        var clickWasWithinContainer = containerOuter.element.contains(target);
        if (clickWasWithinContainer) {
            if (!this.dropdown.isActive && !containerOuter.isDisabled) {
                if (this._isTextElement) {
                    if (document.activeElement !== this.input.element) {
                        this.input.focus();
                    }
                }
                else {
                    this.showDropdown();
                    containerOuter.element.focus();
                }
            }
            else if (this._isSelectOneElement &&
                target !== this.input.element &&
                !this.dropdown.element.contains(target)) {
                this.hideDropdown();
            }
        }
        else {
            containerOuter.removeFocusState();
            this.hideDropdown(true);
            this.unhighlightAll();
        }
    };
    Choices.prototype._onFocus = function (_a) {
        var target = _a.target;
        var containerOuter = this.containerOuter;
        var focusWasWithinContainer = target && containerOuter.element.contains(target);
        if (!focusWasWithinContainer) {
            return;
        }
        var targetIsInput = target === this.input.element;
        if (this._isTextElement) {
            if (targetIsInput) {
                containerOuter.addFocusState();
            }
        }
        else if (this._isSelectMultipleElement) {
            if (targetIsInput) {
                this.showDropdown(true);
                // If element is a select box, the focused element is the container and the dropdown
                // isn't already open, focus and show dropdown
                containerOuter.addFocusState();
            }
        }
        else {
            containerOuter.addFocusState();
            if (targetIsInput) {
                this.showDropdown(true);
            }
        }
    };
    Choices.prototype._onBlur = function (_a) {
        var target = _a.target;
        var containerOuter = this.containerOuter;
        var blurWasWithinContainer = target && containerOuter.element.contains(target);
        if (blurWasWithinContainer && !this._isScrollingOnIe) {
            var targetIsInput = target === this.input.element;
            if (this._isTextElement || this._isSelectMultipleElement) {
                if (targetIsInput) {
                    containerOuter.removeFocusState();
                    this.hideDropdown(true);
                    this.unhighlightAll();
                }
            }
            else {
                containerOuter.removeFocusState();
                if (targetIsInput || (target === containerOuter.element && !this._canSearch)) {
                    this.hideDropdown(true);
                }
            }
        }
        else {
            // On IE11, clicking the scollbar blurs our input and thus
            // closes the dropdown. To stop this, we refocus our input
            // if we know we are on IE *and* are scrolling.
            this._isScrollingOnIe = false;
            this.input.element.focus();
        }
    };
    Choices.prototype._onFormReset = function () {
        var _this = this;
        this._store.withTxn(function () {
            _this.clearInput();
            _this.hideDropdown();
            _this.refresh(false, false, true);
            if (_this._initialItems.length) {
                _this.setChoiceByValue(_this._initialItems);
            }
        });
    };
    Choices.prototype._highlightChoice = function (el) {
        if (el === void 0) { el = null; }
        var choices = Array.from(this.dropdown.element.querySelectorAll(selectableChoiceIdentifier));
        if (!choices.length) {
            return;
        }
        var passedEl = el;
        var highlightedState = this.config.classNames.highlightedState;
        var highlightedChoices = Array.from(this.dropdown.element.querySelectorAll(getClassNamesSelector(highlightedState)));
        // Remove any highlighted choices
        highlightedChoices.forEach(function (choice) {
            removeClassesFromElement(choice, highlightedState);
            choice.setAttribute('aria-selected', 'false');
        });
        if (passedEl) {
            this._highlightPosition = choices.indexOf(passedEl);
        }
        else {
            // Highlight choice based on last known highlight location
            if (choices.length > this._highlightPosition) {
                // If we have an option to highlight
                passedEl = choices[this._highlightPosition];
            }
            else {
                // Otherwise highlight the option before
                passedEl = choices[choices.length - 1];
            }
            if (!passedEl) {
                passedEl = choices[0];
            }
        }
        addClassesToElement(passedEl, highlightedState);
        passedEl.setAttribute('aria-selected', 'true');
        this.passedElement.triggerEvent(EventType.highlightChoice, {
            el: passedEl,
        });
        if (this.dropdown.isActive) {
            // IE11 ignores aria-label and blocks virtual keyboard
            // if aria-activedescendant is set without a dropdown
            this.input.setActiveDescendant(passedEl.id);
            this.containerOuter.setActiveDescendant(passedEl.id);
        }
    };
    Choices.prototype._addItem = function (item, withEvents, userTriggered) {
        if (withEvents === void 0) { withEvents = true; }
        if (userTriggered === void 0) { userTriggered = false; }
        if (!item.id) {
            throw new TypeError('item.id must be set before _addItem is called for a choice/item');
        }
        if (this.config.singleModeForMultiSelect || this._isSelectOneElement) {
            this.removeActiveItems(item.id);
        }
        this._store.dispatch(addItem(item));
        if (withEvents) {
            this.passedElement.triggerEvent(EventType.addItem, this._getChoiceForOutput(item));
            if (userTriggered) {
                this.passedElement.triggerEvent(EventType.choice, this._getChoiceForOutput(item));
            }
        }
    };
    Choices.prototype._removeItem = function (item) {
        if (!item.id) {
            return;
        }
        this._store.dispatch(removeItem$1(item));
        this.passedElement.triggerEvent(EventType.removeItem, this._getChoiceForOutput(item));
    };
    Choices.prototype._addChoice = function (choice, withEvents, userTriggered) {
        if (withEvents === void 0) { withEvents = true; }
        if (userTriggered === void 0) { userTriggered = false; }
        if (choice.id) {
            throw new TypeError('Can not re-add a choice which has already been added');
        }
        var config = this.config;
        if ((this._isSelectElement || !config.duplicateItemsAllowed) &&
            this._store.choices.find(function (c) { return config.valueComparer(c.value, choice.value); })) {
            return;
        }
        // Generate unique id, in-place update is required so chaining _addItem works as expected
        this._lastAddedChoiceId++;
        choice.id = this._lastAddedChoiceId;
        choice.elementId = "".concat(this._baseId, "-").concat(this._idNames.itemChoice, "-").concat(choice.id);
        var prependValue = config.prependValue, appendValue = config.appendValue;
        if (prependValue) {
            choice.value = prependValue + choice.value;
        }
        if (appendValue) {
            choice.value += appendValue.toString();
        }
        if ((prependValue || appendValue) && choice.element) {
            choice.element.value = choice.value;
        }
        this._clearNotice();
        this._store.dispatch(addChoice(choice));
        if (choice.selected) {
            this._addItem(choice, withEvents, userTriggered);
        }
    };
    Choices.prototype._addGroup = function (group, withEvents) {
        var _this = this;
        if (withEvents === void 0) { withEvents = true; }
        if (group.id) {
            throw new TypeError('Can not re-add a group which has already been added');
        }
        this._store.dispatch(addGroup(group));
        if (!group.choices) {
            return;
        }
        // add unique id for the group(s), and do not store the full list of choices in this group
        this._lastAddedGroupId++;
        group.id = this._lastAddedGroupId;
        group.choices.forEach(function (item) {
            item.group = group;
            if (group.disabled) {
                item.disabled = true;
            }
            _this._addChoice(item, withEvents);
        });
    };
    Choices.prototype._createTemplates = function () {
        var _this = this;
        var callbackOnCreateTemplates = this.config.callbackOnCreateTemplates;
        var userTemplates = {};
        if (typeof callbackOnCreateTemplates === 'function') {
            userTemplates = callbackOnCreateTemplates.call(this, strToEl, escapeForTemplate, getClassNames);
        }
        var templating = {};
        Object.keys(this._templates).forEach(function (name) {
            if (name in userTemplates) {
                templating[name] = userTemplates[name].bind(_this);
            }
            else {
                templating[name] = _this._templates[name].bind(_this);
            }
        });
        this._templates = templating;
    };
    Choices.prototype._createElements = function () {
        var templating = this._templates;
        var _a = this, config = _a.config, isSelectOneElement = _a._isSelectOneElement;
        var position = config.position, classNames = config.classNames;
        var elementType = this._elementType;
        this.containerOuter = new Container({
            element: templating.containerOuter(config, this._direction, this._isSelectElement, isSelectOneElement, config.searchEnabled, elementType, config.labelId),
            classNames: classNames,
            type: elementType,
            position: position,
        });
        this.containerInner = new Container({
            element: templating.containerInner(config),
            classNames: classNames,
            type: elementType,
            position: position,
        });
        this.input = new Input({
            element: templating.input(config, this._placeholderValue),
            classNames: classNames,
            type: elementType,
            preventPaste: !config.paste,
        });
        this.choiceList = new List({
            element: templating.choiceList(config, isSelectOneElement),
        });
        this.itemList = new List({
            element: templating.itemList(config, isSelectOneElement),
        });
        this.dropdown = new Dropdown({
            element: templating.dropdown(config),
            classNames: classNames,
            type: elementType,
        });
    };
    Choices.prototype._createStructure = function () {
        var _a = this, containerInner = _a.containerInner, containerOuter = _a.containerOuter, passedElement = _a.passedElement;
        var dropdownElement = this.dropdown.element;
        // Hide original element
        passedElement.conceal();
        // Wrap input in container preserving DOM ordering
        containerInner.wrap(passedElement.element);
        // Wrapper inner container with outer container
        containerOuter.wrap(containerInner.element);
        if (this._isSelectOneElement) {
            this.input.placeholder = this.config.searchPlaceholderValue || '';
        }
        else {
            if (this._placeholderValue) {
                this.input.placeholder = this._placeholderValue;
            }
            this.input.setWidth();
        }
        containerOuter.element.appendChild(containerInner.element);
        containerOuter.element.appendChild(dropdownElement);
        containerInner.element.appendChild(this.itemList.element);
        dropdownElement.appendChild(this.choiceList.element);
        if (!this._isSelectOneElement) {
            containerInner.element.appendChild(this.input.element);
        }
        else if (this.config.searchEnabled) {
            dropdownElement.insertBefore(this.input.element, dropdownElement.firstChild);
        }
        this._highlightPosition = 0;
        this._isSearching = false;
    };
    Choices.prototype._initStore = function () {
        var _this = this;
        this._store.subscribe(this._render).withTxn(function () {
            _this._addPredefinedChoices(_this._presetChoices, _this._isSelectOneElement && !_this._hasNonChoicePlaceholder, false);
        });
        if (!this._store.choices.length || (this._isSelectOneElement && this._hasNonChoicePlaceholder)) {
            this._render();
        }
    };
    Choices.prototype._addPredefinedChoices = function (choices, selectFirstOption, withEvents) {
        var _this = this;
        if (selectFirstOption === void 0) { selectFirstOption = false; }
        if (withEvents === void 0) { withEvents = true; }
        if (selectFirstOption) {
            /**
             * If there is a selected choice already or the choice is not the first in
             * the array, add each choice normally.
             *
             * Otherwise we pre-select the first enabled choice in the array ("select-one" only)
             */
            var noSelectedChoices = choices.findIndex(function (choice) { return choice.selected; }) === -1;
            if (noSelectedChoices) {
                choices.some(function (choice) {
                    if (choice.disabled || 'choices' in choice) {
                        return false;
                    }
                    choice.selected = true;
                    return true;
                });
            }
        }
        choices.forEach(function (item) {
            if ('choices' in item) {
                if (_this._isSelectElement) {
                    _this._addGroup(item, withEvents);
                }
            }
            else {
                _this._addChoice(item, withEvents);
            }
        });
    };
    Choices.prototype._findAndSelectChoiceByValue = function (value, userTriggered) {
        var _this = this;
        if (userTriggered === void 0) { userTriggered = false; }
        // Check 'value' property exists and the choice isn't already selected
        var foundChoice = this._store.choices.find(function (choice) { return _this.config.valueComparer(choice.value, value); });
        if (foundChoice && !foundChoice.disabled && !foundChoice.selected) {
            this._addItem(foundChoice, true, userTriggered);
            return true;
        }
        return false;
    };
    Choices.prototype._generatePlaceholderValue = function () {
        var config = this.config;
        if (!config.placeholder) {
            return null;
        }
        if (this._hasNonChoicePlaceholder) {
            return config.placeholderValue;
        }
        if (this._isSelectElement) {
            var placeholderOption = this.passedElement.placeholderOption;
            return placeholderOption ? placeholderOption.text : null;
        }
        return null;
    };
    Choices.prototype._warnChoicesInitFailed = function (caller) {
        if (this.config.silent) {
            return;
        }
        if (!this.initialised) {
            throw new TypeError("".concat(caller, " called on a non-initialised instance of Choices"));
        }
        else if (!this.initialisedOK) {
            throw new TypeError("".concat(caller, " called for an element which has multiple instances of Choices initialised on it"));
        }
    };
    Choices.version = '11.0.2';
    return Choices;
}());




/***/ }),

/***/ "./node_modules/nouislider/dist/nouislider.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/nouislider/dist/nouislider.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PipsMode: () => (/* binding */ PipsMode),
/* harmony export */   PipsType: () => (/* binding */ PipsType),
/* harmony export */   create: () => (/* binding */ initialize),
/* harmony export */   cssClasses: () => (/* binding */ cssClasses),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

var PipsMode;
(function (PipsMode) {
    PipsMode["Range"] = "range";
    PipsMode["Steps"] = "steps";
    PipsMode["Positions"] = "positions";
    PipsMode["Count"] = "count";
    PipsMode["Values"] = "values";
})(PipsMode || (PipsMode = {}));
var PipsType;
(function (PipsType) {
    PipsType[PipsType["None"] = -1] = "None";
    PipsType[PipsType["NoValue"] = 0] = "NoValue";
    PipsType[PipsType["LargeValue"] = 1] = "LargeValue";
    PipsType[PipsType["SmallValue"] = 2] = "SmallValue";
})(PipsType || (PipsType = {}));
//region Helper Methods
function isValidFormatter(entry) {
    return isValidPartialFormatter(entry) && typeof entry.from === "function";
}
function isValidPartialFormatter(entry) {
    // partial formatters only need a to function and not a from function
    return typeof entry === "object" && typeof entry.to === "function";
}
function removeElement(el) {
    el.parentElement.removeChild(el);
}
function isSet(value) {
    return value !== null && value !== undefined;
}
// Bindable version
function preventDefault(e) {
    e.preventDefault();
}
// Removes duplicates from an array.
function unique(array) {
    return array.filter(function (a) {
        return !this[a] ? (this[a] = true) : false;
    }, {});
}
// Round a value to the closest 'to'.
function closest(value, to) {
    return Math.round(value / to) * to;
}
// Current position of an element relative to the document.
function offset(elem, orientation) {
    var rect = elem.getBoundingClientRect();
    var doc = elem.ownerDocument;
    var docElem = doc.documentElement;
    var pageOffset = getPageOffset(doc);
    // getBoundingClientRect contains left scroll in Chrome on Android.
    // I haven't found a feature detection that proves this. Worst case
    // scenario on mis-match: the 'tap' feature on horizontal sliders breaks.
    if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) {
        pageOffset.x = 0;
    }
    return orientation ? rect.top + pageOffset.y - docElem.clientTop : rect.left + pageOffset.x - docElem.clientLeft;
}
// Checks whether a value is numerical.
function isNumeric(a) {
    return typeof a === "number" && !isNaN(a) && isFinite(a);
}
// Sets a class and removes it after [duration] ms.
function addClassFor(element, className, duration) {
    if (duration > 0) {
        addClass(element, className);
        setTimeout(function () {
            removeClass(element, className);
        }, duration);
    }
}
// Limits a value to 0 - 100
function limit(a) {
    return Math.max(Math.min(a, 100), 0);
}
// Wraps a variable as an array, if it isn't one yet.
// Note that an input array is returned by reference!
function asArray(a) {
    return Array.isArray(a) ? a : [a];
}
// Counts decimals
function countDecimals(numStr) {
    numStr = String(numStr);
    var pieces = numStr.split(".");
    return pieces.length > 1 ? pieces[1].length : 0;
}
// http://youmightnotneedjquery.com/#add_class
function addClass(el, className) {
    if (el.classList && !/\s/.test(className)) {
        el.classList.add(className);
    }
    else {
        el.className += " " + className;
    }
}
// http://youmightnotneedjquery.com/#remove_class
function removeClass(el, className) {
    if (el.classList && !/\s/.test(className)) {
        el.classList.remove(className);
    }
    else {
        el.className = el.className.replace(new RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)", "gi"), " ");
    }
}
// https://plainjs.com/javascript/attributes/adding-removing-and-testing-for-classes-9/
function hasClass(el, className) {
    return el.classList ? el.classList.contains(className) : new RegExp("\\b" + className + "\\b").test(el.className);
}
// https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY#Notes
function getPageOffset(doc) {
    var supportPageOffset = window.pageXOffset !== undefined;
    var isCSS1Compat = (doc.compatMode || "") === "CSS1Compat";
    var x = supportPageOffset
        ? window.pageXOffset
        : isCSS1Compat
            ? doc.documentElement.scrollLeft
            : doc.body.scrollLeft;
    var y = supportPageOffset
        ? window.pageYOffset
        : isCSS1Compat
            ? doc.documentElement.scrollTop
            : doc.body.scrollTop;
    return {
        x: x,
        y: y,
    };
}
// we provide a function to compute constants instead
// of accessing window.* as soon as the module needs it
// so that we do not compute anything if not needed
function getActions() {
    // Determine the events to bind. IE11 implements pointerEvents without
    // a prefix, which breaks compatibility with the IE10 implementation.
    return window.navigator.pointerEnabled
        ? {
            start: "pointerdown",
            move: "pointermove",
            end: "pointerup",
        }
        : window.navigator.msPointerEnabled
            ? {
                start: "MSPointerDown",
                move: "MSPointerMove",
                end: "MSPointerUp",
            }
            : {
                start: "mousedown touchstart",
                move: "mousemove touchmove",
                end: "mouseup touchend",
            };
}
// https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
// Issue #785
function getSupportsPassive() {
    var supportsPassive = false;
    /* eslint-disable */
    try {
        var opts = Object.defineProperty({}, "passive", {
            get: function () {
                supportsPassive = true;
            },
        });
        // @ts-ignore
        window.addEventListener("test", null, opts);
    }
    catch (e) { }
    /* eslint-enable */
    return supportsPassive;
}
function getSupportsTouchActionNone() {
    return window.CSS && CSS.supports && CSS.supports("touch-action", "none");
}
//endregion
//region Range Calculation
// Determine the size of a sub-range in relation to a full range.
function subRangeRatio(pa, pb) {
    return 100 / (pb - pa);
}
// (percentage) How many percent is this value of this range?
function fromPercentage(range, value, startRange) {
    return (value * 100) / (range[startRange + 1] - range[startRange]);
}
// (percentage) Where is this value on this range?
function toPercentage(range, value) {
    return fromPercentage(range, range[0] < 0 ? value + Math.abs(range[0]) : value - range[0], 0);
}
// (value) How much is this percentage on this range?
function isPercentage(range, value) {
    return (value * (range[1] - range[0])) / 100 + range[0];
}
function getJ(value, arr) {
    var j = 1;
    while (value >= arr[j]) {
        j += 1;
    }
    return j;
}
// (percentage) Input a value, find where, on a scale of 0-100, it applies.
function toStepping(xVal, xPct, value) {
    if (value >= xVal.slice(-1)[0]) {
        return 100;
    }
    var j = getJ(value, xVal);
    var va = xVal[j - 1];
    var vb = xVal[j];
    var pa = xPct[j - 1];
    var pb = xPct[j];
    return pa + toPercentage([va, vb], value) / subRangeRatio(pa, pb);
}
// (value) Input a percentage, find where it is on the specified range.
function fromStepping(xVal, xPct, value) {
    // There is no range group that fits 100
    if (value >= 100) {
        return xVal.slice(-1)[0];
    }
    var j = getJ(value, xPct);
    var va = xVal[j - 1];
    var vb = xVal[j];
    var pa = xPct[j - 1];
    var pb = xPct[j];
    return isPercentage([va, vb], (value - pa) * subRangeRatio(pa, pb));
}
// (percentage) Get the step that applies at a certain value.
function getStep(xPct, xSteps, snap, value) {
    if (value === 100) {
        return value;
    }
    var j = getJ(value, xPct);
    var a = xPct[j - 1];
    var b = xPct[j];
    // If 'snap' is set, steps are used as fixed points on the slider.
    if (snap) {
        // Find the closest position, a or b.
        if (value - a > (b - a) / 2) {
            return b;
        }
        return a;
    }
    if (!xSteps[j - 1]) {
        return value;
    }
    return xPct[j - 1] + closest(value - xPct[j - 1], xSteps[j - 1]);
}
//endregion
//region Spectrum
var Spectrum = /** @class */ (function () {
    function Spectrum(entry, snap, singleStep) {
        this.xPct = [];
        this.xVal = [];
        this.xSteps = [];
        this.xNumSteps = [];
        this.xHighestCompleteStep = [];
        this.xSteps = [singleStep || false];
        this.xNumSteps = [false];
        this.snap = snap;
        var index;
        var ordered = [];
        // Map the object keys to an array.
        Object.keys(entry).forEach(function (index) {
            ordered.push([asArray(entry[index]), index]);
        });
        // Sort all entries by value (numeric sort).
        ordered.sort(function (a, b) {
            return a[0][0] - b[0][0];
        });
        // Convert all entries to subranges.
        for (index = 0; index < ordered.length; index++) {
            this.handleEntryPoint(ordered[index][1], ordered[index][0]);
        }
        // Store the actual step values.
        // xSteps is sorted in the same order as xPct and xVal.
        this.xNumSteps = this.xSteps.slice(0);
        // Convert all numeric steps to the percentage of the subrange they represent.
        for (index = 0; index < this.xNumSteps.length; index++) {
            this.handleStepPoint(index, this.xNumSteps[index]);
        }
    }
    Spectrum.prototype.getDistance = function (value) {
        var distances = [];
        for (var index = 0; index < this.xNumSteps.length - 1; index++) {
            distances[index] = fromPercentage(this.xVal, value, index);
        }
        return distances;
    };
    // Calculate the percentual distance over the whole scale of ranges.
    // direction: 0 = backwards / 1 = forwards
    Spectrum.prototype.getAbsoluteDistance = function (value, distances, direction) {
        var xPct_index = 0;
        // Calculate range where to start calculation
        if (value < this.xPct[this.xPct.length - 1]) {
            while (value > this.xPct[xPct_index + 1]) {
                xPct_index++;
            }
        }
        else if (value === this.xPct[this.xPct.length - 1]) {
            xPct_index = this.xPct.length - 2;
        }
        // If looking backwards and the value is exactly at a range separator then look one range further
        if (!direction && value === this.xPct[xPct_index + 1]) {
            xPct_index++;
        }
        if (distances === null) {
            distances = [];
        }
        var start_factor;
        var rest_factor = 1;
        var rest_rel_distance = distances[xPct_index];
        var range_pct = 0;
        var rel_range_distance = 0;
        var abs_distance_counter = 0;
        var range_counter = 0;
        // Calculate what part of the start range the value is
        if (direction) {
            start_factor = (value - this.xPct[xPct_index]) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
        }
        else {
            start_factor = (this.xPct[xPct_index + 1] - value) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
        }
        // Do until the complete distance across ranges is calculated
        while (rest_rel_distance > 0) {
            // Calculate the percentage of total range
            range_pct = this.xPct[xPct_index + 1 + range_counter] - this.xPct[xPct_index + range_counter];
            // Detect if the margin, padding or limit is larger then the current range and calculate
            if (distances[xPct_index + range_counter] * rest_factor + 100 - start_factor * 100 > 100) {
                // If larger then take the percentual distance of the whole range
                rel_range_distance = range_pct * start_factor;
                // Rest factor of relative percentual distance still to be calculated
                rest_factor = (rest_rel_distance - 100 * start_factor) / distances[xPct_index + range_counter];
                // Set start factor to 1 as for next range it does not apply.
                start_factor = 1;
            }
            else {
                // If smaller or equal then take the percentual distance of the calculate percentual part of that range
                rel_range_distance = ((distances[xPct_index + range_counter] * range_pct) / 100) * rest_factor;
                // No rest left as the rest fits in current range
                rest_factor = 0;
            }
            if (direction) {
                abs_distance_counter = abs_distance_counter - rel_range_distance;
                // Limit range to first range when distance becomes outside of minimum range
                if (this.xPct.length + range_counter >= 1) {
                    range_counter--;
                }
            }
            else {
                abs_distance_counter = abs_distance_counter + rel_range_distance;
                // Limit range to last range when distance becomes outside of maximum range
                if (this.xPct.length - range_counter >= 1) {
                    range_counter++;
                }
            }
            // Rest of relative percentual distance still to be calculated
            rest_rel_distance = distances[xPct_index + range_counter] * rest_factor;
        }
        return value + abs_distance_counter;
    };
    Spectrum.prototype.toStepping = function (value) {
        value = toStepping(this.xVal, this.xPct, value);
        return value;
    };
    Spectrum.prototype.fromStepping = function (value) {
        return fromStepping(this.xVal, this.xPct, value);
    };
    Spectrum.prototype.getStep = function (value) {
        value = getStep(this.xPct, this.xSteps, this.snap, value);
        return value;
    };
    Spectrum.prototype.getDefaultStep = function (value, isDown, size) {
        var j = getJ(value, this.xPct);
        // When at the top or stepping down, look at the previous sub-range
        if (value === 100 || (isDown && value === this.xPct[j - 1])) {
            j = Math.max(j - 1, 1);
        }
        return (this.xVal[j] - this.xVal[j - 1]) / size;
    };
    Spectrum.prototype.getNearbySteps = function (value) {
        var j = getJ(value, this.xPct);
        return {
            stepBefore: {
                startValue: this.xVal[j - 2],
                step: this.xNumSteps[j - 2],
                highestStep: this.xHighestCompleteStep[j - 2],
            },
            thisStep: {
                startValue: this.xVal[j - 1],
                step: this.xNumSteps[j - 1],
                highestStep: this.xHighestCompleteStep[j - 1],
            },
            stepAfter: {
                startValue: this.xVal[j],
                step: this.xNumSteps[j],
                highestStep: this.xHighestCompleteStep[j],
            },
        };
    };
    Spectrum.prototype.countStepDecimals = function () {
        var stepDecimals = this.xNumSteps.map(countDecimals);
        return Math.max.apply(null, stepDecimals);
    };
    Spectrum.prototype.hasNoSize = function () {
        return this.xVal[0] === this.xVal[this.xVal.length - 1];
    };
    // Outside testing
    Spectrum.prototype.convert = function (value) {
        return this.getStep(this.toStepping(value));
    };
    Spectrum.prototype.handleEntryPoint = function (index, value) {
        var percentage;
        // Covert min/max syntax to 0 and 100.
        if (index === "min") {
            percentage = 0;
        }
        else if (index === "max") {
            percentage = 100;
        }
        else {
            percentage = parseFloat(index);
        }
        // Check for correct input.
        if (!isNumeric(percentage) || !isNumeric(value[0])) {
            throw new Error("noUiSlider: 'range' value isn't numeric.");
        }
        // Store values.
        this.xPct.push(percentage);
        this.xVal.push(value[0]);
        var value1 = Number(value[1]);
        // NaN will evaluate to false too, but to keep
        // logging clear, set step explicitly. Make sure
        // not to override the 'step' setting with false.
        if (!percentage) {
            if (!isNaN(value1)) {
                this.xSteps[0] = value1;
            }
        }
        else {
            this.xSteps.push(isNaN(value1) ? false : value1);
        }
        this.xHighestCompleteStep.push(0);
    };
    Spectrum.prototype.handleStepPoint = function (i, n) {
        // Ignore 'false' stepping.
        if (!n) {
            return;
        }
        // Step over zero-length ranges (#948);
        if (this.xVal[i] === this.xVal[i + 1]) {
            this.xSteps[i] = this.xHighestCompleteStep[i] = this.xVal[i];
            return;
        }
        // Factor to range ratio
        this.xSteps[i] =
            fromPercentage([this.xVal[i], this.xVal[i + 1]], n, 0) / subRangeRatio(this.xPct[i], this.xPct[i + 1]);
        var totalSteps = (this.xVal[i + 1] - this.xVal[i]) / this.xNumSteps[i];
        var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);
        var step = this.xVal[i] + this.xNumSteps[i] * highestStep;
        this.xHighestCompleteStep[i] = step;
    };
    return Spectrum;
}());
//endregion
//region Options
/*	Every input option is tested and parsed. This will prevent
    endless validation in internal methods. These tests are
    structured with an item for every option available. An
    option can be marked as required by setting the 'r' flag.
    The testing function is provided with three arguments:
        - The provided value for the option;
        - A reference to the options object;
        - The name for the option;

    The testing function returns false when an error is detected,
    or true when everything is OK. It can also modify the option
    object, to make sure all values can be correctly looped elsewhere. */
//region Defaults
var defaultFormatter = {
    to: function (value) {
        return value === undefined ? "" : value.toFixed(2);
    },
    from: Number,
};
var cssClasses = {
    target: "target",
    base: "base",
    origin: "origin",
    handle: "handle",
    handleLower: "handle-lower",
    handleUpper: "handle-upper",
    touchArea: "touch-area",
    horizontal: "horizontal",
    vertical: "vertical",
    background: "background",
    connect: "connect",
    connects: "connects",
    ltr: "ltr",
    rtl: "rtl",
    textDirectionLtr: "txt-dir-ltr",
    textDirectionRtl: "txt-dir-rtl",
    draggable: "draggable",
    drag: "state-drag",
    tap: "state-tap",
    active: "active",
    tooltip: "tooltip",
    pips: "pips",
    pipsHorizontal: "pips-horizontal",
    pipsVertical: "pips-vertical",
    marker: "marker",
    markerHorizontal: "marker-horizontal",
    markerVertical: "marker-vertical",
    markerNormal: "marker-normal",
    markerLarge: "marker-large",
    markerSub: "marker-sub",
    value: "value",
    valueHorizontal: "value-horizontal",
    valueVertical: "value-vertical",
    valueNormal: "value-normal",
    valueLarge: "value-large",
    valueSub: "value-sub",
};
// Namespaces of internal event listeners
var INTERNAL_EVENT_NS = {
    tooltips: ".__tooltips",
    aria: ".__aria",
};
//endregion
function testStep(parsed, entry) {
    if (!isNumeric(entry)) {
        throw new Error("noUiSlider: 'step' is not numeric.");
    }
    // The step option can still be used to set stepping
    // for linear sliders. Overwritten if set in 'range'.
    parsed.singleStep = entry;
}
function testKeyboardPageMultiplier(parsed, entry) {
    if (!isNumeric(entry)) {
        throw new Error("noUiSlider: 'keyboardPageMultiplier' is not numeric.");
    }
    parsed.keyboardPageMultiplier = entry;
}
function testKeyboardMultiplier(parsed, entry) {
    if (!isNumeric(entry)) {
        throw new Error("noUiSlider: 'keyboardMultiplier' is not numeric.");
    }
    parsed.keyboardMultiplier = entry;
}
function testKeyboardDefaultStep(parsed, entry) {
    if (!isNumeric(entry)) {
        throw new Error("noUiSlider: 'keyboardDefaultStep' is not numeric.");
    }
    parsed.keyboardDefaultStep = entry;
}
function testRange(parsed, entry) {
    // Filter incorrect input.
    if (typeof entry !== "object" || Array.isArray(entry)) {
        throw new Error("noUiSlider: 'range' is not an object.");
    }
    // Catch missing start or end.
    if (entry.min === undefined || entry.max === undefined) {
        throw new Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
    }
    parsed.spectrum = new Spectrum(entry, parsed.snap || false, parsed.singleStep);
}
function testStart(parsed, entry) {
    entry = asArray(entry);
    // Validate input. Values aren't tested, as the public .val method
    // will always provide a valid location.
    if (!Array.isArray(entry) || !entry.length) {
        throw new Error("noUiSlider: 'start' option is incorrect.");
    }
    // Store the number of handles.
    parsed.handles = entry.length;
    // When the slider is initialized, the .val method will
    // be called with the start options.
    parsed.start = entry;
}
function testSnap(parsed, entry) {
    if (typeof entry !== "boolean") {
        throw new Error("noUiSlider: 'snap' option must be a boolean.");
    }
    // Enforce 100% stepping within subranges.
    parsed.snap = entry;
}
function testAnimate(parsed, entry) {
    if (typeof entry !== "boolean") {
        throw new Error("noUiSlider: 'animate' option must be a boolean.");
    }
    // Enforce 100% stepping within subranges.
    parsed.animate = entry;
}
function testAnimationDuration(parsed, entry) {
    if (typeof entry !== "number") {
        throw new Error("noUiSlider: 'animationDuration' option must be a number.");
    }
    parsed.animationDuration = entry;
}
function testConnect(parsed, entry) {
    var connect = [false];
    var i;
    // Map legacy options
    if (entry === "lower") {
        entry = [true, false];
    }
    else if (entry === "upper") {
        entry = [false, true];
    }
    // Handle boolean options
    if (entry === true || entry === false) {
        for (i = 1; i < parsed.handles; i++) {
            connect.push(entry);
        }
        connect.push(false);
    }
    // Reject invalid input
    else if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) {
        throw new Error("noUiSlider: 'connect' option doesn't match handle count.");
    }
    else {
        connect = entry;
    }
    parsed.connect = connect;
}
function testOrientation(parsed, entry) {
    // Set orientation to an a numerical value for easy
    // array selection.
    switch (entry) {
        case "horizontal":
            parsed.ort = 0;
            break;
        case "vertical":
            parsed.ort = 1;
            break;
        default:
            throw new Error("noUiSlider: 'orientation' option is invalid.");
    }
}
function testMargin(parsed, entry) {
    if (!isNumeric(entry)) {
        throw new Error("noUiSlider: 'margin' option must be numeric.");
    }
    // Issue #582
    if (entry === 0) {
        return;
    }
    parsed.margin = parsed.spectrum.getDistance(entry);
}
function testLimit(parsed, entry) {
    if (!isNumeric(entry)) {
        throw new Error("noUiSlider: 'limit' option must be numeric.");
    }
    parsed.limit = parsed.spectrum.getDistance(entry);
    if (!parsed.limit || parsed.handles < 2) {
        throw new Error("noUiSlider: 'limit' option is only supported on linear sliders with 2 or more handles.");
    }
}
function testPadding(parsed, entry) {
    var index;
    if (!isNumeric(entry) && !Array.isArray(entry)) {
        throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
    }
    if (Array.isArray(entry) && !(entry.length === 2 || isNumeric(entry[0]) || isNumeric(entry[1]))) {
        throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
    }
    if (entry === 0) {
        return;
    }
    if (!Array.isArray(entry)) {
        entry = [entry, entry];
    }
    // 'getDistance' returns false for invalid values.
    parsed.padding = [parsed.spectrum.getDistance(entry[0]), parsed.spectrum.getDistance(entry[1])];
    for (index = 0; index < parsed.spectrum.xNumSteps.length - 1; index++) {
        // last "range" can't contain step size as it is purely an endpoint.
        if (parsed.padding[0][index] < 0 || parsed.padding[1][index] < 0) {
            throw new Error("noUiSlider: 'padding' option must be a positive number(s).");
        }
    }
    var totalPadding = entry[0] + entry[1];
    var firstValue = parsed.spectrum.xVal[0];
    var lastValue = parsed.spectrum.xVal[parsed.spectrum.xVal.length - 1];
    if (totalPadding / (lastValue - firstValue) > 1) {
        throw new Error("noUiSlider: 'padding' option must not exceed 100% of the range.");
    }
}
function testDirection(parsed, entry) {
    // Set direction as a numerical value for easy parsing.
    // Invert connection for RTL sliders, so that the proper
    // handles get the connect/background classes.
    switch (entry) {
        case "ltr":
            parsed.dir = 0;
            break;
        case "rtl":
            parsed.dir = 1;
            break;
        default:
            throw new Error("noUiSlider: 'direction' option was not recognized.");
    }
}
function testBehaviour(parsed, entry) {
    // Make sure the input is a string.
    if (typeof entry !== "string") {
        throw new Error("noUiSlider: 'behaviour' must be a string containing options.");
    }
    // Check if the string contains any keywords.
    // None are required.
    var tap = entry.indexOf("tap") >= 0;
    var drag = entry.indexOf("drag") >= 0;
    var fixed = entry.indexOf("fixed") >= 0;
    var snap = entry.indexOf("snap") >= 0;
    var hover = entry.indexOf("hover") >= 0;
    var unconstrained = entry.indexOf("unconstrained") >= 0;
    var invertConnects = entry.indexOf("invert-connects") >= 0;
    var dragAll = entry.indexOf("drag-all") >= 0;
    var smoothSteps = entry.indexOf("smooth-steps") >= 0;
    if (fixed) {
        if (parsed.handles !== 2) {
            throw new Error("noUiSlider: 'fixed' behaviour must be used with 2 handles");
        }
        // Use margin to enforce fixed state
        testMargin(parsed, parsed.start[1] - parsed.start[0]);
    }
    if (invertConnects && parsed.handles !== 2) {
        throw new Error("noUiSlider: 'invert-connects' behaviour must be used with 2 handles");
    }
    if (unconstrained && (parsed.margin || parsed.limit)) {
        throw new Error("noUiSlider: 'unconstrained' behaviour cannot be used with margin or limit");
    }
    parsed.events = {
        tap: tap || snap,
        drag: drag,
        dragAll: dragAll,
        smoothSteps: smoothSteps,
        fixed: fixed,
        snap: snap,
        hover: hover,
        unconstrained: unconstrained,
        invertConnects: invertConnects,
    };
}
function testTooltips(parsed, entry) {
    if (entry === false) {
        return;
    }
    if (entry === true || isValidPartialFormatter(entry)) {
        parsed.tooltips = [];
        for (var i = 0; i < parsed.handles; i++) {
            parsed.tooltips.push(entry);
        }
    }
    else {
        entry = asArray(entry);
        if (entry.length !== parsed.handles) {
            throw new Error("noUiSlider: must pass a formatter for all handles.");
        }
        entry.forEach(function (formatter) {
            if (typeof formatter !== "boolean" && !isValidPartialFormatter(formatter)) {
                throw new Error("noUiSlider: 'tooltips' must be passed a formatter or 'false'.");
            }
        });
        parsed.tooltips = entry;
    }
}
function testHandleAttributes(parsed, entry) {
    if (entry.length !== parsed.handles) {
        throw new Error("noUiSlider: must pass a attributes for all handles.");
    }
    parsed.handleAttributes = entry;
}
function testAriaFormat(parsed, entry) {
    if (!isValidPartialFormatter(entry)) {
        throw new Error("noUiSlider: 'ariaFormat' requires 'to' method.");
    }
    parsed.ariaFormat = entry;
}
function testFormat(parsed, entry) {
    if (!isValidFormatter(entry)) {
        throw new Error("noUiSlider: 'format' requires 'to' and 'from' methods.");
    }
    parsed.format = entry;
}
function testKeyboardSupport(parsed, entry) {
    if (typeof entry !== "boolean") {
        throw new Error("noUiSlider: 'keyboardSupport' option must be a boolean.");
    }
    parsed.keyboardSupport = entry;
}
function testDocumentElement(parsed, entry) {
    // This is an advanced option. Passed values are used without validation.
    parsed.documentElement = entry;
}
function testCssPrefix(parsed, entry) {
    if (typeof entry !== "string" && entry !== false) {
        throw new Error("noUiSlider: 'cssPrefix' must be a string or `false`.");
    }
    parsed.cssPrefix = entry;
}
function testCssClasses(parsed, entry) {
    if (typeof entry !== "object") {
        throw new Error("noUiSlider: 'cssClasses' must be an object.");
    }
    if (typeof parsed.cssPrefix === "string") {
        parsed.cssClasses = {};
        Object.keys(entry).forEach(function (key) {
            parsed.cssClasses[key] = parsed.cssPrefix + entry[key];
        });
    }
    else {
        parsed.cssClasses = entry;
    }
}
// Test all developer settings and parse to assumption-safe values.
function testOptions(options) {
    // To prove a fix for #537, freeze options here.
    // If the object is modified, an error will be thrown.
    // Object.freeze(options);
    var parsed = {
        margin: null,
        limit: null,
        padding: null,
        animate: true,
        animationDuration: 300,
        ariaFormat: defaultFormatter,
        format: defaultFormatter,
    };
    // Tests are executed in the order they are presented here.
    var tests = {
        step: { r: false, t: testStep },
        keyboardPageMultiplier: { r: false, t: testKeyboardPageMultiplier },
        keyboardMultiplier: { r: false, t: testKeyboardMultiplier },
        keyboardDefaultStep: { r: false, t: testKeyboardDefaultStep },
        start: { r: true, t: testStart },
        connect: { r: true, t: testConnect },
        direction: { r: true, t: testDirection },
        snap: { r: false, t: testSnap },
        animate: { r: false, t: testAnimate },
        animationDuration: { r: false, t: testAnimationDuration },
        range: { r: true, t: testRange },
        orientation: { r: false, t: testOrientation },
        margin: { r: false, t: testMargin },
        limit: { r: false, t: testLimit },
        padding: { r: false, t: testPadding },
        behaviour: { r: true, t: testBehaviour },
        ariaFormat: { r: false, t: testAriaFormat },
        format: { r: false, t: testFormat },
        tooltips: { r: false, t: testTooltips },
        keyboardSupport: { r: true, t: testKeyboardSupport },
        documentElement: { r: false, t: testDocumentElement },
        cssPrefix: { r: true, t: testCssPrefix },
        cssClasses: { r: true, t: testCssClasses },
        handleAttributes: { r: false, t: testHandleAttributes },
    };
    var defaults = {
        connect: false,
        direction: "ltr",
        behaviour: "tap",
        orientation: "horizontal",
        keyboardSupport: true,
        cssPrefix: "noUi-",
        cssClasses: cssClasses,
        keyboardPageMultiplier: 5,
        keyboardMultiplier: 1,
        keyboardDefaultStep: 10,
    };
    // AriaFormat defaults to regular format, if any.
    if (options.format && !options.ariaFormat) {
        options.ariaFormat = options.format;
    }
    // Run all options through a testing mechanism to ensure correct
    // input. It should be noted that options might get modified to
    // be handled properly. E.g. wrapping integers in arrays.
    Object.keys(tests).forEach(function (name) {
        // If the option isn't set, but it is required, throw an error.
        if (!isSet(options[name]) && defaults[name] === undefined) {
            if (tests[name].r) {
                throw new Error("noUiSlider: '" + name + "' is required.");
            }
            return;
        }
        tests[name].t(parsed, !isSet(options[name]) ? defaults[name] : options[name]);
    });
    // Forward pips options
    parsed.pips = options.pips;
    // All recent browsers accept unprefixed transform.
    // We need -ms- for IE9 and -webkit- for older Android;
    // Assume use of -webkit- if unprefixed and -ms- are not supported.
    // https://caniuse.com/#feat=transforms2d
    var d = document.createElement("div");
    var msPrefix = d.style.msTransform !== undefined;
    var noPrefix = d.style.transform !== undefined;
    parsed.transformRule = noPrefix ? "transform" : msPrefix ? "msTransform" : "webkitTransform";
    // Pips don't move, so we can place them using left/top.
    var styles = [
        ["left", "top"],
        ["right", "bottom"],
    ];
    parsed.style = styles[parsed.dir][parsed.ort];
    return parsed;
}
//endregion
function scope(target, options, originalOptions) {
    var actions = getActions();
    var supportsTouchActionNone = getSupportsTouchActionNone();
    var supportsPassive = supportsTouchActionNone && getSupportsPassive();
    // All variables local to 'scope' are prefixed with 'scope_'
    // Slider DOM Nodes
    var scope_Target = target;
    var scope_Base;
    var scope_ConnectBase;
    var scope_Handles;
    var scope_Connects;
    var scope_Pips;
    var scope_Tooltips;
    // Slider state values
    var scope_Spectrum = options.spectrum;
    var scope_Values = [];
    var scope_Locations = [];
    var scope_HandleNumbers = [];
    var scope_ActiveHandlesCount = 0;
    var scope_Events = {};
    var scope_ConnectsInverted = false;
    // Document Nodes
    var scope_Document = target.ownerDocument;
    var scope_DocumentElement = options.documentElement || scope_Document.documentElement;
    var scope_Body = scope_Document.body;
    // For horizontal sliders in standard ltr documents,
    // make .noUi-origin overflow to the left so the document doesn't scroll.
    var scope_DirOffset = scope_Document.dir === "rtl" || options.ort === 1 ? 0 : 100;
    // Creates a node, adds it to target, returns the new node.
    function addNodeTo(addTarget, className) {
        var div = scope_Document.createElement("div");
        if (className) {
            addClass(div, className);
        }
        addTarget.appendChild(div);
        return div;
    }
    // Append a origin to the base
    function addOrigin(base, handleNumber) {
        var origin = addNodeTo(base, options.cssClasses.origin);
        var handle = addNodeTo(origin, options.cssClasses.handle);
        addNodeTo(handle, options.cssClasses.touchArea);
        handle.setAttribute("data-handle", String(handleNumber));
        if (options.keyboardSupport) {
            // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex
            // 0 = focusable and reachable
            handle.setAttribute("tabindex", "0");
            handle.addEventListener("keydown", function (event) {
                return eventKeydown(event, handleNumber);
            });
        }
        if (options.handleAttributes !== undefined) {
            var attributes_1 = options.handleAttributes[handleNumber];
            Object.keys(attributes_1).forEach(function (attribute) {
                handle.setAttribute(attribute, attributes_1[attribute]);
            });
        }
        handle.setAttribute("role", "slider");
        handle.setAttribute("aria-orientation", options.ort ? "vertical" : "horizontal");
        if (handleNumber === 0) {
            addClass(handle, options.cssClasses.handleLower);
        }
        else if (handleNumber === options.handles - 1) {
            addClass(handle, options.cssClasses.handleUpper);
        }
        origin.handle = handle;
        return origin;
    }
    // Insert nodes for connect elements
    function addConnect(base, add) {
        if (!add) {
            return false;
        }
        return addNodeTo(base, options.cssClasses.connect);
    }
    // Add handles to the slider base.
    function addElements(connectOptions, base) {
        scope_ConnectBase = addNodeTo(base, options.cssClasses.connects);
        scope_Handles = [];
        scope_Connects = [];
        scope_Connects.push(addConnect(scope_ConnectBase, connectOptions[0]));
        // [::::O====O====O====]
        // connectOptions = [0, 1, 1, 1]
        for (var i = 0; i < options.handles; i++) {
            // Keep a list of all added handles.
            scope_Handles.push(addOrigin(base, i));
            scope_HandleNumbers[i] = i;
            scope_Connects.push(addConnect(scope_ConnectBase, connectOptions[i + 1]));
        }
    }
    // Initialize a single slider.
    function addSlider(addTarget) {
        // Apply classes and data to the target.
        addClass(addTarget, options.cssClasses.target);
        if (options.dir === 0) {
            addClass(addTarget, options.cssClasses.ltr);
        }
        else {
            addClass(addTarget, options.cssClasses.rtl);
        }
        if (options.ort === 0) {
            addClass(addTarget, options.cssClasses.horizontal);
        }
        else {
            addClass(addTarget, options.cssClasses.vertical);
        }
        var textDirection = getComputedStyle(addTarget).direction;
        if (textDirection === "rtl") {
            addClass(addTarget, options.cssClasses.textDirectionRtl);
        }
        else {
            addClass(addTarget, options.cssClasses.textDirectionLtr);
        }
        return addNodeTo(addTarget, options.cssClasses.base);
    }
    function addTooltip(handle, handleNumber) {
        if (!options.tooltips || !options.tooltips[handleNumber]) {
            return false;
        }
        return addNodeTo(handle.firstChild, options.cssClasses.tooltip);
    }
    function isSliderDisabled() {
        return scope_Target.hasAttribute("disabled");
    }
    // Disable the slider dragging if any handle is disabled
    function isHandleDisabled(handleNumber) {
        var handleOrigin = scope_Handles[handleNumber];
        return handleOrigin.hasAttribute("disabled");
    }
    function disable(handleNumber) {
        if (handleNumber !== null && handleNumber !== undefined) {
            scope_Handles[handleNumber].setAttribute("disabled", "");
            scope_Handles[handleNumber].handle.removeAttribute("tabindex");
        }
        else {
            scope_Target.setAttribute("disabled", "");
            scope_Handles.forEach(function (handle) {
                handle.handle.removeAttribute("tabindex");
            });
        }
    }
    function enable(handleNumber) {
        if (handleNumber !== null && handleNumber !== undefined) {
            scope_Handles[handleNumber].removeAttribute("disabled");
            scope_Handles[handleNumber].handle.setAttribute("tabindex", "0");
        }
        else {
            scope_Target.removeAttribute("disabled");
            scope_Handles.forEach(function (handle) {
                handle.removeAttribute("disabled");
                handle.handle.setAttribute("tabindex", "0");
            });
        }
    }
    function removeTooltips() {
        if (scope_Tooltips) {
            removeEvent("update" + INTERNAL_EVENT_NS.tooltips);
            scope_Tooltips.forEach(function (tooltip) {
                if (tooltip) {
                    removeElement(tooltip);
                }
            });
            scope_Tooltips = null;
        }
    }
    // The tooltips option is a shorthand for using the 'update' event.
    function tooltips() {
        removeTooltips();
        // Tooltips are added with options.tooltips in original order.
        scope_Tooltips = scope_Handles.map(addTooltip);
        bindEvent("update" + INTERNAL_EVENT_NS.tooltips, function (values, handleNumber, unencoded) {
            if (!scope_Tooltips || !options.tooltips) {
                return;
            }
            if (scope_Tooltips[handleNumber] === false) {
                return;
            }
            var formattedValue = values[handleNumber];
            if (options.tooltips[handleNumber] !== true) {
                formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);
            }
            scope_Tooltips[handleNumber].innerHTML = formattedValue;
        });
    }
    function aria() {
        removeEvent("update" + INTERNAL_EVENT_NS.aria);
        bindEvent("update" + INTERNAL_EVENT_NS.aria, function (values, handleNumber, unencoded, tap, positions) {
            // Update Aria Values for all handles, as a change in one changes min and max values for the next.
            scope_HandleNumbers.forEach(function (index) {
                var handle = scope_Handles[index];
                var min = checkHandlePosition(scope_Locations, index, 0, true, true, true);
                var max = checkHandlePosition(scope_Locations, index, 100, true, true, true);
                var now = positions[index];
                // Formatted value for display
                var text = String(options.ariaFormat.to(unencoded[index]));
                // Map to slider range values
                min = scope_Spectrum.fromStepping(min).toFixed(1);
                max = scope_Spectrum.fromStepping(max).toFixed(1);
                now = scope_Spectrum.fromStepping(now).toFixed(1);
                handle.children[0].setAttribute("aria-valuemin", min);
                handle.children[0].setAttribute("aria-valuemax", max);
                handle.children[0].setAttribute("aria-valuenow", now);
                handle.children[0].setAttribute("aria-valuetext", text);
            });
        });
    }
    function getGroup(pips) {
        // Use the range.
        if (pips.mode === PipsMode.Range || pips.mode === PipsMode.Steps) {
            return scope_Spectrum.xVal;
        }
        if (pips.mode === PipsMode.Count) {
            if (pips.values < 2) {
                throw new Error("noUiSlider: 'values' (>= 2) required for mode 'count'.");
            }
            // Divide 0 - 100 in 'count' parts.
            var interval = pips.values - 1;
            var spread = 100 / interval;
            var values = [];
            // List these parts and have them handled as 'positions'.
            while (interval--) {
                values[interval] = interval * spread;
            }
            values.push(100);
            return mapToRange(values, pips.stepped);
        }
        if (pips.mode === PipsMode.Positions) {
            // Map all percentages to on-range values.
            return mapToRange(pips.values, pips.stepped);
        }
        if (pips.mode === PipsMode.Values) {
            // If the value must be stepped, it needs to be converted to a percentage first.
            if (pips.stepped) {
                return pips.values.map(function (value) {
                    // Convert to percentage, apply step, return to value.
                    return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));
                });
            }
            // Otherwise, we can simply use the values.
            return pips.values;
        }
        return []; // pips.mode = never
    }
    function mapToRange(values, stepped) {
        return values.map(function (value) {
            return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value);
        });
    }
    function generateSpread(pips) {
        function safeIncrement(value, increment) {
            // Avoid floating point variance by dropping the smallest decimal places.
            return Number((value + increment).toFixed(7));
        }
        var group = getGroup(pips);
        var indexes = {};
        var firstInRange = scope_Spectrum.xVal[0];
        var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];
        var ignoreFirst = false;
        var ignoreLast = false;
        var prevPct = 0;
        // Create a copy of the group, sort it and filter away all duplicates.
        group = unique(group.slice().sort(function (a, b) {
            return a - b;
        }));
        // Make sure the range starts with the first element.
        if (group[0] !== firstInRange) {
            group.unshift(firstInRange);
            ignoreFirst = true;
        }
        // Likewise for the last one.
        if (group[group.length - 1] !== lastInRange) {
            group.push(lastInRange);
            ignoreLast = true;
        }
        group.forEach(function (current, index) {
            // Get the current step and the lower + upper positions.
            var step;
            var i;
            var q;
            var low = current;
            var high = group[index + 1];
            var newPct;
            var pctDifference;
            var pctPos;
            var type;
            var steps;
            var realSteps;
            var stepSize;
            var isSteps = pips.mode === PipsMode.Steps;
            // When using 'steps' mode, use the provided steps.
            // Otherwise, we'll step on to the next subrange.
            if (isSteps) {
                step = scope_Spectrum.xNumSteps[index];
            }
            // Default to a 'full' step.
            if (!step) {
                step = high - low;
            }
            // If high is undefined we are at the last subrange. Make sure it iterates once (#1088)
            if (high === undefined) {
                high = low;
            }
            // Make sure step isn't 0, which would cause an infinite loop (#654)
            step = Math.max(step, 0.0000001);
            // Find all steps in the subrange.
            for (i = low; i <= high; i = safeIncrement(i, step)) {
                // Get the percentage value for the current step,
                // calculate the size for the subrange.
                newPct = scope_Spectrum.toStepping(i);
                pctDifference = newPct - prevPct;
                steps = pctDifference / (pips.density || 1);
                realSteps = Math.round(steps);
                // This ratio represents the amount of percentage-space a point indicates.
                // For a density 1 the points/percentage = 1. For density 2, that percentage needs to be re-divided.
                // Round the percentage offset to an even number, then divide by two
                // to spread the offset on both sides of the range.
                stepSize = pctDifference / realSteps;
                // Divide all points evenly, adding the correct number to this subrange.
                // Run up to <= so that 100% gets a point, event if ignoreLast is set.
                for (q = 1; q <= realSteps; q += 1) {
                    // The ratio between the rounded value and the actual size might be ~1% off.
                    // Correct the percentage offset by the number of points
                    // per subrange. density = 1 will result in 100 points on the
                    // full range, 2 for 50, 4 for 25, etc.
                    pctPos = prevPct + q * stepSize;
                    indexes[pctPos.toFixed(5)] = [scope_Spectrum.fromStepping(pctPos), 0];
                }
                // Determine the point type.
                type = group.indexOf(i) > -1 ? PipsType.LargeValue : isSteps ? PipsType.SmallValue : PipsType.NoValue;
                // Enforce the 'ignoreFirst' option by overwriting the type for 0.
                if (!index && ignoreFirst && i !== high) {
                    type = 0;
                }
                if (!(i === high && ignoreLast)) {
                    // Mark the 'type' of this point. 0 = plain, 1 = real value, 2 = step value.
                    indexes[newPct.toFixed(5)] = [i, type];
                }
                // Update the percentage count.
                prevPct = newPct;
            }
        });
        return indexes;
    }
    function addMarking(spread, filterFunc, formatter) {
        var _a, _b;
        var element = scope_Document.createElement("div");
        var valueSizeClasses = (_a = {},
            _a[PipsType.None] = "",
            _a[PipsType.NoValue] = options.cssClasses.valueNormal,
            _a[PipsType.LargeValue] = options.cssClasses.valueLarge,
            _a[PipsType.SmallValue] = options.cssClasses.valueSub,
            _a);
        var markerSizeClasses = (_b = {},
            _b[PipsType.None] = "",
            _b[PipsType.NoValue] = options.cssClasses.markerNormal,
            _b[PipsType.LargeValue] = options.cssClasses.markerLarge,
            _b[PipsType.SmallValue] = options.cssClasses.markerSub,
            _b);
        var valueOrientationClasses = [options.cssClasses.valueHorizontal, options.cssClasses.valueVertical];
        var markerOrientationClasses = [options.cssClasses.markerHorizontal, options.cssClasses.markerVertical];
        addClass(element, options.cssClasses.pips);
        addClass(element, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);
        function getClasses(type, source) {
            var a = source === options.cssClasses.value;
            var orientationClasses = a ? valueOrientationClasses : markerOrientationClasses;
            var sizeClasses = a ? valueSizeClasses : markerSizeClasses;
            return source + " " + orientationClasses[options.ort] + " " + sizeClasses[type];
        }
        function addSpread(offset, value, type) {
            // Apply the filter function, if it is set.
            type = filterFunc ? filterFunc(value, type) : type;
            if (type === PipsType.None) {
                return;
            }
            // Add a marker for every point
            var node = addNodeTo(element, false);
            node.className = getClasses(type, options.cssClasses.marker);
            node.style[options.style] = offset + "%";
            // Values are only appended for points marked '1' or '2'.
            if (type > PipsType.NoValue) {
                node = addNodeTo(element, false);
                node.className = getClasses(type, options.cssClasses.value);
                node.setAttribute("data-value", String(value));
                node.style[options.style] = offset + "%";
                node.innerHTML = String(formatter.to(value));
            }
        }
        // Append all points.
        Object.keys(spread).forEach(function (offset) {
            addSpread(offset, spread[offset][0], spread[offset][1]);
        });
        return element;
    }
    function removePips() {
        if (scope_Pips) {
            removeElement(scope_Pips);
            scope_Pips = null;
        }
    }
    function pips(pips) {
        // Fix #669
        removePips();
        var spread = generateSpread(pips);
        var filter = pips.filter;
        var format = pips.format || {
            to: function (value) {
                return String(Math.round(value));
            },
        };
        scope_Pips = scope_Target.appendChild(addMarking(spread, filter, format));
        return scope_Pips;
    }
    // Shorthand for base dimensions.
    function baseSize() {
        var rect = scope_Base.getBoundingClientRect();
        var alt = ("offset" + ["Width", "Height"][options.ort]);
        return options.ort === 0 ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];
    }
    // Handler for attaching events trough a proxy.
    function attachEvent(events, element, callback, data) {
        // This function can be used to 'filter' events to the slider.
        // element is a node, not a nodeList
        var method = function (event) {
            var e = fixEvent(event, data.pageOffset, data.target || element);
            // fixEvent returns false if this event has a different target
            // when handling (multi-) touch events;
            if (!e) {
                return false;
            }
            // doNotReject is passed by all end events to make sure released touches
            // are not rejected, leaving the slider "stuck" to the cursor;
            if (isSliderDisabled() && !data.doNotReject) {
                return false;
            }
            // Stop if an active 'tap' transition is taking place.
            if (hasClass(scope_Target, options.cssClasses.tap) && !data.doNotReject) {
                return false;
            }
            // Ignore right or middle clicks on start #454
            if (events === actions.start && e.buttons !== undefined && e.buttons > 1) {
                return false;
            }
            // Ignore right or middle clicks on start #454
            if (data.hover && e.buttons) {
                return false;
            }
            // 'supportsPassive' is only true if a browser also supports touch-action: none in CSS.
            // iOS safari does not, so it doesn't get to benefit from passive scrolling. iOS does support
            // touch-action: manipulation, but that allows panning, which breaks
            // sliders after zooming/on non-responsive pages.
            // See: https://bugs.webkit.org/show_bug.cgi?id=133112
            if (!supportsPassive) {
                e.preventDefault();
            }
            e.calcPoint = e.points[options.ort];
            // Call the event handler with the event [ and additional data ].
            callback(e, data);
            return;
        };
        var methods = [];
        // Bind a closure on the target for every event type.
        events.split(" ").forEach(function (eventName) {
            element.addEventListener(eventName, method, supportsPassive ? { passive: true } : false);
            methods.push([eventName, method]);
        });
        return methods;
    }
    // Provide a clean event with standardized offset values.
    function fixEvent(e, pageOffset, eventTarget) {
        // Filter the event to register the type, which can be
        // touch, mouse or pointer. Offset changes need to be
        // made on an event specific basis.
        var touch = e.type.indexOf("touch") === 0;
        var mouse = e.type.indexOf("mouse") === 0;
        var pointer = e.type.indexOf("pointer") === 0;
        var x = 0;
        var y = 0;
        // IE10 implemented pointer events with a prefix;
        if (e.type.indexOf("MSPointer") === 0) {
            pointer = true;
        }
        // Erroneous events seem to be passed in occasionally on iOS/iPadOS after user finishes interacting with
        // the slider. They appear to be of type MouseEvent, yet they don't have usual properties set. Ignore
        // events that have no touches or buttons associated with them. (#1057, #1079, #1095)
        if (e.type === "mousedown" && !e.buttons && !e.touches) {
            return false;
        }
        // The only thing one handle should be concerned about is the touches that originated on top of it.
        if (touch) {
            // Returns true if a touch originated on the target.
            var isTouchOnTarget = function (checkTouch) {
                var target = checkTouch.target;
                return (target === eventTarget ||
                    eventTarget.contains(target) ||
                    (e.composed && e.composedPath().shift() === eventTarget));
            };
            // In the case of touchstart events, we need to make sure there is still no more than one
            // touch on the target so we look amongst all touches.
            if (e.type === "touchstart") {
                var targetTouches = Array.prototype.filter.call(e.touches, isTouchOnTarget);
                // Do not support more than one touch per handle.
                if (targetTouches.length > 1) {
                    return false;
                }
                x = targetTouches[0].pageX;
                y = targetTouches[0].pageY;
            }
            else {
                // In the other cases, find on changedTouches is enough.
                var targetTouch = Array.prototype.find.call(e.changedTouches, isTouchOnTarget);
                // Cancel if the target touch has not moved.
                if (!targetTouch) {
                    return false;
                }
                x = targetTouch.pageX;
                y = targetTouch.pageY;
            }
        }
        pageOffset = pageOffset || getPageOffset(scope_Document);
        if (mouse || pointer) {
            x = e.clientX + pageOffset.x;
            y = e.clientY + pageOffset.y;
        }
        e.pageOffset = pageOffset;
        e.points = [x, y];
        e.cursor = mouse || pointer; // Fix #435
        return e;
    }
    // Translate a coordinate in the document to a percentage on the slider
    function calcPointToPercentage(calcPoint) {
        var location = calcPoint - offset(scope_Base, options.ort);
        var proposal = (location * 100) / baseSize();
        // Clamp proposal between 0% and 100%
        // Out-of-bound coordinates may occur when .noUi-base pseudo-elements
        // are used (e.g. contained handles feature)
        proposal = limit(proposal);
        return options.dir ? 100 - proposal : proposal;
    }
    // Find handle closest to a certain percentage on the slider
    function getClosestHandle(clickedPosition) {
        var smallestDifference = 100;
        var handleNumber = false;
        scope_Handles.forEach(function (handle, index) {
            // Disabled handles are ignored
            if (isHandleDisabled(index)) {
                return;
            }
            var handlePosition = scope_Locations[index];
            var differenceWithThisHandle = Math.abs(handlePosition - clickedPosition);
            // Initial state
            var clickAtEdge = differenceWithThisHandle === 100 && smallestDifference === 100;
            // Difference with this handle is smaller than the previously checked handle
            var isCloser = differenceWithThisHandle < smallestDifference;
            var isCloserAfter = differenceWithThisHandle <= smallestDifference && clickedPosition > handlePosition;
            if (isCloser || isCloserAfter || clickAtEdge) {
                handleNumber = index;
                smallestDifference = differenceWithThisHandle;
            }
        });
        return handleNumber;
    }
    // Fire 'end' when a mouse or pen leaves the document.
    function documentLeave(event, data) {
        if (event.type === "mouseout" &&
            event.target.nodeName === "HTML" &&
            event.relatedTarget === null) {
            eventEnd(event, data);
        }
    }
    // Handle movement on document for handle and range drag.
    function eventMove(event, data) {
        // Fix #498
        // Check value of .buttons in 'start' to work around a bug in IE10 mobile (data.buttonsProperty).
        // https://connect.microsoft.com/IE/feedback/details/927005/mobile-ie10-windows-phone-buttons-property-of-pointermove-event-always-zero
        // IE9 has .buttons and .which zero on mousemove.
        // Firefox breaks the spec MDN defines.
        if (navigator.appVersion.indexOf("MSIE 9") === -1 && event.buttons === 0 && data.buttonsProperty !== 0) {
            return eventEnd(event, data);
        }
        // Check if we are moving up or down
        var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);
        // Convert the movement into a percentage of the slider width/height
        var proposal = (movement * 100) / data.baseSize;
        moveHandles(movement > 0, proposal, data.locations, data.handleNumbers, data.connect);
    }
    // Unbind move events on document, call callbacks.
    function eventEnd(event, data) {
        // The handle is no longer active, so remove the class.
        if (data.handle) {
            removeClass(data.handle, options.cssClasses.active);
            scope_ActiveHandlesCount -= 1;
        }
        // Unbind the move and end events, which are added on 'start'.
        data.listeners.forEach(function (c) {
            scope_DocumentElement.removeEventListener(c[0], c[1]);
        });
        if (scope_ActiveHandlesCount === 0) {
            // Remove dragging class.
            removeClass(scope_Target, options.cssClasses.drag);
            setZindex();
            // Remove cursor styles and text-selection events bound to the body.
            if (event.cursor) {
                scope_Body.style.cursor = "";
                scope_Body.removeEventListener("selectstart", preventDefault);
            }
        }
        if (options.events.smoothSteps) {
            data.handleNumbers.forEach(function (handleNumber) {
                setHandle(handleNumber, scope_Locations[handleNumber], true, true, false, false);
            });
            data.handleNumbers.forEach(function (handleNumber) {
                fireEvent("update", handleNumber);
            });
        }
        data.handleNumbers.forEach(function (handleNumber) {
            fireEvent("change", handleNumber);
            fireEvent("set", handleNumber);
            fireEvent("end", handleNumber);
        });
    }
    // Bind move events on document.
    function eventStart(event, data) {
        // Ignore event if any handle is disabled
        if (data.handleNumbers.some(isHandleDisabled)) {
            return;
        }
        var handle;
        if (data.handleNumbers.length === 1) {
            var handleOrigin = scope_Handles[data.handleNumbers[0]];
            handle = handleOrigin.children[0];
            scope_ActiveHandlesCount += 1;
            // Mark the handle as 'active' so it can be styled.
            addClass(handle, options.cssClasses.active);
        }
        // A drag should never propagate up to the 'tap' event.
        event.stopPropagation();
        // Record the event listeners.
        var listeners = [];
        // Attach the move and end events.
        var moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {
            // The event target has changed so we need to propagate the original one so that we keep
            // relying on it to extract target touches.
            target: event.target,
            handle: handle,
            connect: data.connect,
            listeners: listeners,
            startCalcPoint: event.calcPoint,
            baseSize: baseSize(),
            pageOffset: event.pageOffset,
            handleNumbers: data.handleNumbers,
            buttonsProperty: event.buttons,
            locations: scope_Locations.slice(),
        });
        var endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {
            target: event.target,
            handle: handle,
            listeners: listeners,
            doNotReject: true,
            handleNumbers: data.handleNumbers,
        });
        var outEvent = attachEvent("mouseout", scope_DocumentElement, documentLeave, {
            target: event.target,
            handle: handle,
            listeners: listeners,
            doNotReject: true,
            handleNumbers: data.handleNumbers,
        });
        // We want to make sure we pushed the listeners in the listener list rather than creating
        // a new one as it has already been passed to the event handlers.
        listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent));
        // Text selection isn't an issue on touch devices,
        // so adding cursor styles can be skipped.
        if (event.cursor) {
            // Prevent the 'I' cursor and extend the range-drag cursor.
            scope_Body.style.cursor = getComputedStyle(event.target).cursor;
            // Mark the target with a dragging state.
            if (scope_Handles.length > 1) {
                addClass(scope_Target, options.cssClasses.drag);
            }
            // Prevent text selection when dragging the handles.
            // In noUiSlider <= 9.2.0, this was handled by calling preventDefault on mouse/touch start/move,
            // which is scroll blocking. The selectstart event is supported by FireFox starting from version 52,
            // meaning the only holdout is iOS Safari. This doesn't matter: text selection isn't triggered there.
            // The 'cursor' flag is false.
            // See: http://caniuse.com/#search=selectstart
            scope_Body.addEventListener("selectstart", preventDefault, false);
        }
        data.handleNumbers.forEach(function (handleNumber) {
            fireEvent("start", handleNumber);
        });
    }
    // Move closest handle to tapped location.
    function eventTap(event) {
        // The tap event shouldn't propagate up
        event.stopPropagation();
        var proposal = calcPointToPercentage(event.calcPoint);
        var handleNumber = getClosestHandle(proposal);
        // Tackle the case that all handles are 'disabled'.
        if (handleNumber === false) {
            return;
        }
        // Flag the slider as it is now in a transitional state.
        // Transition takes a configurable amount of ms (default 300). Re-enable the slider after that.
        if (!options.events.snap) {
            addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
        }
        setHandle(handleNumber, proposal, true, true);
        setZindex();
        fireEvent("slide", handleNumber, true);
        fireEvent("update", handleNumber, true);
        if (!options.events.snap) {
            fireEvent("change", handleNumber, true);
            fireEvent("set", handleNumber, true);
        }
        else {
            eventStart(event, { handleNumbers: [handleNumber] });
        }
    }
    // Fires a 'hover' event for a hovered mouse/pen position.
    function eventHover(event) {
        var proposal = calcPointToPercentage(event.calcPoint);
        var to = scope_Spectrum.getStep(proposal);
        var value = scope_Spectrum.fromStepping(to);
        Object.keys(scope_Events).forEach(function (targetEvent) {
            if ("hover" === targetEvent.split(".")[0]) {
                scope_Events[targetEvent].forEach(function (callback) {
                    callback.call(scope_Self, value);
                });
            }
        });
    }
    // Handles keydown on focused handles
    // Don't move the document when pressing arrow keys on focused handles
    function eventKeydown(event, handleNumber) {
        if (isSliderDisabled() || isHandleDisabled(handleNumber)) {
            return false;
        }
        var horizontalKeys = ["Left", "Right"];
        var verticalKeys = ["Down", "Up"];
        var largeStepKeys = ["PageDown", "PageUp"];
        var edgeKeys = ["Home", "End"];
        if (options.dir && !options.ort) {
            // On an right-to-left slider, the left and right keys act inverted
            horizontalKeys.reverse();
        }
        else if (options.ort && !options.dir) {
            // On a top-to-bottom slider, the up and down keys act inverted
            verticalKeys.reverse();
            largeStepKeys.reverse();
        }
        // Strip "Arrow" for IE compatibility. https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key
        var key = event.key.replace("Arrow", "");
        var isLargeDown = key === largeStepKeys[0];
        var isLargeUp = key === largeStepKeys[1];
        var isDown = key === verticalKeys[0] || key === horizontalKeys[0] || isLargeDown;
        var isUp = key === verticalKeys[1] || key === horizontalKeys[1] || isLargeUp;
        var isMin = key === edgeKeys[0];
        var isMax = key === edgeKeys[1];
        if (!isDown && !isUp && !isMin && !isMax) {
            return true;
        }
        event.preventDefault();
        var to;
        if (isUp || isDown) {
            var direction = isDown ? 0 : 1;
            var steps = getNextStepsForHandle(handleNumber);
            var step = steps[direction];
            // At the edge of a slider, do nothing
            if (step === null) {
                return false;
            }
            // No step set, use the default of 10% of the sub-range
            if (step === false) {
                step = scope_Spectrum.getDefaultStep(scope_Locations[handleNumber], isDown, options.keyboardDefaultStep);
            }
            if (isLargeUp || isLargeDown) {
                step *= options.keyboardPageMultiplier;
            }
            else {
                step *= options.keyboardMultiplier;
            }
            // Step over zero-length ranges (#948);
            step = Math.max(step, 0.0000001);
            // Decrement for down steps
            step = (isDown ? -1 : 1) * step;
            to = scope_Values[handleNumber] + step;
        }
        else if (isMax) {
            // End key
            to = options.spectrum.xVal[options.spectrum.xVal.length - 1];
        }
        else {
            // Home key
            to = options.spectrum.xVal[0];
        }
        setHandle(handleNumber, scope_Spectrum.toStepping(to), true, true);
        fireEvent("slide", handleNumber);
        fireEvent("update", handleNumber);
        fireEvent("change", handleNumber);
        fireEvent("set", handleNumber);
        return false;
    }
    // Attach events to several slider parts.
    function bindSliderEvents(behaviour) {
        // Attach the standard drag event to the handles.
        if (!behaviour.fixed) {
            scope_Handles.forEach(function (handle, index) {
                // These events are only bound to the visual handle
                // element, not the 'real' origin element.
                attachEvent(actions.start, handle.children[0], eventStart, {
                    handleNumbers: [index],
                });
            });
        }
        // Attach the tap event to the slider base.
        if (behaviour.tap) {
            attachEvent(actions.start, scope_Base, eventTap, {});
        }
        // Fire hover events
        if (behaviour.hover) {
            attachEvent(actions.move, scope_Base, eventHover, {
                hover: true,
            });
        }
        // Make the range draggable.
        if (behaviour.drag) {
            scope_Connects.forEach(function (connect, index) {
                if (connect === false || index === 0 || index === scope_Connects.length - 1) {
                    return;
                }
                var handleBefore = scope_Handles[index - 1];
                var handleAfter = scope_Handles[index];
                var eventHolders = [connect];
                var handlesToDrag = [handleBefore, handleAfter];
                var handleNumbersToDrag = [index - 1, index];
                addClass(connect, options.cssClasses.draggable);
                // When the range is fixed, the entire range can
                // be dragged by the handles. The handle in the first
                // origin will propagate the start event upward,
                // but it needs to be bound manually on the other.
                if (behaviour.fixed) {
                    eventHolders.push(handleBefore.children[0]);
                    eventHolders.push(handleAfter.children[0]);
                }
                if (behaviour.dragAll) {
                    handlesToDrag = scope_Handles;
                    handleNumbersToDrag = scope_HandleNumbers;
                }
                eventHolders.forEach(function (eventHolder) {
                    attachEvent(actions.start, eventHolder, eventStart, {
                        handles: handlesToDrag,
                        handleNumbers: handleNumbersToDrag,
                        connect: connect,
                    });
                });
            });
        }
    }
    // Attach an event to this slider, possibly including a namespace
    function bindEvent(namespacedEvent, callback) {
        scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];
        scope_Events[namespacedEvent].push(callback);
        // If the event bound is 'update,' fire it immediately for all handles.
        if (namespacedEvent.split(".")[0] === "update") {
            scope_Handles.forEach(function (a, index) {
                fireEvent("update", index);
            });
        }
    }
    function isInternalNamespace(namespace) {
        return namespace === INTERNAL_EVENT_NS.aria || namespace === INTERNAL_EVENT_NS.tooltips;
    }
    // Undo attachment of event
    function removeEvent(namespacedEvent) {
        var event = namespacedEvent && namespacedEvent.split(".")[0];
        var namespace = event ? namespacedEvent.substring(event.length) : namespacedEvent;
        Object.keys(scope_Events).forEach(function (bind) {
            var tEvent = bind.split(".")[0];
            var tNamespace = bind.substring(tEvent.length);
            if ((!event || event === tEvent) && (!namespace || namespace === tNamespace)) {
                // only delete protected internal event if intentional
                if (!isInternalNamespace(tNamespace) || namespace === tNamespace) {
                    delete scope_Events[bind];
                }
            }
        });
    }
    // External event handling
    function fireEvent(eventName, handleNumber, tap) {
        Object.keys(scope_Events).forEach(function (targetEvent) {
            var eventType = targetEvent.split(".")[0];
            if (eventName === eventType) {
                scope_Events[targetEvent].forEach(function (callback) {
                    callback.call(
                    // Use the slider public API as the scope ('this')
                    scope_Self, 
                    // Return values as array, so arg_1[arg_2] is always valid.
                    scope_Values.map(options.format.to), 
                    // Handle index, 0 or 1
                    handleNumber, 
                    // Un-formatted slider values
                    scope_Values.slice(), 
                    // Event is fired by tap, true or false
                    tap || false, 
                    // Left offset of the handle, in relation to the slider
                    scope_Locations.slice(), 
                    // add the slider public API to an accessible parameter when this is unavailable
                    scope_Self);
                });
            }
        });
    }
    // Split out the handle positioning logic so the Move event can use it, too
    function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue, smoothSteps) {
        var distance;
        // For sliders with multiple handles, limit movement to the other handle.
        // Apply the margin option by adding it to the handle positions.
        if (scope_Handles.length > 1 && !options.events.unconstrained) {
            if (lookBackward && handleNumber > 0) {
                distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.margin, false);
                to = Math.max(to, distance);
            }
            if (lookForward && handleNumber < scope_Handles.length - 1) {
                distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.margin, true);
                to = Math.min(to, distance);
            }
        }
        // The limit option has the opposite effect, limiting handles to a
        // maximum distance from another. Limit must be > 0, as otherwise
        // handles would be unmovable.
        if (scope_Handles.length > 1 && options.limit) {
            if (lookBackward && handleNumber > 0) {
                distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.limit, false);
                to = Math.min(to, distance);
            }
            if (lookForward && handleNumber < scope_Handles.length - 1) {
                distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.limit, true);
                to = Math.max(to, distance);
            }
        }
        // The padding option keeps the handles a certain distance from the
        // edges of the slider. Padding must be > 0.
        if (options.padding) {
            if (handleNumber === 0) {
                distance = scope_Spectrum.getAbsoluteDistance(0, options.padding[0], false);
                to = Math.max(to, distance);
            }
            if (handleNumber === scope_Handles.length - 1) {
                distance = scope_Spectrum.getAbsoluteDistance(100, options.padding[1], true);
                to = Math.min(to, distance);
            }
        }
        if (!smoothSteps) {
            to = scope_Spectrum.getStep(to);
        }
        // Limit percentage to the 0 - 100 range
        to = limit(to);
        // Return false if handle can't move
        if (to === reference[handleNumber] && !getValue) {
            return false;
        }
        return to;
    }
    // Uses slider orientation to create CSS rules. a = base value;
    function inRuleOrder(v, a) {
        var o = options.ort;
        return (o ? a : v) + ", " + (o ? v : a);
    }
    // Moves handle(s) by a percentage
    // (bool, % to move, [% where handle started, ...], [index in scope_Handles, ...])
    function moveHandles(upward, proposal, locations, handleNumbers, connect) {
        var proposals = locations.slice();
        // Store first handle now, so we still have it in case handleNumbers is reversed
        var firstHandle = handleNumbers[0];
        var smoothSteps = options.events.smoothSteps;
        var b = [!upward, upward];
        var f = [upward, !upward];
        // Copy handleNumbers so we don't change the dataset
        handleNumbers = handleNumbers.slice();
        // Check to see which handle is 'leading'.
        // If that one can't move the second can't either.
        if (upward) {
            handleNumbers.reverse();
        }
        // Step 1: get the maximum percentage that any of the handles can move
        if (handleNumbers.length > 1) {
            handleNumbers.forEach(function (handleNumber, o) {
                var to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b[o], f[o], false, smoothSteps);
                // Stop if one of the handles can't move.
                if (to === false) {
                    proposal = 0;
                }
                else {
                    proposal = to - proposals[handleNumber];
                    proposals[handleNumber] = to;
                }
            });
        }
        // If using one handle, check backward AND forward
        else {
            b = f = [true];
        }
        var state = false;
        // Step 2: Try to set the handles with the found percentage
        handleNumbers.forEach(function (handleNumber, o) {
            state =
                setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o], false, smoothSteps) || state;
        });
        // Step 3: If a handle moved, fire events
        if (state) {
            handleNumbers.forEach(function (handleNumber) {
                fireEvent("update", handleNumber);
                fireEvent("slide", handleNumber);
            });
            // If target is a connect, then fire drag event
            if (connect != undefined) {
                fireEvent("drag", firstHandle);
            }
        }
    }
    // Takes a base value and an offset. This offset is used for the connect bar size.
    // In the initial design for this feature, the origin element was 1% wide.
    // Unfortunately, a rounding bug in Chrome makes it impossible to implement this feature
    // in this manner: https://bugs.chromium.org/p/chromium/issues/detail?id=798223
    function transformDirection(a, b) {
        return options.dir ? 100 - a - b : a;
    }
    // Updates scope_Locations and scope_Values, updates visual state
    function updateHandlePosition(handleNumber, to) {
        // Update locations.
        scope_Locations[handleNumber] = to;
        // Convert the value to the slider stepping/range.
        scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);
        var translation = transformDirection(to, 0) - scope_DirOffset;
        var translateRule = "translate(" + inRuleOrder(translation + "%", "0") + ")";
        scope_Handles[handleNumber].style[options.transformRule] = translateRule;
        // sanity check for at least 2 handles (e.g. during setup)
        if (options.events.invertConnects && scope_Locations.length > 1) {
            // check if handles passed each other, but don't match the ConnectsInverted state
            var handlesAreInOrder = scope_Locations.every(function (position, index, locations) {
                return index === 0 || position >= locations[index - 1];
            });
            if (scope_ConnectsInverted !== !handlesAreInOrder) {
                // invert connects when handles pass each other
                invertConnects();
                // invertConnects already updates all connect elements
                return;
            }
        }
        updateConnect(handleNumber);
        updateConnect(handleNumber + 1);
        if (scope_ConnectsInverted) {
            // When connects are inverted, we also have to update adjacent connects
            updateConnect(handleNumber - 1);
            updateConnect(handleNumber + 2);
        }
    }
    // Handles before the slider middle are stacked later = higher,
    // Handles after the middle later is lower
    // [[7] [8] .......... | .......... [5] [4]
    function setZindex() {
        scope_HandleNumbers.forEach(function (handleNumber) {
            var dir = scope_Locations[handleNumber] > 50 ? -1 : 1;
            var zIndex = 3 + (scope_Handles.length + dir * handleNumber);
            scope_Handles[handleNumber].style.zIndex = String(zIndex);
        });
    }
    // Test suggested values and apply margin, step.
    // if exactInput is true, don't run checkHandlePosition, then the handle can be placed in between steps (#436)
    function setHandle(handleNumber, to, lookBackward, lookForward, exactInput, smoothSteps) {
        if (!exactInput) {
            to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false, smoothSteps);
        }
        if (to === false) {
            return false;
        }
        updateHandlePosition(handleNumber, to);
        return true;
    }
    // Updates style attribute for connect nodes
    function updateConnect(index) {
        // Skip connects set to false
        if (!scope_Connects[index]) {
            return;
        }
        // Create a copy of locations, so we can sort them for the local scope logic
        var locations = scope_Locations.slice();
        if (scope_ConnectsInverted) {
            locations.sort(function (a, b) {
                return a - b;
            });
        }
        var l = 0;
        var h = 100;
        if (index !== 0) {
            l = locations[index - 1];
        }
        if (index !== scope_Connects.length - 1) {
            h = locations[index];
        }
        // We use two rules:
        // 'translate' to change the left/top offset;
        // 'scale' to change the width of the element;
        // As the element has a width of 100%, a translation of 100% is equal to 100% of the parent (.noUi-base)
        var connectWidth = h - l;
        var translateRule = "translate(" + inRuleOrder(transformDirection(l, connectWidth) + "%", "0") + ")";
        var scaleRule = "scale(" + inRuleOrder(connectWidth / 100, "1") + ")";
        scope_Connects[index].style[options.transformRule] =
            translateRule + " " + scaleRule;
    }
    // Parses value passed to .set method. Returns current value if not parse-able.
    function resolveToValue(to, handleNumber) {
        // Setting with null indicates an 'ignore'.
        // Inputting 'false' is invalid.
        if (to === null || to === false || to === undefined) {
            return scope_Locations[handleNumber];
        }
        // If a formatted number was passed, attempt to decode it.
        if (typeof to === "number") {
            to = String(to);
        }
        to = options.format.from(to);
        if (to !== false) {
            to = scope_Spectrum.toStepping(to);
        }
        // If parsing the number failed, use the current value.
        if (to === false || isNaN(to)) {
            return scope_Locations[handleNumber];
        }
        return to;
    }
    // Set the slider value.
    function valueSet(input, fireSetEvent, exactInput) {
        var values = asArray(input);
        var isInit = scope_Locations[0] === undefined;
        // Event fires by default
        fireSetEvent = fireSetEvent === undefined ? true : fireSetEvent;
        // Animation is optional.
        // Make sure the initial values were set before using animated placement.
        if (options.animate && !isInit) {
            addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
        }
        // First pass, without lookAhead but with lookBackward. Values are set from left to right.
        scope_HandleNumbers.forEach(function (handleNumber) {
            setHandle(handleNumber, resolveToValue(values[handleNumber], handleNumber), true, false, exactInput);
        });
        var i = scope_HandleNumbers.length === 1 ? 0 : 1;
        // Spread handles evenly across the slider if the range has no size (min=max)
        if (isInit && scope_Spectrum.hasNoSize()) {
            exactInput = true;
            scope_Locations[0] = 0;
            if (scope_HandleNumbers.length > 1) {
                var space_1 = 100 / (scope_HandleNumbers.length - 1);
                scope_HandleNumbers.forEach(function (handleNumber) {
                    scope_Locations[handleNumber] = handleNumber * space_1;
                });
            }
        }
        // Secondary passes. Now that all base values are set, apply constraints.
        // Iterate all handles to ensure constraints are applied for the entire slider (Issue #1009)
        for (; i < scope_HandleNumbers.length; ++i) {
            scope_HandleNumbers.forEach(function (handleNumber) {
                setHandle(handleNumber, scope_Locations[handleNumber], true, true, exactInput);
            });
        }
        setZindex();
        scope_HandleNumbers.forEach(function (handleNumber) {
            fireEvent("update", handleNumber);
            // Fire the event only for handles that received a new value, as per #579
            if (values[handleNumber] !== null && fireSetEvent) {
                fireEvent("set", handleNumber);
            }
        });
    }
    // Reset slider to initial values
    function valueReset(fireSetEvent) {
        valueSet(options.start, fireSetEvent);
    }
    // Set value for a single handle
    function valueSetHandle(handleNumber, value, fireSetEvent, exactInput) {
        // Ensure numeric input
        handleNumber = Number(handleNumber);
        if (!(handleNumber >= 0 && handleNumber < scope_HandleNumbers.length)) {
            throw new Error("noUiSlider: invalid handle number, got: " + handleNumber);
        }
        // Look both backward and forward, since we don't want this handle to "push" other handles (#960);
        // The exactInput argument can be used to ignore slider stepping (#436)
        setHandle(handleNumber, resolveToValue(value, handleNumber), true, true, exactInput);
        fireEvent("update", handleNumber);
        if (fireSetEvent) {
            fireEvent("set", handleNumber);
        }
    }
    // Get the slider value.
    function valueGet(unencoded) {
        if (unencoded === void 0) { unencoded = false; }
        if (unencoded) {
            // return a copy of the raw values
            return scope_Values.length === 1 ? scope_Values[0] : scope_Values.slice(0);
        }
        var values = scope_Values.map(options.format.to);
        // If only one handle is used, return a single value.
        if (values.length === 1) {
            return values[0];
        }
        return values;
    }
    // Removes classes from the root and empties it.
    function destroy() {
        // remove protected internal listeners
        removeEvent(INTERNAL_EVENT_NS.aria);
        removeEvent(INTERNAL_EVENT_NS.tooltips);
        Object.keys(options.cssClasses).forEach(function (key) {
            removeClass(scope_Target, options.cssClasses[key]);
        });
        while (scope_Target.firstChild) {
            scope_Target.removeChild(scope_Target.firstChild);
        }
        delete scope_Target.noUiSlider;
    }
    function getNextStepsForHandle(handleNumber) {
        var location = scope_Locations[handleNumber];
        var nearbySteps = scope_Spectrum.getNearbySteps(location);
        var value = scope_Values[handleNumber];
        var increment = nearbySteps.thisStep.step;
        var decrement = null;
        // If snapped, directly use defined step value
        if (options.snap) {
            return [
                value - nearbySteps.stepBefore.startValue || null,
                nearbySteps.stepAfter.startValue - value || null,
            ];
        }
        // If the next value in this step moves into the next step,
        // the increment is the start of the next step - the current value
        if (increment !== false) {
            if (value + increment > nearbySteps.stepAfter.startValue) {
                increment = nearbySteps.stepAfter.startValue - value;
            }
        }
        // If the value is beyond the starting point
        if (value > nearbySteps.thisStep.startValue) {
            decrement = nearbySteps.thisStep.step;
        }
        else if (nearbySteps.stepBefore.step === false) {
            decrement = false;
        }
        // If a handle is at the start of a step, it always steps back into the previous step first
        else {
            decrement = value - nearbySteps.stepBefore.highestStep;
        }
        // Now, if at the slider edges, there is no in/decrement
        if (location === 100) {
            increment = null;
        }
        else if (location === 0) {
            decrement = null;
        }
        // As per #391, the comparison for the decrement step can have some rounding issues.
        var stepDecimals = scope_Spectrum.countStepDecimals();
        // Round per #391
        if (increment !== null && increment !== false) {
            increment = Number(increment.toFixed(stepDecimals));
        }
        if (decrement !== null && decrement !== false) {
            decrement = Number(decrement.toFixed(stepDecimals));
        }
        return [decrement, increment];
    }
    // Get the current step size for the slider.
    function getNextSteps() {
        return scope_HandleNumbers.map(getNextStepsForHandle);
    }
    // Updatable: margin, limit, padding, step, range, animate, snap
    function updateOptions(optionsToUpdate, fireSetEvent) {
        // Spectrum is created using the range, snap, direction and step options.
        // 'snap' and 'step' can be updated.
        // If 'snap' and 'step' are not passed, they should remain unchanged.
        var v = valueGet();
        var updateAble = [
            "margin",
            "limit",
            "padding",
            "range",
            "animate",
            "snap",
            "step",
            "format",
            "pips",
            "tooltips",
            "connect",
        ];
        // Only change options that we're actually passed to update.
        updateAble.forEach(function (name) {
            // Check for undefined. null removes the value.
            if (optionsToUpdate[name] !== undefined) {
                originalOptions[name] = optionsToUpdate[name];
            }
        });
        var newOptions = testOptions(originalOptions);
        // Load new options into the slider state
        updateAble.forEach(function (name) {
            if (optionsToUpdate[name] !== undefined) {
                options[name] = newOptions[name];
            }
        });
        scope_Spectrum = newOptions.spectrum;
        // Limit, margin and padding depend on the spectrum but are stored outside of it. (#677)
        options.margin = newOptions.margin;
        options.limit = newOptions.limit;
        options.padding = newOptions.padding;
        // Update pips, removes existing.
        if (options.pips) {
            pips(options.pips);
        }
        else {
            removePips();
        }
        // Update tooltips, removes existing.
        if (options.tooltips) {
            tooltips();
        }
        else {
            removeTooltips();
        }
        // Invalidate the current positioning so valueSet forces an update.
        scope_Locations = [];
        valueSet(isSet(optionsToUpdate.start) ? optionsToUpdate.start : v, fireSetEvent);
        // Update connects only if it was set
        if (optionsToUpdate.connect) {
            updateConnectOption();
        }
    }
    function updateConnectOption() {
        // IE supported way of removing children including event handlers
        while (scope_ConnectBase.firstChild) {
            scope_ConnectBase.removeChild(scope_ConnectBase.firstChild);
        }
        // Adding new connects according to the new connect options
        for (var i = 0; i <= options.handles; i++) {
            scope_Connects[i] = addConnect(scope_ConnectBase, options.connect[i]);
            updateConnect(i);
        }
        // re-adding drag events for the new connect elements
        // to ignore the other events we have to negate the 'if (!behaviour.fixed)' check
        bindSliderEvents({ drag: options.events.drag, fixed: true });
    }
    // Invert options for connect handles
    function invertConnects() {
        scope_ConnectsInverted = !scope_ConnectsInverted;
        testConnect(options, 
        // inverse the connect boolean array
        options.connect.map(function (b) { return !b; }));
        updateConnectOption();
    }
    // Initialization steps
    function setupSlider() {
        // Create the base element, initialize HTML and set classes.
        // Add handles and connect elements.
        scope_Base = addSlider(scope_Target);
        addElements(options.connect, scope_Base);
        // Attach user events.
        bindSliderEvents(options.events);
        // Use the public value method to set the start values.
        valueSet(options.start);
        if (options.pips) {
            pips(options.pips);
        }
        if (options.tooltips) {
            tooltips();
        }
        aria();
    }
    setupSlider();
    var scope_Self = {
        destroy: destroy,
        steps: getNextSteps,
        on: bindEvent,
        off: removeEvent,
        get: valueGet,
        set: valueSet,
        setHandle: valueSetHandle,
        reset: valueReset,
        disable: disable,
        enable: enable,
        // Exposed for unit testing, don't use this in your application.
        __moveHandles: function (upward, proposal, handleNumbers) {
            moveHandles(upward, proposal, scope_Locations, handleNumbers);
        },
        options: originalOptions,
        updateOptions: updateOptions,
        target: scope_Target,
        removePips: removePips,
        removeTooltips: removeTooltips,
        getPositions: function () {
            return scope_Locations.slice();
        },
        getTooltips: function () {
            return scope_Tooltips;
        },
        getOrigins: function () {
            return scope_Handles;
        },
        pips: pips, // Issue #594
    };
    return scope_Self;
}
// Run the standard initializer
function initialize(target, originalOptions) {
    if (!target || !target.nodeName) {
        throw new Error("noUiSlider: create requires a single element, got: " + target);
    }
    // Throw an error if the slider was already initialized.
    if (target.noUiSlider) {
        throw new Error("noUiSlider: Slider was already initialized.");
    }
    // Test the options and create the slider environment;
    var options = testOptions(originalOptions);
    var api = scope(target, options, originalOptions);
    target.noUiSlider = api;
    return api;
}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    // Exposed for unit testing, don't use this in your application.
    __spectrum: Spectrum,
    // A reference to the default classes, allows global changes.
    // Use the cssClasses option for changes to one slider.
    cssClasses: cssClasses,
    create: initialize,
});


/***/ }),

/***/ "./node_modules/simplebar-core/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/simplebar-core/dist/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SimpleBarCore)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/throttle.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/debounce.js");
/**
 * simplebar-core - v1.2.6
 * Scrollbars, simpler.
 * https://grsmto.github.io/simplebar/
 *
 * Made by Adrien Denat from a fork by Jonathan Nicol
 * Under MIT License
 */



/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function getElementWindow$1(element) {
    if (!element ||
        !element.ownerDocument ||
        !element.ownerDocument.defaultView) {
        return window;
    }
    return element.ownerDocument.defaultView;
}
function getElementDocument$1(element) {
    if (!element || !element.ownerDocument) {
        return document;
    }
    return element.ownerDocument;
}
// Helper function to retrieve options from element attributes
var getOptions$1 = function (obj) {
    var initialObj = {};
    var options = Array.prototype.reduce.call(obj, function (acc, attribute) {
        var option = attribute.name.match(/data-simplebar-(.+)/);
        if (option) {
            var key = option[1].replace(/\W+(.)/g, function (_, chr) { return chr.toUpperCase(); });
            switch (attribute.value) {
                case 'true':
                    acc[key] = true;
                    break;
                case 'false':
                    acc[key] = false;
                    break;
                case undefined:
                    acc[key] = true;
                    break;
                default:
                    acc[key] = attribute.value;
            }
        }
        return acc;
    }, initialObj);
    return options;
};
function addClasses$1(el, classes) {
    var _a;
    if (!el)
        return;
    (_a = el.classList).add.apply(_a, classes.split(' '));
}
function removeClasses$1(el, classes) {
    if (!el)
        return;
    classes.split(' ').forEach(function (className) {
        el.classList.remove(className);
    });
}
function classNamesToQuery$1(classNames) {
    return ".".concat(classNames.split(' ').join('.'));
}
var canUseDOM = !!(typeof window !== 'undefined' &&
    window.document &&
    window.document.createElement);

var helpers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    addClasses: addClasses$1,
    canUseDOM: canUseDOM,
    classNamesToQuery: classNamesToQuery$1,
    getElementDocument: getElementDocument$1,
    getElementWindow: getElementWindow$1,
    getOptions: getOptions$1,
    removeClasses: removeClasses$1
});

var cachedScrollbarWidth = null;
var cachedDevicePixelRatio = null;
if (canUseDOM) {
    window.addEventListener('resize', function () {
        if (cachedDevicePixelRatio !== window.devicePixelRatio) {
            cachedDevicePixelRatio = window.devicePixelRatio;
            cachedScrollbarWidth = null;
        }
    });
}
function scrollbarWidth() {
    if (cachedScrollbarWidth === null) {
        if (typeof document === 'undefined') {
            cachedScrollbarWidth = 0;
            return cachedScrollbarWidth;
        }
        var body = document.body;
        var box = document.createElement('div');
        box.classList.add('simplebar-hide-scrollbar');
        body.appendChild(box);
        var width = box.getBoundingClientRect().right;
        body.removeChild(box);
        cachedScrollbarWidth = width;
    }
    return cachedScrollbarWidth;
}

var getElementWindow = getElementWindow$1, getElementDocument = getElementDocument$1, getOptions = getOptions$1, addClasses = addClasses$1, removeClasses = removeClasses$1, classNamesToQuery = classNamesToQuery$1;
var SimpleBarCore = /** @class */ (function () {
    function SimpleBarCore(element, options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        this.removePreventClickId = null;
        this.minScrollbarWidth = 20;
        this.stopScrollDelay = 175;
        this.isScrolling = false;
        this.isMouseEntering = false;
        this.isDragging = false;
        this.scrollXTicking = false;
        this.scrollYTicking = false;
        this.wrapperEl = null;
        this.contentWrapperEl = null;
        this.contentEl = null;
        this.offsetEl = null;
        this.maskEl = null;
        this.placeholderEl = null;
        this.heightAutoObserverWrapperEl = null;
        this.heightAutoObserverEl = null;
        this.rtlHelpers = null;
        this.scrollbarWidth = 0;
        this.resizeObserver = null;
        this.mutationObserver = null;
        this.elStyles = null;
        this.isRtl = null;
        this.mouseX = 0;
        this.mouseY = 0;
        this.onMouseMove = function () { };
        this.onWindowResize = function () { };
        this.onStopScrolling = function () { };
        this.onMouseEntered = function () { };
        /**
         * On scroll event handling
         */
        this.onScroll = function () {
            var elWindow = getElementWindow(_this.el);
            if (!_this.scrollXTicking) {
                elWindow.requestAnimationFrame(_this.scrollX);
                _this.scrollXTicking = true;
            }
            if (!_this.scrollYTicking) {
                elWindow.requestAnimationFrame(_this.scrollY);
                _this.scrollYTicking = true;
            }
            if (!_this.isScrolling) {
                _this.isScrolling = true;
                addClasses(_this.el, _this.classNames.scrolling);
            }
            _this.showScrollbar('x');
            _this.showScrollbar('y');
            _this.onStopScrolling();
        };
        this.scrollX = function () {
            if (_this.axis.x.isOverflowing) {
                _this.positionScrollbar('x');
            }
            _this.scrollXTicking = false;
        };
        this.scrollY = function () {
            if (_this.axis.y.isOverflowing) {
                _this.positionScrollbar('y');
            }
            _this.scrollYTicking = false;
        };
        this._onStopScrolling = function () {
            removeClasses(_this.el, _this.classNames.scrolling);
            if (_this.options.autoHide) {
                _this.hideScrollbar('x');
                _this.hideScrollbar('y');
            }
            _this.isScrolling = false;
        };
        this.onMouseEnter = function () {
            if (!_this.isMouseEntering) {
                addClasses(_this.el, _this.classNames.mouseEntered);
                _this.showScrollbar('x');
                _this.showScrollbar('y');
                _this.isMouseEntering = true;
            }
            _this.onMouseEntered();
        };
        this._onMouseEntered = function () {
            removeClasses(_this.el, _this.classNames.mouseEntered);
            if (_this.options.autoHide) {
                _this.hideScrollbar('x');
                _this.hideScrollbar('y');
            }
            _this.isMouseEntering = false;
        };
        this._onMouseMove = function (e) {
            _this.mouseX = e.clientX;
            _this.mouseY = e.clientY;
            if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) {
                _this.onMouseMoveForAxis('x');
            }
            if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) {
                _this.onMouseMoveForAxis('y');
            }
        };
        this.onMouseLeave = function () {
            _this.onMouseMove.cancel();
            if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) {
                _this.onMouseLeaveForAxis('x');
            }
            if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) {
                _this.onMouseLeaveForAxis('y');
            }
            _this.mouseX = -1;
            _this.mouseY = -1;
        };
        this._onWindowResize = function () {
            // Recalculate scrollbarWidth in case it's a zoom
            _this.scrollbarWidth = _this.getScrollbarWidth();
            _this.hideNativeScrollbar();
        };
        this.onPointerEvent = function (e) {
            if (!_this.axis.x.track.el ||
                !_this.axis.y.track.el ||
                !_this.axis.x.scrollbar.el ||
                !_this.axis.y.scrollbar.el)
                return;
            var isWithinTrackXBounds, isWithinTrackYBounds;
            _this.axis.x.track.rect = _this.axis.x.track.el.getBoundingClientRect();
            _this.axis.y.track.rect = _this.axis.y.track.el.getBoundingClientRect();
            if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) {
                isWithinTrackXBounds = _this.isWithinBounds(_this.axis.x.track.rect);
            }
            if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) {
                isWithinTrackYBounds = _this.isWithinBounds(_this.axis.y.track.rect);
            }
            // If any pointer event is called on the scrollbar
            if (isWithinTrackXBounds || isWithinTrackYBounds) {
                // Prevent event leaking
                e.stopPropagation();
                if (e.type === 'pointerdown' && e.pointerType !== 'touch') {
                    if (isWithinTrackXBounds) {
                        _this.axis.x.scrollbar.rect =
                            _this.axis.x.scrollbar.el.getBoundingClientRect();
                        if (_this.isWithinBounds(_this.axis.x.scrollbar.rect)) {
                            _this.onDragStart(e, 'x');
                        }
                        else {
                            _this.onTrackClick(e, 'x');
                        }
                    }
                    if (isWithinTrackYBounds) {
                        _this.axis.y.scrollbar.rect =
                            _this.axis.y.scrollbar.el.getBoundingClientRect();
                        if (_this.isWithinBounds(_this.axis.y.scrollbar.rect)) {
                            _this.onDragStart(e, 'y');
                        }
                        else {
                            _this.onTrackClick(e, 'y');
                        }
                    }
                }
            }
        };
        /**
         * Drag scrollbar handle
         */
        this.drag = function (e) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
            if (!_this.draggedAxis || !_this.contentWrapperEl)
                return;
            var eventOffset;
            var track = _this.axis[_this.draggedAxis].track;
            var trackSize = (_b = (_a = track.rect) === null || _a === void 0 ? void 0 : _a[_this.axis[_this.draggedAxis].sizeAttr]) !== null && _b !== void 0 ? _b : 0;
            var scrollbar = _this.axis[_this.draggedAxis].scrollbar;
            var contentSize = (_d = (_c = _this.contentWrapperEl) === null || _c === void 0 ? void 0 : _c[_this.axis[_this.draggedAxis].scrollSizeAttr]) !== null && _d !== void 0 ? _d : 0;
            var hostSize = parseInt((_f = (_e = _this.elStyles) === null || _e === void 0 ? void 0 : _e[_this.axis[_this.draggedAxis].sizeAttr]) !== null && _f !== void 0 ? _f : '0px', 10);
            e.preventDefault();
            e.stopPropagation();
            if (_this.draggedAxis === 'y') {
                eventOffset = e.pageY;
            }
            else {
                eventOffset = e.pageX;
            }
            // Calculate how far the user's mouse is from the top/left of the scrollbar (minus the dragOffset).
            var dragPos = eventOffset -
                ((_h = (_g = track.rect) === null || _g === void 0 ? void 0 : _g[_this.axis[_this.draggedAxis].offsetAttr]) !== null && _h !== void 0 ? _h : 0) -
                _this.axis[_this.draggedAxis].dragOffset;
            dragPos =
                _this.draggedAxis === 'x' && _this.isRtl
                    ? ((_k = (_j = track.rect) === null || _j === void 0 ? void 0 : _j[_this.axis[_this.draggedAxis].sizeAttr]) !== null && _k !== void 0 ? _k : 0) -
                        scrollbar.size -
                        dragPos
                    : dragPos;
            // Convert the mouse position into a percentage of the scrollbar height/width.
            var dragPerc = dragPos / (trackSize - scrollbar.size);
            // Scroll the content by the same percentage.
            var scrollPos = dragPerc * (contentSize - hostSize);
            // Fix browsers inconsistency on RTL
            if (_this.draggedAxis === 'x' && _this.isRtl) {
                scrollPos = ((_l = SimpleBarCore.getRtlHelpers()) === null || _l === void 0 ? void 0 : _l.isScrollingToNegative)
                    ? -scrollPos
                    : scrollPos;
            }
            _this.contentWrapperEl[_this.axis[_this.draggedAxis].scrollOffsetAttr] =
                scrollPos;
        };
        /**
         * End scroll handle drag
         */
        this.onEndDrag = function (e) {
            _this.isDragging = false;
            var elDocument = getElementDocument(_this.el);
            var elWindow = getElementWindow(_this.el);
            e.preventDefault();
            e.stopPropagation();
            removeClasses(_this.el, _this.classNames.dragging);
            _this.onStopScrolling();
            elDocument.removeEventListener('mousemove', _this.drag, true);
            elDocument.removeEventListener('mouseup', _this.onEndDrag, true);
            _this.removePreventClickId = elWindow.setTimeout(function () {
                // Remove these asynchronously so we still suppress click events
                // generated simultaneously with mouseup.
                elDocument.removeEventListener('click', _this.preventClick, true);
                elDocument.removeEventListener('dblclick', _this.preventClick, true);
                _this.removePreventClickId = null;
            });
        };
        /**
         * Handler to ignore click events during drag
         */
        this.preventClick = function (e) {
            e.preventDefault();
            e.stopPropagation();
        };
        this.el = element;
        this.options = __assign(__assign({}, SimpleBarCore.defaultOptions), options);
        this.classNames = __assign(__assign({}, SimpleBarCore.defaultOptions.classNames), options.classNames);
        this.axis = {
            x: {
                scrollOffsetAttr: 'scrollLeft',
                sizeAttr: 'width',
                scrollSizeAttr: 'scrollWidth',
                offsetSizeAttr: 'offsetWidth',
                offsetAttr: 'left',
                overflowAttr: 'overflowX',
                dragOffset: 0,
                isOverflowing: true,
                forceVisible: false,
                track: { size: null, el: null, rect: null, isVisible: false },
                scrollbar: { size: null, el: null, rect: null, isVisible: false }
            },
            y: {
                scrollOffsetAttr: 'scrollTop',
                sizeAttr: 'height',
                scrollSizeAttr: 'scrollHeight',
                offsetSizeAttr: 'offsetHeight',
                offsetAttr: 'top',
                overflowAttr: 'overflowY',
                dragOffset: 0,
                isOverflowing: true,
                forceVisible: false,
                track: { size: null, el: null, rect: null, isVisible: false },
                scrollbar: { size: null, el: null, rect: null, isVisible: false }
            }
        };
        if (typeof this.el !== 'object' || !this.el.nodeName) {
            throw new Error("Argument passed to SimpleBar must be an HTML element instead of ".concat(this.el));
        }
        this.onMouseMove = (0,lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"])(this._onMouseMove, 64);
        this.onWindowResize = (0,lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"])(this._onWindowResize, 64, { leading: true });
        this.onStopScrolling = (0,lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"])(this._onStopScrolling, this.stopScrollDelay);
        this.onMouseEntered = (0,lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"])(this._onMouseEntered, this.stopScrollDelay);
        this.init();
    }
    /**
     * Helper to fix browsers inconsistency on RTL:
     *  - Firefox inverts the scrollbar initial position
     *  - IE11 inverts both scrollbar position and scrolling offset
     * Directly inspired by @KingSora's OverlayScrollbars https://github.com/KingSora/OverlayScrollbars/blob/master/js/OverlayScrollbars.js#L1634
     */
    SimpleBarCore.getRtlHelpers = function () {
        if (SimpleBarCore.rtlHelpers) {
            return SimpleBarCore.rtlHelpers;
        }
        var dummyDiv = document.createElement('div');
        dummyDiv.innerHTML =
            '<div class="simplebar-dummy-scrollbar-size"><div></div></div>';
        var scrollbarDummyEl = dummyDiv.firstElementChild;
        var dummyChild = scrollbarDummyEl === null || scrollbarDummyEl === void 0 ? void 0 : scrollbarDummyEl.firstElementChild;
        if (!dummyChild)
            return null;
        document.body.appendChild(scrollbarDummyEl);
        scrollbarDummyEl.scrollLeft = 0;
        var dummyContainerOffset = SimpleBarCore.getOffset(scrollbarDummyEl);
        var dummyChildOffset = SimpleBarCore.getOffset(dummyChild);
        scrollbarDummyEl.scrollLeft = -999;
        var dummyChildOffsetAfterScroll = SimpleBarCore.getOffset(dummyChild);
        document.body.removeChild(scrollbarDummyEl);
        SimpleBarCore.rtlHelpers = {
            // determines if the scrolling is responding with negative values
            isScrollOriginAtZero: dummyContainerOffset.left !== dummyChildOffset.left,
            // determines if the origin scrollbar position is inverted or not (positioned on left or right)
            isScrollingToNegative: dummyChildOffset.left !== dummyChildOffsetAfterScroll.left
        };
        return SimpleBarCore.rtlHelpers;
    };
    SimpleBarCore.prototype.getScrollbarWidth = function () {
        // Try/catch for FF 56 throwing on undefined computedStyles
        try {
            // Detect browsers supporting CSS scrollbar styling and do not calculate
            if ((this.contentWrapperEl &&
                getComputedStyle(this.contentWrapperEl, '::-webkit-scrollbar')
                    .display === 'none') ||
                'scrollbarWidth' in document.documentElement.style ||
                '-ms-overflow-style' in document.documentElement.style) {
                return 0;
            }
            else {
                return scrollbarWidth();
            }
        }
        catch (e) {
            return scrollbarWidth();
        }
    };
    SimpleBarCore.getOffset = function (el) {
        var rect = el.getBoundingClientRect();
        var elDocument = getElementDocument(el);
        var elWindow = getElementWindow(el);
        return {
            top: rect.top +
                (elWindow.pageYOffset || elDocument.documentElement.scrollTop),
            left: rect.left +
                (elWindow.pageXOffset || elDocument.documentElement.scrollLeft)
        };
    };
    SimpleBarCore.prototype.init = function () {
        // We stop here on server-side
        if (canUseDOM) {
            this.initDOM();
            this.rtlHelpers = SimpleBarCore.getRtlHelpers();
            this.scrollbarWidth = this.getScrollbarWidth();
            this.recalculate();
            this.initListeners();
        }
    };
    SimpleBarCore.prototype.initDOM = function () {
        var _a, _b;
        // assume that element has his DOM already initiated
        this.wrapperEl = this.el.querySelector(classNamesToQuery(this.classNames.wrapper));
        this.contentWrapperEl =
            this.options.scrollableNode ||
                this.el.querySelector(classNamesToQuery(this.classNames.contentWrapper));
        this.contentEl =
            this.options.contentNode ||
                this.el.querySelector(classNamesToQuery(this.classNames.contentEl));
        this.offsetEl = this.el.querySelector(classNamesToQuery(this.classNames.offset));
        this.maskEl = this.el.querySelector(classNamesToQuery(this.classNames.mask));
        this.placeholderEl = this.findChild(this.wrapperEl, classNamesToQuery(this.classNames.placeholder));
        this.heightAutoObserverWrapperEl = this.el.querySelector(classNamesToQuery(this.classNames.heightAutoObserverWrapperEl));
        this.heightAutoObserverEl = this.el.querySelector(classNamesToQuery(this.classNames.heightAutoObserverEl));
        this.axis.x.track.el = this.findChild(this.el, "".concat(classNamesToQuery(this.classNames.track)).concat(classNamesToQuery(this.classNames.horizontal)));
        this.axis.y.track.el = this.findChild(this.el, "".concat(classNamesToQuery(this.classNames.track)).concat(classNamesToQuery(this.classNames.vertical)));
        this.axis.x.scrollbar.el =
            ((_a = this.axis.x.track.el) === null || _a === void 0 ? void 0 : _a.querySelector(classNamesToQuery(this.classNames.scrollbar))) || null;
        this.axis.y.scrollbar.el =
            ((_b = this.axis.y.track.el) === null || _b === void 0 ? void 0 : _b.querySelector(classNamesToQuery(this.classNames.scrollbar))) || null;
        if (!this.options.autoHide) {
            addClasses(this.axis.x.scrollbar.el, this.classNames.visible);
            addClasses(this.axis.y.scrollbar.el, this.classNames.visible);
        }
    };
    SimpleBarCore.prototype.initListeners = function () {
        var _this = this;
        var _a;
        var elWindow = getElementWindow(this.el);
        // Event listeners
        this.el.addEventListener('mouseenter', this.onMouseEnter);
        this.el.addEventListener('pointerdown', this.onPointerEvent, true);
        this.el.addEventListener('mousemove', this.onMouseMove);
        this.el.addEventListener('mouseleave', this.onMouseLeave);
        (_a = this.contentWrapperEl) === null || _a === void 0 ? void 0 : _a.addEventListener('scroll', this.onScroll);
        // Browser zoom triggers a window resize
        elWindow.addEventListener('resize', this.onWindowResize);
        if (!this.contentEl)
            return;
        if (window.ResizeObserver) {
            // Hack for https://github.com/WICG/ResizeObserver/issues/38
            var resizeObserverStarted_1 = false;
            var resizeObserver = elWindow.ResizeObserver || ResizeObserver;
            this.resizeObserver = new resizeObserver(function () {
                if (!resizeObserverStarted_1)
                    return;
                elWindow.requestAnimationFrame(function () {
                    _this.recalculate();
                });
            });
            this.resizeObserver.observe(this.el);
            this.resizeObserver.observe(this.contentEl);
            elWindow.requestAnimationFrame(function () {
                resizeObserverStarted_1 = true;
            });
        }
        // This is required to detect horizontal scroll. Vertical scroll only needs the resizeObserver.
        this.mutationObserver = new elWindow.MutationObserver(function () {
            elWindow.requestAnimationFrame(function () {
                _this.recalculate();
            });
        });
        this.mutationObserver.observe(this.contentEl, {
            childList: true,
            subtree: true,
            characterData: true
        });
    };
    SimpleBarCore.prototype.recalculate = function () {
        if (!this.heightAutoObserverEl ||
            !this.contentEl ||
            !this.contentWrapperEl ||
            !this.wrapperEl ||
            !this.placeholderEl)
            return;
        var elWindow = getElementWindow(this.el);
        this.elStyles = elWindow.getComputedStyle(this.el);
        this.isRtl = this.elStyles.direction === 'rtl';
        var contentElOffsetWidth = this.contentEl.offsetWidth;
        var isHeightAuto = this.heightAutoObserverEl.offsetHeight <= 1;
        var isWidthAuto = this.heightAutoObserverEl.offsetWidth <= 1 || contentElOffsetWidth > 0;
        var contentWrapperElOffsetWidth = this.contentWrapperEl.offsetWidth;
        var elOverflowX = this.elStyles.overflowX;
        var elOverflowY = this.elStyles.overflowY;
        this.contentEl.style.padding = "".concat(this.elStyles.paddingTop, " ").concat(this.elStyles.paddingRight, " ").concat(this.elStyles.paddingBottom, " ").concat(this.elStyles.paddingLeft);
        this.wrapperEl.style.margin = "-".concat(this.elStyles.paddingTop, " -").concat(this.elStyles.paddingRight, " -").concat(this.elStyles.paddingBottom, " -").concat(this.elStyles.paddingLeft);
        var contentElScrollHeight = this.contentEl.scrollHeight;
        var contentElScrollWidth = this.contentEl.scrollWidth;
        this.contentWrapperEl.style.height = isHeightAuto ? 'auto' : '100%';
        // Determine placeholder size
        this.placeholderEl.style.width = isWidthAuto
            ? "".concat(contentElOffsetWidth || contentElScrollWidth, "px")
            : 'auto';
        this.placeholderEl.style.height = "".concat(contentElScrollHeight, "px");
        var contentWrapperElOffsetHeight = this.contentWrapperEl.offsetHeight;
        this.axis.x.isOverflowing =
            contentElOffsetWidth !== 0 && contentElScrollWidth > contentElOffsetWidth;
        this.axis.y.isOverflowing =
            contentElScrollHeight > contentWrapperElOffsetHeight;
        // Set isOverflowing to false if user explicitely set hidden overflow
        this.axis.x.isOverflowing =
            elOverflowX === 'hidden' ? false : this.axis.x.isOverflowing;
        this.axis.y.isOverflowing =
            elOverflowY === 'hidden' ? false : this.axis.y.isOverflowing;
        this.axis.x.forceVisible =
            this.options.forceVisible === 'x' || this.options.forceVisible === true;
        this.axis.y.forceVisible =
            this.options.forceVisible === 'y' || this.options.forceVisible === true;
        this.hideNativeScrollbar();
        // Set isOverflowing to false if scrollbar is not necessary (content is shorter than offset)
        var offsetForXScrollbar = this.axis.x.isOverflowing
            ? this.scrollbarWidth
            : 0;
        var offsetForYScrollbar = this.axis.y.isOverflowing
            ? this.scrollbarWidth
            : 0;
        this.axis.x.isOverflowing =
            this.axis.x.isOverflowing &&
                contentElScrollWidth > contentWrapperElOffsetWidth - offsetForYScrollbar;
        this.axis.y.isOverflowing =
            this.axis.y.isOverflowing &&
                contentElScrollHeight >
                    contentWrapperElOffsetHeight - offsetForXScrollbar;
        this.axis.x.scrollbar.size = this.getScrollbarSize('x');
        this.axis.y.scrollbar.size = this.getScrollbarSize('y');
        if (this.axis.x.scrollbar.el)
            this.axis.x.scrollbar.el.style.width = "".concat(this.axis.x.scrollbar.size, "px");
        if (this.axis.y.scrollbar.el)
            this.axis.y.scrollbar.el.style.height = "".concat(this.axis.y.scrollbar.size, "px");
        this.positionScrollbar('x');
        this.positionScrollbar('y');
        this.toggleTrackVisibility('x');
        this.toggleTrackVisibility('y');
    };
    /**
     * Calculate scrollbar size
     */
    SimpleBarCore.prototype.getScrollbarSize = function (axis) {
        var _a, _b;
        if (axis === void 0) { axis = 'y'; }
        if (!this.axis[axis].isOverflowing || !this.contentEl) {
            return 0;
        }
        var contentSize = this.contentEl[this.axis[axis].scrollSizeAttr];
        var trackSize = (_b = (_a = this.axis[axis].track.el) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetSizeAttr]) !== null && _b !== void 0 ? _b : 0;
        var scrollbarRatio = trackSize / contentSize;
        var scrollbarSize;
        // Calculate new height/position of drag handle.
        scrollbarSize = Math.max(~~(scrollbarRatio * trackSize), this.options.scrollbarMinSize);
        if (this.options.scrollbarMaxSize) {
            scrollbarSize = Math.min(scrollbarSize, this.options.scrollbarMaxSize);
        }
        return scrollbarSize;
    };
    SimpleBarCore.prototype.positionScrollbar = function (axis) {
        var _a, _b, _c;
        if (axis === void 0) { axis = 'y'; }
        var scrollbar = this.axis[axis].scrollbar;
        if (!this.axis[axis].isOverflowing ||
            !this.contentWrapperEl ||
            !scrollbar.el ||
            !this.elStyles) {
            return;
        }
        var contentSize = this.contentWrapperEl[this.axis[axis].scrollSizeAttr];
        var trackSize = ((_a = this.axis[axis].track.el) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetSizeAttr]) || 0;
        var hostSize = parseInt(this.elStyles[this.axis[axis].sizeAttr], 10);
        var scrollOffset = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];
        scrollOffset =
            axis === 'x' &&
                this.isRtl &&
                ((_b = SimpleBarCore.getRtlHelpers()) === null || _b === void 0 ? void 0 : _b.isScrollOriginAtZero)
                ? -scrollOffset
                : scrollOffset;
        if (axis === 'x' && this.isRtl) {
            scrollOffset = ((_c = SimpleBarCore.getRtlHelpers()) === null || _c === void 0 ? void 0 : _c.isScrollingToNegative)
                ? scrollOffset
                : -scrollOffset;
        }
        var scrollPourcent = scrollOffset / (contentSize - hostSize);
        var handleOffset = ~~((trackSize - scrollbar.size) * scrollPourcent);
        handleOffset =
            axis === 'x' && this.isRtl
                ? -handleOffset + (trackSize - scrollbar.size)
                : handleOffset;
        scrollbar.el.style.transform =
            axis === 'x'
                ? "translate3d(".concat(handleOffset, "px, 0, 0)")
                : "translate3d(0, ".concat(handleOffset, "px, 0)");
    };
    SimpleBarCore.prototype.toggleTrackVisibility = function (axis) {
        if (axis === void 0) { axis = 'y'; }
        var track = this.axis[axis].track.el;
        var scrollbar = this.axis[axis].scrollbar.el;
        if (!track || !scrollbar || !this.contentWrapperEl)
            return;
        if (this.axis[axis].isOverflowing || this.axis[axis].forceVisible) {
            track.style.visibility = 'visible';
            this.contentWrapperEl.style[this.axis[axis].overflowAttr] = 'scroll';
            this.el.classList.add("".concat(this.classNames.scrollable, "-").concat(axis));
        }
        else {
            track.style.visibility = 'hidden';
            this.contentWrapperEl.style[this.axis[axis].overflowAttr] = 'hidden';
            this.el.classList.remove("".concat(this.classNames.scrollable, "-").concat(axis));
        }
        // Even if forceVisible is enabled, scrollbar itself should be hidden
        if (this.axis[axis].isOverflowing) {
            scrollbar.style.display = 'block';
        }
        else {
            scrollbar.style.display = 'none';
        }
    };
    SimpleBarCore.prototype.showScrollbar = function (axis) {
        if (axis === void 0) { axis = 'y'; }
        if (this.axis[axis].isOverflowing && !this.axis[axis].scrollbar.isVisible) {
            addClasses(this.axis[axis].scrollbar.el, this.classNames.visible);
            this.axis[axis].scrollbar.isVisible = true;
        }
    };
    SimpleBarCore.prototype.hideScrollbar = function (axis) {
        if (axis === void 0) { axis = 'y'; }
        if (this.isDragging)
            return;
        if (this.axis[axis].isOverflowing && this.axis[axis].scrollbar.isVisible) {
            removeClasses(this.axis[axis].scrollbar.el, this.classNames.visible);
            this.axis[axis].scrollbar.isVisible = false;
        }
    };
    SimpleBarCore.prototype.hideNativeScrollbar = function () {
        if (!this.offsetEl)
            return;
        this.offsetEl.style[this.isRtl ? 'left' : 'right'] =
            this.axis.y.isOverflowing || this.axis.y.forceVisible
                ? "-".concat(this.scrollbarWidth, "px")
                : '0px';
        this.offsetEl.style.bottom =
            this.axis.x.isOverflowing || this.axis.x.forceVisible
                ? "-".concat(this.scrollbarWidth, "px")
                : '0px';
    };
    SimpleBarCore.prototype.onMouseMoveForAxis = function (axis) {
        if (axis === void 0) { axis = 'y'; }
        var currentAxis = this.axis[axis];
        if (!currentAxis.track.el || !currentAxis.scrollbar.el)
            return;
        currentAxis.track.rect = currentAxis.track.el.getBoundingClientRect();
        currentAxis.scrollbar.rect =
            currentAxis.scrollbar.el.getBoundingClientRect();
        if (this.isWithinBounds(currentAxis.track.rect)) {
            this.showScrollbar(axis);
            addClasses(currentAxis.track.el, this.classNames.hover);
            if (this.isWithinBounds(currentAxis.scrollbar.rect)) {
                addClasses(currentAxis.scrollbar.el, this.classNames.hover);
            }
            else {
                removeClasses(currentAxis.scrollbar.el, this.classNames.hover);
            }
        }
        else {
            removeClasses(currentAxis.track.el, this.classNames.hover);
            if (this.options.autoHide) {
                this.hideScrollbar(axis);
            }
        }
    };
    SimpleBarCore.prototype.onMouseLeaveForAxis = function (axis) {
        if (axis === void 0) { axis = 'y'; }
        removeClasses(this.axis[axis].track.el, this.classNames.hover);
        removeClasses(this.axis[axis].scrollbar.el, this.classNames.hover);
        if (this.options.autoHide) {
            this.hideScrollbar(axis);
        }
    };
    /**
     * on scrollbar handle drag movement starts
     */
    SimpleBarCore.prototype.onDragStart = function (e, axis) {
        var _a;
        if (axis === void 0) { axis = 'y'; }
        this.isDragging = true;
        var elDocument = getElementDocument(this.el);
        var elWindow = getElementWindow(this.el);
        var scrollbar = this.axis[axis].scrollbar;
        // Measure how far the user's mouse is from the top of the scrollbar drag handle.
        var eventOffset = axis === 'y' ? e.pageY : e.pageX;
        this.axis[axis].dragOffset =
            eventOffset - (((_a = scrollbar.rect) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetAttr]) || 0);
        this.draggedAxis = axis;
        addClasses(this.el, this.classNames.dragging);
        elDocument.addEventListener('mousemove', this.drag, true);
        elDocument.addEventListener('mouseup', this.onEndDrag, true);
        if (this.removePreventClickId === null) {
            elDocument.addEventListener('click', this.preventClick, true);
            elDocument.addEventListener('dblclick', this.preventClick, true);
        }
        else {
            elWindow.clearTimeout(this.removePreventClickId);
            this.removePreventClickId = null;
        }
    };
    SimpleBarCore.prototype.onTrackClick = function (e, axis) {
        var _this = this;
        var _a, _b, _c, _d;
        if (axis === void 0) { axis = 'y'; }
        var currentAxis = this.axis[axis];
        if (!this.options.clickOnTrack ||
            !currentAxis.scrollbar.el ||
            !this.contentWrapperEl)
            return;
        // Preventing the event's default to trigger click underneath
        e.preventDefault();
        var elWindow = getElementWindow(this.el);
        this.axis[axis].scrollbar.rect =
            currentAxis.scrollbar.el.getBoundingClientRect();
        var scrollbar = this.axis[axis].scrollbar;
        var scrollbarOffset = (_b = (_a = scrollbar.rect) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetAttr]) !== null && _b !== void 0 ? _b : 0;
        var hostSize = parseInt((_d = (_c = this.elStyles) === null || _c === void 0 ? void 0 : _c[this.axis[axis].sizeAttr]) !== null && _d !== void 0 ? _d : '0px', 10);
        var scrolled = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];
        var t = axis === 'y'
            ? this.mouseY - scrollbarOffset
            : this.mouseX - scrollbarOffset;
        var dir = t < 0 ? -1 : 1;
        var scrollSize = dir === -1 ? scrolled - hostSize : scrolled + hostSize;
        var speed = 40;
        var scrollTo = function () {
            if (!_this.contentWrapperEl)
                return;
            if (dir === -1) {
                if (scrolled > scrollSize) {
                    scrolled -= speed;
                    _this.contentWrapperEl[_this.axis[axis].scrollOffsetAttr] = scrolled;
                    elWindow.requestAnimationFrame(scrollTo);
                }
            }
            else {
                if (scrolled < scrollSize) {
                    scrolled += speed;
                    _this.contentWrapperEl[_this.axis[axis].scrollOffsetAttr] = scrolled;
                    elWindow.requestAnimationFrame(scrollTo);
                }
            }
        };
        scrollTo();
    };
    /**
     * Getter for content element
     */
    SimpleBarCore.prototype.getContentElement = function () {
        return this.contentEl;
    };
    /**
     * Getter for original scrolling element
     */
    SimpleBarCore.prototype.getScrollElement = function () {
        return this.contentWrapperEl;
    };
    SimpleBarCore.prototype.removeListeners = function () {
        var elWindow = getElementWindow(this.el);
        // Event listeners
        this.el.removeEventListener('mouseenter', this.onMouseEnter);
        this.el.removeEventListener('pointerdown', this.onPointerEvent, true);
        this.el.removeEventListener('mousemove', this.onMouseMove);
        this.el.removeEventListener('mouseleave', this.onMouseLeave);
        if (this.contentWrapperEl) {
            this.contentWrapperEl.removeEventListener('scroll', this.onScroll);
        }
        elWindow.removeEventListener('resize', this.onWindowResize);
        if (this.mutationObserver) {
            this.mutationObserver.disconnect();
        }
        if (this.resizeObserver) {
            this.resizeObserver.disconnect();
        }
        // Cancel all debounced functions
        this.onMouseMove.cancel();
        this.onWindowResize.cancel();
        this.onStopScrolling.cancel();
        this.onMouseEntered.cancel();
    };
    /**
     * Remove all listeners from DOM nodes
     */
    SimpleBarCore.prototype.unMount = function () {
        this.removeListeners();
    };
    /**
     * Check if mouse is within bounds
     */
    SimpleBarCore.prototype.isWithinBounds = function (bbox) {
        return (this.mouseX >= bbox.left &&
            this.mouseX <= bbox.left + bbox.width &&
            this.mouseY >= bbox.top &&
            this.mouseY <= bbox.top + bbox.height);
    };
    /**
     * Find element children matches query
     */
    SimpleBarCore.prototype.findChild = function (el, query) {
        var matches = el.matches ||
            el.webkitMatchesSelector ||
            el.mozMatchesSelector ||
            el.msMatchesSelector;
        return Array.prototype.filter.call(el.children, function (child) {
            return matches.call(child, query);
        })[0];
    };
    SimpleBarCore.rtlHelpers = null;
    SimpleBarCore.defaultOptions = {
        forceVisible: false,
        clickOnTrack: true,
        scrollbarMinSize: 25,
        scrollbarMaxSize: 0,
        ariaLabel: 'scrollable content',
        tabIndex: 0,
        classNames: {
            contentEl: 'simplebar-content',
            contentWrapper: 'simplebar-content-wrapper',
            offset: 'simplebar-offset',
            mask: 'simplebar-mask',
            wrapper: 'simplebar-wrapper',
            placeholder: 'simplebar-placeholder',
            scrollbar: 'simplebar-scrollbar',
            track: 'simplebar-track',
            heightAutoObserverWrapperEl: 'simplebar-height-auto-observer-wrapper',
            heightAutoObserverEl: 'simplebar-height-auto-observer',
            visible: 'simplebar-visible',
            horizontal: 'simplebar-horizontal',
            vertical: 'simplebar-vertical',
            hover: 'simplebar-hover',
            dragging: 'simplebar-dragging',
            scrolling: 'simplebar-scrolling',
            scrollable: 'simplebar-scrollable',
            mouseEntered: 'simplebar-mouse-entered'
        },
        scrollableNode: null,
        contentNode: null,
        autoHide: true
    };
    /**
     * Static functions
     */
    SimpleBarCore.getOptions = getOptions;
    SimpleBarCore.helpers = helpers;
    return SimpleBarCore;
}());


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/simplebar/dist/index.mjs":
/*!***********************************************!*\
  !*** ./node_modules/simplebar/dist/index.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SimpleBar)
/* harmony export */ });
/* harmony import */ var simplebar_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! simplebar-core */ "./node_modules/simplebar-core/dist/index.mjs");
/**
 * simplebar - v6.2.7
 * Scrollbars, simpler.
 * https://grsmto.github.io/simplebar/
 *
 * Made by Adrien Denat from a fork by Jonathan Nicol
 * Under MIT License
 */



/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var _a = simplebar_core__WEBPACK_IMPORTED_MODULE_0__["default"].helpers, getOptions = _a.getOptions, addClasses = _a.addClasses, canUseDOM = _a.canUseDOM;
var SimpleBar = /** @class */ (function (_super) {
    __extends(SimpleBar, _super);
    function SimpleBar() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var _this = _super.apply(this, args) || this;
        // // Save a reference to the instance, so we know this DOM node has already been instancied
        SimpleBar.instances.set(args[0], _this);
        return _this;
    }
    SimpleBar.initDOMLoadedElements = function () {
        document.removeEventListener('DOMContentLoaded', this.initDOMLoadedElements);
        window.removeEventListener('load', this.initDOMLoadedElements);
        Array.prototype.forEach.call(document.querySelectorAll('[data-simplebar]'), function (el) {
            if (el.getAttribute('data-simplebar') !== 'init' &&
                !SimpleBar.instances.has(el))
                new SimpleBar(el, getOptions(el.attributes));
        });
    };
    SimpleBar.removeObserver = function () {
        var _a;
        (_a = SimpleBar.globalObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    };
    SimpleBar.prototype.initDOM = function () {
        var _this = this;
        var _a, _b, _c;
        // make sure this element doesn't have the elements yet
        if (!Array.prototype.filter.call(this.el.children, function (child) {
            return child.classList.contains(_this.classNames.wrapper);
        }).length) {
            // Prepare DOM
            this.wrapperEl = document.createElement('div');
            this.contentWrapperEl = document.createElement('div');
            this.offsetEl = document.createElement('div');
            this.maskEl = document.createElement('div');
            this.contentEl = document.createElement('div');
            this.placeholderEl = document.createElement('div');
            this.heightAutoObserverWrapperEl = document.createElement('div');
            this.heightAutoObserverEl = document.createElement('div');
            addClasses(this.wrapperEl, this.classNames.wrapper);
            addClasses(this.contentWrapperEl, this.classNames.contentWrapper);
            addClasses(this.offsetEl, this.classNames.offset);
            addClasses(this.maskEl, this.classNames.mask);
            addClasses(this.contentEl, this.classNames.contentEl);
            addClasses(this.placeholderEl, this.classNames.placeholder);
            addClasses(this.heightAutoObserverWrapperEl, this.classNames.heightAutoObserverWrapperEl);
            addClasses(this.heightAutoObserverEl, this.classNames.heightAutoObserverEl);
            while (this.el.firstChild) {
                this.contentEl.appendChild(this.el.firstChild);
            }
            this.contentWrapperEl.appendChild(this.contentEl);
            this.offsetEl.appendChild(this.contentWrapperEl);
            this.maskEl.appendChild(this.offsetEl);
            this.heightAutoObserverWrapperEl.appendChild(this.heightAutoObserverEl);
            this.wrapperEl.appendChild(this.heightAutoObserverWrapperEl);
            this.wrapperEl.appendChild(this.maskEl);
            this.wrapperEl.appendChild(this.placeholderEl);
            this.el.appendChild(this.wrapperEl);
            (_a = this.contentWrapperEl) === null || _a === void 0 ? void 0 : _a.setAttribute('tabindex', this.options.tabIndex.toString());
            (_b = this.contentWrapperEl) === null || _b === void 0 ? void 0 : _b.setAttribute('role', 'region');
            (_c = this.contentWrapperEl) === null || _c === void 0 ? void 0 : _c.setAttribute('aria-label', this.options.ariaLabel);
        }
        if (!this.axis.x.track.el || !this.axis.y.track.el) {
            var track = document.createElement('div');
            var scrollbar = document.createElement('div');
            addClasses(track, this.classNames.track);
            addClasses(scrollbar, this.classNames.scrollbar);
            track.appendChild(scrollbar);
            this.axis.x.track.el = track.cloneNode(true);
            addClasses(this.axis.x.track.el, this.classNames.horizontal);
            this.axis.y.track.el = track.cloneNode(true);
            addClasses(this.axis.y.track.el, this.classNames.vertical);
            this.el.appendChild(this.axis.x.track.el);
            this.el.appendChild(this.axis.y.track.el);
        }
        simplebar_core__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.initDOM.call(this);
        this.el.setAttribute('data-simplebar', 'init');
    };
    SimpleBar.prototype.unMount = function () {
        simplebar_core__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.unMount.call(this);
        SimpleBar.instances["delete"](this.el);
    };
    SimpleBar.initHtmlApi = function () {
        this.initDOMLoadedElements = this.initDOMLoadedElements.bind(this);
        // MutationObserver is IE11+
        if (typeof MutationObserver !== 'undefined') {
            // Mutation observer to observe dynamically added elements
            this.globalObserver = new MutationObserver(SimpleBar.handleMutations);
            this.globalObserver.observe(document, { childList: true, subtree: true });
        }
        // Taken from jQuery `ready` function
        // Instantiate elements already present on the page
        if (document.readyState === 'complete' || // @ts-ignore: IE specific
            (document.readyState !== 'loading' && !document.documentElement.doScroll)) {
            // Handle it asynchronously to allow scripts the opportunity to delay init
            window.setTimeout(this.initDOMLoadedElements);
        }
        else {
            document.addEventListener('DOMContentLoaded', this.initDOMLoadedElements);
            window.addEventListener('load', this.initDOMLoadedElements);
        }
    };
    SimpleBar.handleMutations = function (mutations) {
        mutations.forEach(function (mutation) {
            mutation.addedNodes.forEach(function (addedNode) {
                if (addedNode.nodeType === 1) {
                    if (addedNode.hasAttribute('data-simplebar')) {
                        !SimpleBar.instances.has(addedNode) &&
                            document.documentElement.contains(addedNode) &&
                            new SimpleBar(addedNode, getOptions(addedNode.attributes));
                    }
                    else {
                        addedNode
                            .querySelectorAll('[data-simplebar]')
                            .forEach(function (el) {
                            if (el.getAttribute('data-simplebar') !== 'init' &&
                                !SimpleBar.instances.has(el) &&
                                document.documentElement.contains(el))
                                new SimpleBar(el, getOptions(el.attributes));
                        });
                    }
                }
            });
            mutation.removedNodes.forEach(function (removedNode) {
                var _a;
                if (removedNode.nodeType === 1) {
                    if (removedNode.getAttribute('data-simplebar') === 'init') {
                        !document.documentElement.contains(removedNode) &&
                            ((_a = SimpleBar.instances.get(removedNode)) === null || _a === void 0 ? void 0 : _a.unMount());
                    }
                    else {
                        Array.prototype.forEach.call(removedNode.querySelectorAll('[data-simplebar="init"]'), function (el) {
                            var _a;
                            !document.documentElement.contains(el) &&
                                ((_a = SimpleBar.instances.get(el)) === null || _a === void 0 ? void 0 : _a.unMount());
                        });
                    }
                }
            });
        });
    };
    SimpleBar.instances = new WeakMap();
    return SimpleBar;
}(simplebar_core__WEBPACK_IMPORTED_MODULE_0__["default"]));
/**
 * HTML API
 * Called only in a browser env.
 */
if (canUseDOM) {
    SimpleBar.initHtmlApi();
}


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/swiper/modules/a11y.mjs":
/*!**********************************************!*\
  !*** ./node_modules/swiper/modules/a11y.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ A11y)
/* harmony export */ });
/* harmony import */ var _shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/ssr-window.esm.mjs */ "./node_modules/swiper/shared/ssr-window.esm.mjs");
/* harmony import */ var _shared_classes_to_selector_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/classes-to-selector.mjs */ "./node_modules/swiper/shared/classes-to-selector.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");




function A11y(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    a11y: {
      enabled: true,
      notificationClass: 'swiper-notification',
      prevSlideMessage: 'Previous slide',
      nextSlideMessage: 'Next slide',
      firstSlideMessage: 'This is the first slide',
      lastSlideMessage: 'This is the last slide',
      paginationBulletMessage: 'Go to slide {{index}}',
      slideLabelMessage: '{{index}} / {{slidesLength}}',
      containerMessage: null,
      containerRoleDescriptionMessage: null,
      containerRole: null,
      itemRoleDescriptionMessage: null,
      slideRole: 'group',
      id: null,
      scrollOnFocus: true
    }
  });
  swiper.a11y = {
    clicked: false
  };
  let liveRegion = null;
  let preventFocusHandler;
  let focusTargetSlideEl;
  let visibilityChangedTimestamp = new Date().getTime();
  function notify(message) {
    const notification = liveRegion;
    if (notification.length === 0) return;
    notification.innerHTML = '';
    notification.innerHTML = message;
  }
  function getRandomNumber(size) {
    if (size === void 0) {
      size = 16;
    }
    const randomChar = () => Math.round(16 * Math.random()).toString(16);
    return 'x'.repeat(size).replace(/x/g, randomChar);
  }
  function makeElFocusable(el) {
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    el.forEach(subEl => {
      subEl.setAttribute('tabIndex', '0');
    });
  }
  function makeElNotFocusable(el) {
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    el.forEach(subEl => {
      subEl.setAttribute('tabIndex', '-1');
    });
  }
  function addElRole(el, role) {
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    el.forEach(subEl => {
      subEl.setAttribute('role', role);
    });
  }
  function addElRoleDescription(el, description) {
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    el.forEach(subEl => {
      subEl.setAttribute('aria-roledescription', description);
    });
  }
  function addElControls(el, controls) {
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    el.forEach(subEl => {
      subEl.setAttribute('aria-controls', controls);
    });
  }
  function addElLabel(el, label) {
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    el.forEach(subEl => {
      subEl.setAttribute('aria-label', label);
    });
  }
  function addElId(el, id) {
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    el.forEach(subEl => {
      subEl.setAttribute('id', id);
    });
  }
  function addElLive(el, live) {
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    el.forEach(subEl => {
      subEl.setAttribute('aria-live', live);
    });
  }
  function disableEl(el) {
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    el.forEach(subEl => {
      subEl.setAttribute('aria-disabled', true);
    });
  }
  function enableEl(el) {
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    el.forEach(subEl => {
      subEl.setAttribute('aria-disabled', false);
    });
  }
  function onEnterOrSpaceKey(e) {
    if (e.keyCode !== 13 && e.keyCode !== 32) return;
    const params = swiper.params.a11y;
    const targetEl = e.target;
    if (swiper.pagination && swiper.pagination.el && (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))) {
      if (!e.target.matches((0,_shared_classes_to_selector_mjs__WEBPACK_IMPORTED_MODULE_1__.c)(swiper.params.pagination.bulletClass))) return;
    }
    if (swiper.navigation && swiper.navigation.prevEl && swiper.navigation.nextEl) {
      const prevEls = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(swiper.navigation.prevEl);
      const nextEls = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(swiper.navigation.nextEl);
      if (nextEls.includes(targetEl)) {
        if (!(swiper.isEnd && !swiper.params.loop)) {
          swiper.slideNext();
        }
        if (swiper.isEnd) {
          notify(params.lastSlideMessage);
        } else {
          notify(params.nextSlideMessage);
        }
      }
      if (prevEls.includes(targetEl)) {
        if (!(swiper.isBeginning && !swiper.params.loop)) {
          swiper.slidePrev();
        }
        if (swiper.isBeginning) {
          notify(params.firstSlideMessage);
        } else {
          notify(params.prevSlideMessage);
        }
      }
    }
    if (swiper.pagination && targetEl.matches((0,_shared_classes_to_selector_mjs__WEBPACK_IMPORTED_MODULE_1__.c)(swiper.params.pagination.bulletClass))) {
      targetEl.click();
    }
  }
  function updateNavigation() {
    if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;
    const {
      nextEl,
      prevEl
    } = swiper.navigation;
    if (prevEl) {
      if (swiper.isBeginning) {
        disableEl(prevEl);
        makeElNotFocusable(prevEl);
      } else {
        enableEl(prevEl);
        makeElFocusable(prevEl);
      }
    }
    if (nextEl) {
      if (swiper.isEnd) {
        disableEl(nextEl);
        makeElNotFocusable(nextEl);
      } else {
        enableEl(nextEl);
        makeElFocusable(nextEl);
      }
    }
  }
  function hasPagination() {
    return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;
  }
  function hasClickablePagination() {
    return hasPagination() && swiper.params.pagination.clickable;
  }
  function updatePagination() {
    const params = swiper.params.a11y;
    if (!hasPagination()) return;
    swiper.pagination.bullets.forEach(bulletEl => {
      if (swiper.params.pagination.clickable) {
        makeElFocusable(bulletEl);
        if (!swiper.params.pagination.renderBullet) {
          addElRole(bulletEl, 'button');
          addElLabel(bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.h)(bulletEl) + 1));
        }
      }
      if (bulletEl.matches((0,_shared_classes_to_selector_mjs__WEBPACK_IMPORTED_MODULE_1__.c)(swiper.params.pagination.bulletActiveClass))) {
        bulletEl.setAttribute('aria-current', 'true');
      } else {
        bulletEl.removeAttribute('aria-current');
      }
    });
  }
  const initNavEl = (el, wrapperId, message) => {
    makeElFocusable(el);
    if (el.tagName !== 'BUTTON') {
      addElRole(el, 'button');
      el.addEventListener('keydown', onEnterOrSpaceKey);
    }
    addElLabel(el, message);
    addElControls(el, wrapperId);
  };
  const handlePointerDown = e => {
    if (focusTargetSlideEl && focusTargetSlideEl !== e.target && !focusTargetSlideEl.contains(e.target)) {
      preventFocusHandler = true;
    }
    swiper.a11y.clicked = true;
  };
  const handlePointerUp = () => {
    preventFocusHandler = false;
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        if (!swiper.destroyed) {
          swiper.a11y.clicked = false;
        }
      });
    });
  };
  const onVisibilityChange = e => {
    visibilityChangedTimestamp = new Date().getTime();
  };
  const handleFocus = e => {
    if (swiper.a11y.clicked || !swiper.params.a11y.scrollOnFocus) return;
    if (new Date().getTime() - visibilityChangedTimestamp < 100) return;
    const slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
    if (!slideEl || !swiper.slides.includes(slideEl)) return;
    focusTargetSlideEl = slideEl;
    const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;
    const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);
    if (isActive || isVisible) return;
    if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;
    if (swiper.isHorizontal()) {
      swiper.el.scrollLeft = 0;
    } else {
      swiper.el.scrollTop = 0;
    }
    requestAnimationFrame(() => {
      if (preventFocusHandler) return;
      if (swiper.params.loop) {
        swiper.slideToLoop(parseInt(slideEl.getAttribute('data-swiper-slide-index')), 0);
      } else {
        swiper.slideTo(swiper.slides.indexOf(slideEl), 0);
      }
      preventFocusHandler = false;
    });
  };
  const initSlides = () => {
    const params = swiper.params.a11y;
    if (params.itemRoleDescriptionMessage) {
      addElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);
    }
    if (params.slideRole) {
      addElRole(swiper.slides, params.slideRole);
    }
    const slidesLength = swiper.slides.length;
    if (params.slideLabelMessage) {
      swiper.slides.forEach((slideEl, index) => {
        const slideIndex = swiper.params.loop ? parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10) : index;
        const ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
        addElLabel(slideEl, ariaLabelMessage);
      });
    }
  };
  const init = () => {
    const params = swiper.params.a11y;
    swiper.el.append(liveRegion);

    // Container
    const containerEl = swiper.el;
    if (params.containerRoleDescriptionMessage) {
      addElRoleDescription(containerEl, params.containerRoleDescriptionMessage);
    }
    if (params.containerMessage) {
      addElLabel(containerEl, params.containerMessage);
    }
    if (params.containerRole) {
      addElRole(containerEl, params.containerRole);
    }

    // Wrapper
    const wrapperEl = swiper.wrapperEl;
    const wrapperId = params.id || wrapperEl.getAttribute('id') || `swiper-wrapper-${getRandomNumber(16)}`;
    const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';
    addElId(wrapperEl, wrapperId);
    addElLive(wrapperEl, live);

    // Slide
    initSlides();

    // Navigation
    let {
      nextEl,
      prevEl
    } = swiper.navigation ? swiper.navigation : {};
    nextEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(nextEl);
    prevEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(prevEl);
    if (nextEl) {
      nextEl.forEach(el => initNavEl(el, wrapperId, params.nextSlideMessage));
    }
    if (prevEl) {
      prevEl.forEach(el => initNavEl(el, wrapperId, params.prevSlideMessage));
    }

    // Pagination
    if (hasClickablePagination()) {
      const paginationEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(swiper.pagination.el);
      paginationEl.forEach(el => {
        el.addEventListener('keydown', onEnterOrSpaceKey);
      });
    }

    // Tab focus
    const document = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
    document.addEventListener('visibilitychange', onVisibilityChange);
    swiper.el.addEventListener('focus', handleFocus, true);
    swiper.el.addEventListener('focus', handleFocus, true);
    swiper.el.addEventListener('pointerdown', handlePointerDown, true);
    swiper.el.addEventListener('pointerup', handlePointerUp, true);
  };
  function destroy() {
    if (liveRegion) liveRegion.remove();
    let {
      nextEl,
      prevEl
    } = swiper.navigation ? swiper.navigation : {};
    nextEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(nextEl);
    prevEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(prevEl);
    if (nextEl) {
      nextEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));
    }
    if (prevEl) {
      prevEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));
    }

    // Pagination
    if (hasClickablePagination()) {
      const paginationEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(swiper.pagination.el);
      paginationEl.forEach(el => {
        el.removeEventListener('keydown', onEnterOrSpaceKey);
      });
    }
    const document = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
    document.removeEventListener('visibilitychange', onVisibilityChange);
    // Tab focus
    if (swiper.el && typeof swiper.el !== 'string') {
      swiper.el.removeEventListener('focus', handleFocus, true);
      swiper.el.removeEventListener('pointerdown', handlePointerDown, true);
      swiper.el.removeEventListener('pointerup', handlePointerUp, true);
    }
  }
  on('beforeInit', () => {
    liveRegion = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.c)('span', swiper.params.a11y.notificationClass);
    liveRegion.setAttribute('aria-live', 'assertive');
    liveRegion.setAttribute('aria-atomic', 'true');
  });
  on('afterInit', () => {
    if (!swiper.params.a11y.enabled) return;
    init();
  });
  on('slidesLengthChange snapGridLengthChange slidesGridLengthChange', () => {
    if (!swiper.params.a11y.enabled) return;
    initSlides();
  });
  on('fromEdge toEdge afterInit lock unlock', () => {
    if (!swiper.params.a11y.enabled) return;
    updateNavigation();
  });
  on('paginationUpdate', () => {
    if (!swiper.params.a11y.enabled) return;
    updatePagination();
  });
  on('destroy', () => {
    if (!swiper.params.a11y.enabled) return;
    destroy();
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/autoplay.mjs":
/*!**************************************************!*\
  !*** ./node_modules/swiper/modules/autoplay.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Autoplay)
/* harmony export */ });
/* harmony import */ var _shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/ssr-window.esm.mjs */ "./node_modules/swiper/shared/ssr-window.esm.mjs");


/* eslint no-underscore-dangle: "off" */
/* eslint no-use-before-define: "off" */
function Autoplay(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit,
    params
  } = _ref;
  swiper.autoplay = {
    running: false,
    paused: false,
    timeLeft: 0
  };
  extendParams({
    autoplay: {
      enabled: false,
      delay: 3000,
      waitForTransition: true,
      disableOnInteraction: false,
      stopOnLastSlide: false,
      reverseDirection: false,
      pauseOnMouseEnter: false
    }
  });
  let timeout;
  let raf;
  let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3000;
  let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3000;
  let autoplayTimeLeft;
  let autoplayStartTime = new Date().getTime();
  let wasPaused;
  let isTouched;
  let pausedByTouch;
  let touchStartTimeout;
  let slideChanged;
  let pausedByInteraction;
  let pausedByPointerEnter;
  function onTransitionEnd(e) {
    if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;
    if (e.target !== swiper.wrapperEl) return;
    swiper.wrapperEl.removeEventListener('transitionend', onTransitionEnd);
    if (pausedByPointerEnter || e.detail && e.detail.bySwiperTouchMove) {
      return;
    }
    resume();
  }
  const calcTimeLeft = () => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    if (swiper.autoplay.paused) {
      wasPaused = true;
    } else if (wasPaused) {
      autoplayDelayCurrent = autoplayTimeLeft;
      wasPaused = false;
    }
    const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();
    swiper.autoplay.timeLeft = timeLeft;
    emit('autoplayTimeLeft', timeLeft, timeLeft / autoplayDelayTotal);
    raf = requestAnimationFrame(() => {
      calcTimeLeft();
    });
  };
  const getSlideDelay = () => {
    let activeSlideEl;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      activeSlideEl = swiper.slides.filter(slideEl => slideEl.classList.contains('swiper-slide-active'))[0];
    } else {
      activeSlideEl = swiper.slides[swiper.activeIndex];
    }
    if (!activeSlideEl) return undefined;
    const currentSlideDelay = parseInt(activeSlideEl.getAttribute('data-swiper-autoplay'), 10);
    return currentSlideDelay;
  };
  const run = delayForce => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    cancelAnimationFrame(raf);
    calcTimeLeft();
    let delay = typeof delayForce === 'undefined' ? swiper.params.autoplay.delay : delayForce;
    autoplayDelayTotal = swiper.params.autoplay.delay;
    autoplayDelayCurrent = swiper.params.autoplay.delay;
    const currentSlideDelay = getSlideDelay();
    if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === 'undefined') {
      delay = currentSlideDelay;
      autoplayDelayTotal = currentSlideDelay;
      autoplayDelayCurrent = currentSlideDelay;
    }
    autoplayTimeLeft = delay;
    const speed = swiper.params.speed;
    const proceed = () => {
      if (!swiper || swiper.destroyed) return;
      if (swiper.params.autoplay.reverseDirection) {
        if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {
          swiper.slidePrev(speed, true, true);
          emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          swiper.slideTo(swiper.slides.length - 1, speed, true, true);
          emit('autoplay');
        }
      } else {
        if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {
          swiper.slideNext(speed, true, true);
          emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          swiper.slideTo(0, speed, true, true);
          emit('autoplay');
        }
      }
      if (swiper.params.cssMode) {
        autoplayStartTime = new Date().getTime();
        requestAnimationFrame(() => {
          run();
        });
      }
    };
    if (delay > 0) {
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        proceed();
      }, delay);
    } else {
      requestAnimationFrame(() => {
        proceed();
      });
    }

    // eslint-disable-next-line
    return delay;
  };
  const start = () => {
    autoplayStartTime = new Date().getTime();
    swiper.autoplay.running = true;
    run();
    emit('autoplayStart');
  };
  const stop = () => {
    swiper.autoplay.running = false;
    clearTimeout(timeout);
    cancelAnimationFrame(raf);
    emit('autoplayStop');
  };
  const pause = (internal, reset) => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    clearTimeout(timeout);
    if (!internal) {
      pausedByInteraction = true;
    }
    const proceed = () => {
      emit('autoplayPause');
      if (swiper.params.autoplay.waitForTransition) {
        swiper.wrapperEl.addEventListener('transitionend', onTransitionEnd);
      } else {
        resume();
      }
    };
    swiper.autoplay.paused = true;
    if (reset) {
      if (slideChanged) {
        autoplayTimeLeft = swiper.params.autoplay.delay;
      }
      slideChanged = false;
      proceed();
      return;
    }
    const delay = autoplayTimeLeft || swiper.params.autoplay.delay;
    autoplayTimeLeft = delay - (new Date().getTime() - autoplayStartTime);
    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;
    if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;
    proceed();
  };
  const resume = () => {
    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;
    autoplayStartTime = new Date().getTime();
    if (pausedByInteraction) {
      pausedByInteraction = false;
      run(autoplayTimeLeft);
    } else {
      run();
    }
    swiper.autoplay.paused = false;
    emit('autoplayResume');
  };
  const onVisibilityChange = () => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    const document = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
    if (document.visibilityState === 'hidden') {
      pausedByInteraction = true;
      pause(true);
    }
    if (document.visibilityState === 'visible') {
      resume();
    }
  };
  const onPointerEnter = e => {
    if (e.pointerType !== 'mouse') return;
    pausedByInteraction = true;
    pausedByPointerEnter = true;
    if (swiper.animating || swiper.autoplay.paused) return;
    pause(true);
  };
  const onPointerLeave = e => {
    if (e.pointerType !== 'mouse') return;
    pausedByPointerEnter = false;
    if (swiper.autoplay.paused) {
      resume();
    }
  };
  const attachMouseEvents = () => {
    if (swiper.params.autoplay.pauseOnMouseEnter) {
      swiper.el.addEventListener('pointerenter', onPointerEnter);
      swiper.el.addEventListener('pointerleave', onPointerLeave);
    }
  };
  const detachMouseEvents = () => {
    if (swiper.el && typeof swiper.el !== 'string') {
      swiper.el.removeEventListener('pointerenter', onPointerEnter);
      swiper.el.removeEventListener('pointerleave', onPointerLeave);
    }
  };
  const attachDocumentEvents = () => {
    const document = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
    document.addEventListener('visibilitychange', onVisibilityChange);
  };
  const detachDocumentEvents = () => {
    const document = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
    document.removeEventListener('visibilitychange', onVisibilityChange);
  };
  on('init', () => {
    if (swiper.params.autoplay.enabled) {
      attachMouseEvents();
      attachDocumentEvents();
      start();
    }
  });
  on('destroy', () => {
    detachMouseEvents();
    detachDocumentEvents();
    if (swiper.autoplay.running) {
      stop();
    }
  });
  on('_freeModeStaticRelease', () => {
    if (pausedByTouch || pausedByInteraction) {
      resume();
    }
  });
  on('_freeModeNoMomentumRelease', () => {
    if (!swiper.params.autoplay.disableOnInteraction) {
      pause(true, true);
    } else {
      stop();
    }
  });
  on('beforeTransitionStart', (_s, speed, internal) => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    if (internal || !swiper.params.autoplay.disableOnInteraction) {
      pause(true, true);
    } else {
      stop();
    }
  });
  on('sliderFirstMove', () => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    if (swiper.params.autoplay.disableOnInteraction) {
      stop();
      return;
    }
    isTouched = true;
    pausedByTouch = false;
    pausedByInteraction = false;
    touchStartTimeout = setTimeout(() => {
      pausedByInteraction = true;
      pausedByTouch = true;
      pause(true);
    }, 200);
  });
  on('touchEnd', () => {
    if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;
    clearTimeout(touchStartTimeout);
    clearTimeout(timeout);
    if (swiper.params.autoplay.disableOnInteraction) {
      pausedByTouch = false;
      isTouched = false;
      return;
    }
    if (pausedByTouch && swiper.params.cssMode) resume();
    pausedByTouch = false;
    isTouched = false;
  });
  on('slideChange', () => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    slideChanged = true;
  });
  Object.assign(swiper.autoplay, {
    start,
    stop,
    pause,
    resume
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/controller.mjs":
/*!****************************************************!*\
  !*** ./node_modules/swiper/modules/controller.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Controller)
/* harmony export */ });
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");


/* eslint no-bitwise: ["error", { "allow": [">>"] }] */
function Controller(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    controller: {
      control: undefined,
      inverse: false,
      by: 'slide' // or 'container'
    }
  });

  swiper.controller = {
    control: undefined
  };
  function LinearSpline(x, y) {
    const binarySearch = function search() {
      let maxIndex;
      let minIndex;
      let guess;
      return (array, val) => {
        minIndex = -1;
        maxIndex = array.length;
        while (maxIndex - minIndex > 1) {
          guess = maxIndex + minIndex >> 1;
          if (array[guess] <= val) {
            minIndex = guess;
          } else {
            maxIndex = guess;
          }
        }
        return maxIndex;
      };
    }();
    this.x = x;
    this.y = y;
    this.lastIndex = x.length - 1;
    // Given an x value (x2), return the expected y2 value:
    // (x1,y1) is the known point before given value,
    // (x3,y3) is the known point after given value.
    let i1;
    let i3;
    this.interpolate = function interpolate(x2) {
      if (!x2) return 0;

      // Get the indexes of x1 and x3 (the array indexes before and after given x2):
      i3 = binarySearch(this.x, x2);
      i1 = i3 - 1;

      // We have our indexes i1 & i3, so we can calculate already:
      // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1
      return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
    };
    return this;
  }
  function getInterpolateFunction(c) {
    swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);
  }
  function setTranslate(_t, byController) {
    const controlled = swiper.controller.control;
    let multiplier;
    let controlledTranslate;
    const Swiper = swiper.constructor;
    function setControlledTranslate(c) {
      if (c.destroyed) return;

      // this will create an Interpolate function based on the snapGrids
      // x is the Grid of the scrolled scroller and y will be the controlled scroller
      // it makes sense to create this only once and recall it for the interpolation
      // the function does a lot of value caching for performance
      const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
      if (swiper.params.controller.by === 'slide') {
        getInterpolateFunction(c);
        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
        // but it did not work out
        controlledTranslate = -swiper.controller.spline.interpolate(-translate);
      }
      if (!controlledTranslate || swiper.params.controller.by === 'container') {
        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
        if (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) {
          multiplier = 1;
        }
        controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
      }
      if (swiper.params.controller.inverse) {
        controlledTranslate = c.maxTranslate() - controlledTranslate;
      }
      c.updateProgress(controlledTranslate);
      c.setTranslate(controlledTranslate, swiper);
      c.updateActiveIndex();
      c.updateSlidesClasses();
    }
    if (Array.isArray(controlled)) {
      for (let i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTranslate(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTranslate(controlled);
    }
  }
  function setTransition(duration, byController) {
    const Swiper = swiper.constructor;
    const controlled = swiper.controller.control;
    let i;
    function setControlledTransition(c) {
      if (c.destroyed) return;
      c.setTransition(duration, swiper);
      if (duration !== 0) {
        c.transitionStart();
        if (c.params.autoHeight) {
          (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.n)(() => {
            c.updateAutoHeight();
          });
        }
        (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(c.wrapperEl, () => {
          if (!controlled) return;
          c.transitionEnd();
        });
      }
    }
    if (Array.isArray(controlled)) {
      for (i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTransition(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTransition(controlled);
    }
  }
  function removeSpline() {
    if (!swiper.controller.control) return;
    if (swiper.controller.spline) {
      swiper.controller.spline = undefined;
      delete swiper.controller.spline;
    }
  }
  on('beforeInit', () => {
    if (typeof window !== 'undefined' && (
    // eslint-disable-line
    typeof swiper.params.controller.control === 'string' || swiper.params.controller.control instanceof HTMLElement)) {
      const controlElements = typeof swiper.params.controller.control === 'string' ? [...document.querySelectorAll(swiper.params.controller.control)] : [swiper.params.controller.control];
      controlElements.forEach(controlElement => {
        if (!swiper.controller.control) swiper.controller.control = [];
        if (controlElement && controlElement.swiper) {
          swiper.controller.control.push(controlElement.swiper);
        } else if (controlElement) {
          const eventName = `${swiper.params.eventsPrefix}init`;
          const onControllerSwiper = e => {
            swiper.controller.control.push(e.detail[0]);
            swiper.update();
            controlElement.removeEventListener(eventName, onControllerSwiper);
          };
          controlElement.addEventListener(eventName, onControllerSwiper);
        }
      });
      return;
    }
    swiper.controller.control = swiper.params.controller.control;
  });
  on('update', () => {
    removeSpline();
  });
  on('resize', () => {
    removeSpline();
  });
  on('observerUpdate', () => {
    removeSpline();
  });
  on('setTranslate', (_s, translate, byController) => {
    if (!swiper.controller.control || swiper.controller.control.destroyed) return;
    swiper.controller.setTranslate(translate, byController);
  });
  on('setTransition', (_s, duration, byController) => {
    if (!swiper.controller.control || swiper.controller.control.destroyed) return;
    swiper.controller.setTransition(duration, byController);
  });
  Object.assign(swiper.controller, {
    setTranslate,
    setTransition
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/effect-cards.mjs":
/*!******************************************************!*\
  !*** ./node_modules/swiper/modules/effect-cards.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectCards)
/* harmony export */ });
/* harmony import */ var _shared_create_shadow_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/create-shadow.mjs */ "./node_modules/swiper/shared/create-shadow.mjs");
/* harmony import */ var _shared_effect_init_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/effect-init.mjs */ "./node_modules/swiper/shared/effect-init.mjs");
/* harmony import */ var _shared_effect_target_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/effect-target.mjs */ "./node_modules/swiper/shared/effect-target.mjs");
/* harmony import */ var _shared_effect_virtual_transition_end_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/effect-virtual-transition-end.mjs */ "./node_modules/swiper/shared/effect-virtual-transition-end.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");






function EffectCards(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    cardsEffect: {
      slideShadows: true,
      rotate: true,
      perSlideRotate: 2,
      perSlideOffset: 8
    }
  });
  const setTranslate = () => {
    const {
      slides,
      activeIndex,
      rtlTranslate: rtl
    } = swiper;
    const params = swiper.params.cardsEffect;
    const {
      startTranslate,
      isTouched
    } = swiper.touchEventsData;
    const currentTranslate = rtl ? -swiper.translate : swiper.translate;
    for (let i = 0; i < slides.length; i += 1) {
      const slideEl = slides[i];
      const slideProgress = slideEl.progress;
      const progress = Math.min(Math.max(slideProgress, -4), 4);
      let offset = slideEl.swiperSlideOffset;
      if (swiper.params.centeredSlides && !swiper.params.cssMode) {
        swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;
      }
      if (swiper.params.centeredSlides && swiper.params.cssMode) {
        offset -= slides[0].swiperSlideOffset;
      }
      let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;
      let tY = 0;
      const tZ = -100 * Math.abs(progress);
      let scale = 1;
      let rotate = -params.perSlideRotate * progress;
      let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;
      const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;
      const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;
      const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;
      if (isSwipeToNext || isSwipeToPrev) {
        const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;
        rotate += -28 * progress * subProgress;
        scale += -0.5 * subProgress;
        tXAdd += 96 * subProgress;
        tY = `${-25 * subProgress * Math.abs(progress)}%`;
      }
      if (progress < 0) {
        // next
        tX = `calc(${tX}px ${rtl ? '-' : '+'} (${tXAdd * Math.abs(progress)}%))`;
      } else if (progress > 0) {
        // prev
        tX = `calc(${tX}px ${rtl ? '-' : '+'} (-${tXAdd * Math.abs(progress)}%))`;
      } else {
        tX = `${tX}px`;
      }
      if (!swiper.isHorizontal()) {
        const prevY = tY;
        tY = tX;
        tX = prevY;
      }
      const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;

      /* eslint-disable */
      const transform = `
        translate3d(${tX}, ${tY}, ${tZ}px)
        rotateZ(${params.rotate ? rtl ? -rotate : rotate : 0}deg)
        scale(${scaleString})
      `;
      /* eslint-enable */

      if (params.slideShadows) {
        // Set shadows
        let shadowEl = slideEl.querySelector('.swiper-slide-shadow');
        if (!shadowEl) {
          shadowEl = (0,_shared_create_shadow_mjs__WEBPACK_IMPORTED_MODULE_0__.c)('cards', slideEl);
        }
        if (shadowEl) shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);
      }
      slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
      const targetEl = (0,_shared_effect_target_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(params, slideEl);
      targetEl.style.transform = transform;
    }
  };
  const setTransition = duration => {
    const transformElements = swiper.slides.map(slideEl => (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_4__.g)(slideEl));
    transformElements.forEach(el => {
      el.style.transitionDuration = `${duration}ms`;
      el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {
        shadowEl.style.transitionDuration = `${duration}ms`;
      });
    });
    (0,_shared_effect_virtual_transition_end_mjs__WEBPACK_IMPORTED_MODULE_3__.e)({
      swiper,
      duration,
      transformElements
    });
  };
  (0,_shared_effect_init_mjs__WEBPACK_IMPORTED_MODULE_1__.e)({
    effect: 'cards',
    swiper,
    on,
    setTranslate,
    setTransition,
    perspective: () => true,
    overwriteParams: () => ({
      watchSlidesProgress: true,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/effect-coverflow.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/swiper/modules/effect-coverflow.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectCoverflow)
/* harmony export */ });
/* harmony import */ var _shared_create_shadow_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/create-shadow.mjs */ "./node_modules/swiper/shared/create-shadow.mjs");
/* harmony import */ var _shared_effect_init_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/effect-init.mjs */ "./node_modules/swiper/shared/effect-init.mjs");
/* harmony import */ var _shared_effect_target_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/effect-target.mjs */ "./node_modules/swiper/shared/effect-target.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");





function EffectCoverflow(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    coverflowEffect: {
      rotate: 50,
      stretch: 0,
      depth: 100,
      scale: 1,
      modifier: 1,
      slideShadows: true
    }
  });
  const setTranslate = () => {
    const {
      width: swiperWidth,
      height: swiperHeight,
      slides,
      slidesSizesGrid
    } = swiper;
    const params = swiper.params.coverflowEffect;
    const isHorizontal = swiper.isHorizontal();
    const transform = swiper.translate;
    const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
    const rotate = isHorizontal ? params.rotate : -params.rotate;
    const translate = params.depth;
    const r = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_3__.o)(swiper);
    // Each slide offset from center
    for (let i = 0, length = slides.length; i < length; i += 1) {
      const slideEl = slides[i];
      const slideSize = slidesSizesGrid[i];
      const slideOffset = slideEl.swiperSlideOffset;
      const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;
      const offsetMultiplier = typeof params.modifier === 'function' ? params.modifier(centerOffset) : centerOffset * params.modifier;
      let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
      let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
      // var rotateZ = 0
      let translateZ = -translate * Math.abs(offsetMultiplier);
      let stretch = params.stretch;
      // Allow percentage to make a relative stretch for responsive sliders
      if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
        stretch = parseFloat(params.stretch) / 100 * slideSize;
      }
      let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
      let translateX = isHorizontal ? stretch * offsetMultiplier : 0;
      let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);

      // Fix for ultra small values
      if (Math.abs(translateX) < 0.001) translateX = 0;
      if (Math.abs(translateY) < 0.001) translateY = 0;
      if (Math.abs(translateZ) < 0.001) translateZ = 0;
      if (Math.abs(rotateY) < 0.001) rotateY = 0;
      if (Math.abs(rotateX) < 0.001) rotateX = 0;
      if (Math.abs(scale) < 0.001) scale = 0;
      const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${r(rotateX)}deg) rotateY(${r(rotateY)}deg) scale(${scale})`;
      const targetEl = (0,_shared_effect_target_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(params, slideEl);
      targetEl.style.transform = slideTransform;
      slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
      if (params.slideShadows) {
        // Set shadows
        let shadowBeforeEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');
        let shadowAfterEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');
        if (!shadowBeforeEl) {
          shadowBeforeEl = (0,_shared_create_shadow_mjs__WEBPACK_IMPORTED_MODULE_0__.c)('coverflow', slideEl, isHorizontal ? 'left' : 'top');
        }
        if (!shadowAfterEl) {
          shadowAfterEl = (0,_shared_create_shadow_mjs__WEBPACK_IMPORTED_MODULE_0__.c)('coverflow', slideEl, isHorizontal ? 'right' : 'bottom');
        }
        if (shadowBeforeEl) shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
        if (shadowAfterEl) shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
      }
    }
  };
  const setTransition = duration => {
    const transformElements = swiper.slides.map(slideEl => (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_3__.g)(slideEl));
    transformElements.forEach(el => {
      el.style.transitionDuration = `${duration}ms`;
      el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {
        shadowEl.style.transitionDuration = `${duration}ms`;
      });
    });
  };
  (0,_shared_effect_init_mjs__WEBPACK_IMPORTED_MODULE_1__.e)({
    effect: 'coverflow',
    swiper,
    on,
    setTranslate,
    setTransition,
    perspective: () => true,
    overwriteParams: () => ({
      watchSlidesProgress: true
    })
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/effect-creative.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/swiper/modules/effect-creative.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectCreative)
/* harmony export */ });
/* harmony import */ var _shared_create_shadow_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/create-shadow.mjs */ "./node_modules/swiper/shared/create-shadow.mjs");
/* harmony import */ var _shared_effect_init_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/effect-init.mjs */ "./node_modules/swiper/shared/effect-init.mjs");
/* harmony import */ var _shared_effect_target_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/effect-target.mjs */ "./node_modules/swiper/shared/effect-target.mjs");
/* harmony import */ var _shared_effect_virtual_transition_end_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/effect-virtual-transition-end.mjs */ "./node_modules/swiper/shared/effect-virtual-transition-end.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");






function EffectCreative(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    creativeEffect: {
      limitProgress: 1,
      shadowPerProgress: false,
      progressMultiplier: 1,
      perspective: true,
      prev: {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        opacity: 1,
        scale: 1
      },
      next: {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        opacity: 1,
        scale: 1
      }
    }
  });
  const getTranslateValue = value => {
    if (typeof value === 'string') return value;
    return `${value}px`;
  };
  const setTranslate = () => {
    const {
      slides,
      wrapperEl,
      slidesSizesGrid
    } = swiper;
    const params = swiper.params.creativeEffect;
    const {
      progressMultiplier: multiplier
    } = params;
    const isCenteredSlides = swiper.params.centeredSlides;
    const rotateFix = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_4__.o)(swiper);
    if (isCenteredSlides) {
      const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;
      wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;
    }
    for (let i = 0; i < slides.length; i += 1) {
      const slideEl = slides[i];
      const slideProgress = slideEl.progress;
      const progress = Math.min(Math.max(slideEl.progress, -params.limitProgress), params.limitProgress);
      let originalProgress = progress;
      if (!isCenteredSlides) {
        originalProgress = Math.min(Math.max(slideEl.originalProgress, -params.limitProgress), params.limitProgress);
      }
      const offset = slideEl.swiperSlideOffset;
      const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];
      const r = [0, 0, 0];
      let custom = false;
      if (!swiper.isHorizontal()) {
        t[1] = t[0];
        t[0] = 0;
      }
      let data = {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        scale: 1,
        opacity: 1
      };
      if (progress < 0) {
        data = params.next;
        custom = true;
      } else if (progress > 0) {
        data = params.prev;
        custom = true;
      }
      // set translate
      t.forEach((value, index) => {
        t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;
      });
      // set rotates
      r.forEach((value, index) => {
        let val = data.rotate[index] * Math.abs(progress * multiplier);
        r[index] = val;
      });
      slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
      const translateString = t.join(', ');
      const rotateString = `rotateX(${rotateFix(r[0])}deg) rotateY(${rotateFix(r[1])}deg) rotateZ(${rotateFix(r[2])}deg)`;
      const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;
      const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;
      const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;

      // Set shadows
      if (custom && data.shadow || !custom) {
        let shadowEl = slideEl.querySelector('.swiper-slide-shadow');
        if (!shadowEl && data.shadow) {
          shadowEl = (0,_shared_create_shadow_mjs__WEBPACK_IMPORTED_MODULE_0__.c)('creative', slideEl);
        }
        if (shadowEl) {
          const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;
          shadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);
        }
      }
      const targetEl = (0,_shared_effect_target_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(params, slideEl);
      targetEl.style.transform = transform;
      targetEl.style.opacity = opacityString;
      if (data.origin) {
        targetEl.style.transformOrigin = data.origin;
      }
    }
  };
  const setTransition = duration => {
    const transformElements = swiper.slides.map(slideEl => (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_4__.g)(slideEl));
    transformElements.forEach(el => {
      el.style.transitionDuration = `${duration}ms`;
      el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {
        shadowEl.style.transitionDuration = `${duration}ms`;
      });
    });
    (0,_shared_effect_virtual_transition_end_mjs__WEBPACK_IMPORTED_MODULE_3__.e)({
      swiper,
      duration,
      transformElements,
      allSlides: true
    });
  };
  (0,_shared_effect_init_mjs__WEBPACK_IMPORTED_MODULE_1__.e)({
    effect: 'creative',
    swiper,
    on,
    setTranslate,
    setTransition,
    perspective: () => swiper.params.creativeEffect.perspective,
    overwriteParams: () => ({
      watchSlidesProgress: true,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/effect-cube.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/swiper/modules/effect-cube.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectCube)
/* harmony export */ });
/* harmony import */ var _shared_effect_init_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/effect-init.mjs */ "./node_modules/swiper/shared/effect-init.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");



function EffectCube(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    cubeEffect: {
      slideShadows: true,
      shadow: true,
      shadowOffset: 20,
      shadowScale: 0.94
    }
  });
  const createSlideShadows = (slideEl, progress, isHorizontal) => {
    let shadowBefore = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');
    let shadowAfter = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');
    if (!shadowBefore) {
      shadowBefore = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}`.split(' '));
      slideEl.append(shadowBefore);
    }
    if (!shadowAfter) {
      shadowAfter = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}`.split(' '));
      slideEl.append(shadowAfter);
    }
    if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);
    if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);
  };
  const recreateShadows = () => {
    // create new ones
    const isHorizontal = swiper.isHorizontal();
    swiper.slides.forEach(slideEl => {
      const progress = Math.max(Math.min(slideEl.progress, 1), -1);
      createSlideShadows(slideEl, progress, isHorizontal);
    });
  };
  const setTranslate = () => {
    const {
      el,
      wrapperEl,
      slides,
      width: swiperWidth,
      height: swiperHeight,
      rtlTranslate: rtl,
      size: swiperSize,
      browser
    } = swiper;
    const r = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.o)(swiper);
    const params = swiper.params.cubeEffect;
    const isHorizontal = swiper.isHorizontal();
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let wrapperRotate = 0;
    let cubeShadowEl;
    if (params.shadow) {
      if (isHorizontal) {
        cubeShadowEl = swiper.wrapperEl.querySelector('.swiper-cube-shadow');
        if (!cubeShadowEl) {
          cubeShadowEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)('div', 'swiper-cube-shadow');
          swiper.wrapperEl.append(cubeShadowEl);
        }
        cubeShadowEl.style.height = `${swiperWidth}px`;
      } else {
        cubeShadowEl = el.querySelector('.swiper-cube-shadow');
        if (!cubeShadowEl) {
          cubeShadowEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)('div', 'swiper-cube-shadow');
          el.append(cubeShadowEl);
        }
      }
    }
    for (let i = 0; i < slides.length; i += 1) {
      const slideEl = slides[i];
      let slideIndex = i;
      if (isVirtual) {
        slideIndex = parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10);
      }
      let slideAngle = slideIndex * 90;
      let round = Math.floor(slideAngle / 360);
      if (rtl) {
        slideAngle = -slideAngle;
        round = Math.floor(-slideAngle / 360);
      }
      const progress = Math.max(Math.min(slideEl.progress, 1), -1);
      let tx = 0;
      let ty = 0;
      let tz = 0;
      if (slideIndex % 4 === 0) {
        tx = -round * 4 * swiperSize;
        tz = 0;
      } else if ((slideIndex - 1) % 4 === 0) {
        tx = 0;
        tz = -round * 4 * swiperSize;
      } else if ((slideIndex - 2) % 4 === 0) {
        tx = swiperSize + round * 4 * swiperSize;
        tz = swiperSize;
      } else if ((slideIndex - 3) % 4 === 0) {
        tx = -swiperSize;
        tz = 3 * swiperSize + swiperSize * 4 * round;
      }
      if (rtl) {
        tx = -tx;
      }
      if (!isHorizontal) {
        ty = tx;
        tx = 0;
      }
      const transform = `rotateX(${r(isHorizontal ? 0 : -slideAngle)}deg) rotateY(${r(isHorizontal ? slideAngle : 0)}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
      if (progress <= 1 && progress > -1) {
        wrapperRotate = slideIndex * 90 + progress * 90;
        if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
      }
      slideEl.style.transform = transform;
      if (params.slideShadows) {
        createSlideShadows(slideEl, progress, isHorizontal);
      }
    }
    wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;
    wrapperEl.style['-webkit-transform-origin'] = `50% 50% -${swiperSize / 2}px`;
    if (params.shadow) {
      if (isHorizontal) {
        cubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(89.99deg) rotateZ(0deg) scale(${params.shadowScale})`;
      } else {
        const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
        const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
        const scale1 = params.shadowScale;
        const scale2 = params.shadowScale / multiplier;
        const offset = params.shadowOffset;
        cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-89.99deg)`;
      }
    }
    const zFactor = (browser.isSafari || browser.isWebView) && browser.needPerspectiveFix ? -swiperSize / 2 : 0;
    wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${r(swiper.isHorizontal() ? 0 : wrapperRotate)}deg) rotateY(${r(swiper.isHorizontal() ? -wrapperRotate : 0)}deg)`;
    wrapperEl.style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);
  };
  const setTransition = duration => {
    const {
      el,
      slides
    } = swiper;
    slides.forEach(slideEl => {
      slideEl.style.transitionDuration = `${duration}ms`;
      slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(subEl => {
        subEl.style.transitionDuration = `${duration}ms`;
      });
    });
    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
      const shadowEl = el.querySelector('.swiper-cube-shadow');
      if (shadowEl) shadowEl.style.transitionDuration = `${duration}ms`;
    }
  };
  (0,_shared_effect_init_mjs__WEBPACK_IMPORTED_MODULE_0__.e)({
    effect: 'cube',
    swiper,
    on,
    setTranslate,
    setTransition,
    recreateShadows,
    getEffectParams: () => swiper.params.cubeEffect,
    perspective: () => true,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      resistanceRatio: 0,
      spaceBetween: 0,
      centeredSlides: false,
      virtualTranslate: true
    })
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/effect-fade.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/swiper/modules/effect-fade.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectFade)
/* harmony export */ });
/* harmony import */ var _shared_effect_init_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/effect-init.mjs */ "./node_modules/swiper/shared/effect-init.mjs");
/* harmony import */ var _shared_effect_target_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/effect-target.mjs */ "./node_modules/swiper/shared/effect-target.mjs");
/* harmony import */ var _shared_effect_virtual_transition_end_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/effect-virtual-transition-end.mjs */ "./node_modules/swiper/shared/effect-virtual-transition-end.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");





function EffectFade(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    fadeEffect: {
      crossFade: false
    }
  });
  const setTranslate = () => {
    const {
      slides
    } = swiper;
    const params = swiper.params.fadeEffect;
    for (let i = 0; i < slides.length; i += 1) {
      const slideEl = swiper.slides[i];
      const offset = slideEl.swiperSlideOffset;
      let tx = -offset;
      if (!swiper.params.virtualTranslate) tx -= swiper.translate;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
      }
      const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);
      const targetEl = (0,_shared_effect_target_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(params, slideEl);
      targetEl.style.opacity = slideOpacity;
      targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;
    }
  };
  const setTransition = duration => {
    const transformElements = swiper.slides.map(slideEl => (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_3__.g)(slideEl));
    transformElements.forEach(el => {
      el.style.transitionDuration = `${duration}ms`;
    });
    (0,_shared_effect_virtual_transition_end_mjs__WEBPACK_IMPORTED_MODULE_2__.e)({
      swiper,
      duration,
      transformElements,
      allSlides: true
    });
  };
  (0,_shared_effect_init_mjs__WEBPACK_IMPORTED_MODULE_0__.e)({
    effect: 'fade',
    swiper,
    on,
    setTranslate,
    setTransition,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      spaceBetween: 0,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/effect-flip.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/swiper/modules/effect-flip.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectFlip)
/* harmony export */ });
/* harmony import */ var _shared_create_shadow_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/create-shadow.mjs */ "./node_modules/swiper/shared/create-shadow.mjs");
/* harmony import */ var _shared_effect_init_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/effect-init.mjs */ "./node_modules/swiper/shared/effect-init.mjs");
/* harmony import */ var _shared_effect_target_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/effect-target.mjs */ "./node_modules/swiper/shared/effect-target.mjs");
/* harmony import */ var _shared_effect_virtual_transition_end_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/effect-virtual-transition-end.mjs */ "./node_modules/swiper/shared/effect-virtual-transition-end.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");






function EffectFlip(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    flipEffect: {
      slideShadows: true,
      limitRotation: true
    }
  });
  const createSlideShadows = (slideEl, progress) => {
    let shadowBefore = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');
    let shadowAfter = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');
    if (!shadowBefore) {
      shadowBefore = (0,_shared_create_shadow_mjs__WEBPACK_IMPORTED_MODULE_0__.c)('flip', slideEl, swiper.isHorizontal() ? 'left' : 'top');
    }
    if (!shadowAfter) {
      shadowAfter = (0,_shared_create_shadow_mjs__WEBPACK_IMPORTED_MODULE_0__.c)('flip', slideEl, swiper.isHorizontal() ? 'right' : 'bottom');
    }
    if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);
    if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);
  };
  const recreateShadows = () => {
    // Set shadows
    swiper.params.flipEffect;
    swiper.slides.forEach(slideEl => {
      let progress = slideEl.progress;
      if (swiper.params.flipEffect.limitRotation) {
        progress = Math.max(Math.min(slideEl.progress, 1), -1);
      }
      createSlideShadows(slideEl, progress);
    });
  };
  const setTranslate = () => {
    const {
      slides,
      rtlTranslate: rtl
    } = swiper;
    const params = swiper.params.flipEffect;
    const rotateFix = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_4__.o)(swiper);
    for (let i = 0; i < slides.length; i += 1) {
      const slideEl = slides[i];
      let progress = slideEl.progress;
      if (swiper.params.flipEffect.limitRotation) {
        progress = Math.max(Math.min(slideEl.progress, 1), -1);
      }
      const offset = slideEl.swiperSlideOffset;
      const rotate = -180 * progress;
      let rotateY = rotate;
      let rotateX = 0;
      let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
        rotateX = -rotateY;
        rotateY = 0;
      } else if (rtl) {
        rotateY = -rotateY;
      }
      slideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
      if (params.slideShadows) {
        createSlideShadows(slideEl, progress);
      }
      const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateFix(rotateX)}deg) rotateY(${rotateFix(rotateY)}deg)`;
      const targetEl = (0,_shared_effect_target_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(params, slideEl);
      targetEl.style.transform = transform;
    }
  };
  const setTransition = duration => {
    const transformElements = swiper.slides.map(slideEl => (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_4__.g)(slideEl));
    transformElements.forEach(el => {
      el.style.transitionDuration = `${duration}ms`;
      el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {
        shadowEl.style.transitionDuration = `${duration}ms`;
      });
    });
    (0,_shared_effect_virtual_transition_end_mjs__WEBPACK_IMPORTED_MODULE_3__.e)({
      swiper,
      duration,
      transformElements
    });
  };
  (0,_shared_effect_init_mjs__WEBPACK_IMPORTED_MODULE_1__.e)({
    effect: 'flip',
    swiper,
    on,
    setTranslate,
    setTransition,
    recreateShadows,
    getEffectParams: () => swiper.params.flipEffect,
    perspective: () => true,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      spaceBetween: 0,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/free-mode.mjs":
/*!***************************************************!*\
  !*** ./node_modules/swiper/modules/free-mode.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ freeMode)
/* harmony export */ });
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");


function freeMode(_ref) {
  let {
    swiper,
    extendParams,
    emit,
    once
  } = _ref;
  extendParams({
    freeMode: {
      enabled: false,
      momentum: true,
      momentumRatio: 1,
      momentumBounce: true,
      momentumBounceRatio: 1,
      momentumVelocityRatio: 1,
      sticky: false,
      minimumVelocity: 0.02
    }
  });
  function onTouchStart() {
    if (swiper.params.cssMode) return;
    const translate = swiper.getTranslate();
    swiper.setTranslate(translate);
    swiper.setTransition(0);
    swiper.touchEventsData.velocities.length = 0;
    swiper.freeMode.onTouchEnd({
      currentPos: swiper.rtl ? swiper.translate : -swiper.translate
    });
  }
  function onTouchMove() {
    if (swiper.params.cssMode) return;
    const {
      touchEventsData: data,
      touches
    } = swiper;
    // Velocity
    if (data.velocities.length === 0) {
      data.velocities.push({
        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
        time: data.touchStartTime
      });
    }
    data.velocities.push({
      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
      time: (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.d)()
    });
  }
  function onTouchEnd(_ref2) {
    let {
      currentPos
    } = _ref2;
    if (swiper.params.cssMode) return;
    const {
      params,
      wrapperEl,
      rtlTranslate: rtl,
      snapGrid,
      touchEventsData: data
    } = swiper;
    // Time diff
    const touchEndTime = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.d)();
    const timeDiff = touchEndTime - data.touchStartTime;
    if (currentPos < -swiper.minTranslate()) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (currentPos > -swiper.maxTranslate()) {
      if (swiper.slides.length < snapGrid.length) {
        swiper.slideTo(snapGrid.length - 1);
      } else {
        swiper.slideTo(swiper.slides.length - 1);
      }
      return;
    }
    if (params.freeMode.momentum) {
      if (data.velocities.length > 1) {
        const lastMoveEvent = data.velocities.pop();
        const velocityEvent = data.velocities.pop();
        const distance = lastMoveEvent.position - velocityEvent.position;
        const time = lastMoveEvent.time - velocityEvent.time;
        swiper.velocity = distance / time;
        swiper.velocity /= 2;
        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {
          swiper.velocity = 0;
        }
        // this implies that the user stopped moving a finger then released.
        // There would be no events with distance zero, so the last event is stale.
        if (time > 150 || (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.d)() - lastMoveEvent.time > 300) {
          swiper.velocity = 0;
        }
      } else {
        swiper.velocity = 0;
      }
      swiper.velocity *= params.freeMode.momentumVelocityRatio;
      data.velocities.length = 0;
      let momentumDuration = 1000 * params.freeMode.momentumRatio;
      const momentumDistance = swiper.velocity * momentumDuration;
      let newPosition = swiper.translate + momentumDistance;
      if (rtl) newPosition = -newPosition;
      let doBounce = false;
      let afterBouncePosition;
      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
      let needsLoopFix;
      if (newPosition < swiper.maxTranslate()) {
        if (params.freeMode.momentumBounce) {
          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
            newPosition = swiper.maxTranslate() - bounceAmount;
          }
          afterBouncePosition = swiper.maxTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.maxTranslate();
        }
        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (newPosition > swiper.minTranslate()) {
        if (params.freeMode.momentumBounce) {
          if (newPosition - swiper.minTranslate() > bounceAmount) {
            newPosition = swiper.minTranslate() + bounceAmount;
          }
          afterBouncePosition = swiper.minTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.minTranslate();
        }
        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (params.freeMode.sticky) {
        let nextSlide;
        for (let j = 0; j < snapGrid.length; j += 1) {
          if (snapGrid[j] > -newPosition) {
            nextSlide = j;
            break;
          }
        }
        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
          newPosition = snapGrid[nextSlide];
        } else {
          newPosition = snapGrid[nextSlide - 1];
        }
        newPosition = -newPosition;
      }
      if (needsLoopFix) {
        once('transitionEnd', () => {
          swiper.loopFix();
        });
      }
      // Fix duration
      if (swiper.velocity !== 0) {
        if (rtl) {
          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
        } else {
          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
        }
        if (params.freeMode.sticky) {
          // If freeMode.sticky is active and the user ends a swipe with a slow-velocity
          // event, then durations can be 20+ seconds to slide one (or zero!) slides.
          // It's easy to see this when simulating touch with mouse events. To fix this,
          // limit single-slide swipes to the default slide duration. This also has the
          // nice side effect of matching slide speed if the user stopped moving before
          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
          // For faster swipes, also apply limits (albeit higher ones).
          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
          if (moveDistance < currentSlideSize) {
            momentumDuration = params.speed;
          } else if (moveDistance < 2 * currentSlideSize) {
            momentumDuration = params.speed * 1.5;
          } else {
            momentumDuration = params.speed * 2.5;
          }
        }
      } else if (params.freeMode.sticky) {
        swiper.slideToClosest();
        return;
      }
      if (params.freeMode.momentumBounce && doBounce) {
        swiper.updateProgress(afterBouncePosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        swiper.animating = true;
        (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(wrapperEl, () => {
          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
          emit('momentumBounce');
          swiper.setTransition(params.speed);
          setTimeout(() => {
            swiper.setTranslate(afterBouncePosition);
            (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(wrapperEl, () => {
              if (!swiper || swiper.destroyed) return;
              swiper.transitionEnd();
            });
          }, 0);
        });
      } else if (swiper.velocity) {
        emit('_freeModeNoMomentumRelease');
        swiper.updateProgress(newPosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        if (!swiper.animating) {
          swiper.animating = true;
          (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(wrapperEl, () => {
            if (!swiper || swiper.destroyed) return;
            swiper.transitionEnd();
          });
        }
      } else {
        swiper.updateProgress(newPosition);
      }
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    } else if (params.freeMode.sticky) {
      swiper.slideToClosest();
      return;
    } else if (params.freeMode) {
      emit('_freeModeNoMomentumRelease');
    }
    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
      emit('_freeModeStaticRelease');
      swiper.updateProgress();
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
  }
  Object.assign(swiper, {
    freeMode: {
      onTouchStart,
      onTouchMove,
      onTouchEnd
    }
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/grid.mjs":
/*!**********************************************!*\
  !*** ./node_modules/swiper/modules/grid.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Grid)
/* harmony export */ });
function Grid(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    grid: {
      rows: 1,
      fill: 'column'
    }
  });
  let slidesNumberEvenToRows;
  let slidesPerRow;
  let numFullColumns;
  let wasMultiRow;
  const getSpaceBetween = () => {
    let spaceBetween = swiper.params.spaceBetween;
    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
      spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;
    } else if (typeof spaceBetween === 'string') {
      spaceBetween = parseFloat(spaceBetween);
    }
    return spaceBetween;
  };
  const initSlides = slides => {
    const {
      slidesPerView
    } = swiper.params;
    const {
      rows,
      fill
    } = swiper.params.grid;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : slides.length;
    numFullColumns = Math.floor(slidesLength / rows);
    if (Math.floor(slidesLength / rows) === slidesLength / rows) {
      slidesNumberEvenToRows = slidesLength;
    } else {
      slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;
    }
    if (slidesPerView !== 'auto' && fill === 'row') {
      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);
    }
    slidesPerRow = slidesNumberEvenToRows / rows;
  };
  const unsetSlides = () => {
    if (swiper.slides) {
      swiper.slides.forEach(slide => {
        if (slide.swiperSlideGridSet) {
          slide.style.height = '';
          slide.style[swiper.getDirectionLabel('margin-top')] = '';
        }
      });
    }
  };
  const updateSlide = (i, slide, slides) => {
    const {
      slidesPerGroup
    } = swiper.params;
    const spaceBetween = getSpaceBetween();
    const {
      rows,
      fill
    } = swiper.params.grid;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : slides.length;
    // Set slides order
    let newSlideOrderIndex;
    let column;
    let row;
    if (fill === 'row' && slidesPerGroup > 1) {
      const groupIndex = Math.floor(i / (slidesPerGroup * rows));
      const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;
      const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);
      row = Math.floor(slideIndexInGroup / columnsInGroup);
      column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;
      newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;
      slide.style.order = newSlideOrderIndex;
    } else if (fill === 'column') {
      column = Math.floor(i / rows);
      row = i - column * rows;
      if (column > numFullColumns || column === numFullColumns && row === rows - 1) {
        row += 1;
        if (row >= rows) {
          row = 0;
          column += 1;
        }
      }
    } else {
      row = Math.floor(i / slidesPerRow);
      column = i - row * slidesPerRow;
    }
    slide.row = row;
    slide.column = column;
    slide.style.height = `calc((100% - ${(rows - 1) * spaceBetween}px) / ${rows})`;
    slide.style[swiper.getDirectionLabel('margin-top')] = row !== 0 ? spaceBetween && `${spaceBetween}px` : '';
    slide.swiperSlideGridSet = true;
  };
  const updateWrapperSize = (slideSize, snapGrid) => {
    const {
      centeredSlides,
      roundLengths
    } = swiper.params;
    const spaceBetween = getSpaceBetween();
    const {
      rows
    } = swiper.params.grid;
    swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;
    swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;
    if (!swiper.params.cssMode) {
      swiper.wrapperEl.style[swiper.getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;
    }
    if (centeredSlides) {
      const newSlidesGrid = [];
      for (let i = 0; i < snapGrid.length; i += 1) {
        let slidesGridItem = snapGrid[i];
        if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
      }
      snapGrid.splice(0, snapGrid.length);
      snapGrid.push(...newSlidesGrid);
    }
  };
  const onInit = () => {
    wasMultiRow = swiper.params.grid && swiper.params.grid.rows > 1;
  };
  const onUpdate = () => {
    const {
      params,
      el
    } = swiper;
    const isMultiRow = params.grid && params.grid.rows > 1;
    if (wasMultiRow && !isMultiRow) {
      el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
      numFullColumns = 1;
      swiper.emitContainerClasses();
    } else if (!wasMultiRow && isMultiRow) {
      el.classList.add(`${params.containerModifierClass}grid`);
      if (params.grid.fill === 'column') {
        el.classList.add(`${params.containerModifierClass}grid-column`);
      }
      swiper.emitContainerClasses();
    }
    wasMultiRow = isMultiRow;
  };
  on('init', onInit);
  on('update', onUpdate);
  swiper.grid = {
    initSlides,
    unsetSlides,
    updateSlide,
    updateWrapperSize
  };
}




/***/ }),

/***/ "./node_modules/swiper/modules/hash-navigation.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/swiper/modules/hash-navigation.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HashNavigation)
/* harmony export */ });
/* harmony import */ var _shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/ssr-window.esm.mjs */ "./node_modules/swiper/shared/ssr-window.esm.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");



function HashNavigation(_ref) {
  let {
    swiper,
    extendParams,
    emit,
    on
  } = _ref;
  let initialized = false;
  const document = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
  const window = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  extendParams({
    hashNavigation: {
      enabled: false,
      replaceState: false,
      watchState: false,
      getSlideIndex(_s, hash) {
        if (swiper.virtual && swiper.params.virtual.enabled) {
          const slideWithHash = swiper.slides.filter(slideEl => slideEl.getAttribute('data-hash') === hash)[0];
          if (!slideWithHash) return 0;
          const index = parseInt(slideWithHash.getAttribute('data-swiper-slide-index'), 10);
          return index;
        }
        return swiper.getSlideIndex((0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(swiper.slidesEl, `.${swiper.params.slideClass}[data-hash="${hash}"], swiper-slide[data-hash="${hash}"]`)[0]);
      }
    }
  });
  const onHashChange = () => {
    emit('hashChange');
    const newHash = document.location.hash.replace('#', '');
    const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index="${swiper.activeIndex}"]`) : swiper.slides[swiper.activeIndex];
    const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') : '';
    if (newHash !== activeSlideHash) {
      const newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);
      if (typeof newIndex === 'undefined' || Number.isNaN(newIndex)) return;
      swiper.slideTo(newIndex);
    }
  };
  const setHash = () => {
    if (!initialized || !swiper.params.hashNavigation.enabled) return;
    const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index="${swiper.activeIndex}"]`) : swiper.slides[swiper.activeIndex];
    const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') || activeSlideEl.getAttribute('data-history') : '';
    if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {
      window.history.replaceState(null, null, `#${activeSlideHash}` || '');
      emit('hashSet');
    } else {
      document.location.hash = activeSlideHash || '';
      emit('hashSet');
    }
  };
  const init = () => {
    if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;
    initialized = true;
    const hash = document.location.hash.replace('#', '');
    if (hash) {
      const speed = 0;
      const index = swiper.params.hashNavigation.getSlideIndex(swiper, hash);
      swiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true);
    }
    if (swiper.params.hashNavigation.watchState) {
      window.addEventListener('hashchange', onHashChange);
    }
  };
  const destroy = () => {
    if (swiper.params.hashNavigation.watchState) {
      window.removeEventListener('hashchange', onHashChange);
    }
  };
  on('init', () => {
    if (swiper.params.hashNavigation.enabled) {
      init();
    }
  });
  on('destroy', () => {
    if (swiper.params.hashNavigation.enabled) {
      destroy();
    }
  });
  on('transitionEnd _freeModeNoMomentumRelease', () => {
    if (initialized) {
      setHash();
    }
  });
  on('slideChange', () => {
    if (initialized && swiper.params.cssMode) {
      setHash();
    }
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/history.mjs":
/*!*************************************************!*\
  !*** ./node_modules/swiper/modules/history.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ History)
/* harmony export */ });
/* harmony import */ var _shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/ssr-window.esm.mjs */ "./node_modules/swiper/shared/ssr-window.esm.mjs");


function History(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    history: {
      enabled: false,
      root: '',
      replaceState: false,
      key: 'slides',
      keepQuery: false
    }
  });
  let initialized = false;
  let paths = {};
  const slugify = text => {
    return text.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
  };
  const getPathValues = urlOverride => {
    const window = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
    let location;
    if (urlOverride) {
      location = new URL(urlOverride);
    } else {
      location = window.location;
    }
    const pathArray = location.pathname.slice(1).split('/').filter(part => part !== '');
    const total = pathArray.length;
    const key = pathArray[total - 2];
    const value = pathArray[total - 1];
    return {
      key,
      value
    };
  };
  const setHistory = (key, index) => {
    const window = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
    if (!initialized || !swiper.params.history.enabled) return;
    let location;
    if (swiper.params.url) {
      location = new URL(swiper.params.url);
    } else {
      location = window.location;
    }
    const slide = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index="${index}"]`) : swiper.slides[index];
    let value = slugify(slide.getAttribute('data-history'));
    if (swiper.params.history.root.length > 0) {
      let root = swiper.params.history.root;
      if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);
      value = `${root}/${key ? `${key}/` : ''}${value}`;
    } else if (!location.pathname.includes(key)) {
      value = `${key ? `${key}/` : ''}${value}`;
    }
    if (swiper.params.history.keepQuery) {
      value += location.search;
    }
    const currentState = window.history.state;
    if (currentState && currentState.value === value) {
      return;
    }
    if (swiper.params.history.replaceState) {
      window.history.replaceState({
        value
      }, null, value);
    } else {
      window.history.pushState({
        value
      }, null, value);
    }
  };
  const scrollToSlide = (speed, value, runCallbacks) => {
    if (value) {
      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
        const slide = swiper.slides[i];
        const slideHistory = slugify(slide.getAttribute('data-history'));
        if (slideHistory === value) {
          const index = swiper.getSlideIndex(slide);
          swiper.slideTo(index, speed, runCallbacks);
        }
      }
    } else {
      swiper.slideTo(0, speed, runCallbacks);
    }
  };
  const setHistoryPopState = () => {
    paths = getPathValues(swiper.params.url);
    scrollToSlide(swiper.params.speed, paths.value, false);
  };
  const init = () => {
    const window = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
    if (!swiper.params.history) return;
    if (!window.history || !window.history.pushState) {
      swiper.params.history.enabled = false;
      swiper.params.hashNavigation.enabled = true;
      return;
    }
    initialized = true;
    paths = getPathValues(swiper.params.url);
    if (!paths.key && !paths.value) {
      if (!swiper.params.history.replaceState) {
        window.addEventListener('popstate', setHistoryPopState);
      }
      return;
    }
    scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);
    if (!swiper.params.history.replaceState) {
      window.addEventListener('popstate', setHistoryPopState);
    }
  };
  const destroy = () => {
    const window = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
    if (!swiper.params.history.replaceState) {
      window.removeEventListener('popstate', setHistoryPopState);
    }
  };
  on('init', () => {
    if (swiper.params.history.enabled) {
      init();
    }
  });
  on('destroy', () => {
    if (swiper.params.history.enabled) {
      destroy();
    }
  });
  on('transitionEnd _freeModeNoMomentumRelease', () => {
    if (initialized) {
      setHistory(swiper.params.history.key, swiper.activeIndex);
    }
  });
  on('slideChange', () => {
    if (initialized && swiper.params.cssMode) {
      setHistory(swiper.params.history.key, swiper.activeIndex);
    }
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/keyboard.mjs":
/*!**************************************************!*\
  !*** ./node_modules/swiper/modules/keyboard.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Keyboard)
/* harmony export */ });
/* harmony import */ var _shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/ssr-window.esm.mjs */ "./node_modules/swiper/shared/ssr-window.esm.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");



/* eslint-disable consistent-return */
function Keyboard(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const document = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
  const window = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  swiper.keyboard = {
    enabled: false
  };
  extendParams({
    keyboard: {
      enabled: false,
      onlyInViewport: true,
      pageUpDown: true
    }
  });
  function handle(event) {
    if (!swiper.enabled) return;
    const {
      rtlTranslate: rtl
    } = swiper;
    let e = event;
    if (e.originalEvent) e = e.originalEvent; // jquery fix
    const kc = e.keyCode || e.charCode;
    const pageUpDown = swiper.params.keyboard.pageUpDown;
    const isPageUp = pageUpDown && kc === 33;
    const isPageDown = pageUpDown && kc === 34;
    const isArrowLeft = kc === 37;
    const isArrowRight = kc === 39;
    const isArrowUp = kc === 38;
    const isArrowDown = kc === 40;
    // Directions locks
    if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
      return false;
    }
    if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
      return false;
    }
    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
      return undefined;
    }
    if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
      return undefined;
    }
    if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
      let inView = false;
      // Check that swiper should be inside of visible area of window
      if ((0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.a)(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 && (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.a)(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0) {
        return undefined;
      }
      const el = swiper.el;
      const swiperWidth = el.clientWidth;
      const swiperHeight = el.clientHeight;
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      const swiperOffset = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.b)(el);
      if (rtl) swiperOffset.left -= el.scrollLeft;
      const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];
      for (let i = 0; i < swiperCoord.length; i += 1) {
        const point = swiperCoord[i];
        if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
          if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line
          inView = true;
        }
      }
      if (!inView) return undefined;
    }
    if (swiper.isHorizontal()) {
      if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      }
      if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();
      if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();
    } else {
      if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      }
      if (isPageDown || isArrowDown) swiper.slideNext();
      if (isPageUp || isArrowUp) swiper.slidePrev();
    }
    emit('keyPress', kc);
    return undefined;
  }
  function enable() {
    if (swiper.keyboard.enabled) return;
    document.addEventListener('keydown', handle);
    swiper.keyboard.enabled = true;
  }
  function disable() {
    if (!swiper.keyboard.enabled) return;
    document.removeEventListener('keydown', handle);
    swiper.keyboard.enabled = false;
  }
  on('init', () => {
    if (swiper.params.keyboard.enabled) {
      enable();
    }
  });
  on('destroy', () => {
    if (swiper.keyboard.enabled) {
      disable();
    }
  });
  Object.assign(swiper.keyboard, {
    enable,
    disable
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/manipulation.mjs":
/*!******************************************************!*\
  !*** ./node_modules/swiper/modules/manipulation.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Manipulation)
/* harmony export */ });
function appendSlide(slides) {
  const swiper = this;
  const {
    params,
    slidesEl
  } = swiper;
  if (params.loop) {
    swiper.loopDestroy();
  }
  const appendElement = slideEl => {
    if (typeof slideEl === 'string') {
      const tempDOM = document.createElement('div');
      tempDOM.innerHTML = slideEl;
      slidesEl.append(tempDOM.children[0]);
      tempDOM.innerHTML = '';
    } else {
      slidesEl.append(slideEl);
    }
  };
  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) appendElement(slides[i]);
    }
  } else {
    appendElement(slides);
  }
  swiper.recalcSlides();
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!params.observer || swiper.isElement) {
    swiper.update();
  }
}

function prependSlide(slides) {
  const swiper = this;
  const {
    params,
    activeIndex,
    slidesEl
  } = swiper;
  if (params.loop) {
    swiper.loopDestroy();
  }
  let newActiveIndex = activeIndex + 1;
  const prependElement = slideEl => {
    if (typeof slideEl === 'string') {
      const tempDOM = document.createElement('div');
      tempDOM.innerHTML = slideEl;
      slidesEl.prepend(tempDOM.children[0]);
      tempDOM.innerHTML = '';
    } else {
      slidesEl.prepend(slideEl);
    }
  };
  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) prependElement(slides[i]);
    }
    newActiveIndex = activeIndex + slides.length;
  } else {
    prependElement(slides);
  }
  swiper.recalcSlides();
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!params.observer || swiper.isElement) {
    swiper.update();
  }
  swiper.slideTo(newActiveIndex, 0, false);
}

function addSlide(index, slides) {
  const swiper = this;
  const {
    params,
    activeIndex,
    slidesEl
  } = swiper;
  let activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.recalcSlides();
  }
  const baseLength = swiper.slides.length;
  if (index <= 0) {
    swiper.prependSlide(slides);
    return;
  }
  if (index >= baseLength) {
    swiper.appendSlide(slides);
    return;
  }
  let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
  const slidesBuffer = [];
  for (let i = baseLength - 1; i >= index; i -= 1) {
    const currentSlide = swiper.slides[i];
    currentSlide.remove();
    slidesBuffer.unshift(currentSlide);
  }
  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) slidesEl.append(slides[i]);
    }
    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
  } else {
    slidesEl.append(slides);
  }
  for (let i = 0; i < slidesBuffer.length; i += 1) {
    slidesEl.append(slidesBuffer[i]);
  }
  swiper.recalcSlides();
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!params.observer || swiper.isElement) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

function removeSlide(slidesIndexes) {
  const swiper = this;
  const {
    params,
    activeIndex
  } = swiper;
  let activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
  }
  let newActiveIndex = activeIndexBuffer;
  let indexToRemove;
  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
    for (let i = 0; i < slidesIndexes.length; i += 1) {
      indexToRemove = slidesIndexes[i];
      if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();
      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    }
    newActiveIndex = Math.max(newActiveIndex, 0);
  } else {
    indexToRemove = slidesIndexes;
    if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();
    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    newActiveIndex = Math.max(newActiveIndex, 0);
  }
  swiper.recalcSlides();
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!params.observer || swiper.isElement) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

function removeAllSlides() {
  const swiper = this;
  const slidesIndexes = [];
  for (let i = 0; i < swiper.slides.length; i += 1) {
    slidesIndexes.push(i);
  }
  swiper.removeSlide(slidesIndexes);
}

function Manipulation(_ref) {
  let {
    swiper
  } = _ref;
  Object.assign(swiper, {
    appendSlide: appendSlide.bind(swiper),
    prependSlide: prependSlide.bind(swiper),
    addSlide: addSlide.bind(swiper),
    removeSlide: removeSlide.bind(swiper),
    removeAllSlides: removeAllSlides.bind(swiper)
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/mousewheel.mjs":
/*!****************************************************!*\
  !*** ./node_modules/swiper/modules/mousewheel.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Mousewheel)
/* harmony export */ });
/* harmony import */ var _shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/ssr-window.esm.mjs */ "./node_modules/swiper/shared/ssr-window.esm.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");



/* eslint-disable consistent-return */
function Mousewheel(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const window = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  extendParams({
    mousewheel: {
      enabled: false,
      releaseOnEdges: false,
      invert: false,
      forceToAxis: false,
      sensitivity: 1,
      eventsTarget: 'container',
      thresholdDelta: null,
      thresholdTime: null,
      noMousewheelClass: 'swiper-no-mousewheel'
    }
  });
  swiper.mousewheel = {
    enabled: false
  };
  let timeout;
  let lastScrollTime = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();
  let lastEventBeforeSnap;
  const recentWheelEvents = [];
  function normalize(e) {
    // Reasonable defaults
    const PIXEL_STEP = 10;
    const LINE_HEIGHT = 40;
    const PAGE_HEIGHT = 800;
    let sX = 0;
    let sY = 0; // spinX, spinY
    let pX = 0;
    let pY = 0; // pixelX, pixelY

    // Legacy
    if ('detail' in e) {
      sY = e.detail;
    }
    if ('wheelDelta' in e) {
      sY = -e.wheelDelta / 120;
    }
    if ('wheelDeltaY' in e) {
      sY = -e.wheelDeltaY / 120;
    }
    if ('wheelDeltaX' in e) {
      sX = -e.wheelDeltaX / 120;
    }

    // side scrolling on FF with DOMMouseScroll
    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
      sX = sY;
      sY = 0;
    }
    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;
    if ('deltaY' in e) {
      pY = e.deltaY;
    }
    if ('deltaX' in e) {
      pX = e.deltaX;
    }
    if (e.shiftKey && !pX) {
      // if user scrolls with shift he wants horizontal scroll
      pX = pY;
      pY = 0;
    }
    if ((pX || pY) && e.deltaMode) {
      if (e.deltaMode === 1) {
        // delta in LINE units
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      } else {
        // delta in PAGE units
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    }

    // Fall-back if spin cannot be determined
    if (pX && !sX) {
      sX = pX < 1 ? -1 : 1;
    }
    if (pY && !sY) {
      sY = pY < 1 ? -1 : 1;
    }
    return {
      spinX: sX,
      spinY: sY,
      pixelX: pX,
      pixelY: pY
    };
  }
  function handleMouseEnter() {
    if (!swiper.enabled) return;
    swiper.mouseEntered = true;
  }
  function handleMouseLeave() {
    if (!swiper.enabled) return;
    swiper.mouseEntered = false;
  }
  function animateSlider(newEvent) {
    if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {
      // Prevent if delta of wheel scroll delta is below configured threshold
      return false;
    }
    if (swiper.params.mousewheel.thresholdTime && (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {
      // Prevent if time between scrolls is below configured threshold
      return false;
    }

    // If the movement is NOT big enough and
    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
    //   Don't go any further (avoid insignificant scroll movement).
    if (newEvent.delta >= 6 && (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)() - lastScrollTime < 60) {
      // Return false as a default
      return true;
    }
    // If user is scrolling towards the end:
    //   If the slider hasn't hit the latest slide or
    //   if the slider is a loop and
    //   if the slider isn't moving right now:
    //     Go to next slide and
    //     emit a scroll event.
    // Else (the user is scrolling towards the beginning) and
    // if the slider hasn't hit the first slide or
    // if the slider is a loop and
    // if the slider isn't moving right now:
    //   Go to prev slide and
    //   emit a scroll event.
    if (newEvent.direction < 0) {
      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
        swiper.slideNext();
        emit('scroll', newEvent.raw);
      }
    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
      swiper.slidePrev();
      emit('scroll', newEvent.raw);
    }
    // If you got here is because an animation has been triggered so store the current time
    lastScrollTime = new window.Date().getTime();
    // Return false as a default
    return false;
  }
  function releaseScroll(newEvent) {
    const params = swiper.params.mousewheel;
    if (newEvent.direction < 0) {
      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
        // Return true to animate scroll on edges
        return true;
      }
    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
      // Return true to animate scroll on edges
      return true;
    }
    return false;
  }
  function handle(event) {
    let e = event;
    let disableParentSwiper = true;
    if (!swiper.enabled) return;

    // Ignore event if the target or its parents have the swiper-no-mousewheel class
    if (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;
    const params = swiper.params.mousewheel;
    if (swiper.params.cssMode) {
      e.preventDefault();
    }
    let targetEl = swiper.el;
    if (swiper.params.mousewheel.eventsTarget !== 'container') {
      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
    }
    const targetElContainsTarget = targetEl && targetEl.contains(e.target);
    if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;
    if (e.originalEvent) e = e.originalEvent; // jquery fix
    let delta = 0;
    const rtlFactor = swiper.rtlTranslate ? -1 : 1;
    const data = normalize(e);
    if (params.forceToAxis) {
      if (swiper.isHorizontal()) {
        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;
      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;
    } else {
      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
    }
    if (delta === 0) return true;
    if (params.invert) delta = -delta;

    // Get the scroll positions
    let positions = swiper.getTranslate() + delta * params.sensitivity;
    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();

    // When loop is true:
    //     the disableParentSwiper will be true.
    // When loop is false:
    //     if the scroll positions is not on edge,
    //     then the disableParentSwiper will be true.
    //     if the scroll on edge positions,
    //     then the disableParentSwiper will be false.
    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();
    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
      // Register the new event in a variable which stores the relevant data
      const newEvent = {
        time: (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)(),
        delta: Math.abs(delta),
        direction: Math.sign(delta),
        raw: event
      };

      // Keep the most recent events
      if (recentWheelEvents.length >= 2) {
        recentWheelEvents.shift(); // only store the last N events
      }

      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
      recentWheelEvents.push(newEvent);

      // If there is at least one previous recorded event:
      //   If direction has changed or
      //   if the scroll is quicker than the previous one:
      //     Animate the slider.
      // Else (this is the first time the wheel is moved):
      //     Animate the slider.
      if (prevEvent) {
        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
          animateSlider(newEvent);
        }
      } else {
        animateSlider(newEvent);
      }

      // If it's time to release the scroll:
      //   Return now so you don't hit the preventDefault.
      if (releaseScroll(newEvent)) {
        return true;
      }
    } else {
      // Freemode or scrollContainer:

      // If we recently snapped after a momentum scroll, then ignore wheel events
      // to give time for the deceleration to finish. Stop ignoring after 500 msecs
      // or if it's a new scroll (larger delta or inverse sign as last event before
      // an end-of-momentum snap).
      const newEvent = {
        time: (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)(),
        delta: Math.abs(delta),
        direction: Math.sign(delta)
      };
      const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;
      if (!ignoreWheelEvents) {
        lastEventBeforeSnap = undefined;
        let position = swiper.getTranslate() + delta * params.sensitivity;
        const wasBeginning = swiper.isBeginning;
        const wasEnd = swiper.isEnd;
        if (position >= swiper.minTranslate()) position = swiper.minTranslate();
        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
        swiper.setTransition(0);
        swiper.setTranslate(position);
        swiper.updateProgress();
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
          swiper.updateSlidesClasses();
        }
        if (swiper.params.loop) {
          swiper.loopFix({
            direction: newEvent.direction < 0 ? 'next' : 'prev',
            byMousewheel: true
          });
        }
        if (swiper.params.freeMode.sticky) {
          // When wheel scrolling starts with sticky (aka snap) enabled, then detect
          // the end of a momentum scroll by storing recent (N=15?) wheel events.
          // 1. do all N events have decreasing or same (absolute value) delta?
          // 2. did all N events arrive in the last M (M=500?) msecs?
          // 3. does the earliest event have an (absolute value) delta that's
          //    at least P (P=1?) larger than the most recent event's delta?
          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
          // If 1-4 are "yes" then we're near the end of a momentum scroll deceleration.
          // Snap immediately and ignore remaining wheel events in this scroll.
          // See comment above for "remaining wheel events in this scroll" determination.
          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
          clearTimeout(timeout);
          timeout = undefined;
          if (recentWheelEvents.length >= 15) {
            recentWheelEvents.shift(); // only store the last N events
          }

          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
          const firstEvent = recentWheelEvents[0];
          recentWheelEvents.push(newEvent);
          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
            recentWheelEvents.splice(0);
          } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
            // We're at the end of the deceleration of a momentum scroll, so there's no need
            // to wait for more events. Snap ASAP on the next tick.
            // Also, because there's some remaining momentum we'll bias the snap in the
            // direction of the ongoing scroll because it's better UX for the scroll to snap
            // in the same direction as the scroll instead of reversing to snap.  Therefore,
            // if it's already scrolled more than 20% in the current direction, keep going.
            const snapToThreshold = delta > 0 ? 0.8 : 0.2;
            lastEventBeforeSnap = newEvent;
            recentWheelEvents.splice(0);
            timeout = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(() => {
              if (swiper.destroyed || !swiper.params) return;
              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
            }, 0); // no delay; move on next tick
          }

          if (!timeout) {
            // if we get here, then we haven't detected the end of a momentum scroll, so
            // we'll consider a scroll "complete" when there haven't been any wheel events
            // for 500ms.
            timeout = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(() => {
              if (swiper.destroyed || !swiper.params) return;
              const snapToThreshold = 0.5;
              lastEventBeforeSnap = newEvent;
              recentWheelEvents.splice(0);
              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
            }, 500);
          }
        }

        // Emit event
        if (!ignoreWheelEvents) emit('scroll', e);

        // Stop autoplay
        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();
        // Return page scroll on edge positions
        if (params.releaseOnEdges && (position === swiper.minTranslate() || position === swiper.maxTranslate())) {
          return true;
        }
      }
    }
    if (e.preventDefault) e.preventDefault();else e.returnValue = false;
    return false;
  }
  function events(method) {
    let targetEl = swiper.el;
    if (swiper.params.mousewheel.eventsTarget !== 'container') {
      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
    }
    targetEl[method]('mouseenter', handleMouseEnter);
    targetEl[method]('mouseleave', handleMouseLeave);
    targetEl[method]('wheel', handle);
  }
  function enable() {
    if (swiper.params.cssMode) {
      swiper.wrapperEl.removeEventListener('wheel', handle);
      return true;
    }
    if (swiper.mousewheel.enabled) return false;
    events('addEventListener');
    swiper.mousewheel.enabled = true;
    return true;
  }
  function disable() {
    if (swiper.params.cssMode) {
      swiper.wrapperEl.addEventListener(event, handle);
      return true;
    }
    if (!swiper.mousewheel.enabled) return false;
    events('removeEventListener');
    swiper.mousewheel.enabled = false;
    return true;
  }
  on('init', () => {
    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
      disable();
    }
    if (swiper.params.mousewheel.enabled) enable();
  });
  on('destroy', () => {
    if (swiper.params.cssMode) {
      enable();
    }
    if (swiper.mousewheel.enabled) disable();
  });
  Object.assign(swiper.mousewheel, {
    enable,
    disable
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/navigation.mjs":
/*!****************************************************!*\
  !*** ./node_modules/swiper/modules/navigation.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Navigation)
/* harmony export */ });
/* harmony import */ var _shared_create_element_if_not_defined_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/create-element-if-not-defined.mjs */ "./node_modules/swiper/shared/create-element-if-not-defined.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");



function Navigation(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  extendParams({
    navigation: {
      nextEl: null,
      prevEl: null,
      hideOnClick: false,
      disabledClass: 'swiper-button-disabled',
      hiddenClass: 'swiper-button-hidden',
      lockClass: 'swiper-button-lock',
      navigationDisabledClass: 'swiper-navigation-disabled'
    }
  });
  swiper.navigation = {
    nextEl: null,
    prevEl: null
  };
  function getEl(el) {
    let res;
    if (el && typeof el === 'string' && swiper.isElement) {
      res = swiper.el.querySelector(el) || swiper.hostEl.querySelector(el);
      if (res) return res;
    }
    if (el) {
      if (typeof el === 'string') res = [...document.querySelectorAll(el)];
      if (swiper.params.uniqueNavElements && typeof el === 'string' && res && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {
        res = swiper.el.querySelector(el);
      } else if (res && res.length === 1) {
        res = res[0];
      }
    }
    if (el && !res) return el;
    // if (Array.isArray(res) && res.length === 1) res = res[0];
    return res;
  }
  function toggleEl(el, disabled) {
    const params = swiper.params.navigation;
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(el);
    el.forEach(subEl => {
      if (subEl) {
        subEl.classList[disabled ? 'add' : 'remove'](...params.disabledClass.split(' '));
        if (subEl.tagName === 'BUTTON') subEl.disabled = disabled;
        if (swiper.params.watchOverflow && swiper.enabled) {
          subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);
        }
      }
    });
  }
  function update() {
    // Update Navigation Buttons
    const {
      nextEl,
      prevEl
    } = swiper.navigation;
    if (swiper.params.loop) {
      toggleEl(prevEl, false);
      toggleEl(nextEl, false);
      return;
    }
    toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);
    toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);
  }
  function onPrevClick(e) {
    e.preventDefault();
    if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
    swiper.slidePrev();
    emit('navigationPrev');
  }
  function onNextClick(e) {
    e.preventDefault();
    if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
    swiper.slideNext();
    emit('navigationNext');
  }
  function init() {
    const params = swiper.params.navigation;
    swiper.params.navigation = (0,_shared_create_element_if_not_defined_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
      nextEl: 'swiper-button-next',
      prevEl: 'swiper-button-prev'
    });
    if (!(params.nextEl || params.prevEl)) return;
    let nextEl = getEl(params.nextEl);
    let prevEl = getEl(params.prevEl);
    Object.assign(swiper.navigation, {
      nextEl,
      prevEl
    });
    nextEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(nextEl);
    prevEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(prevEl);
    const initButton = (el, dir) => {
      if (el) {
        el.addEventListener('click', dir === 'next' ? onNextClick : onPrevClick);
      }
      if (!swiper.enabled && el) {
        el.classList.add(...params.lockClass.split(' '));
      }
    };
    nextEl.forEach(el => initButton(el, 'next'));
    prevEl.forEach(el => initButton(el, 'prev'));
  }
  function destroy() {
    let {
      nextEl,
      prevEl
    } = swiper.navigation;
    nextEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(nextEl);
    prevEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(prevEl);
    const destroyButton = (el, dir) => {
      el.removeEventListener('click', dir === 'next' ? onNextClick : onPrevClick);
      el.classList.remove(...swiper.params.navigation.disabledClass.split(' '));
    };
    nextEl.forEach(el => destroyButton(el, 'next'));
    prevEl.forEach(el => destroyButton(el, 'prev'));
  }
  on('init', () => {
    if (swiper.params.navigation.enabled === false) {
      // eslint-disable-next-line
      disable();
    } else {
      init();
      update();
    }
  });
  on('toEdge fromEdge lock unlock', () => {
    update();
  });
  on('destroy', () => {
    destroy();
  });
  on('enable disable', () => {
    let {
      nextEl,
      prevEl
    } = swiper.navigation;
    nextEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(nextEl);
    prevEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(prevEl);
    if (swiper.enabled) {
      update();
      return;
    }
    [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.add(swiper.params.navigation.lockClass));
  });
  on('click', (_s, e) => {
    let {
      nextEl,
      prevEl
    } = swiper.navigation;
    nextEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(nextEl);
    prevEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(prevEl);
    const targetEl = e.target;
    let targetIsButton = prevEl.includes(targetEl) || nextEl.includes(targetEl);
    if (swiper.isElement && !targetIsButton) {
      const path = e.path || e.composedPath && e.composedPath();
      if (path) {
        targetIsButton = path.find(pathEl => nextEl.includes(pathEl) || prevEl.includes(pathEl));
      }
    }
    if (swiper.params.navigation.hideOnClick && !targetIsButton) {
      if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
      let isHidden;
      if (nextEl.length) {
        isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);
      } else if (prevEl.length) {
        isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);
      }
      if (isHidden === true) {
        emit('navigationShow');
      } else {
        emit('navigationHide');
      }
      [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.toggle(swiper.params.navigation.hiddenClass));
    }
  });
  const enable = () => {
    swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(' '));
    init();
    update();
  };
  const disable = () => {
    swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(' '));
    destroy();
  };
  Object.assign(swiper.navigation, {
    enable,
    disable,
    update,
    init,
    destroy
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/pagination.mjs":
/*!****************************************************!*\
  !*** ./node_modules/swiper/modules/pagination.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Pagination)
/* harmony export */ });
/* harmony import */ var _shared_classes_to_selector_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/classes-to-selector.mjs */ "./node_modules/swiper/shared/classes-to-selector.mjs");
/* harmony import */ var _shared_create_element_if_not_defined_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/create-element-if-not-defined.mjs */ "./node_modules/swiper/shared/create-element-if-not-defined.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");




function Pagination(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const pfx = 'swiper-pagination';
  extendParams({
    pagination: {
      el: null,
      bulletElement: 'span',
      clickable: false,
      hideOnClick: false,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: false,
      type: 'bullets',
      // 'bullets' or 'progressbar' or 'fraction' or 'custom'
      dynamicBullets: false,
      dynamicMainBullets: 1,
      formatFractionCurrent: number => number,
      formatFractionTotal: number => number,
      bulletClass: `${pfx}-bullet`,
      bulletActiveClass: `${pfx}-bullet-active`,
      modifierClass: `${pfx}-`,
      currentClass: `${pfx}-current`,
      totalClass: `${pfx}-total`,
      hiddenClass: `${pfx}-hidden`,
      progressbarFillClass: `${pfx}-progressbar-fill`,
      progressbarOppositeClass: `${pfx}-progressbar-opposite`,
      clickableClass: `${pfx}-clickable`,
      lockClass: `${pfx}-lock`,
      horizontalClass: `${pfx}-horizontal`,
      verticalClass: `${pfx}-vertical`,
      paginationDisabledClass: `${pfx}-disabled`
    }
  });
  swiper.pagination = {
    el: null,
    bullets: []
  };
  let bulletSize;
  let dynamicBulletIndex = 0;
  function isPaginationDisabled() {
    return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;
  }
  function setSideBullets(bulletEl, position) {
    const {
      bulletActiveClass
    } = swiper.params.pagination;
    if (!bulletEl) return;
    bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];
    if (bulletEl) {
      bulletEl.classList.add(`${bulletActiveClass}-${position}`);
      bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];
      if (bulletEl) {
        bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);
      }
    }
  }
  function getMoveDirection(prevIndex, nextIndex, length) {
    prevIndex = prevIndex % length;
    nextIndex = nextIndex % length;
    if (nextIndex === prevIndex + 1) {
      return 'next';
    } else if (nextIndex === prevIndex - 1) {
      return 'previous';
    }
    return;
  }
  function onBulletClick(e) {
    const bulletEl = e.target.closest((0,_shared_classes_to_selector_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(swiper.params.pagination.bulletClass));
    if (!bulletEl) {
      return;
    }
    e.preventDefault();
    const index = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.h)(bulletEl) * swiper.params.slidesPerGroup;
    if (swiper.params.loop) {
      if (swiper.realIndex === index) return;
      const moveDirection = getMoveDirection(swiper.realIndex, index, swiper.slides.length);
      if (moveDirection === 'next') {
        swiper.slideNext();
      } else if (moveDirection === 'previous') {
        swiper.slidePrev();
      } else {
        swiper.slideToLoop(index);
      }
    } else {
      swiper.slideTo(index);
    }
  }
  function update() {
    // Render || Update Pagination bullets/items
    const rtl = swiper.rtl;
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    let el = swiper.pagination.el;
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    // Current/Total
    let current;
    let previousIndex;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
    if (swiper.params.loop) {
      previousIndex = swiper.previousRealIndex || 0;
      current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;
    } else if (typeof swiper.snapIndex !== 'undefined') {
      current = swiper.snapIndex;
      previousIndex = swiper.previousSnapIndex;
    } else {
      previousIndex = swiper.previousIndex || 0;
      current = swiper.activeIndex || 0;
    }
    // Types
    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      const bullets = swiper.pagination.bullets;
      let firstIndex;
      let lastIndex;
      let midIndex;
      if (params.dynamicBullets) {
        bulletSize = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.f)(bullets[0], swiper.isHorizontal() ? 'width' : 'height', true);
        el.forEach(subEl => {
          subEl.style[swiper.isHorizontal() ? 'width' : 'height'] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;
        });
        if (params.dynamicMainBullets > 1 && previousIndex !== undefined) {
          dynamicBulletIndex += current - (previousIndex || 0);
          if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
            dynamicBulletIndex = params.dynamicMainBullets - 1;
          } else if (dynamicBulletIndex < 0) {
            dynamicBulletIndex = 0;
          }
        }
        firstIndex = Math.max(current - dynamicBulletIndex, 0);
        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
        midIndex = (lastIndex + firstIndex) / 2;
      }
      bullets.forEach(bulletEl => {
        const classesToRemove = [...['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`)].map(s => typeof s === 'string' && s.includes(' ') ? s.split(' ') : s).flat();
        bulletEl.classList.remove(...classesToRemove);
      });
      if (el.length > 1) {
        bullets.forEach(bullet => {
          const bulletIndex = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.h)(bullet);
          if (bulletIndex === current) {
            bullet.classList.add(...params.bulletActiveClass.split(' '));
          } else if (swiper.isElement) {
            bullet.setAttribute('part', 'bullet');
          }
          if (params.dynamicBullets) {
            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
              bullet.classList.add(...`${params.bulletActiveClass}-main`.split(' '));
            }
            if (bulletIndex === firstIndex) {
              setSideBullets(bullet, 'prev');
            }
            if (bulletIndex === lastIndex) {
              setSideBullets(bullet, 'next');
            }
          }
        });
      } else {
        const bullet = bullets[current];
        if (bullet) {
          bullet.classList.add(...params.bulletActiveClass.split(' '));
        }
        if (swiper.isElement) {
          bullets.forEach((bulletEl, bulletIndex) => {
            bulletEl.setAttribute('part', bulletIndex === current ? 'bullet-active' : 'bullet');
          });
        }
        if (params.dynamicBullets) {
          const firstDisplayedBullet = bullets[firstIndex];
          const lastDisplayedBullet = bullets[lastIndex];
          for (let i = firstIndex; i <= lastIndex; i += 1) {
            if (bullets[i]) {
              bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(' '));
            }
          }
          setSideBullets(firstDisplayedBullet, 'prev');
          setSideBullets(lastDisplayedBullet, 'next');
        }
      }
      if (params.dynamicBullets) {
        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
        const offsetProp = rtl ? 'right' : 'left';
        bullets.forEach(bullet => {
          bullet.style[swiper.isHorizontal() ? offsetProp : 'top'] = `${bulletsOffset}px`;
        });
      }
    }
    el.forEach((subEl, subElIndex) => {
      if (params.type === 'fraction') {
        subEl.querySelectorAll((0,_shared_classes_to_selector_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(params.currentClass)).forEach(fractionEl => {
          fractionEl.textContent = params.formatFractionCurrent(current + 1);
        });
        subEl.querySelectorAll((0,_shared_classes_to_selector_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(params.totalClass)).forEach(totalEl => {
          totalEl.textContent = params.formatFractionTotal(total);
        });
      }
      if (params.type === 'progressbar') {
        let progressbarDirection;
        if (params.progressbarOpposite) {
          progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
        } else {
          progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
        }
        const scale = (current + 1) / total;
        let scaleX = 1;
        let scaleY = 1;
        if (progressbarDirection === 'horizontal') {
          scaleX = scale;
        } else {
          scaleY = scale;
        }
        subEl.querySelectorAll((0,_shared_classes_to_selector_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(params.progressbarFillClass)).forEach(progressEl => {
          progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;
          progressEl.style.transitionDuration = `${swiper.params.speed}ms`;
        });
      }
      if (params.type === 'custom' && params.renderCustom) {
        subEl.innerHTML = params.renderCustom(swiper, current + 1, total);
        if (subElIndex === 0) emit('paginationRender', subEl);
      } else {
        if (subElIndex === 0) emit('paginationRender', subEl);
        emit('paginationUpdate', subEl);
      }
      if (swiper.params.watchOverflow && swiper.enabled) {
        subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);
      }
    });
  }
  function render() {
    // Render Container
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.grid && swiper.params.grid.rows > 1 ? swiper.slides.length / Math.ceil(swiper.params.grid.rows) : swiper.slides.length;
    let el = swiper.pagination.el;
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    let paginationHTML = '';
    if (params.type === 'bullets') {
      let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
      if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {
        numberOfBullets = slidesLength;
      }
      for (let i = 0; i < numberOfBullets; i += 1) {
        if (params.renderBullet) {
          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
        } else {
          // prettier-ignore
          paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part="bullet"' : ''} class="${params.bulletClass}"></${params.bulletElement}>`;
        }
      }
    }
    if (params.type === 'fraction') {
      if (params.renderFraction) {
        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
      } else {
        paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
      }
    }
    if (params.type === 'progressbar') {
      if (params.renderProgressbar) {
        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
      } else {
        paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
      }
    }
    swiper.pagination.bullets = [];
    el.forEach(subEl => {
      if (params.type !== 'custom') {
        subEl.innerHTML = paginationHTML || '';
      }
      if (params.type === 'bullets') {
        swiper.pagination.bullets.push(...subEl.querySelectorAll((0,_shared_classes_to_selector_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(params.bulletClass)));
      }
    });
    if (params.type !== 'custom') {
      emit('paginationRender', el[0]);
    }
  }
  function init() {
    swiper.params.pagination = (0,_shared_create_element_if_not_defined_mjs__WEBPACK_IMPORTED_MODULE_1__.c)(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
      el: 'swiper-pagination'
    });
    const params = swiper.params.pagination;
    if (!params.el) return;
    let el;
    if (typeof params.el === 'string' && swiper.isElement) {
      el = swiper.el.querySelector(params.el);
    }
    if (!el && typeof params.el === 'string') {
      el = [...document.querySelectorAll(params.el)];
    }
    if (!el) {
      el = params.el;
    }
    if (!el || el.length === 0) return;
    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && Array.isArray(el) && el.length > 1) {
      el = [...swiper.el.querySelectorAll(params.el)];
      // check if it belongs to another nested Swiper
      if (el.length > 1) {
        el = el.filter(subEl => {
          if ((0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.a)(subEl, '.swiper')[0] !== swiper.el) return false;
          return true;
        })[0];
      }
    }
    if (Array.isArray(el) && el.length === 1) el = el[0];
    Object.assign(swiper.pagination, {
      el
    });
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    el.forEach(subEl => {
      if (params.type === 'bullets' && params.clickable) {
        subEl.classList.add(...(params.clickableClass || '').split(' '));
      }
      subEl.classList.add(params.modifierClass + params.type);
      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
      if (params.type === 'bullets' && params.dynamicBullets) {
        subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);
        dynamicBulletIndex = 0;
        if (params.dynamicMainBullets < 1) {
          params.dynamicMainBullets = 1;
        }
      }
      if (params.type === 'progressbar' && params.progressbarOpposite) {
        subEl.classList.add(params.progressbarOppositeClass);
      }
      if (params.clickable) {
        subEl.addEventListener('click', onBulletClick);
      }
      if (!swiper.enabled) {
        subEl.classList.add(params.lockClass);
      }
    });
  }
  function destroy() {
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    let el = swiper.pagination.el;
    if (el) {
      el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
      el.forEach(subEl => {
        subEl.classList.remove(params.hiddenClass);
        subEl.classList.remove(params.modifierClass + params.type);
        subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
        if (params.clickable) {
          subEl.classList.remove(...(params.clickableClass || '').split(' '));
          subEl.removeEventListener('click', onBulletClick);
        }
      });
    }
    if (swiper.pagination.bullets) swiper.pagination.bullets.forEach(subEl => subEl.classList.remove(...params.bulletActiveClass.split(' ')));
  }
  on('changeDirection', () => {
    if (!swiper.pagination || !swiper.pagination.el) return;
    const params = swiper.params.pagination;
    let {
      el
    } = swiper.pagination;
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
    el.forEach(subEl => {
      subEl.classList.remove(params.horizontalClass, params.verticalClass);
      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    });
  });
  on('init', () => {
    if (swiper.params.pagination.enabled === false) {
      // eslint-disable-next-line
      disable();
    } else {
      init();
      render();
      update();
    }
  });
  on('activeIndexChange', () => {
    if (typeof swiper.snapIndex === 'undefined') {
      update();
    }
  });
  on('snapIndexChange', () => {
    update();
  });
  on('snapGridLengthChange', () => {
    render();
    update();
  });
  on('destroy', () => {
    destroy();
  });
  on('enable disable', () => {
    let {
      el
    } = swiper.pagination;
    if (el) {
      el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
      el.forEach(subEl => subEl.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.pagination.lockClass));
    }
  });
  on('lock unlock', () => {
    update();
  });
  on('click', (_s, e) => {
    const targetEl = e.target;
    const el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(swiper.pagination.el);
    if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {
      if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
      const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);
      if (isHidden === true) {
        emit('paginationShow');
      } else {
        emit('paginationHide');
      }
      el.forEach(subEl => subEl.classList.toggle(swiper.params.pagination.hiddenClass));
    }
  });
  const enable = () => {
    swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);
    let {
      el
    } = swiper.pagination;
    if (el) {
      el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
      el.forEach(subEl => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));
    }
    init();
    render();
    update();
  };
  const disable = () => {
    swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);
    let {
      el
    } = swiper.pagination;
    if (el) {
      el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(el);
      el.forEach(subEl => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));
    }
    destroy();
  };
  Object.assign(swiper.pagination, {
    enable,
    disable,
    render,
    update,
    init,
    destroy
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/parallax.mjs":
/*!**************************************************!*\
  !*** ./node_modules/swiper/modules/parallax.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Parallax)
/* harmony export */ });
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");


function Parallax(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    parallax: {
      enabled: false
    }
  });
  const elementsSelector = '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]';
  const setTransform = (el, progress) => {
    const {
      rtl
    } = swiper;
    const rtlFactor = rtl ? -1 : 1;
    const p = el.getAttribute('data-swiper-parallax') || '0';
    let x = el.getAttribute('data-swiper-parallax-x');
    let y = el.getAttribute('data-swiper-parallax-y');
    const scale = el.getAttribute('data-swiper-parallax-scale');
    const opacity = el.getAttribute('data-swiper-parallax-opacity');
    const rotate = el.getAttribute('data-swiper-parallax-rotate');
    if (x || y) {
      x = x || '0';
      y = y || '0';
    } else if (swiper.isHorizontal()) {
      x = p;
      y = '0';
    } else {
      y = p;
      x = '0';
    }
    if (x.indexOf('%') >= 0) {
      x = `${parseInt(x, 10) * progress * rtlFactor}%`;
    } else {
      x = `${x * progress * rtlFactor}px`;
    }
    if (y.indexOf('%') >= 0) {
      y = `${parseInt(y, 10) * progress}%`;
    } else {
      y = `${y * progress}px`;
    }
    if (typeof opacity !== 'undefined' && opacity !== null) {
      const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
      el.style.opacity = currentOpacity;
    }
    let transform = `translate3d(${x}, ${y}, 0px)`;
    if (typeof scale !== 'undefined' && scale !== null) {
      const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
      transform += ` scale(${currentScale})`;
    }
    if (rotate && typeof rotate !== 'undefined' && rotate !== null) {
      const currentRotate = rotate * progress * -1;
      transform += ` rotate(${currentRotate}deg)`;
    }
    el.style.transform = transform;
  };
  const setTranslate = () => {
    const {
      el,
      slides,
      progress,
      snapGrid,
      isElement
    } = swiper;
    const elements = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.e)(el, elementsSelector);
    if (swiper.isElement) {
      elements.push(...(0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.e)(swiper.hostEl, elementsSelector));
    }
    elements.forEach(subEl => {
      setTransform(subEl, progress);
    });
    slides.forEach((slideEl, slideIndex) => {
      let slideProgress = slideEl.progress;
      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
        slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
      }
      slideProgress = Math.min(Math.max(slideProgress, -1), 1);
      slideEl.querySelectorAll(`${elementsSelector}, [data-swiper-parallax-rotate]`).forEach(subEl => {
        setTransform(subEl, slideProgress);
      });
    });
  };
  const setTransition = function (duration) {
    if (duration === void 0) {
      duration = swiper.params.speed;
    }
    const {
      el,
      hostEl
    } = swiper;
    const elements = [...el.querySelectorAll(elementsSelector)];
    if (swiper.isElement) {
      elements.push(...hostEl.querySelectorAll(elementsSelector));
    }
    elements.forEach(parallaxEl => {
      let parallaxDuration = parseInt(parallaxEl.getAttribute('data-swiper-parallax-duration'), 10) || duration;
      if (duration === 0) parallaxDuration = 0;
      parallaxEl.style.transitionDuration = `${parallaxDuration}ms`;
    });
  };
  on('beforeInit', () => {
    if (!swiper.params.parallax.enabled) return;
    swiper.params.watchSlidesProgress = true;
    swiper.originalParams.watchSlidesProgress = true;
  });
  on('init', () => {
    if (!swiper.params.parallax.enabled) return;
    setTranslate();
  });
  on('setTranslate', () => {
    if (!swiper.params.parallax.enabled) return;
    setTranslate();
  });
  on('setTransition', (_swiper, duration) => {
    if (!swiper.params.parallax.enabled) return;
    setTransition(duration);
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/scrollbar.mjs":
/*!***************************************************!*\
  !*** ./node_modules/swiper/modules/scrollbar.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Scrollbar)
/* harmony export */ });
/* harmony import */ var _shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/ssr-window.esm.mjs */ "./node_modules/swiper/shared/ssr-window.esm.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");
/* harmony import */ var _shared_create_element_if_not_defined_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/create-element-if-not-defined.mjs */ "./node_modules/swiper/shared/create-element-if-not-defined.mjs");
/* harmony import */ var _shared_classes_to_selector_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/classes-to-selector.mjs */ "./node_modules/swiper/shared/classes-to-selector.mjs");





function Scrollbar(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const document = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
  let isTouched = false;
  let timeout = null;
  let dragTimeout = null;
  let dragStartPos;
  let dragSize;
  let trackSize;
  let divider;
  extendParams({
    scrollbar: {
      el: null,
      dragSize: 'auto',
      hide: false,
      draggable: false,
      snapOnRelease: true,
      lockClass: 'swiper-scrollbar-lock',
      dragClass: 'swiper-scrollbar-drag',
      scrollbarDisabledClass: 'swiper-scrollbar-disabled',
      horizontalClass: `swiper-scrollbar-horizontal`,
      verticalClass: `swiper-scrollbar-vertical`
    }
  });
  swiper.scrollbar = {
    el: null,
    dragEl: null
  };
  function setTranslate() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    const {
      scrollbar,
      rtlTranslate: rtl
    } = swiper;
    const {
      dragEl,
      el
    } = scrollbar;
    const params = swiper.params.scrollbar;
    const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;
    let newSize = dragSize;
    let newPos = (trackSize - dragSize) * progress;
    if (rtl) {
      newPos = -newPos;
      if (newPos > 0) {
        newSize = dragSize - newPos;
        newPos = 0;
      } else if (-newPos + dragSize > trackSize) {
        newSize = trackSize + newPos;
      }
    } else if (newPos < 0) {
      newSize = dragSize + newPos;
      newPos = 0;
    } else if (newPos + dragSize > trackSize) {
      newSize = trackSize - newPos;
    }
    if (swiper.isHorizontal()) {
      dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;
      dragEl.style.width = `${newSize}px`;
    } else {
      dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;
      dragEl.style.height = `${newSize}px`;
    }
    if (params.hide) {
      clearTimeout(timeout);
      el.style.opacity = 1;
      timeout = setTimeout(() => {
        el.style.opacity = 0;
        el.style.transitionDuration = '400ms';
      }, 1000);
    }
  }
  function setTransition(duration) {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;
  }
  function updateSize() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    const {
      scrollbar
    } = swiper;
    const {
      dragEl,
      el
    } = scrollbar;
    dragEl.style.width = '';
    dragEl.style.height = '';
    trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;
    divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));
    if (swiper.params.scrollbar.dragSize === 'auto') {
      dragSize = trackSize * divider;
    } else {
      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
    }
    if (swiper.isHorizontal()) {
      dragEl.style.width = `${dragSize}px`;
    } else {
      dragEl.style.height = `${dragSize}px`;
    }
    if (divider >= 1) {
      el.style.display = 'none';
    } else {
      el.style.display = '';
    }
    if (swiper.params.scrollbar.hide) {
      el.style.opacity = 0;
    }
    if (swiper.params.watchOverflow && swiper.enabled) {
      scrollbar.el.classList[swiper.isLocked ? 'add' : 'remove'](swiper.params.scrollbar.lockClass);
    }
  }
  function getPointerPosition(e) {
    return swiper.isHorizontal() ? e.clientX : e.clientY;
  }
  function setDragPosition(e) {
    const {
      scrollbar,
      rtlTranslate: rtl
    } = swiper;
    const {
      el
    } = scrollbar;
    let positionRatio;
    positionRatio = (getPointerPosition(e) - (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.b)(el)[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
    positionRatio = Math.max(Math.min(positionRatio, 1), 0);
    if (rtl) {
      positionRatio = 1 - positionRatio;
    }
    const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
    swiper.updateProgress(position);
    swiper.setTranslate(position);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  function onDragStart(e) {
    const params = swiper.params.scrollbar;
    const {
      scrollbar,
      wrapperEl
    } = swiper;
    const {
      el,
      dragEl
    } = scrollbar;
    isTouched = true;
    dragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
    e.preventDefault();
    e.stopPropagation();
    wrapperEl.style.transitionDuration = '100ms';
    dragEl.style.transitionDuration = '100ms';
    setDragPosition(e);
    clearTimeout(dragTimeout);
    el.style.transitionDuration = '0ms';
    if (params.hide) {
      el.style.opacity = 1;
    }
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style['scroll-snap-type'] = 'none';
    }
    emit('scrollbarDragStart', e);
  }
  function onDragMove(e) {
    const {
      scrollbar,
      wrapperEl
    } = swiper;
    const {
      el,
      dragEl
    } = scrollbar;
    if (!isTouched) return;
    if (e.preventDefault && e.cancelable) e.preventDefault();else e.returnValue = false;
    setDragPosition(e);
    wrapperEl.style.transitionDuration = '0ms';
    el.style.transitionDuration = '0ms';
    dragEl.style.transitionDuration = '0ms';
    emit('scrollbarDragMove', e);
  }
  function onDragEnd(e) {
    const params = swiper.params.scrollbar;
    const {
      scrollbar,
      wrapperEl
    } = swiper;
    const {
      el
    } = scrollbar;
    if (!isTouched) return;
    isTouched = false;
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style['scroll-snap-type'] = '';
      wrapperEl.style.transitionDuration = '';
    }
    if (params.hide) {
      clearTimeout(dragTimeout);
      dragTimeout = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(() => {
        el.style.opacity = 0;
        el.style.transitionDuration = '400ms';
      }, 1000);
    }
    emit('scrollbarDragEnd', e);
    if (params.snapOnRelease) {
      swiper.slideToClosest();
    }
  }
  function events(method) {
    const {
      scrollbar,
      params
    } = swiper;
    const el = scrollbar.el;
    if (!el) return;
    const target = el;
    const activeListener = params.passiveListeners ? {
      passive: false,
      capture: false
    } : false;
    const passiveListener = params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    if (!target) return;
    const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
    target[eventMethod]('pointerdown', onDragStart, activeListener);
    document[eventMethod]('pointermove', onDragMove, activeListener);
    document[eventMethod]('pointerup', onDragEnd, passiveListener);
  }
  function enableDraggable() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    events('on');
  }
  function disableDraggable() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    events('off');
  }
  function init() {
    const {
      scrollbar,
      el: swiperEl
    } = swiper;
    swiper.params.scrollbar = (0,_shared_create_element_if_not_defined_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
      el: 'swiper-scrollbar'
    });
    const params = swiper.params.scrollbar;
    if (!params.el) return;
    let el;
    if (typeof params.el === 'string' && swiper.isElement) {
      el = swiper.el.querySelector(params.el);
    }
    if (!el && typeof params.el === 'string') {
      el = document.querySelectorAll(params.el);
      if (!el.length) return;
    } else if (!el) {
      el = params.el;
    }
    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) {
      el = swiperEl.querySelector(params.el);
    }
    if (el.length > 0) el = el[0];
    el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    let dragEl;
    if (el) {
      dragEl = el.querySelector((0,_shared_classes_to_selector_mjs__WEBPACK_IMPORTED_MODULE_3__.c)(swiper.params.scrollbar.dragClass));
      if (!dragEl) {
        dragEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)('div', swiper.params.scrollbar.dragClass);
        el.append(dragEl);
      }
    }
    Object.assign(scrollbar, {
      el,
      dragEl
    });
    if (params.draggable) {
      enableDraggable();
    }
    if (el) {
      el.classList[swiper.enabled ? 'remove' : 'add'](...(0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.i)(swiper.params.scrollbar.lockClass));
    }
  }
  function destroy() {
    const params = swiper.params.scrollbar;
    const el = swiper.scrollbar.el;
    if (el) {
      el.classList.remove(...(0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.i)(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass));
    }
    disableDraggable();
  }
  on('changeDirection', () => {
    if (!swiper.scrollbar || !swiper.scrollbar.el) return;
    const params = swiper.params.scrollbar;
    let {
      el
    } = swiper.scrollbar;
    el = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(el);
    el.forEach(subEl => {
      subEl.classList.remove(params.horizontalClass, params.verticalClass);
      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    });
  });
  on('init', () => {
    if (swiper.params.scrollbar.enabled === false) {
      // eslint-disable-next-line
      disable();
    } else {
      init();
      updateSize();
      setTranslate();
    }
  });
  on('update resize observerUpdate lock unlock changeDirection', () => {
    updateSize();
  });
  on('setTranslate', () => {
    setTranslate();
  });
  on('setTransition', (_s, duration) => {
    setTransition(duration);
  });
  on('enable disable', () => {
    const {
      el
    } = swiper.scrollbar;
    if (el) {
      el.classList[swiper.enabled ? 'remove' : 'add'](...(0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.i)(swiper.params.scrollbar.lockClass));
    }
  });
  on('destroy', () => {
    destroy();
  });
  const enable = () => {
    swiper.el.classList.remove(...(0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.i)(swiper.params.scrollbar.scrollbarDisabledClass));
    if (swiper.scrollbar.el) {
      swiper.scrollbar.el.classList.remove(...(0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.i)(swiper.params.scrollbar.scrollbarDisabledClass));
    }
    init();
    updateSize();
    setTranslate();
  };
  const disable = () => {
    swiper.el.classList.add(...(0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.i)(swiper.params.scrollbar.scrollbarDisabledClass));
    if (swiper.scrollbar.el) {
      swiper.scrollbar.el.classList.add(...(0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.i)(swiper.params.scrollbar.scrollbarDisabledClass));
    }
    destroy();
  };
  Object.assign(swiper.scrollbar, {
    enable,
    disable,
    updateSize,
    setTranslate,
    init,
    destroy
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/thumbs.mjs":
/*!************************************************!*\
  !*** ./node_modules/swiper/modules/thumbs.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Thumb)
/* harmony export */ });
/* harmony import */ var _shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/ssr-window.esm.mjs */ "./node_modules/swiper/shared/ssr-window.esm.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");



function Thumb(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    thumbs: {
      swiper: null,
      multipleActiveThumbs: true,
      autoScrollOffset: 0,
      slideThumbActiveClass: 'swiper-slide-thumb-active',
      thumbsContainerClass: 'swiper-thumbs'
    }
  });
  let initialized = false;
  let swiperCreated = false;
  swiper.thumbs = {
    swiper: null
  };
  function onThumbClick() {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    const clickedIndex = thumbsSwiper.clickedIndex;
    const clickedSlide = thumbsSwiper.clickedSlide;
    if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass)) return;
    if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
    let slideToIndex;
    if (thumbsSwiper.params.loop) {
      slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);
    } else {
      slideToIndex = clickedIndex;
    }
    if (swiper.params.loop) {
      swiper.slideToLoop(slideToIndex);
    } else {
      swiper.slideTo(slideToIndex);
    }
  }
  function init() {
    const {
      thumbs: thumbsParams
    } = swiper.params;
    if (initialized) return false;
    initialized = true;
    const SwiperClass = swiper.constructor;
    if (thumbsParams.swiper instanceof SwiperClass) {
      swiper.thumbs.swiper = thumbsParams.swiper;
      Object.assign(swiper.thumbs.swiper.originalParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      Object.assign(swiper.thumbs.swiper.params, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      swiper.thumbs.swiper.update();
    } else if ((0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.l)(thumbsParams.swiper)) {
      const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
      Object.assign(thumbsSwiperParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
      swiperCreated = true;
    }
    swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);
    swiper.thumbs.swiper.on('tap', onThumbClick);
    return true;
  }
  function update(initial) {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;

    // Activate thumbs
    let thumbsToActivate = 1;
    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
      thumbsToActivate = swiper.params.slidesPerView;
    }
    if (!swiper.params.thumbs.multipleActiveThumbs) {
      thumbsToActivate = 1;
    }
    thumbsToActivate = Math.floor(thumbsToActivate);
    thumbsSwiper.slides.forEach(slideEl => slideEl.classList.remove(thumbActiveClass));
    if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
      for (let i = 0; i < thumbsToActivate; i += 1) {
        (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(thumbsSwiper.slidesEl, `[data-swiper-slide-index="${swiper.realIndex + i}"]`).forEach(slideEl => {
          slideEl.classList.add(thumbActiveClass);
        });
      }
    } else {
      for (let i = 0; i < thumbsToActivate; i += 1) {
        if (thumbsSwiper.slides[swiper.realIndex + i]) {
          thumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);
        }
      }
    }
    const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
    const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
    if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
      const currentThumbsIndex = thumbsSwiper.activeIndex;
      let newThumbsIndex;
      let direction;
      if (thumbsSwiper.params.loop) {
        const newThumbsSlide = thumbsSwiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') === `${swiper.realIndex}`)[0];
        newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);
        direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
      } else {
        newThumbsIndex = swiper.realIndex;
        direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
      }
      if (useOffset) {
        newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
      }
      if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
        if (thumbsSwiper.params.centeredSlides) {
          if (newThumbsIndex > currentThumbsIndex) {
            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
          } else {
            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
          }
        } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) ;
        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
      }
    }
  }
  on('beforeInit', () => {
    const {
      thumbs
    } = swiper.params;
    if (!thumbs || !thumbs.swiper) return;
    if (typeof thumbs.swiper === 'string' || thumbs.swiper instanceof HTMLElement) {
      const document = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
      const getThumbsElementAndInit = () => {
        const thumbsElement = typeof thumbs.swiper === 'string' ? document.querySelector(thumbs.swiper) : thumbs.swiper;
        if (thumbsElement && thumbsElement.swiper) {
          thumbs.swiper = thumbsElement.swiper;
          init();
          update(true);
        } else if (thumbsElement) {
          const eventName = `${swiper.params.eventsPrefix}init`;
          const onThumbsSwiper = e => {
            thumbs.swiper = e.detail[0];
            thumbsElement.removeEventListener(eventName, onThumbsSwiper);
            init();
            update(true);
            thumbs.swiper.update();
            swiper.update();
          };
          thumbsElement.addEventListener(eventName, onThumbsSwiper);
        }
        return thumbsElement;
      };
      const watchForThumbsToAppear = () => {
        if (swiper.destroyed) return;
        const thumbsElement = getThumbsElementAndInit();
        if (!thumbsElement) {
          requestAnimationFrame(watchForThumbsToAppear);
        }
      };
      requestAnimationFrame(watchForThumbsToAppear);
    } else {
      init();
      update(true);
    }
  });
  on('slideChange update resize observerUpdate', () => {
    update();
  });
  on('setTransition', (_s, duration) => {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    thumbsSwiper.setTransition(duration);
  });
  on('beforeDestroy', () => {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    if (swiperCreated) {
      thumbsSwiper.destroy();
    }
  });
  Object.assign(swiper.thumbs, {
    init,
    update
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/virtual.mjs":
/*!*************************************************!*\
  !*** ./node_modules/swiper/modules/virtual.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Virtual)
/* harmony export */ });
/* harmony import */ var _shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/ssr-window.esm.mjs */ "./node_modules/swiper/shared/ssr-window.esm.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");



function Virtual(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  extendParams({
    virtual: {
      enabled: false,
      slides: [],
      cache: true,
      renderSlide: null,
      renderExternal: null,
      renderExternalUpdate: true,
      addSlidesBefore: 0,
      addSlidesAfter: 0
    }
  });
  let cssModeTimeout;
  const document = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
  swiper.virtual = {
    cache: {},
    from: undefined,
    to: undefined,
    slides: [],
    offset: 0,
    slidesGrid: []
  };
  const tempDOM = document.createElement('div');
  function renderSlide(slide, index) {
    const params = swiper.params.virtual;
    if (params.cache && swiper.virtual.cache[index]) {
      return swiper.virtual.cache[index];
    }
    // eslint-disable-next-line
    let slideEl;
    if (params.renderSlide) {
      slideEl = params.renderSlide.call(swiper, slide, index);
      if (typeof slideEl === 'string') {
        tempDOM.innerHTML = slideEl;
        slideEl = tempDOM.children[0];
      }
    } else if (swiper.isElement) {
      slideEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)('swiper-slide');
    } else {
      slideEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)('div', swiper.params.slideClass);
    }
    slideEl.setAttribute('data-swiper-slide-index', index);
    if (!params.renderSlide) {
      slideEl.innerHTML = slide;
    }
    if (params.cache) {
      swiper.virtual.cache[index] = slideEl;
    }
    return slideEl;
  }
  function update(force, beforeInit) {
    const {
      slidesPerView,
      slidesPerGroup,
      centeredSlides,
      loop: isLoop,
      initialSlide
    } = swiper.params;
    if (beforeInit && !isLoop && initialSlide > 0) {
      return;
    }
    const {
      addSlidesBefore,
      addSlidesAfter
    } = swiper.params.virtual;
    const {
      from: previousFrom,
      to: previousTo,
      slides,
      slidesGrid: previousSlidesGrid,
      offset: previousOffset
    } = swiper.virtual;
    if (!swiper.params.cssMode) {
      swiper.updateActiveIndex();
    }
    const activeIndex = swiper.activeIndex || 0;
    let offsetProp;
    if (swiper.rtlTranslate) offsetProp = 'right';else offsetProp = swiper.isHorizontal() ? 'left' : 'top';
    let slidesAfter;
    let slidesBefore;
    if (centeredSlides) {
      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
    } else {
      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
      slidesBefore = (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;
    }
    let from = activeIndex - slidesBefore;
    let to = activeIndex + slidesAfter;
    if (!isLoop) {
      from = Math.max(from, 0);
      to = Math.min(to, slides.length - 1);
    }
    let offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
    if (isLoop && activeIndex >= slidesBefore) {
      from -= slidesBefore;
      if (!centeredSlides) offset += swiper.slidesGrid[0];
    } else if (isLoop && activeIndex < slidesBefore) {
      from = -slidesBefore;
      if (centeredSlides) offset += swiper.slidesGrid[0];
    }
    Object.assign(swiper.virtual, {
      from,
      to,
      offset,
      slidesGrid: swiper.slidesGrid,
      slidesBefore,
      slidesAfter
    });
    function onRendered() {
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();
      emit('virtualUpdate');
    }
    if (previousFrom === from && previousTo === to && !force) {
      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
        swiper.slides.forEach(slideEl => {
          slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;
        });
      }
      swiper.updateProgress();
      emit('virtualUpdate');
      return;
    }
    if (swiper.params.virtual.renderExternal) {
      swiper.params.virtual.renderExternal.call(swiper, {
        offset,
        from,
        to,
        slides: function getSlides() {
          const slidesToRender = [];
          for (let i = from; i <= to; i += 1) {
            slidesToRender.push(slides[i]);
          }
          return slidesToRender;
        }()
      });
      if (swiper.params.virtual.renderExternalUpdate) {
        onRendered();
      } else {
        emit('virtualUpdate');
      }
      return;
    }
    const prependIndexes = [];
    const appendIndexes = [];
    const getSlideIndex = index => {
      let slideIndex = index;
      if (index < 0) {
        slideIndex = slides.length + index;
      } else if (slideIndex >= slides.length) {
        // eslint-disable-next-line
        slideIndex = slideIndex - slides.length;
      }
      return slideIndex;
    };
    if (force) {
      swiper.slides.filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`)).forEach(slideEl => {
        slideEl.remove();
      });
    } else {
      for (let i = previousFrom; i <= previousTo; i += 1) {
        if (i < from || i > to) {
          const slideIndex = getSlideIndex(i);
          swiper.slides.filter(el => el.matches(`.${swiper.params.slideClass}[data-swiper-slide-index="${slideIndex}"], swiper-slide[data-swiper-slide-index="${slideIndex}"]`)).forEach(slideEl => {
            slideEl.remove();
          });
        }
      }
    }
    const loopFrom = isLoop ? -slides.length : 0;
    const loopTo = isLoop ? slides.length * 2 : slides.length;
    for (let i = loopFrom; i < loopTo; i += 1) {
      if (i >= from && i <= to) {
        const slideIndex = getSlideIndex(i);
        if (typeof previousTo === 'undefined' || force) {
          appendIndexes.push(slideIndex);
        } else {
          if (i > previousTo) appendIndexes.push(slideIndex);
          if (i < previousFrom) prependIndexes.push(slideIndex);
        }
      }
    }
    appendIndexes.forEach(index => {
      swiper.slidesEl.append(renderSlide(slides[index], index));
    });
    if (isLoop) {
      for (let i = prependIndexes.length - 1; i >= 0; i -= 1) {
        const index = prependIndexes[i];
        swiper.slidesEl.prepend(renderSlide(slides[index], index));
      }
    } else {
      prependIndexes.sort((a, b) => b - a);
      prependIndexes.forEach(index => {
        swiper.slidesEl.prepend(renderSlide(slides[index], index));
      });
    }
    (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(swiper.slidesEl, '.swiper-slide, swiper-slide').forEach(slideEl => {
      slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;
    });
    onRendered();
  }
  function appendSlide(slides) {
    if (typeof slides === 'object' && 'length' in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.push(slides[i]);
      }
    } else {
      swiper.virtual.slides.push(slides);
    }
    update(true);
  }
  function prependSlide(slides) {
    const activeIndex = swiper.activeIndex;
    let newActiveIndex = activeIndex + 1;
    let numberOfNewSlides = 1;
    if (Array.isArray(slides)) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
      }
      newActiveIndex = activeIndex + slides.length;
      numberOfNewSlides = slides.length;
    } else {
      swiper.virtual.slides.unshift(slides);
    }
    if (swiper.params.virtual.cache) {
      const cache = swiper.virtual.cache;
      const newCache = {};
      Object.keys(cache).forEach(cachedIndex => {
        const cachedEl = cache[cachedIndex];
        const cachedElIndex = cachedEl.getAttribute('data-swiper-slide-index');
        if (cachedElIndex) {
          cachedEl.setAttribute('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);
        }
        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;
      });
      swiper.virtual.cache = newCache;
    }
    update(true);
    swiper.slideTo(newActiveIndex, 0);
  }
  function removeSlide(slidesIndexes) {
    if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
    let activeIndex = swiper.activeIndex;
    if (Array.isArray(slidesIndexes)) {
      for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
        if (swiper.params.virtual.cache) {
          delete swiper.virtual.cache[slidesIndexes[i]];
          // shift cache indexes
          Object.keys(swiper.virtual.cache).forEach(key => {
            if (key > slidesIndexes) {
              swiper.virtual.cache[key - 1] = swiper.virtual.cache[key];
              swiper.virtual.cache[key - 1].setAttribute('data-swiper-slide-index', key - 1);
              delete swiper.virtual.cache[key];
            }
          });
        }
        swiper.virtual.slides.splice(slidesIndexes[i], 1);
        if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
        activeIndex = Math.max(activeIndex, 0);
      }
    } else {
      if (swiper.params.virtual.cache) {
        delete swiper.virtual.cache[slidesIndexes];
        // shift cache indexes
        Object.keys(swiper.virtual.cache).forEach(key => {
          if (key > slidesIndexes) {
            swiper.virtual.cache[key - 1] = swiper.virtual.cache[key];
            swiper.virtual.cache[key - 1].setAttribute('data-swiper-slide-index', key - 1);
            delete swiper.virtual.cache[key];
          }
        });
      }
      swiper.virtual.slides.splice(slidesIndexes, 1);
      if (slidesIndexes < activeIndex) activeIndex -= 1;
      activeIndex = Math.max(activeIndex, 0);
    }
    update(true);
    swiper.slideTo(activeIndex, 0);
  }
  function removeAllSlides() {
    swiper.virtual.slides = [];
    if (swiper.params.virtual.cache) {
      swiper.virtual.cache = {};
    }
    update(true);
    swiper.slideTo(0, 0);
  }
  on('beforeInit', () => {
    if (!swiper.params.virtual.enabled) return;
    let domSlidesAssigned;
    if (typeof swiper.passedParams.virtual.slides === 'undefined') {
      const slides = [...swiper.slidesEl.children].filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`));
      if (slides && slides.length) {
        swiper.virtual.slides = [...slides];
        domSlidesAssigned = true;
        slides.forEach((slideEl, slideIndex) => {
          slideEl.setAttribute('data-swiper-slide-index', slideIndex);
          swiper.virtual.cache[slideIndex] = slideEl;
          slideEl.remove();
        });
      }
    }
    if (!domSlidesAssigned) {
      swiper.virtual.slides = swiper.params.virtual.slides;
    }
    swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
    swiper.params.watchSlidesProgress = true;
    swiper.originalParams.watchSlidesProgress = true;
    update(false, true);
  });
  on('setTranslate', () => {
    if (!swiper.params.virtual.enabled) return;
    if (swiper.params.cssMode && !swiper._immediateVirtual) {
      clearTimeout(cssModeTimeout);
      cssModeTimeout = setTimeout(() => {
        update();
      }, 100);
    } else {
      update();
    }
  });
  on('init update resize', () => {
    if (!swiper.params.virtual.enabled) return;
    if (swiper.params.cssMode) {
      (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);
    }
  });
  Object.assign(swiper.virtual, {
    appendSlide,
    prependSlide,
    removeSlide,
    removeAllSlides,
    update
  });
}




/***/ }),

/***/ "./node_modules/swiper/modules/zoom.mjs":
/*!**********************************************!*\
  !*** ./node_modules/swiper/modules/zoom.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Zoom)
/* harmony export */ });
/* harmony import */ var _shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/ssr-window.esm.mjs */ "./node_modules/swiper/shared/ssr-window.esm.mjs");
/* harmony import */ var _shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils.mjs */ "./node_modules/swiper/shared/utils.mjs");



function Zoom(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const window = (0,_shared_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  extendParams({
    zoom: {
      enabled: false,
      limitToOriginalSize: false,
      maxRatio: 3,
      minRatio: 1,
      toggle: true,
      containerClass: 'swiper-zoom-container',
      zoomedSlideClass: 'swiper-slide-zoomed'
    }
  });
  swiper.zoom = {
    enabled: false
  };
  let currentScale = 1;
  let isScaling = false;
  let fakeGestureTouched;
  let fakeGestureMoved;
  const evCache = [];
  const gesture = {
    originX: 0,
    originY: 0,
    slideEl: undefined,
    slideWidth: undefined,
    slideHeight: undefined,
    imageEl: undefined,
    imageWrapEl: undefined,
    maxRatio: 3
  };
  const image = {
    isTouched: undefined,
    isMoved: undefined,
    currentX: undefined,
    currentY: undefined,
    minX: undefined,
    minY: undefined,
    maxX: undefined,
    maxY: undefined,
    width: undefined,
    height: undefined,
    startX: undefined,
    startY: undefined,
    touchesStart: {},
    touchesCurrent: {}
  };
  const velocity = {
    x: undefined,
    y: undefined,
    prevPositionX: undefined,
    prevPositionY: undefined,
    prevTime: undefined
  };
  let scale = 1;
  Object.defineProperty(swiper.zoom, 'scale', {
    get() {
      return scale;
    },
    set(value) {
      if (scale !== value) {
        const imageEl = gesture.imageEl;
        const slideEl = gesture.slideEl;
        emit('zoomChange', value, imageEl, slideEl);
      }
      scale = value;
    }
  });
  function getDistanceBetweenTouches() {
    if (evCache.length < 2) return 1;
    const x1 = evCache[0].pageX;
    const y1 = evCache[0].pageY;
    const x2 = evCache[1].pageX;
    const y2 = evCache[1].pageY;
    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    return distance;
  }
  function getMaxRatio() {
    const params = swiper.params.zoom;
    const maxRatio = gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;
    if (params.limitToOriginalSize && gesture.imageEl && gesture.imageEl.naturalWidth) {
      const imageMaxRatio = gesture.imageEl.naturalWidth / gesture.imageEl.offsetWidth;
      return Math.min(imageMaxRatio, maxRatio);
    }
    return maxRatio;
  }
  function getScaleOrigin() {
    if (evCache.length < 2) return {
      x: null,
      y: null
    };
    const box = gesture.imageEl.getBoundingClientRect();
    return [(evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x - window.scrollX) / currentScale, (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y - window.scrollY) / currentScale];
  }
  function getSlideSelector() {
    return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
  }
  function eventWithinSlide(e) {
    const slideSelector = getSlideSelector();
    if (e.target.matches(slideSelector)) return true;
    if (swiper.slides.filter(slideEl => slideEl.contains(e.target)).length > 0) return true;
    return false;
  }
  function eventWithinZoomContainer(e) {
    const selector = `.${swiper.params.zoom.containerClass}`;
    if (e.target.matches(selector)) return true;
    if ([...swiper.hostEl.querySelectorAll(selector)].filter(containerEl => containerEl.contains(e.target)).length > 0) return true;
    return false;
  }

  // Events
  function onGestureStart(e) {
    if (e.pointerType === 'mouse') {
      evCache.splice(0, evCache.length);
    }
    if (!eventWithinSlide(e)) return;
    const params = swiper.params.zoom;
    fakeGestureTouched = false;
    fakeGestureMoved = false;
    evCache.push(e);
    if (evCache.length < 2) {
      return;
    }
    fakeGestureTouched = true;
    gesture.scaleStart = getDistanceBetweenTouches();
    if (!gesture.slideEl) {
      gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
      if (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];
      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
      if (imageEl) {
        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];
      }
      gesture.imageEl = imageEl;
      if (imageEl) {
        gesture.imageWrapEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.a)(gesture.imageEl, `.${params.containerClass}`)[0];
      } else {
        gesture.imageWrapEl = undefined;
      }
      if (!gesture.imageWrapEl) {
        gesture.imageEl = undefined;
        return;
      }
      gesture.maxRatio = getMaxRatio();
    }
    if (gesture.imageEl) {
      const [originX, originY] = getScaleOrigin();
      gesture.originX = originX;
      gesture.originY = originY;
      gesture.imageEl.style.transitionDuration = '0ms';
    }
    isScaling = true;
  }
  function onGestureChange(e) {
    if (!eventWithinSlide(e)) return;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);
    if (pointerIndex >= 0) evCache[pointerIndex] = e;
    if (evCache.length < 2) {
      return;
    }
    fakeGestureMoved = true;
    gesture.scaleMove = getDistanceBetweenTouches();
    if (!gesture.imageEl) {
      return;
    }
    zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;
    if (zoom.scale > gesture.maxRatio) {
      zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;
    }
    if (zoom.scale < params.minRatio) {
      zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;
    }
    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
  }
  function onGestureEnd(e) {
    if (!eventWithinSlide(e)) return;
    if (e.pointerType === 'mouse' && e.type === 'pointerout') return;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);
    if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);
    if (!fakeGestureTouched || !fakeGestureMoved) {
      return;
    }
    fakeGestureTouched = false;
    fakeGestureMoved = false;
    if (!gesture.imageEl) return;
    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
    gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;
    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
    currentScale = zoom.scale;
    isScaling = false;
    if (zoom.scale > 1 && gesture.slideEl) {
      gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);
    } else if (zoom.scale <= 1 && gesture.slideEl) {
      gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);
    }
    if (zoom.scale === 1) {
      gesture.originX = 0;
      gesture.originY = 0;
      gesture.slideEl = undefined;
    }
  }
  let allowTouchMoveTimeout;
  function allowTouchMove() {
    swiper.touchEventsData.preventTouchMoveFromPointerMove = false;
  }
  function preventTouchMove() {
    clearTimeout(allowTouchMoveTimeout);
    swiper.touchEventsData.preventTouchMoveFromPointerMove = true;
    allowTouchMoveTimeout = setTimeout(() => {
      if (swiper.destroyed) return;
      allowTouchMove();
    });
  }
  function onTouchStart(e) {
    const device = swiper.device;
    if (!gesture.imageEl) return;
    if (image.isTouched) return;
    if (device.android && e.cancelable) e.preventDefault();
    image.isTouched = true;
    const event = evCache.length > 0 ? evCache[0] : e;
    image.touchesStart.x = event.pageX;
    image.touchesStart.y = event.pageY;
  }
  function onTouchMove(e) {
    if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) {
      return;
    }
    const zoom = swiper.zoom;
    if (!gesture.imageEl) {
      return;
    }
    if (!image.isTouched || !gesture.slideEl) {
      return;
    }
    if (!image.isMoved) {
      image.width = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;
      image.height = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;
      image.startX = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.j)(gesture.imageWrapEl, 'x') || 0;
      image.startY = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.j)(gesture.imageWrapEl, 'y') || 0;
      gesture.slideWidth = gesture.slideEl.offsetWidth;
      gesture.slideHeight = gesture.slideEl.offsetHeight;
      gesture.imageWrapEl.style.transitionDuration = '0ms';
    }
    // Define if we need image drag
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;
    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
    image.maxX = -image.minX;
    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
    image.maxY = -image.minY;
    image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;
    image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;
    const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));
    if (touchesDiff > 5) {
      swiper.allowClick = false;
    }
    if (!image.isMoved && !isScaling) {
      if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
        image.isTouched = false;
        allowTouchMove();
        return;
      }
      if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
        image.isTouched = false;
        allowTouchMove();
        return;
      }
    }
    if (e.cancelable) {
      e.preventDefault();
    }
    e.stopPropagation();
    preventTouchMove();
    image.isMoved = true;
    const scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);
    const {
      originX,
      originY
    } = gesture;
    image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);
    image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);
    if (image.currentX < image.minX) {
      image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;
    }
    if (image.currentX > image.maxX) {
      image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;
    }
    if (image.currentY < image.minY) {
      image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;
    }
    if (image.currentY > image.maxY) {
      image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;
    }

    // Velocity
    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
    if (!velocity.prevTime) velocity.prevTime = Date.now();
    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
    velocity.prevPositionX = image.touchesCurrent.x;
    velocity.prevPositionY = image.touchesCurrent.y;
    velocity.prevTime = Date.now();
    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;
  }
  function onTouchEnd() {
    const zoom = swiper.zoom;
    if (!gesture.imageEl) return;
    if (!image.isTouched || !image.isMoved) {
      image.isTouched = false;
      image.isMoved = false;
      return;
    }
    image.isTouched = false;
    image.isMoved = false;
    let momentumDurationX = 300;
    let momentumDurationY = 300;
    const momentumDistanceX = velocity.x * momentumDurationX;
    const newPositionX = image.currentX + momentumDistanceX;
    const momentumDistanceY = velocity.y * momentumDurationY;
    const newPositionY = image.currentY + momentumDistanceY;

    // Fix duration
    if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
    if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
    image.currentX = newPositionX;
    image.currentY = newPositionY;
    // Define if we need image drag
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;
    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
    image.maxX = -image.minX;
    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
    image.maxY = -image.minY;
    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
    gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;
    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;
  }
  function onTransitionEnd() {
    const zoom = swiper.zoom;
    if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {
      if (gesture.imageEl) {
        gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';
      }
      if (gesture.imageWrapEl) {
        gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';
      }
      gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);
      zoom.scale = 1;
      currentScale = 1;
      gesture.slideEl = undefined;
      gesture.imageEl = undefined;
      gesture.imageWrapEl = undefined;
      gesture.originX = 0;
      gesture.originY = 0;
    }
  }
  function zoomIn(e) {
    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    if (!gesture.slideEl) {
      if (e && e.target) {
        gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
      }
      if (!gesture.slideEl) {
        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
          gesture.slideEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];
        } else {
          gesture.slideEl = swiper.slides[swiper.activeIndex];
        }
      }
      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
      if (imageEl) {
        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];
      }
      gesture.imageEl = imageEl;
      if (imageEl) {
        gesture.imageWrapEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.a)(gesture.imageEl, `.${params.containerClass}`)[0];
      } else {
        gesture.imageWrapEl = undefined;
      }
    }
    if (!gesture.imageEl || !gesture.imageWrapEl) return;
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style.overflow = 'hidden';
      swiper.wrapperEl.style.touchAction = 'none';
    }
    gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);
    let touchX;
    let touchY;
    let offsetX;
    let offsetY;
    let diffX;
    let diffY;
    let translateX;
    let translateY;
    let imageWidth;
    let imageHeight;
    let scaledWidth;
    let scaledHeight;
    let translateMinX;
    let translateMinY;
    let translateMaxX;
    let translateMaxY;
    let slideWidth;
    let slideHeight;
    if (typeof image.touchesStart.x === 'undefined' && e) {
      touchX = e.pageX;
      touchY = e.pageY;
    } else {
      touchX = image.touchesStart.x;
      touchY = image.touchesStart.y;
    }
    const forceZoomRatio = typeof e === 'number' ? e : null;
    if (currentScale === 1 && forceZoomRatio) {
      touchX = undefined;
      touchY = undefined;
      image.touchesStart.x = undefined;
      image.touchesStart.y = undefined;
    }
    const maxRatio = getMaxRatio();
    zoom.scale = forceZoomRatio || maxRatio;
    currentScale = forceZoomRatio || maxRatio;
    if (e && !(currentScale === 1 && forceZoomRatio)) {
      slideWidth = gesture.slideEl.offsetWidth;
      slideHeight = gesture.slideEl.offsetHeight;
      offsetX = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.b)(gesture.slideEl).left + window.scrollX;
      offsetY = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.b)(gesture.slideEl).top + window.scrollY;
      diffX = offsetX + slideWidth / 2 - touchX;
      diffY = offsetY + slideHeight / 2 - touchY;
      imageWidth = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;
      imageHeight = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;
      scaledWidth = imageWidth * zoom.scale;
      scaledHeight = imageHeight * zoom.scale;
      translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
      translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
      translateMaxX = -translateMinX;
      translateMaxY = -translateMinY;
      translateX = diffX * zoom.scale;
      translateY = diffY * zoom.scale;
      if (translateX < translateMinX) {
        translateX = translateMinX;
      }
      if (translateX > translateMaxX) {
        translateX = translateMaxX;
      }
      if (translateY < translateMinY) {
        translateY = translateMinY;
      }
      if (translateY > translateMaxY) {
        translateY = translateMaxY;
      }
    } else {
      translateX = 0;
      translateY = 0;
    }
    if (forceZoomRatio && zoom.scale === 1) {
      gesture.originX = 0;
      gesture.originY = 0;
    }
    gesture.imageWrapEl.style.transitionDuration = '300ms';
    gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;
    gesture.imageEl.style.transitionDuration = '300ms';
    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
  }
  function zoomOut() {
    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    if (!gesture.slideEl) {
      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
        gesture.slideEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];
      } else {
        gesture.slideEl = swiper.slides[swiper.activeIndex];
      }
      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
      if (imageEl) {
        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];
      }
      gesture.imageEl = imageEl;
      if (imageEl) {
        gesture.imageWrapEl = (0,_shared_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.a)(gesture.imageEl, `.${params.containerClass}`)[0];
      } else {
        gesture.imageWrapEl = undefined;
      }
    }
    if (!gesture.imageEl || !gesture.imageWrapEl) return;
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style.overflow = '';
      swiper.wrapperEl.style.touchAction = '';
    }
    zoom.scale = 1;
    currentScale = 1;
    image.touchesStart.x = undefined;
    image.touchesStart.y = undefined;
    gesture.imageWrapEl.style.transitionDuration = '300ms';
    gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';
    gesture.imageEl.style.transitionDuration = '300ms';
    gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';
    gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);
    gesture.slideEl = undefined;
    gesture.originX = 0;
    gesture.originY = 0;
  }

  // Toggle Zoom
  function zoomToggle(e) {
    const zoom = swiper.zoom;
    if (zoom.scale && zoom.scale !== 1) {
      // Zoom Out
      zoomOut();
    } else {
      // Zoom In
      zoomIn(e);
    }
  }
  function getListeners() {
    const passiveListener = swiper.params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    const activeListenerWithCapture = swiper.params.passiveListeners ? {
      passive: false,
      capture: true
    } : true;
    return {
      passiveListener,
      activeListenerWithCapture
    };
  }

  // Attach/Detach Events
  function enable() {
    const zoom = swiper.zoom;
    if (zoom.enabled) return;
    zoom.enabled = true;
    const {
      passiveListener,
      activeListenerWithCapture
    } = getListeners();

    // Scale image
    swiper.wrapperEl.addEventListener('pointerdown', onGestureStart, passiveListener);
    swiper.wrapperEl.addEventListener('pointermove', onGestureChange, activeListenerWithCapture);
    ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {
      swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);
    });

    // Move image
    swiper.wrapperEl.addEventListener('pointermove', onTouchMove, activeListenerWithCapture);
  }
  function disable() {
    const zoom = swiper.zoom;
    if (!zoom.enabled) return;
    zoom.enabled = false;
    const {
      passiveListener,
      activeListenerWithCapture
    } = getListeners();

    // Scale image
    swiper.wrapperEl.removeEventListener('pointerdown', onGestureStart, passiveListener);
    swiper.wrapperEl.removeEventListener('pointermove', onGestureChange, activeListenerWithCapture);
    ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {
      swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);
    });

    // Move image
    swiper.wrapperEl.removeEventListener('pointermove', onTouchMove, activeListenerWithCapture);
  }
  on('init', () => {
    if (swiper.params.zoom.enabled) {
      enable();
    }
  });
  on('destroy', () => {
    disable();
  });
  on('touchStart', (_s, e) => {
    if (!swiper.zoom.enabled) return;
    onTouchStart(e);
  });
  on('touchEnd', (_s, e) => {
    if (!swiper.zoom.enabled) return;
    onTouchEnd();
  });
  on('doubleTap', (_s, e) => {
    if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
      zoomToggle(e);
    }
  });
  on('transitionEnd', () => {
    if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
      onTransitionEnd();
    }
  });
  on('slideChange', () => {
    if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
      onTransitionEnd();
    }
  });
  Object.assign(swiper.zoom, {
    enable,
    disable,
    in: zoomIn,
    out: zoomOut,
    toggle: zoomToggle
  });
}




/***/ }),

/***/ "./node_modules/swiper/shared/classes-to-selector.mjs":
/*!************************************************************!*\
  !*** ./node_modules/swiper/shared/classes-to-selector.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ classesToSelector)
/* harmony export */ });
function classesToSelector(classes) {
  if (classes === void 0) {
    classes = '';
  }
  return `.${classes.trim().replace(/([\.:!+\/])/g, '\\$1') // eslint-disable-line
  .replace(/ /g, '.')}`;
}




/***/ }),

/***/ "./node_modules/swiper/shared/create-element-if-not-defined.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/swiper/shared/create-element-if-not-defined.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createElementIfNotDefined)
/* harmony export */ });
/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.mjs */ "./node_modules/swiper/shared/utils.mjs");


function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
  if (swiper.params.createElements) {
    Object.keys(checkProps).forEach(key => {
      if (!params[key] && params.auto === true) {
        let element = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.e)(swiper.el, `.${checkProps[key]}`)[0];
        if (!element) {
          element = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.c)('div', checkProps[key]);
          element.className = checkProps[key];
          swiper.el.append(element);
        }
        params[key] = element;
        originalParams[key] = element;
      }
    });
  }
  return params;
}




/***/ }),

/***/ "./node_modules/swiper/shared/create-shadow.mjs":
/*!******************************************************!*\
  !*** ./node_modules/swiper/shared/create-shadow.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createShadow)
/* harmony export */ });
/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.mjs */ "./node_modules/swiper/shared/utils.mjs");


function createShadow(suffix, slideEl, side) {
  const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}${suffix ? ` swiper-slide-shadow-${suffix}` : ''}`;
  const shadowContainer = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(slideEl);
  let shadowEl = shadowContainer.querySelector(`.${shadowClass.split(' ').join('.')}`);
  if (!shadowEl) {
    shadowEl = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.c)('div', shadowClass.split(' '));
    shadowContainer.append(shadowEl);
  }
  return shadowEl;
}




/***/ }),

/***/ "./node_modules/swiper/shared/effect-init.mjs":
/*!****************************************************!*\
  !*** ./node_modules/swiper/shared/effect-init.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   e: () => (/* binding */ effectInit)
/* harmony export */ });
function effectInit(params) {
  const {
    effect,
    swiper,
    on,
    setTranslate,
    setTransition,
    overwriteParams,
    perspective,
    recreateShadows,
    getEffectParams
  } = params;
  on('beforeInit', () => {
    if (swiper.params.effect !== effect) return;
    swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);
    if (perspective && perspective()) {
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
    }
    const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
    Object.assign(swiper.params, overwriteParamsResult);
    Object.assign(swiper.originalParams, overwriteParamsResult);
  });
  on('setTranslate', () => {
    if (swiper.params.effect !== effect) return;
    setTranslate();
  });
  on('setTransition', (_s, duration) => {
    if (swiper.params.effect !== effect) return;
    setTransition(duration);
  });
  on('transitionEnd', () => {
    if (swiper.params.effect !== effect) return;
    if (recreateShadows) {
      if (!getEffectParams || !getEffectParams().slideShadows) return;
      // remove shadows
      swiper.slides.forEach(slideEl => {
        slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => shadowEl.remove());
      });
      // create new one
      recreateShadows();
    }
  });
  let requireUpdateOnVirtual;
  on('virtualUpdate', () => {
    if (swiper.params.effect !== effect) return;
    if (!swiper.slides.length) {
      requireUpdateOnVirtual = true;
    }
    requestAnimationFrame(() => {
      if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
        setTranslate();
        requireUpdateOnVirtual = false;
      }
    });
  });
}




/***/ }),

/***/ "./node_modules/swiper/shared/effect-target.mjs":
/*!******************************************************!*\
  !*** ./node_modules/swiper/shared/effect-target.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   e: () => (/* binding */ effectTarget)
/* harmony export */ });
/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.mjs */ "./node_modules/swiper/shared/utils.mjs");


function effectTarget(effectParams, slideEl) {
  const transformEl = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(slideEl);
  if (transformEl !== slideEl) {
    transformEl.style.backfaceVisibility = 'hidden';
    transformEl.style['-webkit-backface-visibility'] = 'hidden';
  }
  return transformEl;
}




/***/ }),

/***/ "./node_modules/swiper/shared/effect-virtual-transition-end.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/swiper/shared/effect-virtual-transition-end.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   e: () => (/* binding */ effectVirtualTransitionEnd)
/* harmony export */ });
/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.mjs */ "./node_modules/swiper/shared/utils.mjs");


function effectVirtualTransitionEnd(_ref) {
  let {
    swiper,
    duration,
    transformElements,
    allSlides
  } = _ref;
  const {
    activeIndex
  } = swiper;
  const getSlide = el => {
    if (!el.parentElement) {
      // assume shadow root
      const slide = swiper.slides.filter(slideEl => slideEl.shadowRoot && slideEl.shadowRoot === el.parentNode)[0];
      return slide;
    }
    return el.parentElement;
  };
  if (swiper.params.virtualTranslate && duration !== 0) {
    let eventTriggered = false;
    let transitionEndTarget;
    if (allSlides) {
      transitionEndTarget = transformElements;
    } else {
      transitionEndTarget = transformElements.filter(transformEl => {
        const el = transformEl.classList.contains('swiper-slide-transform') ? getSlide(transformEl) : transformEl;
        return swiper.getSlideIndex(el) === activeIndex;
      });
    }
    transitionEndTarget.forEach(el => {
      (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(el, () => {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return;
        eventTriggered = true;
        swiper.animating = false;
        const evt = new window.CustomEvent('transitionend', {
          bubbles: true,
          cancelable: true
        });
        swiper.wrapperEl.dispatchEvent(evt);
      });
    });
  }
}




/***/ }),

/***/ "./node_modules/swiper/shared/ssr-window.esm.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/swiper/shared/ssr-window.esm.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getWindow),
/* harmony export */   g: () => (/* binding */ getDocument)
/* harmony export */ });
/**
 * SSR Window 4.0.2
 * Better handling for window object in SSR environment
 * https://github.com/nolimits4web/ssr-window
 *
 * Copyright 2021, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: December 13, 2021
 */
/* eslint-disable no-param-reassign */
function isObject(obj) {
  return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;
}
function extend(target, src) {
  if (target === void 0) {
    target = {};
  }
  if (src === void 0) {
    src = {};
  }
  Object.keys(src).forEach(key => {
    if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {
      extend(target[key], src[key]);
    }
  });
}
const ssrDocument = {
  body: {},
  addEventListener() {},
  removeEventListener() {},
  activeElement: {
    blur() {},
    nodeName: ''
  },
  querySelector() {
    return null;
  },
  querySelectorAll() {
    return [];
  },
  getElementById() {
    return null;
  },
  createEvent() {
    return {
      initEvent() {}
    };
  },
  createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {},
      getElementsByTagName() {
        return [];
      }
    };
  },
  createElementNS() {
    return {};
  },
  importNode() {
    return null;
  },
  location: {
    hash: '',
    host: '',
    hostname: '',
    href: '',
    origin: '',
    pathname: '',
    protocol: '',
    search: ''
  }
};
function getDocument() {
  const doc = typeof document !== 'undefined' ? document : {};
  extend(doc, ssrDocument);
  return doc;
}
const ssrWindow = {
  document: ssrDocument,
  navigator: {
    userAgent: ''
  },
  location: {
    hash: '',
    host: '',
    hostname: '',
    href: '',
    origin: '',
    pathname: '',
    protocol: '',
    search: ''
  },
  history: {
    replaceState() {},
    pushState() {},
    go() {},
    back() {}
  },
  CustomEvent: function CustomEvent() {
    return this;
  },
  addEventListener() {},
  removeEventListener() {},
  getComputedStyle() {
    return {
      getPropertyValue() {
        return '';
      }
    };
  },
  Image() {},
  Date() {},
  screen: {},
  setTimeout() {},
  clearTimeout() {},
  matchMedia() {
    return {};
  },
  requestAnimationFrame(callback) {
    if (typeof setTimeout === 'undefined') {
      callback();
      return null;
    }
    return setTimeout(callback, 0);
  },
  cancelAnimationFrame(id) {
    if (typeof setTimeout === 'undefined') {
      return;
    }
    clearTimeout(id);
  }
};
function getWindow() {
  const win = typeof window !== 'undefined' ? window : {};
  extend(win, ssrWindow);
  return win;
}




/***/ }),

/***/ "./node_modules/swiper/shared/swiper-core.mjs":
/*!****************************************************!*\
  !*** ./node_modules/swiper/shared/swiper-core.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   S: () => (/* binding */ Swiper),
/* harmony export */   d: () => (/* binding */ defaults)
/* harmony export */ });
/* harmony import */ var _ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ssr-window.esm.mjs */ "./node_modules/swiper/shared/ssr-window.esm.mjs");
/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.mjs */ "./node_modules/swiper/shared/utils.mjs");



let support;
function calcSupport() {
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  const document = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
  return {
    smoothScroll: document.documentElement && document.documentElement.style && 'scrollBehavior' in document.documentElement.style,
    touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch)
  };
}
function getSupport() {
  if (!support) {
    support = calcSupport();
  }
  return support;
}

let deviceCached;
function calcDevice(_temp) {
  let {
    userAgent
  } = _temp === void 0 ? {} : _temp;
  const support = getSupport();
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  const platform = window.navigator.platform;
  const ua = userAgent || window.navigator.userAgent;
  const device = {
    ios: false,
    android: false
  };
  const screenWidth = window.screen.width;
  const screenHeight = window.screen.height;
  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
  let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  const windows = platform === 'Win32';
  let macos = platform === 'MacIntel';

  // iPadOs 13 fix
  const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];
  if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad) ipad = [0, 1, '13_0_0'];
    macos = false;
  }

  // Android
  if (android && !windows) {
    device.os = 'android';
    device.android = true;
  }
  if (ipad || iphone || ipod) {
    device.os = 'ios';
    device.ios = true;
  }

  // Export object
  return device;
}
function getDevice(overrides) {
  if (overrides === void 0) {
    overrides = {};
  }
  if (!deviceCached) {
    deviceCached = calcDevice(overrides);
  }
  return deviceCached;
}

let browser;
function calcBrowser() {
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  const device = getDevice();
  let needPerspectiveFix = false;
  function isSafari() {
    const ua = window.navigator.userAgent.toLowerCase();
    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
  }
  if (isSafari()) {
    const ua = String(window.navigator.userAgent);
    if (ua.includes('Version/')) {
      const [major, minor] = ua.split('Version/')[1].split(' ')[0].split('.').map(num => Number(num));
      needPerspectiveFix = major < 16 || major === 16 && minor < 2;
    }
  }
  const isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent);
  const isSafariBrowser = isSafari();
  const need3dFix = isSafariBrowser || isWebView && device.ios;
  return {
    isSafari: needPerspectiveFix || isSafariBrowser,
    needPerspectiveFix,
    need3dFix,
    isWebView
  };
}
function getBrowser() {
  if (!browser) {
    browser = calcBrowser();
  }
  return browser;
}

function Resize(_ref) {
  let {
    swiper,
    on,
    emit
  } = _ref;
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  let observer = null;
  let animationFrame = null;
  const resizeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    emit('beforeResize');
    emit('resize');
  };
  const createObserver = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    observer = new ResizeObserver(entries => {
      animationFrame = window.requestAnimationFrame(() => {
        const {
          width,
          height
        } = swiper;
        let newWidth = width;
        let newHeight = height;
        entries.forEach(_ref2 => {
          let {
            contentBoxSize,
            contentRect,
            target
          } = _ref2;
          if (target && target !== swiper.el) return;
          newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
          newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
        });
        if (newWidth !== width || newHeight !== height) {
          resizeHandler();
        }
      });
    });
    observer.observe(swiper.el);
  };
  const removeObserver = () => {
    if (animationFrame) {
      window.cancelAnimationFrame(animationFrame);
    }
    if (observer && observer.unobserve && swiper.el) {
      observer.unobserve(swiper.el);
      observer = null;
    }
  };
  const orientationChangeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    emit('orientationchange');
  };
  on('init', () => {
    if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
      createObserver();
      return;
    }
    window.addEventListener('resize', resizeHandler);
    window.addEventListener('orientationchange', orientationChangeHandler);
  });
  on('destroy', () => {
    removeObserver();
    window.removeEventListener('resize', resizeHandler);
    window.removeEventListener('orientationchange', orientationChangeHandler);
  });
}

function Observer(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const observers = [];
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  const attach = function (target, options) {
    if (options === void 0) {
      options = {};
    }
    const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
    const observer = new ObserverFunc(mutations => {
      // The observerUpdate event should only be triggered
      // once despite the number of mutations.  Additional
      // triggers are redundant and are very costly
      if (swiper.__preventObserver__) return;
      if (mutations.length === 1) {
        emit('observerUpdate', mutations[0]);
        return;
      }
      const observerUpdate = function observerUpdate() {
        emit('observerUpdate', mutations[0]);
      };
      if (window.requestAnimationFrame) {
        window.requestAnimationFrame(observerUpdate);
      } else {
        window.setTimeout(observerUpdate, 0);
      }
    });
    observer.observe(target, {
      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
      childList: swiper.isElement || (typeof options.childList === 'undefined' ? true : options).childList,
      characterData: typeof options.characterData === 'undefined' ? true : options.characterData
    });
    observers.push(observer);
  };
  const init = () => {
    if (!swiper.params.observer) return;
    if (swiper.params.observeParents) {
      const containerParents = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.a)(swiper.hostEl);
      for (let i = 0; i < containerParents.length; i += 1) {
        attach(containerParents[i]);
      }
    }
    // Observe container
    attach(swiper.hostEl, {
      childList: swiper.params.observeSlideChildren
    });

    // Observe wrapper
    attach(swiper.wrapperEl, {
      attributes: false
    });
  };
  const destroy = () => {
    observers.forEach(observer => {
      observer.disconnect();
    });
    observers.splice(0, observers.length);
  };
  extendParams({
    observer: false,
    observeParents: false,
    observeSlideChildren: false
  });
  on('init', init);
  on('destroy', destroy);
}

/* eslint-disable no-underscore-dangle */

var eventsEmitter = {
  on(events, handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';
    events.split(' ').forEach(event => {
      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
      self.eventsListeners[event][method](handler);
    });
    return self;
  },
  once(events, handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (typeof handler !== 'function') return self;
    function onceHandler() {
      self.off(events, onceHandler);
      if (onceHandler.__emitterProxy) {
        delete onceHandler.__emitterProxy;
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      handler.apply(self, args);
    }
    onceHandler.__emitterProxy = handler;
    return self.on(events, onceHandler, priority);
  },
  onAny(handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';
    if (self.eventsAnyListeners.indexOf(handler) < 0) {
      self.eventsAnyListeners[method](handler);
    }
    return self;
  },
  offAny(handler) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (!self.eventsAnyListeners) return self;
    const index = self.eventsAnyListeners.indexOf(handler);
    if (index >= 0) {
      self.eventsAnyListeners.splice(index, 1);
    }
    return self;
  },
  off(events, handler) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (!self.eventsListeners) return self;
    events.split(' ').forEach(event => {
      if (typeof handler === 'undefined') {
        self.eventsListeners[event] = [];
      } else if (self.eventsListeners[event]) {
        self.eventsListeners[event].forEach((eventHandler, index) => {
          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
            self.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self;
  },
  emit() {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (!self.eventsListeners) return self;
    let events;
    let data;
    let context;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events = args[0];
      data = args.slice(1, args.length);
      context = self;
    } else {
      events = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
    }
    data.unshift(context);
    const eventsArray = Array.isArray(events) ? events : events.split(' ');
    eventsArray.forEach(event => {
      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
        self.eventsAnyListeners.forEach(eventHandler => {
          eventHandler.apply(context, [event, ...data]);
        });
      }
      if (self.eventsListeners && self.eventsListeners[event]) {
        self.eventsListeners[event].forEach(eventHandler => {
          eventHandler.apply(context, data);
        });
      }
    });
    return self;
  }
};

function updateSize() {
  const swiper = this;
  let width;
  let height;
  const el = swiper.el;
  if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
    width = swiper.params.width;
  } else {
    width = el.clientWidth;
  }
  if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
    height = swiper.params.height;
  } else {
    height = el.clientHeight;
  }
  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
    return;
  }

  // Subtract paddings
  width = width - parseInt((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.p)(el, 'padding-left') || 0, 10) - parseInt((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.p)(el, 'padding-right') || 0, 10);
  height = height - parseInt((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.p)(el, 'padding-top') || 0, 10) - parseInt((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.p)(el, 'padding-bottom') || 0, 10);
  if (Number.isNaN(width)) width = 0;
  if (Number.isNaN(height)) height = 0;
  Object.assign(swiper, {
    width,
    height,
    size: swiper.isHorizontal() ? width : height
  });
}

function updateSlides() {
  const swiper = this;
  function getDirectionPropertyValue(node, label) {
    return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);
  }
  const params = swiper.params;
  const {
    wrapperEl,
    slidesEl,
    size: swiperSize,
    rtlTranslate: rtl,
    wrongRTL
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  const slides = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];
  let offsetBefore = params.slidesOffsetBefore;
  if (typeof offsetBefore === 'function') {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }
  let offsetAfter = params.slidesOffsetAfter;
  if (typeof offsetAfter === 'function') {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }
  const previousSnapGridLength = swiper.snapGrid.length;
  const previousSlidesGridLength = swiper.slidesGrid.length;
  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index = 0;
  if (typeof swiperSize === 'undefined') {
    return;
  }
  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
  } else if (typeof spaceBetween === 'string') {
    spaceBetween = parseFloat(spaceBetween);
  }
  swiper.virtualSize = -spaceBetween;

  // reset margins
  slides.forEach(slideEl => {
    if (rtl) {
      slideEl.style.marginLeft = '';
    } else {
      slideEl.style.marginRight = '';
    }
    slideEl.style.marginBottom = '';
    slideEl.style.marginTop = '';
  });

  // reset cssMode offsets
  if (params.centeredSlides && params.cssMode) {
    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(wrapperEl, '--swiper-centered-offset-before', '');
    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(wrapperEl, '--swiper-centered-offset-after', '');
  }
  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
  if (gridEnabled) {
    swiper.grid.initSlides(slides);
  } else if (swiper.grid) {
    swiper.grid.unsetSlides();
  }

  // Calc slides
  let slideSize;
  const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
    return typeof params.breakpoints[key].slidesPerView !== 'undefined';
  }).length > 0;
  for (let i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    let slide;
    if (slides[i]) slide = slides[i];
    if (gridEnabled) {
      swiper.grid.updateSlide(i, slide, slides);
    }
    if (slides[i] && (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.p)(slide, 'display') === 'none') continue; // eslint-disable-line

    if (params.slidesPerView === 'auto') {
      if (shouldResetSlideSize) {
        slides[i].style[swiper.getDirectionLabel('width')] = ``;
      }
      const slideStyles = getComputedStyle(slide);
      const currentTransform = slide.style.transform;
      const currentWebKitTransform = slide.style.webkitTransform;
      if (currentTransform) {
        slide.style.transform = 'none';
      }
      if (currentWebKitTransform) {
        slide.style.webkitTransform = 'none';
      }
      if (params.roundLengths) {
        slideSize = swiper.isHorizontal() ? (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.f)(slide, 'width', true) : (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.f)(slide, 'height', true);
      } else {
        // eslint-disable-next-line
        const width = getDirectionPropertyValue(slideStyles, 'width');
        const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
        const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
        const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
        const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
        const boxSizing = slideStyles.getPropertyValue('box-sizing');
        if (boxSizing && boxSizing === 'border-box') {
          slideSize = width + marginLeft + marginRight;
        } else {
          const {
            clientWidth,
            offsetWidth
          } = slide;
          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
        }
      }
      if (currentTransform) {
        slide.style.transform = currentTransform;
      }
      if (currentWebKitTransform) {
        slide.style.webkitTransform = currentWebKitTransform;
      }
      if (params.roundLengths) slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
      if (params.roundLengths) slideSize = Math.floor(slideSize);
      if (slides[i]) {
        slides[i].style[swiper.getDirectionLabel('width')] = `${slideSize}px`;
      }
    }
    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }
    slidesSizesGrid.push(slideSize);
    if (params.centeredSlides) {
      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }
    swiper.virtualSize += slideSize + spaceBetween;
    prevSlideSize = slideSize;
    index += 1;
  }
  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
    wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
  }
  if (params.setWrapperSize) {
    wrapperEl.style[swiper.getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;
  }
  if (gridEnabled) {
    swiper.grid.updateWrapperSize(slideSize, snapGrid);
  }

  // Remove last grid elements depending on width
  if (!params.centeredSlides) {
    const newSlidesGrid = [];
    for (let i = 0; i < snapGrid.length; i += 1) {
      let slidesGridItem = snapGrid[i];
      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(slidesGridItem);
      }
    }
    snapGrid = newSlidesGrid;
    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }
  if (isVirtual && params.loop) {
    const size = slidesSizesGrid[0] + spaceBetween;
    if (params.slidesPerGroup > 1) {
      const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
      const groupSize = size * params.slidesPerGroup;
      for (let i = 0; i < groups; i += 1) {
        snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
      }
    }
    for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {
      if (params.slidesPerGroup === 1) {
        snapGrid.push(snapGrid[snapGrid.length - 1] + size);
      }
      slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
      swiper.virtualSize += size;
    }
  }
  if (snapGrid.length === 0) snapGrid = [0];
  if (spaceBetween !== 0) {
    const key = swiper.isHorizontal() && rtl ? 'marginLeft' : swiper.getDirectionLabel('marginRight');
    slides.filter((_, slideIndex) => {
      if (!params.cssMode || params.loop) return true;
      if (slideIndex === slides.length - 1) {
        return false;
      }
      return true;
    }).forEach(slideEl => {
      slideEl.style[key] = `${spaceBetween}px`;
    });
  }
  if (params.centeredSlides && params.centeredSlidesBounds) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach(slideSizeValue => {
      allSlidesSize += slideSizeValue + (spaceBetween || 0);
    });
    allSlidesSize -= spaceBetween;
    const maxSnap = allSlidesSize > swiperSize ? allSlidesSize - swiperSize : 0;
    snapGrid = snapGrid.map(snap => {
      if (snap <= 0) return -offsetBefore;
      if (snap > maxSnap) return maxSnap + offsetAfter;
      return snap;
    });
  }
  if (params.centerInsufficientSlides) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach(slideSizeValue => {
      allSlidesSize += slideSizeValue + (spaceBetween || 0);
    });
    allSlidesSize -= spaceBetween;
    const offsetSize = (params.slidesOffsetBefore || 0) + (params.slidesOffsetAfter || 0);
    if (allSlidesSize + offsetSize < swiperSize) {
      const allSlidesOffset = (swiperSize - allSlidesSize - offsetSize) / 2;
      snapGrid.forEach((snap, snapIndex) => {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach((snap, snapIndex) => {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }
  Object.assign(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid
  });
  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
    const addToSnapGrid = -swiper.snapGrid[0];
    const addToSlidesGrid = -swiper.slidesGrid[0];
    swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
    swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
  }
  if (slidesLength !== previousSlidesLength) {
    swiper.emit('slidesLengthChange');
  }
  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow) swiper.checkOverflow();
    swiper.emit('snapGridLengthChange');
  }
  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit('slidesGridLengthChange');
  }
  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }
  swiper.emit('slidesUpdated');
  if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {
    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
    const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
    if (slidesLength <= params.maxBackfaceHiddenSlides) {
      if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);
    } else if (hasClassBackfaceClassAdded) {
      swiper.el.classList.remove(backFaceHiddenClass);
    }
  }
}

function updateAutoHeight(speed) {
  const swiper = this;
  const activeSlides = [];
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  let newHeight = 0;
  let i;
  if (typeof speed === 'number') {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }
  const getSlideByIndex = index => {
    if (isVirtual) {
      return swiper.slides[swiper.getSlideIndexByData(index)];
    }
    return swiper.slides[index];
  };
  // Find slides currently in view
  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      (swiper.visibleSlides || []).forEach(slide => {
        activeSlides.push(slide);
      });
    } else {
      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
        const index = swiper.activeIndex + i;
        if (index > swiper.slides.length && !isVirtual) break;
        activeSlides.push(getSlideByIndex(index));
      }
    }
  } else {
    activeSlides.push(getSlideByIndex(swiper.activeIndex));
  }

  // Find new height from highest slide in view
  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== 'undefined') {
      const height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  }

  // Update Height
  if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;
}

function updateSlidesOffset() {
  const swiper = this;
  const slides = swiper.slides;
  // eslint-disable-next-line
  const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
  for (let i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
  }
}

const toggleSlideClasses$1 = (slideEl, condition, className) => {
  if (condition && !slideEl.classList.contains(className)) {
    slideEl.classList.add(className);
  } else if (!condition && slideEl.classList.contains(className)) {
    slideEl.classList.remove(className);
  }
};
function updateSlidesProgress(translate) {
  if (translate === void 0) {
    translate = this && this.translate || 0;
  }
  const swiper = this;
  const params = swiper.params;
  const {
    slides,
    rtlTranslate: rtl,
    snapGrid
  } = swiper;
  if (slides.length === 0) return;
  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
  let offsetCenter = -translate;
  if (rtl) offsetCenter = translate;
  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];
  let spaceBetween = params.spaceBetween;
  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;
  } else if (typeof spaceBetween === 'string') {
    spaceBetween = parseFloat(spaceBetween);
  }
  for (let i = 0; i < slides.length; i += 1) {
    const slide = slides[i];
    let slideOffset = slide.swiperSlideOffset;
    if (params.cssMode && params.centeredSlides) {
      slideOffset -= slides[0].swiperSlideOffset;
    }
    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
    const slideBefore = -(offsetCenter - slideOffset);
    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
    const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i];
    const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
    if (isVisible) {
      swiper.visibleSlides.push(slide);
      swiper.visibleSlidesIndexes.push(i);
    }
    toggleSlideClasses$1(slide, isVisible, params.slideVisibleClass);
    toggleSlideClasses$1(slide, isFullyVisible, params.slideFullyVisibleClass);
    slide.progress = rtl ? -slideProgress : slideProgress;
    slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
  }
}

function updateProgress(translate) {
  const swiper = this;
  if (typeof translate === 'undefined') {
    const multiplier = swiper.rtlTranslate ? -1 : 1;
    // eslint-disable-next-line
    translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
  }
  const params = swiper.params;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  let {
    progress,
    isBeginning,
    isEnd,
    progressLoop
  } = swiper;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd;
  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate - swiper.minTranslate()) / translatesDiff;
    const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;
    const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;
    isBeginning = isBeginningRounded || progress <= 0;
    isEnd = isEndRounded || progress >= 1;
    if (isBeginningRounded) progress = 0;
    if (isEndRounded) progress = 1;
  }
  if (params.loop) {
    const firstSlideIndex = swiper.getSlideIndexByData(0);
    const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
    const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
    const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
    const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
    const translateAbs = Math.abs(translate);
    if (translateAbs >= firstSlideTranslate) {
      progressLoop = (translateAbs - firstSlideTranslate) / translateMax;
    } else {
      progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
    }
    if (progressLoop > 1) progressLoop -= 1;
  }
  Object.assign(swiper, {
    progress,
    progressLoop,
    isBeginning,
    isEnd
  });
  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
  if (isBeginning && !wasBeginning) {
    swiper.emit('reachBeginning toEdge');
  }
  if (isEnd && !wasEnd) {
    swiper.emit('reachEnd toEdge');
  }
  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
    swiper.emit('fromEdge');
  }
  swiper.emit('progress', progress);
}

const toggleSlideClasses = (slideEl, condition, className) => {
  if (condition && !slideEl.classList.contains(className)) {
    slideEl.classList.add(className);
  } else if (!condition && slideEl.classList.contains(className)) {
    slideEl.classList.remove(className);
  }
};
function updateSlidesClasses() {
  const swiper = this;
  const {
    slides,
    params,
    slidesEl,
    activeIndex
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  const getFilteredSlide = selector => {
    return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
  };
  let activeSlide;
  let prevSlide;
  let nextSlide;
  if (isVirtual) {
    if (params.loop) {
      let slideIndex = activeIndex - swiper.virtual.slidesBefore;
      if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;
      if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;
      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
    } else {
      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`);
    }
  } else {
    if (gridEnabled) {
      activeSlide = slides.filter(slideEl => slideEl.column === activeIndex)[0];
      nextSlide = slides.filter(slideEl => slideEl.column === activeIndex + 1)[0];
      prevSlide = slides.filter(slideEl => slideEl.column === activeIndex - 1)[0];
    } else {
      activeSlide = slides[activeIndex];
    }
  }
  if (activeSlide) {
    if (!gridEnabled) {
      // Next Slide
      nextSlide = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.q)(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
      if (params.loop && !nextSlide) {
        nextSlide = slides[0];
      }

      // Prev Slide
      prevSlide = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.r)(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
      if (params.loop && !prevSlide === 0) {
        prevSlide = slides[slides.length - 1];
      }
    }
  }
  slides.forEach(slideEl => {
    toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);
    toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);
    toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);
  });
  swiper.emitSlidesClasses();
}

const processLazyPreloader = (swiper, imageEl) => {
  if (!swiper || swiper.destroyed || !swiper.params) return;
  const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
  const slideEl = imageEl.closest(slideSelector());
  if (slideEl) {
    let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
    if (!lazyEl && swiper.isElement) {
      if (slideEl.shadowRoot) {
        lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
      } else {
        // init later
        requestAnimationFrame(() => {
          if (slideEl.shadowRoot) {
            lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
            if (lazyEl) lazyEl.remove();
          }
        });
      }
    }
    if (lazyEl) lazyEl.remove();
  }
};
const unlazy = (swiper, index) => {
  if (!swiper.slides[index]) return;
  const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
  if (imageEl) imageEl.removeAttribute('loading');
};
const preload = swiper => {
  if (!swiper || swiper.destroyed || !swiper.params) return;
  let amount = swiper.params.lazyPreloadPrevNext;
  const len = swiper.slides.length;
  if (!len || !amount || amount < 0) return;
  amount = Math.min(amount, len);
  const slidesPerView = swiper.params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
  const activeIndex = swiper.activeIndex;
  if (swiper.params.grid && swiper.params.grid.rows > 1) {
    const activeColumn = activeIndex;
    const preloadColumns = [activeColumn - amount];
    preloadColumns.push(...Array.from({
      length: amount
    }).map((_, i) => {
      return activeColumn + slidesPerView + i;
    }));
    swiper.slides.forEach((slideEl, i) => {
      if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);
    });
    return;
  }
  const slideIndexLastInView = activeIndex + slidesPerView - 1;
  if (swiper.params.rewind || swiper.params.loop) {
    for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {
      const realIndex = (i % len + len) % len;
      if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);
    }
  } else {
    for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {
      if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {
        unlazy(swiper, i);
      }
    }
  }
};

function getActiveIndexByTranslate(swiper) {
  const {
    slidesGrid,
    params
  } = swiper;
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  let activeIndex;
  for (let i = 0; i < slidesGrid.length; i += 1) {
    if (typeof slidesGrid[i + 1] !== 'undefined') {
      if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
        activeIndex = i;
      } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
        activeIndex = i + 1;
      }
    } else if (translate >= slidesGrid[i]) {
      activeIndex = i;
    }
  }
  // Normalize slideIndex
  if (params.normalizeSlideIndex) {
    if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
  }
  return activeIndex;
}
function updateActiveIndex(newActiveIndex) {
  const swiper = this;
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  const {
    snapGrid,
    params,
    activeIndex: previousIndex,
    realIndex: previousRealIndex,
    snapIndex: previousSnapIndex
  } = swiper;
  let activeIndex = newActiveIndex;
  let snapIndex;
  const getVirtualRealIndex = aIndex => {
    let realIndex = aIndex - swiper.virtual.slidesBefore;
    if (realIndex < 0) {
      realIndex = swiper.virtual.slides.length + realIndex;
    }
    if (realIndex >= swiper.virtual.slides.length) {
      realIndex -= swiper.virtual.slides.length;
    }
    return realIndex;
  };
  if (typeof activeIndex === 'undefined') {
    activeIndex = getActiveIndexByTranslate(swiper);
  }
  if (snapGrid.indexOf(translate) >= 0) {
    snapIndex = snapGrid.indexOf(translate);
  } else {
    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  if (activeIndex === previousIndex && !swiper.params.loop) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit('snapIndexChange');
    }
    return;
  }
  if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
    swiper.realIndex = getVirtualRealIndex(activeIndex);
    return;
  }
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;

  // Get real index
  let realIndex;
  if (swiper.virtual && params.virtual.enabled && params.loop) {
    realIndex = getVirtualRealIndex(activeIndex);
  } else if (gridEnabled) {
    const firstSlideInColumn = swiper.slides.filter(slideEl => slideEl.column === activeIndex)[0];
    let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute('data-swiper-slide-index'), 10);
    if (Number.isNaN(activeSlideIndex)) {
      activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);
    }
    realIndex = Math.floor(activeSlideIndex / params.grid.rows);
  } else if (swiper.slides[activeIndex]) {
    const slideIndex = swiper.slides[activeIndex].getAttribute('data-swiper-slide-index');
    if (slideIndex) {
      realIndex = parseInt(slideIndex, 10);
    } else {
      realIndex = activeIndex;
    }
  } else {
    realIndex = activeIndex;
  }
  Object.assign(swiper, {
    previousSnapIndex,
    snapIndex,
    previousRealIndex,
    realIndex,
    previousIndex,
    activeIndex
  });
  if (swiper.initialized) {
    preload(swiper);
  }
  swiper.emit('activeIndexChange');
  swiper.emit('snapIndexChange');
  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    if (previousRealIndex !== realIndex) {
      swiper.emit('realIndexChange');
    }
    swiper.emit('slideChange');
  }
}

function updateClickedSlide(el, path) {
  const swiper = this;
  const params = swiper.params;
  let slide = el.closest(`.${params.slideClass}, swiper-slide`);
  if (!slide && swiper.isElement && path && path.length > 1 && path.includes(el)) {
    [...path.slice(path.indexOf(el) + 1, path.length)].forEach(pathEl => {
      if (!slide && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {
        slide = pathEl;
      }
    });
  }
  let slideFound = false;
  let slideIndex;
  if (slide) {
    for (let i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide) {
        slideFound = true;
        slideIndex = i;
        break;
      }
    }
  }
  if (slide && slideFound) {
    swiper.clickedSlide = slide;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt(slide.getAttribute('data-swiper-slide-index'), 10);
    } else {
      swiper.clickedIndex = slideIndex;
    }
  } else {
    swiper.clickedSlide = undefined;
    swiper.clickedIndex = undefined;
    return;
  }
  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}

var update = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide
};

function getSwiperTranslate(axis) {
  if (axis === void 0) {
    axis = this.isHorizontal() ? 'x' : 'y';
  }
  const swiper = this;
  const {
    params,
    rtlTranslate: rtl,
    translate,
    wrapperEl
  } = swiper;
  if (params.virtualTranslate) {
    return rtl ? -translate : translate;
  }
  if (params.cssMode) {
    return translate;
  }
  let currentTranslate = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.j)(wrapperEl, axis);
  currentTranslate += swiper.cssOverflowAdjustment();
  if (rtl) currentTranslate = -currentTranslate;
  return currentTranslate || 0;
}

function setTranslate(translate, byController) {
  const swiper = this;
  const {
    rtlTranslate: rtl,
    params,
    wrapperEl,
    progress
  } = swiper;
  let x = 0;
  let y = 0;
  const z = 0;
  if (swiper.isHorizontal()) {
    x = rtl ? -translate : translate;
  } else {
    y = translate;
  }
  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }
  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x : y;
  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
  } else if (!params.virtualTranslate) {
    if (swiper.isHorizontal()) {
      x -= swiper.cssOverflowAdjustment();
    } else {
      y -= swiper.cssOverflowAdjustment();
    }
    wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
  }

  // Check if we need to update progress
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== progress) {
    swiper.updateProgress(translate);
  }
  swiper.emit('setTranslate', swiper.translate, byController);
}

function minTranslate() {
  return -this.snapGrid[0];
}

function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}

function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
  if (translate === void 0) {
    translate = 0;
  }
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (translateBounds === void 0) {
    translateBounds = true;
  }
  const swiper = this;
  const {
    params,
    wrapperEl
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  const minTranslate = swiper.minTranslate();
  const maxTranslate = swiper.maxTranslate();
  let newTranslate;
  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate;

  // Update progress
  swiper.updateProgress(newTranslate);
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
    } else {
      if (!swiper.support.smoothScroll) {
        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.t)({
          swiper,
          targetPosition: -newTranslate,
          side: isH ? 'left' : 'top'
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? 'left' : 'top']: -newTranslate,
        behavior: 'smooth'
      });
    }
    return true;
  }
  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionEnd');
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionStart');
    }
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.wrapperEl.removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;
          swiper.animating = false;
          if (runCallbacks) {
            swiper.emit('transitionEnd');
          }
        };
      }
      swiper.wrapperEl.addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
    }
  }
  return true;
}

var translate = {
  getTranslate: getSwiperTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
  translateTo
};

function setTransition(duration, byController) {
  const swiper = this;
  if (!swiper.params.cssMode) {
    swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
    swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : '';
  }
  swiper.emit('setTransition', duration, byController);
}

function transitionEmit(_ref) {
  let {
    swiper,
    runCallbacks,
    direction,
    step
  } = _ref;
  const {
    activeIndex,
    previousIndex
  } = swiper;
  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
  }
  swiper.emit(`transition${step}`);
  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit(`slideResetTransition${step}`);
      return;
    }
    swiper.emit(`slideChangeTransition${step}`);
    if (dir === 'next') {
      swiper.emit(`slideNextTransition${step}`);
    } else {
      swiper.emit(`slidePrevTransition${step}`);
    }
  }
}

function transitionStart(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    params
  } = swiper;
  if (params.cssMode) return;
  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: 'Start'
  });
}

function transitionEnd(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    params
  } = swiper;
  swiper.animating = false;
  if (params.cssMode) return;
  swiper.setTransition(0);
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: 'End'
  });
}

var transition = {
  setTransition,
  transitionStart,
  transitionEnd
};

function slideTo(index, speed, runCallbacks, internal, initial) {
  if (index === void 0) {
    index = 0;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (typeof index === 'string') {
    index = parseInt(index, 10);
  }
  const swiper = this;
  let slideIndex = index;
  if (slideIndex < 0) slideIndex = 0;
  const {
    params,
    snapGrid,
    slidesGrid,
    previousIndex,
    activeIndex,
    rtlTranslate: rtl,
    wrapperEl,
    enabled
  } = swiper;
  if (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  const translate = -snapGrid[snapIndex];
  // Normalize slideIndex
  if (params.normalizeSlideIndex) {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      const normalizedTranslate = -Math.floor(translate * 100);
      const normalizedGrid = Math.floor(slidesGrid[i] * 100);
      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
          slideIndex = i;
        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
          slideIndex = i + 1;
        }
      } else if (normalizedTranslate >= normalizedGrid) {
        slideIndex = i;
      }
    }
  }
  // Directions locks
  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {
      return false;
    }
    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) {
        return false;
      }
    }
  }
  if (slideIndex !== (previousIndex || 0) && runCallbacks) {
    swiper.emit('beforeSlideChangeStart');
  }

  // Update progress
  swiper.updateProgress(translate);
  let direction;
  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset';

  // initial virtual
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  const isInitialVirtual = isVirtual && initial;
  // Update Index
  if (!isInitialVirtual && (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate)) {
    swiper.updateActiveIndex(slideIndex);
    // Update Height
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    swiper.updateSlidesClasses();
    if (params.effect !== 'slide') {
      swiper.setTranslate(translate);
    }
    if (direction !== 'reset') {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }
    return false;
  }
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    const t = rtl ? translate : -translate;
    if (speed === 0) {
      if (isVirtual) {
        swiper.wrapperEl.style.scrollSnapType = 'none';
        swiper._immediateVirtual = true;
      }
      if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
        swiper._cssModeVirtualInitialSet = true;
        requestAnimationFrame(() => {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
        });
      } else {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
      }
      if (isVirtual) {
        requestAnimationFrame(() => {
          swiper.wrapperEl.style.scrollSnapType = '';
          swiper._immediateVirtual = false;
        });
      }
    } else {
      if (!swiper.support.smoothScroll) {
        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.t)({
          swiper,
          targetPosition: t,
          side: isH ? 'left' : 'top'
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? 'left' : 'top']: t,
        behavior: 'smooth'
      });
    }
    return true;
  }
  swiper.setTransition(speed);
  swiper.setTranslate(translate);
  swiper.updateActiveIndex(slideIndex);
  swiper.updateSlidesClasses();
  swiper.emit('beforeTransitionStart', speed, internal);
  swiper.transitionStart(runCallbacks, direction);
  if (speed === 0) {
    swiper.transitionEnd(runCallbacks, direction);
  } else if (!swiper.animating) {
    swiper.animating = true;
    if (!swiper.onSlideToWrapperTransitionEnd) {
      swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
        if (!swiper || swiper.destroyed) return;
        if (e.target !== this) return;
        swiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
        swiper.onSlideToWrapperTransitionEnd = null;
        delete swiper.onSlideToWrapperTransitionEnd;
        swiper.transitionEnd(runCallbacks, direction);
      };
    }
    swiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
  }
  return true;
}

function slideToLoop(index, speed, runCallbacks, internal) {
  if (index === void 0) {
    index = 0;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (typeof index === 'string') {
    const indexAsNumber = parseInt(index, 10);
    index = indexAsNumber;
  }
  const swiper = this;
  if (swiper.destroyed) return;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
  let newIndex = index;
  if (swiper.params.loop) {
    if (swiper.virtual && swiper.params.virtual.enabled) {
      // eslint-disable-next-line
      newIndex = newIndex + swiper.virtual.slidesBefore;
    } else {
      let targetSlideIndex;
      if (gridEnabled) {
        const slideIndex = newIndex * swiper.params.grid.rows;
        targetSlideIndex = swiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === slideIndex)[0].column;
      } else {
        targetSlideIndex = swiper.getSlideIndexByData(newIndex);
      }
      const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;
      const {
        centeredSlides
      } = swiper.params;
      let slidesPerView = swiper.params.slidesPerView;
      if (slidesPerView === 'auto') {
        slidesPerView = swiper.slidesPerViewDynamic();
      } else {
        slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));
        if (centeredSlides && slidesPerView % 2 === 0) {
          slidesPerView = slidesPerView + 1;
        }
      }
      let needLoopFix = cols - targetSlideIndex < slidesPerView;
      if (centeredSlides) {
        needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);
      }
      if (internal && centeredSlides && swiper.params.slidesPerView !== 'auto' && !gridEnabled) {
        needLoopFix = false;
      }
      if (needLoopFix) {
        const direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? 'prev' : 'next' : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? 'next' : 'prev';
        swiper.loopFix({
          direction,
          slideTo: true,
          activeSlideIndex: direction === 'next' ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,
          slideRealIndex: direction === 'next' ? swiper.realIndex : undefined
        });
      }
      if (gridEnabled) {
        const slideIndex = newIndex * swiper.params.grid.rows;
        newIndex = swiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === slideIndex)[0].column;
      } else {
        newIndex = swiper.getSlideIndexByData(newIndex);
      }
    }
  }
  requestAnimationFrame(() => {
    swiper.slideTo(newIndex, speed, runCallbacks, internal);
  });
  return swiper;
}

/* eslint no-unused-vars: "off" */
function slideNext(speed, runCallbacks, internal) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    enabled,
    params,
    animating
  } = swiper;
  if (!enabled || swiper.destroyed) return swiper;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  let perGroup = params.slidesPerGroup;
  if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
    perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
  }
  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding) return false;
    swiper.loopFix({
      direction: 'next'
    });
    // eslint-disable-next-line
    swiper._clientLeft = swiper.wrapperEl.clientLeft;
    if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {
      requestAnimationFrame(() => {
        swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
      });
      return true;
    }
  }
  if (params.rewind && swiper.isEnd) {
    return swiper.slideTo(0, speed, runCallbacks, internal);
  }
  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slidePrev(speed, runCallbacks, internal) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    params,
    snapGrid,
    slidesGrid,
    rtlTranslate,
    enabled,
    animating
  } = swiper;
  if (!enabled || swiper.destroyed) return swiper;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  const isVirtual = swiper.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding) return false;
    swiper.loopFix({
      direction: 'prev'
    });
    // eslint-disable-next-line
    swiper._clientLeft = swiper.wrapperEl.clientLeft;
  }
  const translate = rtlTranslate ? swiper.translate : -swiper.translate;
  function normalize(val) {
    if (val < 0) return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }
  const normalizedTranslate = normalize(translate);
  const normalizedSnapGrid = snapGrid.map(val => normalize(val));
  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
  if (typeof prevSnap === 'undefined' && params.cssMode) {
    let prevSnapIndex;
    snapGrid.forEach((snap, snapIndex) => {
      if (normalizedTranslate >= snap) {
        // prevSnap = snap;
        prevSnapIndex = snapIndex;
      }
    });
    if (typeof prevSnapIndex !== 'undefined') {
      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
    }
  }
  let prevIndex = 0;
  if (typeof prevSnap !== 'undefined') {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
    if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
      prevIndex = Math.max(prevIndex, 0);
    }
  }
  if (params.rewind && swiper.isBeginning) {
    const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
  } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {
    requestAnimationFrame(() => {
      swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    });
    return true;
  }
  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideReset(speed, runCallbacks, internal) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  if (swiper.destroyed) return;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideToClosest(speed, runCallbacks, internal, threshold) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (threshold === void 0) {
    threshold = 0.5;
  }
  const swiper = this;
  if (swiper.destroyed) return;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  let index = swiper.activeIndex;
  const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
  const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  if (translate >= swiper.snapGrid[snapIndex]) {
    // The current translate is on or after the current snap index, so the choice
    // is between the current index and the one after it.
    const currentSnap = swiper.snapGrid[snapIndex];
    const nextSnap = swiper.snapGrid[snapIndex + 1];
    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
      index += swiper.params.slidesPerGroup;
    }
  } else {
    // The current translate is before the current snap index, so the choice
    // is between the current index and the one before it.
    const prevSnap = swiper.snapGrid[snapIndex - 1];
    const currentSnap = swiper.snapGrid[snapIndex];
    if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
      index -= swiper.params.slidesPerGroup;
    }
  }
  index = Math.max(index, 0);
  index = Math.min(index, swiper.slidesGrid.length - 1);
  return swiper.slideTo(index, speed, runCallbacks, internal);
}

function slideToClickedSlide() {
  const swiper = this;
  if (swiper.destroyed) return;
  const {
    params,
    slidesEl
  } = swiper;
  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper.clickedIndex;
  let realIndex;
  const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
  if (params.loop) {
    if (swiper.animating) return;
    realIndex = parseInt(swiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);
    if (params.centeredSlides) {
      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
        swiper.loopFix();
        slideToIndex = swiper.getSlideIndex((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = swiper.getSlideIndex((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
      (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(() => {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}

var slide = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide
};

function loopCreate(slideRealIndex) {
  const swiper = this;
  const {
    params,
    slidesEl
  } = swiper;
  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
  const initSlides = () => {
    const slides = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${params.slideClass}, swiper-slide`);
    slides.forEach((el, index) => {
      el.setAttribute('data-swiper-slide-index', index);
    });
  };
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);
  const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;
  const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;
  const addBlankSlides = amountOfSlides => {
    for (let i = 0; i < amountOfSlides; i += 1) {
      const slideEl = swiper.isElement ? (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)('swiper-slide', [params.slideBlankClass]) : (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)('div', [params.slideClass, params.slideBlankClass]);
      swiper.slidesEl.append(slideEl);
    }
  };
  if (shouldFillGroup) {
    if (params.loopAddBlankSlides) {
      const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;
      addBlankSlides(slidesToAdd);
      swiper.recalcSlides();
      swiper.updateSlides();
    } else {
      (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)('Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)');
    }
    initSlides();
  } else if (shouldFillGrid) {
    if (params.loopAddBlankSlides) {
      const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;
      addBlankSlides(slidesToAdd);
      swiper.recalcSlides();
      swiper.updateSlides();
    } else {
      (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)('Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)');
    }
    initSlides();
  } else {
    initSlides();
  }
  swiper.loopFix({
    slideRealIndex,
    direction: params.centeredSlides ? undefined : 'next'
  });
}

function loopFix(_temp) {
  let {
    slideRealIndex,
    slideTo = true,
    direction,
    setTranslate,
    activeSlideIndex,
    byController,
    byMousewheel
  } = _temp === void 0 ? {} : _temp;
  const swiper = this;
  if (!swiper.params.loop) return;
  swiper.emit('beforeLoopFix');
  const {
    slides,
    allowSlidePrev,
    allowSlideNext,
    slidesEl,
    params
  } = swiper;
  const {
    centeredSlides
  } = params;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;
  if (swiper.virtual && params.virtual.enabled) {
    if (slideTo) {
      if (!params.centeredSlides && swiper.snapIndex === 0) {
        swiper.slideTo(swiper.virtual.slides.length, 0, false, true);
      } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {
        swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);
      } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {
        swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
      }
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    swiper.emit('loopFix');
    return;
  }
  let slidesPerView = params.slidesPerView;
  if (slidesPerView === 'auto') {
    slidesPerView = swiper.slidesPerViewDynamic();
  } else {
    slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));
    if (centeredSlides && slidesPerView % 2 === 0) {
      slidesPerView = slidesPerView + 1;
    }
  }
  const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;
  let loopedSlides = slidesPerGroup;
  if (loopedSlides % slidesPerGroup !== 0) {
    loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;
  }
  loopedSlides += params.loopAdditionalSlides;
  swiper.loopedSlides = loopedSlides;
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  if (slides.length < slidesPerView + loopedSlides) {
    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)('Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters');
  } else if (gridEnabled && params.grid.fill === 'row') {
    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)('Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`');
  }
  const prependSlidesIndexes = [];
  const appendSlidesIndexes = [];
  let activeIndex = swiper.activeIndex;
  if (typeof activeSlideIndex === 'undefined') {
    activeSlideIndex = swiper.getSlideIndex(slides.filter(el => el.classList.contains(params.slideActiveClass))[0]);
  } else {
    activeIndex = activeSlideIndex;
  }
  const isNext = direction === 'next' || !direction;
  const isPrev = direction === 'prev' || !direction;
  let slidesPrepended = 0;
  let slidesAppended = 0;
  const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;
  const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;
  const activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate === 'undefined' ? -slidesPerView / 2 + 0.5 : 0);
  // prepend last slides before start
  if (activeColIndexWithShift < loopedSlides) {
    slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);
    for (let i = 0; i < loopedSlides - activeColIndexWithShift; i += 1) {
      const index = i - Math.floor(i / cols) * cols;
      if (gridEnabled) {
        const colIndexToPrepend = cols - index - 1;
        for (let i = slides.length - 1; i >= 0; i -= 1) {
          if (slides[i].column === colIndexToPrepend) prependSlidesIndexes.push(i);
        }
        // slides.forEach((slide, slideIndex) => {
        //   if (slide.column === colIndexToPrepend) prependSlidesIndexes.push(slideIndex);
        // });
      } else {
        prependSlidesIndexes.push(cols - index - 1);
      }
    }
  } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {
    slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);
    for (let i = 0; i < slidesAppended; i += 1) {
      const index = i - Math.floor(i / cols) * cols;
      if (gridEnabled) {
        slides.forEach((slide, slideIndex) => {
          if (slide.column === index) appendSlidesIndexes.push(slideIndex);
        });
      } else {
        appendSlidesIndexes.push(index);
      }
    }
  }
  swiper.__preventObserver__ = true;
  requestAnimationFrame(() => {
    swiper.__preventObserver__ = false;
  });
  if (isPrev) {
    prependSlidesIndexes.forEach(index => {
      slides[index].swiperLoopMoveDOM = true;
      slidesEl.prepend(slides[index]);
      slides[index].swiperLoopMoveDOM = false;
    });
  }
  if (isNext) {
    appendSlidesIndexes.forEach(index => {
      slides[index].swiperLoopMoveDOM = true;
      slidesEl.append(slides[index]);
      slides[index].swiperLoopMoveDOM = false;
    });
  }
  swiper.recalcSlides();
  if (params.slidesPerView === 'auto') {
    swiper.updateSlides();
  } else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {
    swiper.slides.forEach((slide, slideIndex) => {
      swiper.grid.updateSlide(slideIndex, slide, swiper.slides);
    });
  }
  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }
  if (slideTo) {
    if (prependSlidesIndexes.length > 0 && isPrev) {
      if (typeof slideRealIndex === 'undefined') {
        const currentSlideTranslate = swiper.slidesGrid[activeIndex];
        const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
        const diff = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) {
          swiper.setTranslate(swiper.translate - diff);
        } else {
          swiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);
          if (setTranslate) {
            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
          }
        }
      } else {
        if (setTranslate) {
          const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;
          swiper.slideTo(swiper.activeIndex + shift, 0, false, true);
          swiper.touchEventsData.currentTranslate = swiper.translate;
        }
      }
    } else if (appendSlidesIndexes.length > 0 && isNext) {
      if (typeof slideRealIndex === 'undefined') {
        const currentSlideTranslate = swiper.slidesGrid[activeIndex];
        const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
        const diff = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) {
          swiper.setTranslate(swiper.translate - diff);
        } else {
          swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
          if (setTranslate) {
            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
          }
        }
      } else {
        const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;
        swiper.slideTo(swiper.activeIndex - shift, 0, false, true);
      }
    }
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.controller && swiper.controller.control && !byController) {
    const loopParams = {
      slideRealIndex,
      direction,
      setTranslate,
      activeSlideIndex,
      byController: true
    };
    if (Array.isArray(swiper.controller.control)) {
      swiper.controller.control.forEach(c => {
        if (!c.destroyed && c.params.loop) c.loopFix({
          ...loopParams,
          slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo : false
        });
      });
    } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {
      swiper.controller.control.loopFix({
        ...loopParams,
        slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo : false
      });
    }
  }
  swiper.emit('loopFix');
}

function loopDestroy() {
  const swiper = this;
  const {
    params,
    slidesEl
  } = swiper;
  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
  swiper.recalcSlides();
  const newSlidesOrder = [];
  swiper.slides.forEach(slideEl => {
    const index = typeof slideEl.swiperSlideIndex === 'undefined' ? slideEl.getAttribute('data-swiper-slide-index') * 1 : slideEl.swiperSlideIndex;
    newSlidesOrder[index] = slideEl;
  });
  swiper.slides.forEach(slideEl => {
    slideEl.removeAttribute('data-swiper-slide-index');
  });
  newSlidesOrder.forEach(slideEl => {
    slidesEl.append(slideEl);
  });
  swiper.recalcSlides();
  swiper.slideTo(swiper.realIndex, 0);
}

var loop = {
  loopCreate,
  loopFix,
  loopDestroy
};

function setGrabCursor(moving) {
  const swiper = this;
  if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
  const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
  if (swiper.isElement) {
    swiper.__preventObserver__ = true;
  }
  el.style.cursor = 'move';
  el.style.cursor = moving ? 'grabbing' : 'grab';
  if (swiper.isElement) {
    requestAnimationFrame(() => {
      swiper.__preventObserver__ = false;
    });
  }
}

function unsetGrabCursor() {
  const swiper = this;
  if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
    return;
  }
  if (swiper.isElement) {
    swiper.__preventObserver__ = true;
  }
  swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
  if (swiper.isElement) {
    requestAnimationFrame(() => {
      swiper.__preventObserver__ = false;
    });
  }
}

var grabCursor = {
  setGrabCursor,
  unsetGrabCursor
};

// Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd
function closestElement(selector, base) {
  if (base === void 0) {
    base = this;
  }
  function __closestFrom(el) {
    if (!el || el === (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)() || el === (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)()) return null;
    if (el.assignedSlot) el = el.assignedSlot;
    const found = el.closest(selector);
    if (!found && !el.getRootNode) {
      return null;
    }
    return found || __closestFrom(el.getRootNode().host);
  }
  return __closestFrom(base);
}
function preventEdgeSwipe(swiper, event, startX) {
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  const {
    params
  } = swiper;
  const edgeSwipeDetection = params.edgeSwipeDetection;
  const edgeSwipeThreshold = params.edgeSwipeThreshold;
  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
    if (edgeSwipeDetection === 'prevent') {
      event.preventDefault();
      return true;
    }
    return false;
  }
  return true;
}
function onTouchStart(event) {
  const swiper = this;
  const document = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  const data = swiper.touchEventsData;
  if (e.type === 'pointerdown') {
    if (data.pointerId !== null && data.pointerId !== e.pointerId) {
      return;
    }
    data.pointerId = e.pointerId;
  } else if (e.type === 'touchstart' && e.targetTouches.length === 1) {
    data.touchId = e.targetTouches[0].identifier;
  }
  if (e.type === 'touchstart') {
    // don't proceed touch event
    preventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);
    return;
  }
  const {
    params,
    touches,
    enabled
  } = swiper;
  if (!enabled) return;
  if (!params.simulateTouch && e.pointerType === 'mouse') return;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }
  if (!swiper.animating && params.cssMode && params.loop) {
    swiper.loopFix();
  }
  let targetEl = e.target;
  if (params.touchEventsTarget === 'wrapper') {
    if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.v)(targetEl, swiper.wrapperEl)) return;
  }
  if ('which' in e && e.which === 3) return;
  if ('button' in e && e.button > 0) return;
  if (data.isTouched && data.isMoved) return;

  // change target el for shadow root component
  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';
  // eslint-disable-next-line
  const eventPath = e.composedPath ? e.composedPath() : e.path;
  if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {
    targetEl = eventPath[0];
  }
  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
  const isTargetShadow = !!(e.target && e.target.shadowRoot);

  // use closestElement for shadow root element to get the actual closest for nested shadow root element
  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
    swiper.allowClick = true;
    return;
  }
  if (params.swipeHandler) {
    if (!targetEl.closest(params.swipeHandler)) return;
  }
  touches.currentX = e.pageX;
  touches.currentY = e.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY;

  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

  if (!preventEdgeSwipe(swiper, e, startX)) {
    return;
  }
  Object.assign(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: undefined,
    startMoving: undefined
  });
  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = undefined;
  if (params.threshold > 0) data.allowThresholdMove = false;
  let preventDefault = true;
  if (targetEl.matches(data.focusableElements)) {
    preventDefault = false;
    if (targetEl.nodeName === 'SELECT') {
      data.isTouched = false;
    }
  }
  if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl && (e.pointerType === 'mouse' || e.pointerType !== 'mouse' && !targetEl.matches(data.focusableElements))) {
    document.activeElement.blur();
  }
  const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
  if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
    e.preventDefault();
  }
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
    swiper.freeMode.onTouchStart();
  }
  swiper.emit('touchStart', e);
}

function onTouchMove(event) {
  const document = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
  const swiper = this;
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    enabled
  } = swiper;
  if (!enabled) return;
  if (!params.simulateTouch && event.pointerType === 'mouse') return;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  if (e.type === 'pointermove') {
    if (data.touchId !== null) return; // return from pointer if we use touch
    const id = e.pointerId;
    if (id !== data.pointerId) return;
  }
  let targetTouch;
  if (e.type === 'touchmove') {
    targetTouch = [...e.changedTouches].filter(t => t.identifier === data.touchId)[0];
    if (!targetTouch || targetTouch.identifier !== data.touchId) return;
  } else {
    targetTouch = e;
  }
  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }
    return;
  }
  const pageX = targetTouch.pageX;
  const pageY = targetTouch.pageY;
  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }
  if (!swiper.allowTouchMove) {
    if (!e.target.matches(data.focusableElements)) {
      swiper.allowClick = false;
    }
    if (data.isTouched) {
      Object.assign(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY
      });
      data.touchStartTime = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();
    }
    return;
  }
  if (params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      // Vertical
      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
      return;
    }
  }
  if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== e.target && e.pointerType !== 'mouse') {
    document.activeElement.blur();
  }
  if (document.activeElement) {
    if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }
  if (data.allowTouchCallbacks) {
    swiper.emit('touchMove', e);
  }
  touches.previousX = touches.currentX;
  touches.previousY = touches.currentY;
  touches.currentX = pageX;
  touches.currentY = pageY;
  const diffX = touches.currentX - touches.startX;
  const diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
  if (typeof data.isScrolling === 'undefined') {
    let touchAngle;
    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
      data.isScrolling = false;
    } else {
      // eslint-disable-next-line
      if (diffX * diffX + diffY * diffY >= 25) {
        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
      }
    }
  }
  if (data.isScrolling) {
    swiper.emit('touchMoveOpposite', e);
  }
  if (typeof data.startMoving === 'undefined') {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }
  if (data.isScrolling || e.type === 'touchmove' && data.preventTouchMoveFromPointerMove) {
    data.isTouched = false;
    return;
  }
  if (!data.startMoving) {
    return;
  }
  swiper.allowClick = false;
  if (!params.cssMode && e.cancelable) {
    e.preventDefault();
  }
  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }
  let diff = swiper.isHorizontal() ? diffX : diffY;
  let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
  if (params.oneWayMovement) {
    diff = Math.abs(diff) * (rtl ? 1 : -1);
    touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
  }
  touches.diff = diff;
  diff *= params.touchRatio;
  if (rtl) {
    diff = -diff;
    touchesDiff = -touchesDiff;
  }
  const prevTouchesDirection = swiper.touchesDirection;
  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
  swiper.touchesDirection = touchesDiff > 0 ? 'prev' : 'next';
  const isLoop = swiper.params.loop && !params.cssMode;
  const allowLoopFix = swiper.touchesDirection === 'next' && swiper.allowSlideNext || swiper.touchesDirection === 'prev' && swiper.allowSlidePrev;
  if (!data.isMoved) {
    if (isLoop && allowLoopFix) {
      swiper.loopFix({
        direction: swiper.swipeDirection
      });
    }
    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);
    if (swiper.animating) {
      const evt = new window.CustomEvent('transitionend', {
        bubbles: true,
        cancelable: true,
        detail: {
          bySwiperTouchMove: true
        }
      });
      swiper.wrapperEl.dispatchEvent(evt);
    }
    data.allowMomentumBounce = false;
    // Grab Cursor
    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }
    swiper.emit('sliderFirstMove', e);
  }
  let loopFixed;
  new Date().getTime();
  if (data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
    Object.assign(touches, {
      startX: pageX,
      startY: pageY,
      currentX: pageX,
      currentY: pageY,
      startTranslate: data.currentTranslate
    });
    data.loopSwapReset = true;
    data.startTranslate = data.currentTranslate;
    return;
  }
  swiper.emit('sliderMove', e);
  data.isMoved = true;
  data.currentTranslate = diff + data.startTranslate;
  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }
  if (diff > 0) {
    if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] - (params.slidesPerView !== 'auto' && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.activeIndex + 1] + swiper.params.spaceBetween : 0) - swiper.params.spaceBetween : swiper.minTranslate())) {
      swiper.loopFix({
        direction: 'prev',
        setTranslate: true,
        activeSlideIndex: 0
      });
    }
    if (data.currentTranslate > swiper.minTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) {
        data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
      }
    }
  } else if (diff < 0) {
    if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween + (params.slidesPerView !== 'auto' && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween : 0) : swiper.maxTranslate())) {
      swiper.loopFix({
        direction: 'next',
        setTranslate: true,
        activeSlideIndex: swiper.slides.length - (params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
      });
    }
    if (data.currentTranslate < swiper.maxTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) {
        data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
      }
    }
  }
  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  }

  // Directions locks
  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
    data.currentTranslate = data.startTranslate;
  }

  // Threshold
  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }
  if (!params.followFinger || params.cssMode) return;

  // Update active index in free mode
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {
    swiper.freeMode.onTouchMove();
  }
  // Update progress
  swiper.updateProgress(data.currentTranslate);
  // Update translate
  swiper.setTranslate(data.currentTranslate);
}

function onTouchEnd(event) {
  const swiper = this;
  const data = swiper.touchEventsData;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  let targetTouch;
  const isTouchEvent = e.type === 'touchend' || e.type === 'touchcancel';
  if (!isTouchEvent) {
    if (data.touchId !== null) return; // return from pointer if we use touch
    if (e.pointerId !== data.pointerId) return;
    targetTouch = e;
  } else {
    targetTouch = [...e.changedTouches].filter(t => t.identifier === data.touchId)[0];
    if (!targetTouch || targetTouch.identifier !== data.touchId) return;
  }
  if (['pointercancel', 'pointerout', 'pointerleave', 'contextmenu'].includes(e.type)) {
    const proceed = ['pointercancel', 'contextmenu'].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);
    if (!proceed) {
      return;
    }
  }
  data.pointerId = null;
  data.touchId = null;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    slidesGrid,
    enabled
  } = swiper;
  if (!enabled) return;
  if (!params.simulateTouch && e.pointerType === 'mouse') return;
  if (data.allowTouchCallbacks) {
    swiper.emit('touchEnd', e);
  }
  data.allowTouchCallbacks = false;
  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }
    data.isMoved = false;
    data.startMoving = false;
    return;
  }

  // Return Grab Cursor
  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  }

  // Time diff
  const touchEndTime = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();
  const timeDiff = touchEndTime - data.touchStartTime;

  // Tap, doubleTap, Click
  if (swiper.allowClick) {
    const pathTree = e.path || e.composedPath && e.composedPath();
    swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);
    swiper.emit('tap click', e);
    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
      swiper.emit('doubleTap doubleClick', e);
    }
  }
  data.lastClickTime = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();
  (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(() => {
    if (!swiper.destroyed) swiper.allowClick = true;
  });
  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;
  let currentPos;
  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }
  if (params.cssMode) {
    return;
  }
  if (params.freeMode && params.freeMode.enabled) {
    swiper.freeMode.onTouchEnd({
      currentPos
    });
    return;
  }

  // Find current slide
  const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;
  let stopIndex = 0;
  let groupSize = swiper.slidesSizesGrid[0];
  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (typeof slidesGrid[i + increment] !== 'undefined') {
      if (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
        stopIndex = i;
        groupSize = slidesGrid[i + increment] - slidesGrid[i];
      }
    } else if (swipeToLast || currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }
  let rewindFirstIndex = null;
  let rewindLastIndex = null;
  if (params.rewind) {
    if (swiper.isBeginning) {
      rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    } else if (swiper.isEnd) {
      rewindFirstIndex = 0;
    }
  }
  // Find current slide size
  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
  if (timeDiff > params.longSwipesMs) {
    // Long touches
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === 'next') {
      if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);else swiper.slideTo(stopIndex);
    }
    if (swiper.swipeDirection === 'prev') {
      if (ratio > 1 - params.longSwipesRatio) {
        swiper.slideTo(stopIndex + increment);
      } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
        swiper.slideTo(rewindLastIndex);
      } else {
        swiper.slideTo(stopIndex);
      }
    }
  } else {
    // Short swipes
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === 'next') {
        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
      }
      if (swiper.swipeDirection === 'prev') {
        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
      }
    } else if (e.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}

function onResize() {
  const swiper = this;
  const {
    params,
    el
  } = swiper;
  if (el && el.offsetWidth === 0) return;

  // Breakpoints
  if (params.breakpoints) {
    swiper.setBreakpoint();
  }

  // Save locks
  const {
    allowSlideNext,
    allowSlidePrev,
    snapGrid
  } = swiper;
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

  // Disable locks on resize
  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;
  swiper.updateSize();
  swiper.updateSlides();
  swiper.updateSlidesClasses();
  const isVirtualLoop = isVirtual && params.loop;
  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    if (swiper.params.loop && !isVirtual) {
      swiper.slideToLoop(swiper.realIndex, 0, false, true);
    } else {
      swiper.slideTo(swiper.activeIndex, 0, false, true);
    }
  }
  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    clearTimeout(swiper.autoplay.resizeTimeout);
    swiper.autoplay.resizeTimeout = setTimeout(() => {
      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        swiper.autoplay.resume();
      }
    }, 500);
  }
  // Return locks after resize
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}

function onClick(e) {
  const swiper = this;
  if (!swiper.enabled) return;
  if (!swiper.allowClick) {
    if (swiper.params.preventClicks) e.preventDefault();
    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}

function onScroll() {
  const swiper = this;
  const {
    wrapperEl,
    rtlTranslate,
    enabled
  } = swiper;
  if (!enabled) return;
  swiper.previousTranslate = swiper.translate;
  if (swiper.isHorizontal()) {
    swiper.translate = -wrapperEl.scrollLeft;
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  }
  // eslint-disable-next-line
  if (swiper.translate === 0) swiper.translate = 0;
  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }
  swiper.emit('setTranslate', swiper.translate, false);
}

function onLoad(e) {
  const swiper = this;
  processLazyPreloader(swiper, e.target);
  if (swiper.params.cssMode || swiper.params.slidesPerView !== 'auto' && !swiper.params.autoHeight) {
    return;
  }
  swiper.update();
}

function onDocumentTouchStart() {
  const swiper = this;
  if (swiper.documentTouchHandlerProceeded) return;
  swiper.documentTouchHandlerProceeded = true;
  if (swiper.params.touchReleaseOnEdges) {
    swiper.el.style.touchAction = 'auto';
  }
}

const events = (swiper, method) => {
  const document = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
  const {
    params,
    el,
    wrapperEl,
    device
  } = swiper;
  const capture = !!params.nested;
  const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
  const swiperMethod = method;
  if (!el || typeof el === 'string') return;

  // Touch Events
  document[domMethod]('touchstart', swiper.onDocumentTouchStart, {
    passive: false,
    capture
  });
  el[domMethod]('touchstart', swiper.onTouchStart, {
    passive: false
  });
  el[domMethod]('pointerdown', swiper.onTouchStart, {
    passive: false
  });
  document[domMethod]('touchmove', swiper.onTouchMove, {
    passive: false,
    capture
  });
  document[domMethod]('pointermove', swiper.onTouchMove, {
    passive: false,
    capture
  });
  document[domMethod]('touchend', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('pointerup', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('pointercancel', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('touchcancel', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('pointerout', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('pointerleave', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('contextmenu', swiper.onTouchEnd, {
    passive: true
  });

  // Prevent Links Clicks
  if (params.preventClicks || params.preventClicksPropagation) {
    el[domMethod]('click', swiper.onClick, true);
  }
  if (params.cssMode) {
    wrapperEl[domMethod]('scroll', swiper.onScroll);
  }

  // Resize handler
  if (params.updateOnWindowResize) {
    swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
  } else {
    swiper[swiperMethod]('observerUpdate', onResize, true);
  }

  // Images loader
  el[domMethod]('load', swiper.onLoad, {
    capture: true
  });
};
function attachEvents() {
  const swiper = this;
  const {
    params
  } = swiper;
  swiper.onTouchStart = onTouchStart.bind(swiper);
  swiper.onTouchMove = onTouchMove.bind(swiper);
  swiper.onTouchEnd = onTouchEnd.bind(swiper);
  swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);
  if (params.cssMode) {
    swiper.onScroll = onScroll.bind(swiper);
  }
  swiper.onClick = onClick.bind(swiper);
  swiper.onLoad = onLoad.bind(swiper);
  events(swiper, 'on');
}
function detachEvents() {
  const swiper = this;
  events(swiper, 'off');
}
var events$1 = {
  attachEvents,
  detachEvents
};

const isGridEnabled = (swiper, params) => {
  return swiper.grid && params.grid && params.grid.rows > 1;
};
function setBreakpoint() {
  const swiper = this;
  const {
    realIndex,
    initialized,
    params,
    el
  } = swiper;
  const breakpoints = params.breakpoints;
  if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;

  // Get breakpoint for window width and update parameters
  const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
  if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
  const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
  const breakpointParams = breakpointOnlyParams || swiper.originalParams;
  const wasMultiRow = isGridEnabled(swiper, params);
  const isMultiRow = isGridEnabled(swiper, breakpointParams);
  const wasGrabCursor = swiper.params.grabCursor;
  const isGrabCursor = breakpointParams.grabCursor;
  const wasEnabled = params.enabled;
  if (wasMultiRow && !isMultiRow) {
    el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
    swiper.emitContainerClasses();
  } else if (!wasMultiRow && isMultiRow) {
    el.classList.add(`${params.containerModifierClass}grid`);
    if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
      el.classList.add(`${params.containerModifierClass}grid-column`);
    }
    swiper.emitContainerClasses();
  }
  if (wasGrabCursor && !isGrabCursor) {
    swiper.unsetGrabCursor();
  } else if (!wasGrabCursor && isGrabCursor) {
    swiper.setGrabCursor();
  }

  // Toggle navigation, pagination, scrollbar
  ['navigation', 'pagination', 'scrollbar'].forEach(prop => {
    if (typeof breakpointParams[prop] === 'undefined') return;
    const wasModuleEnabled = params[prop] && params[prop].enabled;
    const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
    if (wasModuleEnabled && !isModuleEnabled) {
      swiper[prop].disable();
    }
    if (!wasModuleEnabled && isModuleEnabled) {
      swiper[prop].enable();
    }
  });
  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
  const wasLoop = params.loop;
  if (directionChanged && initialized) {
    swiper.changeDirection();
  }
  (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(swiper.params, breakpointParams);
  const isEnabled = swiper.params.enabled;
  const hasLoop = swiper.params.loop;
  Object.assign(swiper, {
    allowTouchMove: swiper.params.allowTouchMove,
    allowSlideNext: swiper.params.allowSlideNext,
    allowSlidePrev: swiper.params.allowSlidePrev
  });
  if (wasEnabled && !isEnabled) {
    swiper.disable();
  } else if (!wasEnabled && isEnabled) {
    swiper.enable();
  }
  swiper.currentBreakpoint = breakpoint;
  swiper.emit('_beforeBreakpoint', breakpointParams);
  if (initialized) {
    if (needsReLoop) {
      swiper.loopDestroy();
      swiper.loopCreate(realIndex);
      swiper.updateSlides();
    } else if (!wasLoop && hasLoop) {
      swiper.loopCreate(realIndex);
      swiper.updateSlides();
    } else if (wasLoop && !hasLoop) {
      swiper.loopDestroy();
    }
  }
  swiper.emit('breakpoint', breakpointParams);
}

function getBreakpoint(breakpoints, base, containerEl) {
  if (base === void 0) {
    base = 'window';
  }
  if (!breakpoints || base === 'container' && !containerEl) return undefined;
  let breakpoint = false;
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
  const points = Object.keys(breakpoints).map(point => {
    if (typeof point === 'string' && point.indexOf('@') === 0) {
      const minRatio = parseFloat(point.substr(1));
      const value = currentHeight * minRatio;
      return {
        value,
        point
      };
    }
    return {
      value: point,
      point
    };
  });
  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
  for (let i = 0; i < points.length; i += 1) {
    const {
      point,
      value
    } = points[i];
    if (base === 'window') {
      if (window.matchMedia(`(min-width: ${value}px)`).matches) {
        breakpoint = point;
      }
    } else if (value <= containerEl.clientWidth) {
      breakpoint = point;
    }
  }
  return breakpoint || 'max';
}

var breakpoints = {
  setBreakpoint,
  getBreakpoint
};

function prepareClasses(entries, prefix) {
  const resultClasses = [];
  entries.forEach(item => {
    if (typeof item === 'object') {
      Object.keys(item).forEach(classNames => {
        if (item[classNames]) {
          resultClasses.push(prefix + classNames);
        }
      });
    } else if (typeof item === 'string') {
      resultClasses.push(prefix + item);
    }
  });
  return resultClasses;
}
function addClasses() {
  const swiper = this;
  const {
    classNames,
    params,
    rtl,
    el,
    device
  } = swiper;
  // prettier-ignore
  const suffixes = prepareClasses(['initialized', params.direction, {
    'free-mode': swiper.params.freeMode && params.freeMode.enabled
  }, {
    'autoheight': params.autoHeight
  }, {
    'rtl': rtl
  }, {
    'grid': params.grid && params.grid.rows > 1
  }, {
    'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
  }, {
    'android': device.android
  }, {
    'ios': device.ios
  }, {
    'css-mode': params.cssMode
  }, {
    'centered': params.cssMode && params.centeredSlides
  }, {
    'watch-progress': params.watchSlidesProgress
  }], params.containerModifierClass);
  classNames.push(...suffixes);
  el.classList.add(...classNames);
  swiper.emitContainerClasses();
}

function removeClasses() {
  const swiper = this;
  const {
    el,
    classNames
  } = swiper;
  if (!el || typeof el === 'string') return;
  el.classList.remove(...classNames);
  swiper.emitContainerClasses();
}

var classes = {
  addClasses,
  removeClasses
};

function checkOverflow() {
  const swiper = this;
  const {
    isLocked: wasLocked,
    params
  } = swiper;
  const {
    slidesOffsetBefore
  } = params;
  if (slidesOffsetBefore) {
    const lastSlideIndex = swiper.slides.length - 1;
    const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
    swiper.isLocked = swiper.size > lastSlideRightEdge;
  } else {
    swiper.isLocked = swiper.snapGrid.length === 1;
  }
  if (params.allowSlideNext === true) {
    swiper.allowSlideNext = !swiper.isLocked;
  }
  if (params.allowSlidePrev === true) {
    swiper.allowSlidePrev = !swiper.isLocked;
  }
  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
  }
  if (wasLocked !== swiper.isLocked) {
    swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
  }
}
var checkOverflow$1 = {
  checkOverflow
};

var defaults = {
  init: true,
  direction: 'horizontal',
  oneWayMovement: false,
  swiperElementNodeName: 'SWIPER-CONTAINER',
  touchEventsTarget: 'wrapper',
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  resizeObserver: true,
  nested: false,
  createElements: false,
  eventsPrefix: 'swiper',
  enabled: true,
  focusableElements: 'input, select, option, textarea, button, video, label',
  // Overrides
  width: null,
  height: null,
  //
  preventInteractionOnTransition: false,
  // ssr
  userAgent: null,
  url: null,
  // To support iOS's swipe-to-go-back gesture (when being used in-app).
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,
  // Autoheight
  autoHeight: false,
  // Set wrapper width
  setWrapperSize: false,
  // Virtual Translate
  virtualTranslate: false,
  // Effects
  effect: 'slide',
  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

  // Breakpoints
  breakpoints: undefined,
  breakpointsBase: 'window',
  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  slidesPerGroupAuto: false,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0,
  // in px
  slidesOffsetAfter: 0,
  // in px
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,
  // Disable swiper and hide navigation when container not overflow
  watchOverflow: true,
  // Round length
  roundLengths: false,
  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 5,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,
  // Unique Navigation Elements
  uniqueNavElements: true,
  // Resistance
  resistance: true,
  resistanceRatio: 0.85,
  // Progress
  watchSlidesProgress: false,
  // Cursor
  grabCursor: false,
  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,
  // loop
  loop: false,
  loopAddBlankSlides: true,
  loopAdditionalSlides: 0,
  loopPreventsSliding: true,
  // rewind
  rewind: false,
  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null,
  // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: 'swiper-no-swiping',
  noSwipingSelector: null,
  // Passive Listeners
  passiveListeners: true,
  maxBackfaceHiddenSlides: 10,
  // NS
  containerModifierClass: 'swiper-',
  // NEW
  slideClass: 'swiper-slide',
  slideBlankClass: 'swiper-slide-blank',
  slideActiveClass: 'swiper-slide-active',
  slideVisibleClass: 'swiper-slide-visible',
  slideFullyVisibleClass: 'swiper-slide-fully-visible',
  slideNextClass: 'swiper-slide-next',
  slidePrevClass: 'swiper-slide-prev',
  wrapperClass: 'swiper-wrapper',
  lazyPreloaderClass: 'swiper-lazy-preloader',
  lazyPreloadPrevNext: 0,
  // Callbacks
  runCallbacksOnInit: true,
  // Internals
  _emitClasses: false
};

function moduleExtendParams(params, allModulesParams) {
  return function extendParams(obj) {
    if (obj === void 0) {
      obj = {};
    }
    const moduleParamName = Object.keys(obj)[0];
    const moduleParams = obj[moduleParamName];
    if (typeof moduleParams !== 'object' || moduleParams === null) {
      (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(allModulesParams, obj);
      return;
    }
    if (params[moduleParamName] === true) {
      params[moduleParamName] = {
        enabled: true
      };
    }
    if (moduleParamName === 'navigation' && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {
      params[moduleParamName].auto = true;
    }
    if (['pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {
      params[moduleParamName].auto = true;
    }
    if (!(moduleParamName in params && 'enabled' in moduleParams)) {
      (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(allModulesParams, obj);
      return;
    }
    if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
      params[moduleParamName].enabled = true;
    }
    if (!params[moduleParamName]) params[moduleParamName] = {
      enabled: false
    };
    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(allModulesParams, obj);
  };
}

/* eslint no-param-reassign: "off" */
const prototypes = {
  eventsEmitter,
  update,
  translate,
  transition,
  slide,
  loop,
  grabCursor,
  events: events$1,
  breakpoints,
  checkOverflow: checkOverflow$1,
  classes
};
const extendedDefaults = {};
class Swiper {
  constructor() {
    let el;
    let params;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
      params = args[0];
    } else {
      [el, params] = args;
    }
    if (!params) params = {};
    params = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.w)({}, params);
    if (el && !params.el) params.el = el;
    const document = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
    if (params.el && typeof params.el === 'string' && document.querySelectorAll(params.el).length > 1) {
      const swipers = [];
      document.querySelectorAll(params.el).forEach(containerEl => {
        const newParams = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.w)({}, params, {
          el: containerEl
        });
        swipers.push(new Swiper(newParams));
      });
      // eslint-disable-next-line no-constructor-return
      return swipers;
    }

    // Swiper Instance
    const swiper = this;
    swiper.__swiper__ = true;
    swiper.support = getSupport();
    swiper.device = getDevice({
      userAgent: params.userAgent
    });
    swiper.browser = getBrowser();
    swiper.eventsListeners = {};
    swiper.eventsAnyListeners = [];
    swiper.modules = [...swiper.__modules__];
    if (params.modules && Array.isArray(params.modules)) {
      swiper.modules.push(...params.modules);
    }
    const allModulesParams = {};
    swiper.modules.forEach(mod => {
      mod({
        params,
        swiper,
        extendParams: moduleExtendParams(params, allModulesParams),
        on: swiper.on.bind(swiper),
        once: swiper.once.bind(swiper),
        off: swiper.off.bind(swiper),
        emit: swiper.emit.bind(swiper)
      });
    });

    // Extend defaults with modules params
    const swiperParams = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.w)({}, defaults, allModulesParams);

    // Extend defaults with passed params
    swiper.params = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.w)({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.w)({}, swiper.params);
    swiper.passedParams = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.w)({}, params);

    // add event listeners
    if (swiper.params && swiper.params.on) {
      Object.keys(swiper.params.on).forEach(eventName => {
        swiper.on(eventName, swiper.params.on[eventName]);
      });
    }
    if (swiper.params && swiper.params.onAny) {
      swiper.onAny(swiper.params.onAny);
    }

    // Extend Swiper
    Object.assign(swiper, {
      enabled: swiper.params.enabled,
      el,
      // Classes
      classNames: [],
      // Slides
      slides: [],
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],
      // isDirection
      isHorizontal() {
        return swiper.params.direction === 'horizontal';
      },
      isVertical() {
        return swiper.params.direction === 'vertical';
      },
      // Indexes
      activeIndex: 0,
      realIndex: 0,
      //
      isBeginning: true,
      isEnd: false,
      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,
      cssOverflowAdjustment() {
        // Returns 0 unless `translate` is > 2**23
        // Should be subtracted from css values to prevent overflow
        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
      },
      // Locks
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
      // Touch Events
      touchEventsData: {
        isTouched: undefined,
        isMoved: undefined,
        allowTouchCallbacks: undefined,
        touchStartTime: undefined,
        isScrolling: undefined,
        currentTranslate: undefined,
        startTranslate: undefined,
        allowThresholdMove: undefined,
        // Form elements to match
        focusableElements: swiper.params.focusableElements,
        // Last click time
        lastClickTime: 0,
        clickTimeout: undefined,
        // Velocities
        velocities: [],
        allowMomentumBounce: undefined,
        startMoving: undefined,
        pointerId: null,
        touchId: null
      },
      // Clicks
      allowClick: true,
      // Touches
      allowTouchMove: swiper.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      // Images
      imagesToLoad: [],
      imagesLoaded: 0
    });
    swiper.emit('_swiper');

    // Init
    if (swiper.params.init) {
      swiper.init();
    }

    // Return app instance
    // eslint-disable-next-line no-constructor-return
    return swiper;
  }
  getDirectionLabel(property) {
    if (this.isHorizontal()) {
      return property;
    }
    // prettier-ignore
    return {
      'width': 'height',
      'margin-top': 'margin-left',
      'margin-bottom ': 'margin-right',
      'margin-left': 'margin-top',
      'margin-right': 'margin-bottom',
      'padding-left': 'padding-top',
      'padding-right': 'padding-bottom',
      'marginRight': 'marginBottom'
    }[property];
  }
  getSlideIndex(slideEl) {
    const {
      slidesEl,
      params
    } = this;
    const slides = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${params.slideClass}, swiper-slide`);
    const firstSlideIndex = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.h)(slides[0]);
    return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.h)(slideEl) - firstSlideIndex;
  }
  getSlideIndexByData(index) {
    return this.getSlideIndex(this.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === index)[0]);
  }
  recalcSlides() {
    const swiper = this;
    const {
      slidesEl,
      params
    } = swiper;
    swiper.slides = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${params.slideClass}, swiper-slide`);
  }
  enable() {
    const swiper = this;
    if (swiper.enabled) return;
    swiper.enabled = true;
    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }
    swiper.emit('enable');
  }
  disable() {
    const swiper = this;
    if (!swiper.enabled) return;
    swiper.enabled = false;
    if (swiper.params.grabCursor) {
      swiper.unsetGrabCursor();
    }
    swiper.emit('disable');
  }
  setProgress(progress, speed) {
    const swiper = this;
    progress = Math.min(Math.max(progress, 0), 1);
    const min = swiper.minTranslate();
    const max = swiper.maxTranslate();
    const current = (max - min) * progress + min;
    swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  emitContainerClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    const cls = swiper.el.className.split(' ').filter(className => {
      return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
    });
    swiper.emit('_containerClasses', cls.join(' '));
  }
  getSlideClasses(slideEl) {
    const swiper = this;
    if (swiper.destroyed) return '';
    return slideEl.className.split(' ').filter(className => {
      return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
    }).join(' ');
  }
  emitSlidesClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    const updates = [];
    swiper.slides.forEach(slideEl => {
      const classNames = swiper.getSlideClasses(slideEl);
      updates.push({
        slideEl,
        classNames
      });
      swiper.emit('_slideClass', slideEl, classNames);
    });
    swiper.emit('_slideClasses', updates);
  }
  slidesPerViewDynamic(view, exact) {
    if (view === void 0) {
      view = 'current';
    }
    if (exact === void 0) {
      exact = false;
    }
    const swiper = this;
    const {
      params,
      slides,
      slidesGrid,
      slidesSizesGrid,
      size: swiperSize,
      activeIndex
    } = swiper;
    let spv = 1;
    if (typeof params.slidesPerView === 'number') return params.slidesPerView;
    if (params.centeredSlides) {
      let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;
      let breakLoop;
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += Math.ceil(slides[i].swiperSlideSize);
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
      for (let i = activeIndex - 1; i >= 0; i -= 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
    } else {
      // eslint-disable-next-line
      if (view === 'current') {
        for (let i = activeIndex + 1; i < slides.length; i += 1) {
          const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      } else {
        // previous
        for (let i = activeIndex - 1; i >= 0; i -= 1) {
          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      }
    }
    return spv;
  }
  update() {
    const swiper = this;
    if (!swiper || swiper.destroyed) return;
    const {
      snapGrid,
      params
    } = swiper;
    // Breakpoints
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach(imageEl => {
      if (imageEl.complete) {
        processLazyPreloader(swiper, imageEl);
      }
    });
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();
    function setTranslate() {
      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    let translated;
    if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
      setTranslate();
      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
        const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
        translated = swiper.slideTo(slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
      if (!translated) {
        setTranslate();
      }
    }
    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
    swiper.emit('update');
  }
  changeDirection(newDirection, needUpdate) {
    if (needUpdate === void 0) {
      needUpdate = true;
    }
    const swiper = this;
    const currentDirection = swiper.params.direction;
    if (!newDirection) {
      // eslint-disable-next-line
      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
    }
    if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
      return swiper;
    }
    swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
    swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
    swiper.emitContainerClasses();
    swiper.params.direction = newDirection;
    swiper.slides.forEach(slideEl => {
      if (newDirection === 'vertical') {
        slideEl.style.width = '';
      } else {
        slideEl.style.height = '';
      }
    });
    swiper.emit('changeDirection');
    if (needUpdate) swiper.update();
    return swiper;
  }
  changeLanguageDirection(direction) {
    const swiper = this;
    if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;
    swiper.rtl = direction === 'rtl';
    swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;
    if (swiper.rtl) {
      swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
      swiper.el.dir = 'rtl';
    } else {
      swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
      swiper.el.dir = 'ltr';
    }
    swiper.update();
  }
  mount(element) {
    const swiper = this;
    if (swiper.mounted) return true;

    // Find el
    let el = element || swiper.params.el;
    if (typeof el === 'string') {
      el = document.querySelector(el);
    }
    if (!el) {
      return false;
    }
    el.swiper = swiper;
    if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) {
      swiper.isElement = true;
    }
    const getWrapperSelector = () => {
      return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
    };
    const getWrapper = () => {
      if (el && el.shadowRoot && el.shadowRoot.querySelector) {
        const res = el.shadowRoot.querySelector(getWrapperSelector());
        // Children needs to return slot items
        return res;
      }
      return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(el, getWrapperSelector())[0];
    };
    // Find Wrapper
    let wrapperEl = getWrapper();
    if (!wrapperEl && swiper.params.createElements) {
      wrapperEl = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)('div', swiper.params.wrapperClass);
      el.append(wrapperEl);
      (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(el, `.${swiper.params.slideClass}`).forEach(slideEl => {
        wrapperEl.append(slideEl);
      });
    }
    Object.assign(swiper, {
      el,
      wrapperEl,
      slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,
      hostEl: swiper.isElement ? el.parentNode.host : el,
      mounted: true,
      // RTL
      rtl: el.dir.toLowerCase() === 'rtl' || (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.p)(el, 'direction') === 'rtl',
      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.p)(el, 'direction') === 'rtl'),
      wrongRTL: (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.p)(wrapperEl, 'display') === '-webkit-box'
    });
    return true;
  }
  init(el) {
    const swiper = this;
    if (swiper.initialized) return swiper;
    const mounted = swiper.mount(el);
    if (mounted === false) return swiper;
    swiper.emit('beforeInit');

    // Set breakpoint
    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    }

    // Add Classes
    swiper.addClasses();

    // Update size
    swiper.updateSize();

    // Update slides
    swiper.updateSlides();
    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    }

    // Set Grab Cursor
    if (swiper.params.grabCursor && swiper.enabled) {
      swiper.setGrabCursor();
    }

    // Slide To Initial Slide
    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
      swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
    }

    // Create loop
    if (swiper.params.loop) {
      swiper.loopCreate();
    }

    // Attach events
    swiper.attachEvents();
    const lazyElements = [...swiper.el.querySelectorAll('[loading="lazy"]')];
    if (swiper.isElement) {
      lazyElements.push(...swiper.hostEl.querySelectorAll('[loading="lazy"]'));
    }
    lazyElements.forEach(imageEl => {
      if (imageEl.complete) {
        processLazyPreloader(swiper, imageEl);
      } else {
        imageEl.addEventListener('load', e => {
          processLazyPreloader(swiper, e.target);
        });
      }
    });
    preload(swiper);

    // Init Flag
    swiper.initialized = true;
    preload(swiper);

    // Emit
    swiper.emit('init');
    swiper.emit('afterInit');
    return swiper;
  }
  destroy(deleteInstance, cleanStyles) {
    if (deleteInstance === void 0) {
      deleteInstance = true;
    }
    if (cleanStyles === void 0) {
      cleanStyles = true;
    }
    const swiper = this;
    const {
      params,
      el,
      wrapperEl,
      slides
    } = swiper;
    if (typeof swiper.params === 'undefined' || swiper.destroyed) {
      return null;
    }
    swiper.emit('beforeDestroy');

    // Init Flag
    swiper.initialized = false;

    // Detach events
    swiper.detachEvents();

    // Destroy loop
    if (params.loop) {
      swiper.loopDestroy();
    }

    // Cleanup styles
    if (cleanStyles) {
      swiper.removeClasses();
      if (el && typeof el !== 'string') {
        el.removeAttribute('style');
      }
      if (wrapperEl) {
        wrapperEl.removeAttribute('style');
      }
      if (slides && slides.length) {
        slides.forEach(slideEl => {
          slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
          slideEl.removeAttribute('style');
          slideEl.removeAttribute('data-swiper-slide-index');
        });
      }
    }
    swiper.emit('destroy');

    // Detach emitter events
    Object.keys(swiper.eventsListeners).forEach(eventName => {
      swiper.off(eventName);
    });
    if (deleteInstance !== false) {
      if (swiper.el && typeof swiper.el !== 'string') {
        swiper.el.swiper = null;
      }
      (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.x)(swiper);
    }
    swiper.destroyed = true;
    return null;
  }
  static extendDefaults(newDefaults) {
    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(extendedDefaults, newDefaults);
  }
  static get extendedDefaults() {
    return extendedDefaults;
  }
  static get defaults() {
    return defaults;
  }
  static installModule(mod) {
    if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
    const modules = Swiper.prototype.__modules__;
    if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
      modules.push(mod);
    }
  }
  static use(module) {
    if (Array.isArray(module)) {
      module.forEach(m => Swiper.installModule(m));
      return Swiper;
    }
    Swiper.installModule(module);
    return Swiper;
  }
}
Object.keys(prototypes).forEach(prototypeGroup => {
  Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
  });
});
Swiper.use([Resize, Observer]);




/***/ }),

/***/ "./node_modules/swiper/shared/utils.mjs":
/*!**********************************************!*\
  !*** ./node_modules/swiper/shared/utils.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ elementParents),
/* harmony export */   b: () => (/* binding */ elementOffset),
/* harmony export */   c: () => (/* binding */ createElement),
/* harmony export */   d: () => (/* binding */ now),
/* harmony export */   e: () => (/* binding */ elementChildren),
/* harmony export */   f: () => (/* binding */ elementOuterSize),
/* harmony export */   g: () => (/* binding */ getSlideTransformEl),
/* harmony export */   h: () => (/* binding */ elementIndex),
/* harmony export */   i: () => (/* binding */ classesToTokens),
/* harmony export */   j: () => (/* binding */ getTranslate),
/* harmony export */   k: () => (/* binding */ elementTransitionEnd),
/* harmony export */   l: () => (/* binding */ isObject),
/* harmony export */   m: () => (/* binding */ makeElementsArray),
/* harmony export */   n: () => (/* binding */ nextTick),
/* harmony export */   o: () => (/* binding */ getRotateFix),
/* harmony export */   p: () => (/* binding */ elementStyle),
/* harmony export */   q: () => (/* binding */ elementNextAll),
/* harmony export */   r: () => (/* binding */ elementPrevAll),
/* harmony export */   s: () => (/* binding */ setCSSProperty),
/* harmony export */   t: () => (/* binding */ animateCSSModeScroll),
/* harmony export */   u: () => (/* binding */ showWarning),
/* harmony export */   v: () => (/* binding */ elementIsChildOf),
/* harmony export */   w: () => (/* binding */ extend),
/* harmony export */   x: () => (/* binding */ deleteProps)
/* harmony export */ });
/* harmony import */ var _ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ssr-window.esm.mjs */ "./node_modules/swiper/shared/ssr-window.esm.mjs");


function classesToTokens(classes) {
  if (classes === void 0) {
    classes = '';
  }
  return classes.trim().split(' ').filter(c => !!c.trim());
}

function deleteProps(obj) {
  const object = obj;
  Object.keys(object).forEach(key => {
    try {
      object[key] = null;
    } catch (e) {
      // no getter for object
    }
    try {
      delete object[key];
    } catch (e) {
      // something got wrong
    }
  });
}
function nextTick(callback, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return setTimeout(callback, delay);
}
function now() {
  return Date.now();
}
function getComputedStyle(el) {
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  let style;
  if (window.getComputedStyle) {
    style = window.getComputedStyle(el, null);
  }
  if (!style && el.currentStyle) {
    style = el.currentStyle;
  }
  if (!style) {
    style = el.style;
  }
  return style;
}
function getTranslate(el, axis) {
  if (axis === void 0) {
    axis = 'x';
  }
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  let matrix;
  let curTransform;
  let transformMatrix;
  const curStyle = getComputedStyle(el);
  if (window.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;
    if (curTransform.split(',').length > 6) {
      curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
    }
    // Some old versions of Webkit choke when 'none' is passed; pass
    // empty string instead in this case
    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
    matrix = transformMatrix.toString().split(',');
  }
  if (axis === 'x') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;
    // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
    // Normal Browsers
    else curTransform = parseFloat(matrix[4]);
  }
  if (axis === 'y') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;
    // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
    // Normal Browsers
    else curTransform = parseFloat(matrix[5]);
  }
  return curTransform || 0;
}
function isObject(o) {
  return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
}
function isNode(node) {
  // eslint-disable-next-line
  if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
    return node instanceof HTMLElement;
  }
  return node && (node.nodeType === 1 || node.nodeType === 11);
}
function extend() {
  const to = Object(arguments.length <= 0 ? undefined : arguments[0]);
  const noExtend = ['__proto__', 'constructor', 'prototype'];
  for (let i = 1; i < arguments.length; i += 1) {
    const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];
    if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
      const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);
      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== undefined && desc.enumerable) {
          if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend(to[nextKey], nextSource[nextKey]);
            }
          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            to[nextKey] = {};
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend(to[nextKey], nextSource[nextKey]);
            }
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }
  return to;
}
function setCSSProperty(el, varName, varValue) {
  el.style.setProperty(varName, varValue);
}
function animateCSSModeScroll(_ref) {
  let {
    swiper,
    targetPosition,
    side
  } = _ref;
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  const startPosition = -swiper.translate;
  let startTime = null;
  let time;
  const duration = swiper.params.speed;
  swiper.wrapperEl.style.scrollSnapType = 'none';
  window.cancelAnimationFrame(swiper.cssModeFrameID);
  const dir = targetPosition > startPosition ? 'next' : 'prev';
  const isOutOfBound = (current, target) => {
    return dir === 'next' && current >= target || dir === 'prev' && current <= target;
  };
  const animate = () => {
    time = new Date().getTime();
    if (startTime === null) {
      startTime = time;
    }
    const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
    if (isOutOfBound(currentPosition, targetPosition)) {
      currentPosition = targetPosition;
    }
    swiper.wrapperEl.scrollTo({
      [side]: currentPosition
    });
    if (isOutOfBound(currentPosition, targetPosition)) {
      swiper.wrapperEl.style.overflow = 'hidden';
      swiper.wrapperEl.style.scrollSnapType = '';
      setTimeout(() => {
        swiper.wrapperEl.style.overflow = '';
        swiper.wrapperEl.scrollTo({
          [side]: currentPosition
        });
      });
      window.cancelAnimationFrame(swiper.cssModeFrameID);
      return;
    }
    swiper.cssModeFrameID = window.requestAnimationFrame(animate);
  };
  animate();
}
function getSlideTransformEl(slideEl) {
  return slideEl.querySelector('.swiper-slide-transform') || slideEl.shadowRoot && slideEl.shadowRoot.querySelector('.swiper-slide-transform') || slideEl;
}
function elementChildren(element, selector) {
  if (selector === void 0) {
    selector = '';
  }
  const children = [...element.children];
  if (element instanceof HTMLSlotElement) {
    children.push(...element.assignedElements());
  }
  if (!selector) {
    return children;
  }
  return children.filter(el => el.matches(selector));
}
function elementIsChildOf(el, parent) {
  const isChild = parent.contains(el);
  if (!isChild && parent instanceof HTMLSlotElement) {
    const children = [...parent.assignedElements()];
    return children.includes(el);
  }
  return isChild;
}
function showWarning(text) {
  try {
    console.warn(text);
    return;
  } catch (err) {
    // err
  }
}
function createElement(tag, classes) {
  if (classes === void 0) {
    classes = [];
  }
  const el = document.createElement(tag);
  el.classList.add(...(Array.isArray(classes) ? classes : classesToTokens(classes)));
  return el;
}
function elementOffset(el) {
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  const document = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();
  const box = el.getBoundingClientRect();
  const body = document.body;
  const clientTop = el.clientTop || body.clientTop || 0;
  const clientLeft = el.clientLeft || body.clientLeft || 0;
  const scrollTop = el === window ? window.scrollY : el.scrollTop;
  const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
  return {
    top: box.top + scrollTop - clientTop,
    left: box.left + scrollLeft - clientLeft
  };
}
function elementPrevAll(el, selector) {
  const prevEls = [];
  while (el.previousElementSibling) {
    const prev = el.previousElementSibling; // eslint-disable-line
    if (selector) {
      if (prev.matches(selector)) prevEls.push(prev);
    } else prevEls.push(prev);
    el = prev;
  }
  return prevEls;
}
function elementNextAll(el, selector) {
  const nextEls = [];
  while (el.nextElementSibling) {
    const next = el.nextElementSibling; // eslint-disable-line
    if (selector) {
      if (next.matches(selector)) nextEls.push(next);
    } else nextEls.push(next);
    el = next;
  }
  return nextEls;
}
function elementStyle(el, prop) {
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  return window.getComputedStyle(el, null).getPropertyValue(prop);
}
function elementIndex(el) {
  let child = el;
  let i;
  if (child) {
    i = 0;
    // eslint-disable-next-line
    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1) i += 1;
    }
    return i;
  }
  return undefined;
}
function elementParents(el, selector) {
  const parents = []; // eslint-disable-line
  let parent = el.parentElement; // eslint-disable-line
  while (parent) {
    if (selector) {
      if (parent.matches(selector)) parents.push(parent);
    } else {
      parents.push(parent);
    }
    parent = parent.parentElement;
  }
  return parents;
}
function elementTransitionEnd(el, callback) {
  function fireCallBack(e) {
    if (e.target !== el) return;
    callback.call(el, e);
    el.removeEventListener('transitionend', fireCallBack);
  }
  if (callback) {
    el.addEventListener('transitionend', fireCallBack);
  }
}
function elementOuterSize(el, size, includeMargins) {
  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();
  if (includeMargins) {
    return el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'));
  }
  return el.offsetWidth;
}
function makeElementsArray(el) {
  return (Array.isArray(el) ? el : [el]).filter(e => !!e);
}
function getRotateFix(swiper) {
  return v => {
    if (Math.abs(v) > 0 && swiper.browser && swiper.browser.need3dFix && Math.abs(v) % 90 === 0) {
      return v + 0.001;
    }
    return v;
  };
}




/***/ }),

/***/ "./node_modules/swiper/swiper-bundle.mjs":
/*!***********************************************!*\
  !*** ./node_modules/swiper/swiper-bundle.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Swiper: () => (/* reexport safe */ _shared_swiper_core_mjs__WEBPACK_IMPORTED_MODULE_0__.S),
/* harmony export */   "default": () => (/* reexport safe */ _shared_swiper_core_mjs__WEBPACK_IMPORTED_MODULE_0__.S)
/* harmony export */ });
/* harmony import */ var _shared_swiper_core_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared/swiper-core.mjs */ "./node_modules/swiper/shared/swiper-core.mjs");
/* harmony import */ var _modules_virtual_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/virtual.mjs */ "./node_modules/swiper/modules/virtual.mjs");
/* harmony import */ var _modules_keyboard_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/keyboard.mjs */ "./node_modules/swiper/modules/keyboard.mjs");
/* harmony import */ var _modules_mousewheel_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/mousewheel.mjs */ "./node_modules/swiper/modules/mousewheel.mjs");
/* harmony import */ var _modules_navigation_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/navigation.mjs */ "./node_modules/swiper/modules/navigation.mjs");
/* harmony import */ var _modules_pagination_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/pagination.mjs */ "./node_modules/swiper/modules/pagination.mjs");
/* harmony import */ var _modules_scrollbar_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/scrollbar.mjs */ "./node_modules/swiper/modules/scrollbar.mjs");
/* harmony import */ var _modules_parallax_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modules/parallax.mjs */ "./node_modules/swiper/modules/parallax.mjs");
/* harmony import */ var _modules_zoom_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modules/zoom.mjs */ "./node_modules/swiper/modules/zoom.mjs");
/* harmony import */ var _modules_controller_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modules/controller.mjs */ "./node_modules/swiper/modules/controller.mjs");
/* harmony import */ var _modules_a11y_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./modules/a11y.mjs */ "./node_modules/swiper/modules/a11y.mjs");
/* harmony import */ var _modules_history_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./modules/history.mjs */ "./node_modules/swiper/modules/history.mjs");
/* harmony import */ var _modules_hash_navigation_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modules/hash-navigation.mjs */ "./node_modules/swiper/modules/hash-navigation.mjs");
/* harmony import */ var _modules_autoplay_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./modules/autoplay.mjs */ "./node_modules/swiper/modules/autoplay.mjs");
/* harmony import */ var _modules_thumbs_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./modules/thumbs.mjs */ "./node_modules/swiper/modules/thumbs.mjs");
/* harmony import */ var _modules_free_mode_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./modules/free-mode.mjs */ "./node_modules/swiper/modules/free-mode.mjs");
/* harmony import */ var _modules_grid_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./modules/grid.mjs */ "./node_modules/swiper/modules/grid.mjs");
/* harmony import */ var _modules_manipulation_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./modules/manipulation.mjs */ "./node_modules/swiper/modules/manipulation.mjs");
/* harmony import */ var _modules_effect_fade_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./modules/effect-fade.mjs */ "./node_modules/swiper/modules/effect-fade.mjs");
/* harmony import */ var _modules_effect_cube_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./modules/effect-cube.mjs */ "./node_modules/swiper/modules/effect-cube.mjs");
/* harmony import */ var _modules_effect_flip_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./modules/effect-flip.mjs */ "./node_modules/swiper/modules/effect-flip.mjs");
/* harmony import */ var _modules_effect_coverflow_mjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./modules/effect-coverflow.mjs */ "./node_modules/swiper/modules/effect-coverflow.mjs");
/* harmony import */ var _modules_effect_creative_mjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./modules/effect-creative.mjs */ "./node_modules/swiper/modules/effect-creative.mjs");
/* harmony import */ var _modules_effect_cards_mjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./modules/effect-cards.mjs */ "./node_modules/swiper/modules/effect-cards.mjs");
/**
 * Swiper 11.1.14
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * https://swiperjs.com
 *
 * Copyright 2014-2024 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: September 12, 2024
 */


























// Swiper Class
const modules = [_modules_virtual_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], _modules_keyboard_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], _modules_mousewheel_mjs__WEBPACK_IMPORTED_MODULE_3__["default"], _modules_navigation_mjs__WEBPACK_IMPORTED_MODULE_4__["default"], _modules_pagination_mjs__WEBPACK_IMPORTED_MODULE_5__["default"], _modules_scrollbar_mjs__WEBPACK_IMPORTED_MODULE_6__["default"], _modules_parallax_mjs__WEBPACK_IMPORTED_MODULE_7__["default"], _modules_zoom_mjs__WEBPACK_IMPORTED_MODULE_8__["default"], _modules_controller_mjs__WEBPACK_IMPORTED_MODULE_9__["default"], _modules_a11y_mjs__WEBPACK_IMPORTED_MODULE_10__["default"], _modules_history_mjs__WEBPACK_IMPORTED_MODULE_11__["default"], _modules_hash_navigation_mjs__WEBPACK_IMPORTED_MODULE_12__["default"], _modules_autoplay_mjs__WEBPACK_IMPORTED_MODULE_13__["default"], _modules_thumbs_mjs__WEBPACK_IMPORTED_MODULE_14__["default"], _modules_free_mode_mjs__WEBPACK_IMPORTED_MODULE_15__["default"], _modules_grid_mjs__WEBPACK_IMPORTED_MODULE_16__["default"], _modules_manipulation_mjs__WEBPACK_IMPORTED_MODULE_17__["default"], _modules_effect_fade_mjs__WEBPACK_IMPORTED_MODULE_18__["default"], _modules_effect_cube_mjs__WEBPACK_IMPORTED_MODULE_19__["default"], _modules_effect_flip_mjs__WEBPACK_IMPORTED_MODULE_20__["default"], _modules_effect_coverflow_mjs__WEBPACK_IMPORTED_MODULE_21__["default"], _modules_effect_creative_mjs__WEBPACK_IMPORTED_MODULE_22__["default"], _modules_effect_cards_mjs__WEBPACK_IMPORTED_MODULE_23__["default"]];
_shared_swiper_core_mjs__WEBPACK_IMPORTED_MODULE_0__.S.use(modules);




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!***************************!*\
  !*** ./src/js/scripts.js ***!
  \***************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _css_app_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css/app.css */ "./src/css/app.css");
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component */ "./src/js/component/index.js");
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./function */ "./src/js/function/index.js");
/* harmony import */ var fslightbox__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fslightbox */ "./node_modules/fslightbox/index.js");
/* harmony import */ var fslightbox__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(fslightbox__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var simplebar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! simplebar */ "./node_modules/simplebar/dist/index.mjs");






/*  =======================================================
  Mode Switch
========================================================== */
(0,_component__WEBPACK_IMPORTED_MODULE_1__.Settings)(_function__WEBPACK_IMPORTED_MODULE_2__.config.theme);
let classes = {
  menu: {
    main: 'nk-menu',
    item: 'nk-menu-item',
    link: 'nk-menu-link',
    toggle: 'nk-menu-toggle',
    sub: 'nk-menu-sub',
    subparent: 'has-sub',
    active: 'active',
    current: 'current-page'
  }
};

/*  =======================================================
Custom Layout init
========================================================== */
// Custom Menu (sidebar/header)
(function MenuInit() {
  const elm = document.querySelectorAll(`.${classes.menu.toggle}`);
  let active = classes.menu.active;
  let subparent = classes.menu.subparent;
  let submenu = classes.menu.sub;
  elm.forEach(item => {
    _component__WEBPACK_IMPORTED_MODULE_1__.Menu.load(item, subparent);
    item.addEventListener("click", function (e) {
      e.preventDefault();
      _component__WEBPACK_IMPORTED_MODULE_1__.Menu.toggle(item, active);
      _component__WEBPACK_IMPORTED_MODULE_1__.Menu.closeSiblings(item, active, subparent, submenu);
    });
  });
})();

// Add some class to current link
(0,_component__WEBPACK_IMPORTED_MODULE_1__.CurrentLink)("." + classes.menu.link, classes.menu.item, classes.menu.sub, classes.menu.main, [classes.menu.active, classes.menu.current]);

// Custom Sidebar (sidebar)
_component__WEBPACK_IMPORTED_MODULE_1__.Sidebar.compact();
_component__WEBPACK_IMPORTED_MODULE_1__.Sidebar.toggle();
window.addEventListener('resize', function () {
  _component__WEBPACK_IMPORTED_MODULE_1__.Sidebar.page_resize();
});

/*  =======================================================
init componenets 
========================================================== */
// ToggleClass
(0,_component__WEBPACK_IMPORTED_MODULE_1__.ToggleClass)();
// Dropdown
(0,_component__WEBPACK_IMPORTED_MODULE_1__.Dropdown)();
// Accordion
(0,_component__WEBPACK_IMPORTED_MODULE_1__.Accordion)();
// Modal
(0,_component__WEBPACK_IMPORTED_MODULE_1__.Modal)();
// Tab
(0,_component__WEBPACK_IMPORTED_MODULE_1__.Tab)();
// NumberSpinner
(0,_component__WEBPACK_IMPORTED_MODULE_1__.NumberSpinner)();
// Popover
(0,_component__WEBPACK_IMPORTED_MODULE_1__.Popover)();
// Tooltip
(0,_component__WEBPACK_IMPORTED_MODULE_1__.Tooltip)();
// File Input name show
(0,_component__WEBPACK_IMPORTED_MODULE_1__.FileInput)('.js-file-input');
// Set Progressbar Width
(0,_component__WEBPACK_IMPORTED_MODULE_1__.Progress)('[data-progress]');
// Show hide pasword
(0,_component__WEBPACK_IMPORTED_MODULE_1__.TogglePassword)('.js-password-toggle');
// Sticky nav 
(0,_component__WEBPACK_IMPORTED_MODULE_1__.StickyNav)('.js-sticky-nav');

/*  ================================================================
Plugin inits
==================================================================== */
// Custom select js (Choices)
(0,_component__WEBPACK_IMPORTED_MODULE_1__.Select)('.js-select');
// Custom tags js (tagify)
(0,_component__WEBPACK_IMPORTED_MODULE_1__.Tags)('.js-tags');
// Drag and drop input/upload field (dropzone)
(0,_component__WEBPACK_IMPORTED_MODULE_1__.Dropzone)('.js-upload');
// TimePicker (Custom)
(0,_component__WEBPACK_IMPORTED_MODULE_1__.TimePicker)('.js-timepicker');
// DatePicker (vanillajs-datepicker)
(0,_component__WEBPACK_IMPORTED_MODULE_1__.DatePicker)('.js-datepicker');
// Range Input (noUiSlider)
(0,_component__WEBPACK_IMPORTED_MODULE_1__.Range)('.js-range');
// Form Validation (pristine.js)
(0,_component__WEBPACK_IMPORTED_MODULE_1__.FormValidate)('.js-validate');
// Slider (swiper)
(0,_component__WEBPACK_IMPORTED_MODULE_1__.Slider)('.js-slider');
// Clipboard js
(0,_component__WEBPACK_IMPORTED_MODULE_1__.Clipboard)('.js-copy');
// DataTable
(0,_component__WEBPACK_IMPORTED_MODULE_1__.DataTable)('.js-datatable');
let mapData = {
  scale: ['#ccd7e2', '#798bff'],
  values: {
    AF: 16.63,
    AL: 11.58,
    DZ: 158.97,
    AO: 85.81,
    AG: 1.1,
    AR: 351.02,
    AM: 8.83,
    AU: 1219.72,
    AT: 366.26,
    AZ: 52.17,
    BS: 7.54,
    BH: 21.73,
    BD: 105.4,
    BB: 3.96,
    BY: 52.89,
    BE: 461.33,
    BZ: 1.43,
    BJ: 6.49,
    BT: 1.4,
    BO: 19.18,
    BA: 16.2,
    BW: 12.5,
    BR: 2023.53,
    BN: 11.96,
    BG: 44.84,
    BF: 8.67,
    BI: 1.47,
    KH: 11.36,
    CM: 21.88,
    CA: 1563.66,
    CV: 1.57,
    CF: 2.11,
    TD: 7.59,
    CL: 199.18,
    CN: 5745.13,
    CO: 283.11,
    KM: 0.56,
    CD: 12.6,
    CG: 11.88,
    CR: 35.02,
    CI: 22.38,
    HR: 59.92,
    CY: 22.75,
    CZ: 195.23,
    DK: 304.56,
    DJ: 1.14,
    DM: 0.38,
    DO: 50.87,
    EC: 61.49,
    EG: 216.83,
    SV: 21.8,
    GQ: 14.55,
    ER: 2.25,
    EE: 19.22,
    ET: 30.94,
    FJ: 3.15,
    FI: 231.98,
    FR: 2555.44,
    GA: 12.56,
    GM: 1.04,
    GE: 11.23,
    DE: 3305.9,
    GH: 18.06,
    GR: 305.01,
    GD: 0.65,
    GT: 40.77,
    GN: 4.34,
    GW: 0.83,
    GY: 2.2,
    HT: 6.5,
    HN: 15.34,
    HK: 226.49,
    HU: 132.28,
    IS: 12.77,
    IN: 1430.02,
    ID: 695.06,
    IR: 337.9,
    IQ: 84.14,
    IE: 204.14,
    IL: 201.25,
    IT: 2036.69,
    JM: 13.74,
    JP: 5390.9,
    JO: 27.13,
    KZ: 129.76,
    KE: 32.42,
    KI: 0.15,
    KR: 986.26,
    UNDEFINED: 5.73,
    KW: 117.32,
    KG: 4.44,
    LA: 6.34,
    LV: 23.39,
    LB: 39.15,
    LS: 1.8,
    LR: 0.98,
    LY: 77.91,
    LT: 35.73,
    LU: 52.43,
    MK: 9.58,
    MG: 8.33,
    MW: 5.04,
    MY: 218.95,
    MV: 1.43,
    ML: 9.08,
    MT: 7.8,
    MR: 3.49,
    MU: 9.43,
    MX: 1004.04,
    MD: 5.36,
    MN: 5.81,
    ME: 3.88,
    MA: 91.7,
    MZ: 10.21,
    MM: 35.65,
    NA: 11.45,
    NP: 15.11,
    NL: 770.31,
    NZ: 138,
    NI: 6.38,
    NE: 5.6,
    NG: 206.66,
    NO: 413.51,
    OM: 53.78,
    PK: 174.79,
    PA: 27.2,
    PG: 8.81,
    PY: 17.17,
    PE: 153.55,
    PH: 189.06,
    PL: 438.88,
    PT: 223.7,
    QA: 126.52,
    RO: 158.39,
    RU: 1476.91,
    RW: 5.69,
    WS: 0.55,
    ST: 0.19,
    SA: 434.44,
    SN: 12.66,
    RS: 38.92,
    SC: 0.92,
    SL: 1.9,
    SG: 217.38,
    SK: 86.26,
    SI: 46.44,
    SB: 0.67,
    ZA: 354.41,
    ES: 1374.78,
    LK: 48.24,
    KN: 0.56,
    LC: 1,
    VC: 0.58,
    SD: 65.93,
    SR: 3.3,
    SZ: 3.17,
    SE: 444.59,
    CH: 522.44,
    SY: 59.63,
    TW: 426.98,
    TJ: 5.58,
    TZ: 22.43,
    TH: 312.61,
    TL: 0.62,
    TG: 3.07,
    TO: 0.3,
    TT: 21.2,
    TN: 43.86,
    TR: 729.05,
    TM: 0,
    UG: 17.12,
    UA: 136.56,
    AE: 239.65,
    GB: 2258.57,
    US: 14624.18,
    UY: 40.71,
    UZ: 37.72,
    VU: 0.72,
    VE: 285.21,
    VN: 101.99,
    YE: 30.02,
    ZM: 15.69,
    ZW: 5.57
  }
};
// Vector Map
(0,_component__WEBPACK_IMPORTED_MODULE_1__.WorldMap)('.vector-map', mapData);
})();

/******/ })()
;
//# sourceMappingURL=scripts.js.map